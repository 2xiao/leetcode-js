# [918. ç¯å½¢å­æ•°ç»„çš„æœ€å¤§å’Œ](https://leetcode.com/problems/maximum-sum-circular-subarray)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`é˜Ÿåˆ—`](/tag/queue.md) [`æ•°ç»„`](/tag/array.md) [`åˆ†æ²»`](/tag/divide-and-conquer.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md) [`å•è°ƒé˜Ÿåˆ—`](/tag/monotonic-queue.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/maximum-sum-circular-subarray)

## é¢˜ç›®

Given a **circular integer array** `nums` of length `n`, return _the maximum possible sum of a non-empty **subarray** of_ `nums`.

A **circular array** means the end of the array connects to the beginning of
the array. Formally, the next element of `nums[i]` is `nums[(i + 1) % n]` and
the previous element of `nums[i]` is `nums[(i - 1 + n) % n]`.

A **subarray** may only include each element of the fixed buffer `nums` at
most once. Formally, for a subarray `nums[i], nums[i + 1], ..., nums[j]`,
there does not exist `i <= k1`, `k2 <= j` with `k1 % n == k2 % n`.

**Example 1:**

> Input: nums = [1,-2,3,-2]
>
> Output: 3
>
> Explanation: Subarray [3] has maximum sum 3.

**Example 2:**

> Input: nums = [5,-3,5]
>
> Output: 10
>
> Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10.

**Example 3:**

> Input: nums = [-3,-2,-3]
>
> Output: -2
>
> Explanation: Subarray [-2] has maximum sum -2.

**Constraints:**

- `n == nums.length`
- `1 <= n <= 3 * 10^4`
- `-3 * 104 <= nums[i] <= 3 * 10^4`

## é¢˜ç›®å¤§æ„

ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º `n` çš„**ç¯å½¢æ•´æ•°æ•°ç»„** `nums` ï¼Œè¿”å› _`nums` çš„éç©º **å­æ•°ç»„** çš„æœ€å¤§å¯èƒ½å’Œ_ã€‚

**ç¯å½¢æ•°ç»„** æ„å‘³ç€æ•°ç»„çš„æœ«ç«¯å°†ä¼šä¸å¼€å¤´ç›¸è¿å‘ˆç¯çŠ¶ã€‚å½¢å¼ä¸Šï¼Œ `nums[i]` çš„ä¸‹ä¸€ä¸ªå…ƒç´ æ˜¯ `nums[(i + 1) % n]` ï¼Œ
`nums[i]` çš„å‰ä¸€ä¸ªå…ƒç´ æ˜¯ `nums[(i - 1 + n) % n]` ã€‚

**å­æ•°ç»„** æœ€å¤šåªèƒ½åŒ…å«å›ºå®šç¼“å†²åŒº `nums` ä¸­çš„æ¯ä¸ªå…ƒç´ ä¸€æ¬¡ã€‚å½¢å¼ä¸Šï¼Œå¯¹äºå­æ•°ç»„ `nums[i], nums[i + 1], ...,
nums[j]` ï¼Œä¸å­˜åœ¨ `i <= k1, k2 <= j` å…¶ä¸­ `k1 % n == k2 % n` ã€‚

**ç¤ºä¾‹ 1ï¼š**

> **è¾“å…¥ï¼š** nums = [1,-2,3,-2]
>
> **è¾“å‡ºï¼š** 3
>
> **è§£é‡Šï¼š** ä»å­æ•°ç»„ [3] å¾—åˆ°æœ€å¤§å’Œ 3

**ç¤ºä¾‹ 2ï¼š**

> **è¾“å…¥ï¼š** nums = [5,-3,5]
>
> **è¾“å‡ºï¼š** 10
>
> **è§£é‡Šï¼š** ä»å­æ•°ç»„ [5,5] å¾—åˆ°æœ€å¤§å’Œ 5 + 5 = 10

**ç¤ºä¾‹ 3ï¼š**

> **è¾“å…¥ï¼š** nums = [3,-2,2,-3]
>
> **è¾“å‡ºï¼š** 3
>
> **è§£é‡Šï¼š** ä»å­æ•°ç»„ [3] å’Œ [3,-2,2] éƒ½å¯ä»¥å¾—åˆ°æœ€å¤§å’Œ 3

**æç¤ºï¼š**

- `n == nums.length`
- `1 <= n <= 3 * 10^4`
- `-3 * 104 <= nums[i] <= 3 * 10^4`â€‹â€‹â€‹â€‹â€‹â€‹â€‹

## è§£é¢˜æ€è·¯

è¦è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå¯ä»¥è€ƒè™‘ä¸¤ç§æƒ…å†µï¼š

- **æ™®é€šå­æ•°ç»„**ï¼šå¯ä»¥ç›´æ¥ä½¿ç”¨ç»å…¸çš„ **Kadaneâ€™s Algorithm** æ¥æ‰¾åˆ°éå¾ªç¯çš„æœ€å¤§å­æ•°ç»„å’Œã€‚
- **è·¨è¶Šé¦–å°¾çš„å­æ•°ç»„**ï¼šè¿™ä¸ªå­æ•°ç»„å¯ä»¥è¢«ç†è§£ä¸ºï¼Œæ€»å’Œå‡å»ä¸€ä¸ªæœ€å°çš„å­æ•°ç»„å’Œï¼ˆå³ï¼Œæ‰¾åˆ°æ•´ä¸ªæ•°ç»„çš„å’Œï¼Œå†å‡å»ä¸­é—´çš„ä¸€ä¸ªå­æ•°ç»„ï¼Œä¿ç•™æ•°ç»„ä¸¤ç«¯éƒ¨åˆ†ä½œä¸ºæœ€å¤§å­æ•°ç»„å’Œï¼‰ã€‚è¦å®ç°è¿™ä¸€ç‚¹ï¼Œéœ€è¦æ±‚å‡ºæœ€å°å­æ•°ç»„å’Œã€‚

å› æ­¤ï¼Œè§£é¢˜åˆ†ä¸ºä¸‰æ­¥ï¼š

1. **è®¡ç®—éå¾ªç¯å­æ•°ç»„çš„æœ€å¤§å’Œ**ï¼šä½¿ç”¨ Kadane's ç®—æ³•æ¥æ‰¾åˆ°å­æ•°ç»„çš„æœ€å¤§å’Œ `maxSum`.
2. **è®¡ç®—æœ€å°å­æ•°ç»„å’Œ**ï¼šä½¿ç”¨ Kadane's ç®—æ³•çš„å˜ç§ï¼Œæ‰¾å‡ºå­æ•°ç»„çš„æœ€å°å’Œ `minSum`ï¼Œç„¶åç”¨æ•´ä¸ªæ•°ç»„çš„å’Œ `totalSum` å‡å»è¯¥æœ€å°å’Œã€‚è¿™æ ·å¾—åˆ°è·¨è¶Šé¦–å°¾çš„å­æ•°ç»„å’Œ `totalSum - minSum`ã€‚
3. **è€ƒè™‘ç‰¹æ®Šæƒ…å†µ**ï¼šå½“æ‰€æœ‰å…ƒç´ éƒ½æ˜¯è´Ÿæ•°æ—¶ï¼Œè·¨è¶Šé¦–å°¾çš„å­æ•°ç»„å’Œå¯èƒ½ä¼šæ— æ•ˆï¼Œå› ä¸ºæ•´ä¸ªæ•°ç»„çš„å’Œ `totalSum` ä¼šç­‰äº `minSum`ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¿”å› `maxSum` å³å¯ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œå› ä¸ºåªéå†æ•°ç»„ä¸‰æ¬¡ï¼ˆåˆ†åˆ«æ±‚æœ€å¤§å­æ•°ç»„å’Œã€æœ€å°å­æ•°ç»„å’Œï¼Œä»¥åŠæ€»å’Œï¼‰ï¼Œæ¯æ¬¡éå†éœ€è¦ `O(n)` æ—¶é—´ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(1)`ï¼Œå› ä¸ºåªä½¿ç”¨äº†å¸¸æ•°ç©ºé—´æ¥å­˜å‚¨è‹¥å¹²å˜é‡ï¼Œä¸éœ€è¦é¢å¤–çš„æ•°ç»„æˆ–å…¶ä»–æ•°æ®ç»“æ„ã€‚

## ä»£ç 

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubarraySumCircular = function (nums) {
	const totalSum = nums.reduce((a, b) => a + b, 0);

	const getMaxSum = () => {
		let max = nums[0],
			maxEndingHere = nums[0];
		for (let i = 1; i < nums.length; i++) {
			maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);
			max = Math.max(maxEndingHere, max);
		}
		return max;
	};

	const getMinSum = () => {
		let min = nums[0],
			minEndingHere = nums[0];
		for (let i = 1; i < nums.length; i++) {
			minEndingHere = Math.min(nums[i], minEndingHere + nums[i]);
			min = Math.min(minEndingHere, min);
		}
		return min;
	};

	const maxSum = getMaxSum();
	const minSum = getMinSum();

	if (maxSum < 0) return maxSum;
	return Math.max(maxSum, totalSum - minSum);
};
```
