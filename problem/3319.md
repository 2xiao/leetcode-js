# [3319. ç¬¬ K å¤§çš„å®Œç¾äºŒå‰å­æ ‘çš„å¤§å°](https://2xiao.github.io/leetcode-js/problem/3319.html)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ ‘`](/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`äºŒå‰æ ‘`](/tag/binary-tree.md) [`æ’åº`](/tag/sorting.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/k-th-largest-perfect-subtree-size-in-binary-tree) [`LeetCode`](https://leetcode.com/problems/k-th-largest-perfect-subtree-size-in-binary-tree)

## é¢˜ç›®

You are given the `root` of a **binary tree** and an integer `k`.

Return an integer denoting the size of the `kth` **largest perfect binary** subtree, or `-1` if it doesn't exist.

A **perfect binary tree** is a tree where all leaves are on the same level,
and every parent has two children.

**Example 1:**

> **Input:** root = [5,3,6,5,2,5,7,1,8,null,null,6,8], k = 2
>
> **Output:** 3
>
> **Explanation:**
>
> ![](https://assets.leetcode.com/uploads/2024/06/21/image.jpg)
>
> The roots of the perfect binary subtrees are highlighted in black. Their sizes, in decreasing order are `[3, 3, 1, 1, 1, 1, 1, 1]`. The `2nd` largest size is 3.

**Example 2:**

> **Input:** root = [1,2,3,4,5,6,7], k = 1
>
> **Output:** 7
>
> **Explanation:**
>
> ![](https://assets.leetcode.com/uploads/2024/06/21/image1.jpg)
>
> The sizes of the perfect binary subtrees in decreasing order are `[7, 3, 3, 1, 1, 1, 1]`. The size of the largest perfect binary subtree is 7.

**Example 3:**

> **Input:** root = [1,2,3,null,4], k = 3
>
> **Output:** -1
>
> **Explanation:**
>
> ![](https://assets.leetcode.com/uploads/2024/06/21/image4.jpg)
>
> The sizes of the perfect binary subtrees in decreasing order are `[1, 1]`. There are fewer than 3 perfect binary subtrees.

**Constraints:**

- The number of nodes in the tree is in the range `[1, 2000]`.
- `1 <= Node.val <= 2000`
- `1 <= k <= 1024`

## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€æ£µ **äºŒå‰æ ‘** çš„æ ¹èŠ‚ç‚¹ `root` å’Œä¸€ä¸ªæ•´æ•°`k`ã€‚

è¿”å›ç¬¬ `k` å¤§çš„ **å®Œç¾äºŒå‰å­æ ‘** çš„å¤§å°ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™è¿”å› `-1`ã€‚

**å®Œç¾äºŒå‰æ ‘** æ˜¯æŒ‡æ‰€æœ‰å¶å­èŠ‚ç‚¹éƒ½åœ¨åŒä¸€å±‚çº§çš„æ ‘ï¼Œä¸”æ¯ä¸ªçˆ¶èŠ‚ç‚¹æ°æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ã€‚

**å­æ ‘** æ˜¯æŒ‡æ ‘ä¸­çš„æŸä¸€ä¸ªèŠ‚ç‚¹åŠå…¶æ‰€æœ‰åä»£å½¢æˆçš„æ ‘ã€‚

**ç¤ºä¾‹ 1ï¼š**

> **è¾“å…¥ï¼š** root = [5,3,6,5,2,5,7,1,8,null,null,6,8], k = 2
>
> **è¾“å‡ºï¼š** 3
>
> **è§£é‡Šï¼š**
>
> ![](https://assets.leetcode.com/uploads/2024/06/21/image.jpg)
>
> å®Œç¾äºŒå‰å­æ ‘çš„æ ¹èŠ‚ç‚¹åœ¨å›¾ä¸­ä»¥é»‘è‰²çªå‡ºæ˜¾ç¤ºã€‚å®ƒä»¬çš„å¤§å°æŒ‰é™åºæ’åˆ—ä¸º `[3, 3, 1, 1, 1, 1, 1, 1]`ã€‚  
> ç¬¬ `2` å¤§çš„å®Œç¾äºŒå‰å­æ ‘çš„å¤§å°æ˜¯ 3ã€‚

**ç¤ºä¾‹ 2ï¼š**

> **è¾“å…¥ï¼š** root = [1,2,3,4,5,6,7], k = 1
>
> **è¾“å‡ºï¼š** 7
>
> **è§£é‡Šï¼š**
>
> ![](https://assets.leetcode.com/uploads/2024/06/21/image1.jpg)
>
> å®Œç¾äºŒå‰å­æ ‘çš„å¤§å°æŒ‰é™åºæ’åˆ—ä¸º `[7, 3, 3, 1, 1, 1, 1]`ã€‚æœ€å¤§çš„å®Œç¾äºŒå‰å­æ ‘çš„å¤§å°æ˜¯ 7ã€‚

**ç¤ºä¾‹ 3ï¼š**

> **è¾“å…¥ï¼š** root = [1,2,3,null,4], k = 3
>
> **è¾“å‡ºï¼š** -1
>
> **è§£é‡Šï¼š**
>
> ![](https://assets.leetcode.com/uploads/2024/06/21/image4.jpg)
>
> å®Œç¾äºŒå‰å­æ ‘çš„å¤§å°æŒ‰é™åºæ’åˆ—ä¸º `[1, 1]`ã€‚å®Œç¾äºŒå‰å­æ ‘çš„æ•°é‡å°‘äº 3ã€‚

**æç¤ºï¼š**

- æ ‘ä¸­çš„èŠ‚ç‚¹æ•°ç›®åœ¨ `[1, 2000]` èŒƒå›´å†…ã€‚
- `1 <= Node.val <= 2000`
- `1 <= k <= 1024`

## è§£é¢˜æ€è·¯

å®Œç¾å­æ ‘æ˜¯æŒ‡è¯¥æ ‘çš„æ‰€æœ‰å¶å­èŠ‚ç‚¹åœ¨åŒä¸€å±‚ï¼Œä¸”æ¯ä¸ªéå¶å­èŠ‚ç‚¹éƒ½æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ã€‚å› æ­¤å¯ä»¥ä½¿ç”¨é€’å½’æ¥éå†äºŒå‰æ ‘ï¼Œæ£€æŸ¥æ¯ä¸ªèŠ‚ç‚¹çš„å­æ ‘æ˜¯å¦æ˜¯å®Œç¾å­æ ‘ã€‚

åœ¨é€’å½’è¿‡ç¨‹ä¸­ï¼Œåˆ¤æ–­æŸä¸ªèŠ‚ç‚¹çš„å·¦å³å­æ ‘æ˜¯å¦é«˜åº¦ç›¸åŒä¸”éƒ½æ˜¯å®Œç¾çš„ã€‚å¦‚æœæ˜¯ï¼Œå¯ä»¥è®¡ç®—å½“å‰å­æ ‘çš„èŠ‚ç‚¹æ•°ã€‚

ä½¿ç”¨ä¸€ä¸ªæ•°ç»„å­˜å‚¨æ‰€æœ‰å®Œç¾å­æ ‘çš„å¤§å°ã€‚ç„¶ååœ¨é€’å½’å®Œæˆåï¼Œæ’åºè¯¥æ•°ç»„ï¼Œå¹¶æ‰¾åˆ°ç¬¬ `k` å¤§çš„å®Œç¾å­æ ‘çš„å¤§å°ã€‚

å¦‚æœæ•°ç»„çš„å¤§å°å°äº `k`ï¼Œè¿”å› `-1`ï¼Œå¦åˆ™è¿”å›æ•°ç»„ä¸­ç¬¬ `k` å¤§çš„å…ƒç´ ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œæ¯ä¸ªèŠ‚ç‚¹éå†ä¸€æ¬¡ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œç”¨äºå­˜å‚¨æ‰€æœ‰å®Œç¾å­æ ‘çš„å¤§å°ã€‚

## ä»£ç 

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthLargestPerfectSubtree = function (root, k) {
	let sizes = findPerfectSubtree(root);
	if (sizes.length < k) return -1;

	// æŒ‰é™åºæ’åº
	sizes.sort((a, b) => b - a);
	return sizes[k - 1];
};

var findPerfectSubtree = function (root) {
	let sizes = [];

	// é€’å½’å‡½æ•°ï¼Œè¿”å›å½“å‰å­æ ‘çš„é«˜åº¦ã€èŠ‚ç‚¹æ•°å’Œæ˜¯å¦ä¸ºå®Œç¾äºŒå‰æ ‘
	const dfs = (root) => {
		if (!root) return [0, 0, true];
		const [leftHeight, leftCount, isLeftPerfect] = dfs(root.left);
		const [rightHeight, rightCount, isRightPerfect] = dfs(root.right);

		const rootCount = leftCount + rightCount + 1;

		// æ£€æŸ¥æ˜¯å¦ä¸ºå®Œç¾å­æ ‘
		if (leftHeight == rightHeight && isLeftPerfect && isRightPerfect) {
			sizes.push(rootCount);
			return [leftHeight + 1, rootCount, true];
		}
		return [Math.max(leftHeight, rightHeight) + 1, rootCount, false];
	};

	dfs(root);
	return sizes;
};
```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 110 | [å¹³è¡¡äºŒå‰æ ‘](https://leetcode.com/problems/balanced-binary-tree) | [[âœ“]](/problem/0110.md) |  [`æ ‘`](/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`äºŒå‰æ ‘`](/tag/binary-tree.md) | <font color=#15bd66>Easy</font> |