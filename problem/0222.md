# [222. å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°](https://leetcode.com/problems/count-complete-tree-nodes)

ğŸŸ¢ <font color=#15bd66>Easy</font>&emsp; ğŸ”–&ensp; [`ä½è¿ç®—`](/tag/bit-manipulation.md) [`æ ‘`](/tag/tree.md) [`äºŒåˆ†æŸ¥æ‰¾`](/tag/binary-search.md) [`äºŒå‰æ ‘`](/tag/binary-tree.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/count-complete-tree-nodes)

## é¢˜ç›®

Given the `root` of a **complete** binary tree, return the number of the nodes
in the tree.

According to
**[Wikipedia](http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees)**
, every level, except possibly the last, is completely filled in a complete
binary tree, and all nodes in the last level are as far left as possible. It
can have between `1` and `2h` nodes inclusive at the last level `h`.

Design an algorithm that runs in less than `O(n)` time complexity.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/01/14/complete.jpg)

> Input: root = [1,2,3,4,5,6]
>
> Output: 6

**Example 2:**

> Input: root = []
>
> Output: 0

**Example 3:**

> Input: root = [1]
>
> Output: 1

**Constraints:**

- The number of nodes in the tree is in the range `[0, 5 * 10^4]`.
- `0 <= Node.val <= 5 * 10^4`
- The tree is guaranteed to be **complete**.

## é¢˜ç›®å¤§æ„

è¾“å‡ºä¸€é¢—å®Œå…¨äºŒå‰æ ‘çš„ç»“ç‚¹ä¸ªæ•°ã€‚

## è§£é¢˜æ€è·¯

### æ€è·¯ä¸€ï¼šå±‚åºéå†

æŒ‰ç…§å±‚åºéå†ä¸€æ¬¡æ ‘ï¼Œç„¶åæŠŠæ¯ä¸€å±‚çš„ç»“ç‚¹ä¸ªæ•°ç›¸åŠ å³å¯ã€‚

---

### æ€è·¯äºŒï¼šé€’å½’

å…³é”®æ€æƒ³æ˜¯æ¯”è¾ƒå·¦å³å­æ ‘çš„æ·±åº¦ã€‚å¦‚æœå®ƒä»¬ç›¸ç­‰ï¼Œå·¦å­æ ‘æ˜¯ä¸€ä¸ªæ»¡äºŒå‰æ ‘ï¼ŒèŠ‚ç‚¹æ€»æ•°å¯ä»¥ç›´æ¥è®¡ç®— (`2 ^ i - 1`)ã€‚å¦‚æœæ·±åº¦ä¸ç›¸ç­‰ï¼Œå³å­æ ‘æ˜¯ä¸€ä¸ªæ»¡äºŒå‰æ ‘ï¼ŒèŠ‚ç‚¹æ€»æ•°ä¹Ÿå¯ä»¥æ ¹æ®æ·±åº¦è®¡ç®—ã€‚é€’å½’è°ƒç”¨å¤„ç†ä¸¤ä¸ªå­æ ‘ï¼Œç›´åˆ°è¾¾åˆ°åŸºæœ¬æƒ…å†µï¼ˆä¸€ä¸ªç©ºèŠ‚ç‚¹ï¼‰ã€‚

- `countNodes` å‡½æ•°ä»¥å®Œå…¨äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ä½œä¸ºè¾“å…¥ï¼Œé€’å½’è®¡ç®—èŠ‚ç‚¹çš„æ•°é‡ã€‚
- `getDepth` å‡½æ•°é€šè¿‡éå†å·¦å­©å­ç›´åˆ°å¶å­èŠ‚ç‚¹ï¼Œè®¡ç®—ç»™å®šèŠ‚ç‚¹çš„æ·±åº¦ã€‚

## ä»£ç 

::: code-tabs

@tab å±‚åºéå†

```javascript
/**
 * @param {TreeNode} root
 * @return {number}
 */
var countNodes = function (root) {
	let res = 0;
	if (!root) return res;
	let queue = [root];
	while (queue.length) {
		let len = queue.length;
		for (let i = 0; i < len; i++) {
			if (queue[i].left) queue.push(queue[i].left);
			if (queue[i].right) queue.push(queue[i].right);
			res++;
		}
		queue = queue.slice(len);
	}
	return res;
};
```

@tab é€’å½’

```javascript
/**
 * @param {TreeNode} root
 * @return {number}
 */
var countNodes = function (root) {
	if (!root) return 0;

	const getDepth = (node) => {
		let depth = 0;
		while (node) {
			node = node.left;
			depth++;
		}
		return depth;
	};

	let leftDepth = getDepth(root.left);
	let rightDepth = getDepth(root.right);

	if (leftDepth == rightDepth)
		return Math.pow(2, leftDepth) + countNodes(root.right);
	return Math.pow(2, rightDepth) + countNodes(root.left);
};
```

:::

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 270 | [æœ€æ¥è¿‘çš„äºŒå‰æœç´¢æ ‘å€¼](https://leetcode.com/problems/closest-binary-search-tree-value) |  |  [`æ ‘`](/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`äºŒå‰æœç´¢æ ‘`](/tag/binary-search-tree.md) `2+` | <font color=#15bd66>Easy</font> |