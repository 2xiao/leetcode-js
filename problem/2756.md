---
title: 2756. æ‰¹å¤„ç†æŸ¥è¯¢ ğŸ”’
description: LeetCode,2756. æ‰¹å¤„ç†æŸ¥è¯¢ ğŸ”’,æ‰¹å¤„ç†æŸ¥è¯¢,Query Batching,è§£é¢˜æ€è·¯
keywords:
  - LeetCode
  - 2756. æ‰¹å¤„ç†æŸ¥è¯¢ ğŸ”’
  - æ‰¹å¤„ç†æŸ¥è¯¢
  - Query Batching
  - è§£é¢˜æ€è·¯
---

# 2756. æ‰¹å¤„ç†æŸ¥è¯¢ ğŸ”’

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/query-batching) [`LeetCode`](https://leetcode.com/problems/query-batching)

## é¢˜ç›®

Batching multiple small queries into a single large query can be a useful
optimization. Write a class `QueryBatcher` that implements this functionality.

The constructor should accept two parameters:

- An asynchronous function `queryMultiple` which accepts an array of string keys `input`. It will resolve with an array of values that is the same length as the input array. Each index corresponds to the value associated with `input[i]`. You can assume the promise will never reject.
- A throttle time in milliseconds `t`.

The class has a single method.

- `async getValue(key)`. Accepts a single string key and resolves with a single string value. The keys passed to this function should eventually get passed to the `queryMultiple` function. `queryMultiple` should never be called consecutively within `t` milliseconds. The first time `getValue` is called, `queryMultiple` should immediately be called with that single key. If after `t` milliseconds, `getValue` had been called again, all the passed keys should be passed to `queryMultiple` and ultimately returned. You can assume every key passed to this method is unique.

The following diagram illustrates how the throttling algorithm works. Each
rectangle represents 100ms. The throttle time is 400ms.

![Throttle
info](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2700-2799/2756.Query%20Batching/images/throttle.png)

**Example 1:**

> Input:
>
> ```js
> queryMultiple = async function (keys) {
> 	return keys.map((key) => key + '!');
> };
>
> t = 100;
>
> calls = [
> 	{ key: 'a', time: 10 },
> 	{ key: 'b', time: 20 },
> 	{ key: 'c', time: 30 }
> ];
> ```
>
> Output:
>
> ```js
> [
> 	{ resolved: 'a!', time: 10 },
> 	{ resolved: 'b!', time: 110 },
> 	{ resolved: 'c!', time: 110 }
> ];
> ```
>
> Explanation:
>
> ```js
> const batcher = new QueryBatcher(queryMultiple, 100);
> setTimeout(() => batcher.getValue('a'), 10); // "a!" at t=10ms
> setTimeout(() => batcher.getValue('b'), 20); // "b!" at t=110ms
> setTimeout(() => batcher.getValue('c'), 30); // "c!" at t=110ms
> ```
>
> queryMultiple simply adds an "!" to the key
>
> At t=10ms, getValue('a') is called, queryMultiple(['a']) is immediately called and the result is immediately returned.
>
> At t=20ms, getValue('b') is called but the query is queued
>
> At t=30ms, getValue('c') is called but the query is queued.
>
> At t=110ms, queryMultiple(['a', 'b']) is called and the results are immediately returned.

**Example 2:**

> Input:
>
> ```js
> queryMultiple = async function (keys) {
> 	await new Promise((res) => setTimeout(res, 100));
> 	return keys.map((key) => key + '!');
> };
>
> t = 100;
>
> calls = [
> 	{ key: 'a', time: 10 },
> 	{ key: 'b', time: 20 },
> 	{ key: 'c', time: 30 }
> ];
> ```
>
> Output:
>
> ```js
> [
> 	{ resolved: 'a!', time: 110 },
> 	{ resolved: 'b!', time: 210 },
> 	{ resolved: 'c!', time: 210 }
> ];
> ```
>
> Explanation:
>
> This example is the same as example 1 except there is a 100ms delay in queryMultiple. The results are the same except the promises resolve 100ms later.

**Example 3:**

> Input:
>
> ```js
> queryMultiple = async function(keys) {
> 	await new Promise(res => setTimeout(res, keys.length * 100));
> 	return keys.map(key => key + '!');
> }
>
> t = 100
>
> calls = [
> 	{"key": "a", "time": 10},
> 	{"key": "b", "time": 20},
> 	{"key": "c", "time": 30},
> 	{"key": "d", "time": 40},
> 	{"key": "e", "time": 250}
> 	{"key": "f", "time": 300}
> ]
> ```
>
> Output:
>
> ```js
> [
> 	{ resolved: 'a!', time: 110 },
> 	{ resolved: 'e!', time: 350 },
> 	{ resolved: 'b!', time: 410 },
> 	{ resolved: 'c!', time: 410 },
> 	{ resolved: 'd!', time: 410 },
> 	{ resolved: 'f!', time: 450 }
> ];
> ```
>
> Explanation: queryMultiple(['a']) is called at t=10ms, it is resolved at t=110ms
>
> ```js
> queryMultiple(['b', 'c', 'd']) is called at t=110ms, it is resolved at 410ms
> queryMultiple(['e']) is called at t=250ms, it is resolved at 350ms
> queryMultiple(['f']) is called at t=350ms, it is resolved at 450ms
> ```

**Constraints:**

- `0 <= t <= 1000`
- `0 <= calls.length <= 10`
- `1 <= key.length <= 100`
- All keys are unique

## é¢˜ç›®å¤§æ„

å°†å¤šä¸ªå°æŸ¥è¯¢æ‰¹å¤„ç†ä¸ºå•ä¸ªå¤§æŸ¥è¯¢å¯ä»¥æ˜¯ä¸€ç§æœ‰ç”¨çš„ä¼˜åŒ–ã€‚è¯·ç¼–å†™ä¸€ä¸ªåä¸º `QueryBatcher` çš„ç±»æ¥å®ç°è¿™ä¸ªåŠŸèƒ½ã€‚

å®ƒçš„æ„é€ å‡½æ•°åº”æ¥å—ä¸¤ä¸ªå‚æ•°ï¼š

- ä¸€ä¸ªå¼‚æ­¥å‡½æ•° `queryMultiple` ï¼Œå®ƒæ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²é”®çš„æ•°ç»„ä½œä¸ºè¾“å…¥ã€‚å®ƒå°†è¿”å›ä¸€ä¸ªä¸è¾“å…¥æ•°ç»„é•¿åº¦ç›¸åŒçš„å€¼æ•°ç»„ã€‚æ¯ä¸ªç´¢å¼•å¯¹åº”äºä¸ `input[i]` ç›¸å…³è”çš„å€¼ã€‚å¯ä»¥å‡è®¾è¯¥å¼‚æ­¥å‡½æ•°æ°¸è¿œä¸ä¼šè¢«æ‹’ç»ã€‚
- ä¸€ä¸ªä»¥æ¯«ç§’ä¸ºå•ä½çš„èŠ‚æµæ—¶é—´`t`ã€‚

è¯¥ç±»æœ‰ä¸€ä¸ªæ–¹æ³•ï¼š

- `async getValue(key)`ï¼šæ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²é”®ï¼Œå¹¶è¿”å›ä¸€ä¸ªè§£æåçš„å­—ç¬¦ä¸²å€¼ã€‚ä¼ é€’ç»™æ­¤å‡½æ•°çš„é”®å€¼æœ€ç»ˆåº”ä¼ é€’ç»™ `queryMultiple` å‡½æ•°ã€‚åœ¨ `t` æ¯«ç§’å†…ä¸åº”è¿ç»­è°ƒç”¨ `queryMultiple` ã€‚ç¬¬ä¸€æ¬¡è°ƒç”¨ `getValue` æ—¶ï¼Œåº”ç«‹å³ä½¿ç”¨è¯¥å•ä¸ªé”®è°ƒç”¨ `queryMultiple` ã€‚å¦‚æœåœ¨ `t` æ¯«ç§’åå†æ¬¡è°ƒç”¨äº† `getValue` ï¼Œåˆ™æ‰€æœ‰ä¼ é€’çš„é”®åº”ä¼ é€’ç»™ `queryMultiple` ï¼Œå¹¶è¿”å›æœ€ç»ˆç»“æœã€‚å¯ä»¥å‡è®¾ä¼ é€’ç»™è¯¥æ–¹æ³•çš„æ¯ä¸ªé”®éƒ½æ˜¯å”¯ä¸€çš„ã€‚

ä¸‹å›¾è¯´æ˜äº†èŠ‚æµç®—æ³•çš„å·¥ä½œåŸç†ã€‚æ¯ä¸ªçŸ©å½¢ä»£è¡¨ 100 æ¯«ç§’ã€‚èŠ‚æµæ—¶é—´ä¸º 400 æ¯«ç§’ã€‚

![Throttle
info](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2700-2799/2756.Query%20Batching/images/throttle.png)

**ç¤ºä¾‹ 1ï¼š**

> **è¾“å…¥ï¼š**
>
> ```js
> queryMultiple = async function (keys) {
> 	return keys.map((key) => key + '!');
> };
>
> t = 100;
>
> calls = [
> 	{ key: 'a', time: 10 },
> 	{ key: 'b', time: 20 },
> 	{ key: 'c', time: 30 }
> ];
> ```
>
> **è¾“å‡ºï¼š**
>
> ```js
> [
> 	{ resolved: 'a!', time: 10 },
> 	{ resolved: 'b!', time: 110 },
> 	{ resolved: 'c!', time: 110 }
> ];
> ```
>
> **è§£é‡Šï¼š**
>
> ```js
> const batcher = new QueryBatcher(queryMultiple, 100);
> setTimeout(() => batcher.getValue('a'), 10); // "a!" at t=10ms
> setTimeout(() => batcher.getValue('b'), 20); // "b!" at t=110ms
> setTimeout(() => batcher.getValue('c'), 30); // "c!" at t=110ms
> ```
>
> queryMultiple ç®€å•åœ°ç»™é”®æ·»åŠ äº†"!"ã€‚
>
> åœ¨ t=10ms æ—¶ï¼Œè°ƒç”¨ getValue('a')ï¼Œç«‹å³è°ƒç”¨ queryMultiple(['a']) å¹¶ç«‹å³è¿”å›ç»“æœã€‚
>
> åœ¨ t=20ms æ—¶ï¼Œè°ƒç”¨ getValue('b')ï¼Œä½†æŸ¥è¯¢éœ€è¦ç­‰å¾…ã€‚
>
> åœ¨ t=30ms æ—¶ï¼Œè°ƒç”¨ getValue('c')ï¼Œä½†æŸ¥è¯¢éœ€è¦ç­‰å¾…ã€‚
>
> åœ¨ t=110ms æ—¶ï¼Œè°ƒç”¨ queryMultiple(['b', 'c']) å¹¶ç«‹å³è¿”å›ç»“æœã€‚

**ç¤ºä¾‹ 2ï¼›**

> **è¾“å…¥ï¼š**
>
> ```js
> queryMultiple = async function (keys) {
> 	await new Promise((res) => setTimeout(res, 100));
> 	return keys.map((key) => key + '!');
> };
>
> t = 100;
>
> calls = [
> 	{ key: 'a', time: 10 },
> 	{ key: 'b', time: 20 },
> 	{ key: 'c', time: 30 }
> ];
> ```
>
> **è¾“å‡ºï¼š**
>
> ```js
> [
> 	{ resolved: 'a!', time: 110 },
> 	{ resolved: 'b!', time: 210 },
> 	{ resolved: 'c!', time: 210 }
> ];
> ```
>
> **è§£é‡Šï¼š**
>
> è¿™ä¸ªä¾‹å­ä¸ç¤ºä¾‹ 1 ç›¸åŒï¼Œåªæ˜¯åœ¨ queryMultiple ä¸­æœ‰ä¸€ä¸ª 100ms çš„å»¶è¿Ÿã€‚ç»“æœä¹Ÿç›¸åŒï¼Œåªæ˜¯ promise çš„è§£ææ—¶é—´å»¶è¿Ÿäº† 100msã€‚

**ç¤ºä¾‹ 3ï¼š**

> **è¾“å…¥ï¼š**
>
> ```js
> queryMultiple = async function(keys) {
> 	await new Promise(res => setTimeout(res, keys.length * 100));
> 	return keys.map(key => key + '!');
> }
>
> t = 100
>
> calls = [
> 	{"key": "a", "time": 10},
> 	{"key": "b", "time": 20},
> 	{"key": "c", "time": 30},
> 	{"key": "d", "time": 40},
> 	{"key": "e", "time": 250}
> 	{"key": "f", "time": 300}
> ]
> ```
>
> **è¾“å‡ºï¼š**
>
> ```js
> [
> 	{ resolved: 'a!', time: 110 },
> 	{ resolved: 'e!', time: 350 },
> 	{ resolved: 'b!', time: 410 },
> 	{ resolved: 'c!', time: 410 },
> 	{ resolved: 'd!', time: 410 },
> 	{ resolved: 'f!', time: 450 }
> ];
> ```
>
> **è§£é‡Šï¼š** åœ¨ t=10ms æ—¶ï¼Œè°ƒç”¨ queryMultiple(['a']) ï¼Œåœ¨ t=110ms æ—¶è§£æã€‚
>
> åœ¨ t=110ms æ—¶ï¼Œè°ƒç”¨ queryMultiple(['b', 'c', 'd']) ï¼Œåœ¨ t=410ms æ—¶è§£æã€‚
>
> åœ¨ t=250ms æ—¶ï¼Œè°ƒç”¨ queryMultiple(['e']) ï¼Œåœ¨ t=350ms æ—¶è§£æã€‚
>
> åœ¨ t=350ms æ—¶ï¼Œè°ƒç”¨ queryMultiple(['f']) ï¼Œåœ¨ t=450ms æ—¶è§£æã€‚

**æç¤ºï¼š**

- `0 <= t <= 1000`
- `0 <= calls.length <= 10`
- `1 <= key.length <= 100`
- æ‰€æœ‰çš„é”®å€¼éƒ½æ˜¯å”¯ä¸€çš„

## è§£é¢˜æ€è·¯

1.  **æ„é€ å‡½æ•°**ï¼šåˆå§‹åŒ–`queryMultiple`å‡½æ•°å’ŒèŠ‚æµæ—¶é—´`t`ï¼Œå¹¶åˆ›å»ºä¸€ä¸ªæ‰¹æ¬¡ï¼ˆæ•°ç»„ï¼‰æ¥å­˜å‚¨éœ€è¦æŸ¥è¯¢çš„é”®ï¼Œä»¥åŠå¦ä¸€ä¸ªå¯¹è±¡æ¥å­˜å‚¨æ¯ä¸ªé”®çš„ Promise ä»¥ä¾¿åœ¨æ‰¹å¤„ç†åè§£æç»“æœã€‚

    - `queue` å­˜å‚¨å½“å‰æ‰¹æ¬¡çš„é”®ã€‚
    - `promises` è®°å½•æ¯ä¸ªé”®å¯¹åº”çš„ Promiseï¼Œä½¿æ¯ä¸ªè°ƒç”¨è€…éƒ½èƒ½è·å–åˆ°æŸ¥è¯¢ç»“æœã€‚

2.  **æ‰¹å¤„ç†é€»è¾‘**ï¼š

    - ç¬¬ä¸€æ¬¡è°ƒç”¨ `getValue` æ—¶ï¼Œç«‹å³è§¦å‘æŸ¥è¯¢ã€‚
    - æ¥ä¸‹æ¥çš„è°ƒç”¨åœ¨`t`æ¯«ç§’å†…åªä¼šæ·»åŠ åˆ°æ‰¹æ¬¡ä¸­ï¼Œå¹¶ç­‰å¾…æ‰¹æ¬¡åˆ°è¾¾å»¶è¿Ÿæ—¶é—´åå†ä¸€èµ·æŸ¥è¯¢ã€‚
    - ä½¿ç”¨`setTimeout`æ§åˆ¶æ‰¹æ¬¡çš„é—´éš”æ—¶é—´ã€‚

3.  **getValue æ–¹æ³•**ï¼š

    - `getValue`æ¥å—ä¸€ä¸ªé”®ï¼Œè¿”å›ä¸è¯¥é”®å…³è”çš„å€¼ã€‚
    - å¦‚æœè¯¥é”®æ˜¯ç¬¬ä¸€æ¬¡å‡ºç°ï¼Œåˆ™åˆ›å»ºä¸€ä¸ª Promiseï¼Œå°†å®ƒåŠ å…¥æ‰¹å¤„ç†é˜Ÿåˆ—`queue`ï¼Œå¹¶åœ¨æ‰¹æ¬¡æ‰§è¡Œåè§£æç»“æœã€‚
    - ä½¿ç”¨ `clearTimeout` å’Œ `setTimeout` æ¥æ§åˆ¶è°ƒç”¨é—´éš”ã€‚æ²¡æœ‰è®¡æ—¶å™¨æ—¶ç«‹å³æŸ¥è¯¢ï¼Œæœ‰è®¡æ—¶å™¨åˆ™ç­‰å¾…å…¶åˆ°æœŸã€‚
    - å½“è¾¾åˆ°`t`æ¯«ç§’å»¶è¿Ÿæ—¶ï¼Œå°†æ‰€æœ‰ç§¯ç´¯çš„é”®ä¼ é€’ç»™`queryMultiple`ï¼Œç„¶åå°†å¯¹åº”çš„ç»“æœæ˜ å°„ç»™å„è‡ªçš„ Promiseã€‚

4.  **\_triggerQuery æ–¹æ³•**ï¼š

    - å°† `queue` ä¸­çš„æ‰€æœ‰é”®æ‰¹é‡æŸ¥è¯¢ï¼Œå¹¶å°†è¿”å›ç»“æœåˆ†é…åˆ°ç›¸åº”çš„ Promiseã€‚
    - æŸ¥è¯¢åæ¸…ç©º `queue` å¹¶é‡ç½®è®¡æ—¶å™¨ã€‚

## ä»£ç 

```javascript
class QueryBatcher {
	constructor(queryMultiple, t) {
		this.queryMultiple = queryMultiple;
		this.t = t;
		this.queue = []; // å­˜å‚¨éœ€è¦æŸ¥è¯¢çš„é”®
		this.promises = {}; // å­˜å‚¨æ¯ä¸ªé”®çš„ Promise
		this.timeout = null; // ç”¨äºæ§åˆ¶æ‰¹æ¬¡çš„å»¶è¿Ÿ
	}

	async getValue(key) {
		// å¦‚æœè¯¥é”®æ˜¯ç¬¬ä¸€æ¬¡å‡ºç°ï¼Œåˆ™åˆå§‹åŒ–å®ƒçš„ Promise
		if (!this.promises[key]) {
			this.promises[key] = new Promise((resolve) => {
				this.queue.push(key);
				this.promises[key].resolve = resolve;
			});
			// å¦‚æœæ²¡æœ‰å»¶è¿Ÿè®¡æ—¶å™¨ï¼Œåˆ™ç«‹å³æŸ¥è¯¢å½“å‰æ‰¹æ¬¡ä¸­çš„é”®
			if (this.timeout === null) {
				this._triggerQuery();
			} else {
				// å¦‚æœå·²è®¾ç½®å»¶è¿Ÿè®¡æ—¶å™¨ï¼Œåˆ™ç­‰å¾…å½“å‰è®¡æ—¶å™¨åˆ°æœŸåå†æŸ¥è¯¢
				clearTimeout(this.timeout);
				this.timeout = setTimeout(() => this._triggerQuery(), this.t);
			}
		}
		return this.promises[key];
	}

	// æ‰§è¡Œæ‰¹æ¬¡æŸ¥è¯¢å¹¶è§£æç»“æœ
	async _triggerQuery() {
		const keysToQuery = [...this.queue];
		this.queue = []; // æ¸…ç©ºå½“å‰é˜Ÿåˆ—
		this.timeout = null; // é‡ç½®è®¡æ—¶å™¨

		// è¿›è¡ŒæŸ¥è¯¢ï¼Œå¹¶å°†ç»“æœåˆ†å‘ç»™ç›¸åº”çš„ Promise
		const results = await this.queryMultiple(keysToQuery);
		keysToQuery.forEach((key, index) => {
			this.promises[key].resolve(results[index]);
			delete this.promises[key]; // æŸ¥è¯¢ååˆ é™¤è¯¥é”®çš„ Promise
		});
	}
}
```
