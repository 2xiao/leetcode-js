# [433. æœ€å°åŸºå› å˜åŒ–](https://leetcode.com/problems/minimum-genetic-mutation)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/outline/tag/breadth-first-search.md) [`å“ˆå¸Œè¡¨`](/outline/tag/hash-table.md) [`å­—ç¬¦ä¸²`](/outline/tag/string.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/minimum-genetic-mutation)

## é¢˜ç›®

A gene string can be represented by an 8-character long string, with choices
from `'A'`, `'C'`, `'G'`, and `'T'`.

Suppose we need to investigate a mutation from a gene string `startGene` to a
gene string `endGene` where one mutation is defined as one single character
changed in the gene string.

- For example, `"AACCGGTT" --> "AACCGGTA"` is one mutation.

There is also a gene bank `bank` that records all the valid gene mutations. A
gene must be in `bank` to make it a valid gene string.

Given the two gene strings `startGene` and `endGene` and the gene bank `bank`,
return _the minimum number of mutations needed to mutate from_`startGene`
_to_`endGene`. If there is no such a mutation, return `-1`.

Note that the starting point is assumed to be valid, so it might not be
included in the bank.

**Example 1:**

> Input: startGene = "AACCGGTT", endGene = "AACCGGTA", bank = ["AACCGGTA"]
>
> Output: 1

**Example 2:**

> Input: startGene = "AACCGGTT", endGene = "AAACGGTA", bank = ["AACCGGTA","AACCGCTA","AAACGGTA"]
>
> Output: 2

**Constraints:**

- `0 <= bank.length <= 10`
- `startGene.length == endGene.length == bank[i].length == 8`
- `startGene`, `endGene`, and `bank[i]` consist of only the characters `['A', 'C', 'G', 'T']`.

## é¢˜ç›®å¤§æ„

åŸºå› åºåˆ—å¯ä»¥è¡¨ç¤ºä¸ºä¸€æ¡ç”± `8` ä¸ªå­—ç¬¦ç»„æˆçš„å­—ç¬¦ä¸²ï¼Œå…¶ä¸­æ¯ä¸ªå­—ç¬¦éƒ½æ˜¯ `'A'`ã€`'C'`ã€`'G'` å’Œ `'T'` ä¹‹ä¸€ã€‚

å‡è®¾æˆ‘ä»¬éœ€è¦è°ƒæŸ¥ä»åŸºå› åºåˆ— `start` å˜ä¸º `end` æ‰€å‘ç”Ÿçš„åŸºå› å˜åŒ–ã€‚ä¸€æ¬¡åŸºå› å˜åŒ–å°±æ„å‘³ç€è¿™ä¸ªåŸºå› åºåˆ—ä¸­çš„ä¸€ä¸ªå­—ç¬¦å‘ç”Ÿäº†å˜åŒ–ã€‚

ä¾‹å¦‚ï¼Œ`"AACCGGTT" --> "AACCGGTA"` å°±æ˜¯ä¸€æ¬¡åŸºå› å˜åŒ–ã€‚

å¦æœ‰ä¸€ä¸ªåŸºå› åº“ `bank` è®°å½•äº†æ‰€æœ‰æœ‰æ•ˆçš„åŸºå› å˜åŒ–ï¼Œåªæœ‰åŸºå› åº“ä¸­çš„åŸºå› æ‰æ˜¯æœ‰æ•ˆçš„åŸºå› åºåˆ—ã€‚ï¼ˆå˜åŒ–åçš„åŸºå› å¿…é¡»ä½äºåŸºå› åº“ `bank` ä¸­ï¼‰

ç»™ä½ ä¸¤ä¸ªåŸºå› åºåˆ— `start` å’Œ `end` ï¼Œä»¥åŠä¸€ä¸ªåŸºå› åº“ `bank` ï¼Œè¯·ä½ æ‰¾å‡ºå¹¶è¿”å›èƒ½å¤Ÿä½¿ `start` å˜åŒ–ä¸º `end` æ‰€éœ€çš„æœ€å°‘å˜åŒ–æ¬¡æ•°ã€‚å¦‚æœæ— æ³•å®Œæˆæ­¤åŸºå› å˜åŒ–ï¼Œè¿”å› `-1` ã€‚

æ³¨æ„ï¼šèµ·å§‹åŸºå› åºåˆ— `start` é»˜è®¤æ˜¯æœ‰æ•ˆçš„ï¼Œä½†æ˜¯å®ƒå¹¶ä¸ä¸€å®šä¼šå‡ºç°åœ¨åŸºå› åº“ä¸­ã€‚

## è§£é¢˜æ€è·¯

è¿™ä¸ªé—®é¢˜å¯ä»¥è§†ä½œæ˜¯ä¸€ä¸ªæ— æƒå›¾çš„æœ€çŸ­è·¯å¾„é—®é¢˜ï¼Œæ¯ä¸ªåŸºå› åºåˆ—æ˜¯å›¾ä¸­çš„èŠ‚ç‚¹ï¼Œç›¸é‚»èŠ‚ç‚¹æ˜¯é‚£äº›åªç›¸å·®ä¸€ä¸ªå­—ç¬¦çš„åºåˆ—ã€‚è¦æ‰¾æœ€çŸ­è·¯å¾„ï¼Œå¯ä»¥ä½¿ç”¨ **å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰**ã€‚

1. å°†èµ·å§‹åºåˆ—æ”¾å…¥é˜Ÿåˆ—ï¼ŒåŒæ—¶è®¾å®šä¸€ä¸ªé›†åˆç”¨äºè®°å½•å·²ç»è®¿é—®è¿‡çš„åŸºå› åºåˆ—ï¼Œé¿å…é‡å¤è®¿é—®ã€‚
2. æ¯æ¬¡ä»é˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªåŸºå› åºåˆ—ï¼Œå°è¯•å°†å…¶æ¯ä¸ªå­—ç¬¦æ›¿æ¢ä¸º `A`ã€`C`ã€`G`ã€`T`ï¼Œçœ‹çœ‹æ˜¯å¦èƒ½å¾—åˆ°ä¸€ä¸ªæ–°çš„æœ‰æ•ˆåºåˆ—ï¼ˆè¿™ä¸ªæ–°åºåˆ—éœ€è¦åœ¨åŸºå› åº“ä¸­å­˜åœ¨ï¼Œä¸”æ²¡æœ‰è¢«è®¿é—®è¿‡ï¼‰ã€‚
3. å¦‚æœæŸæ¬¡å¾—åˆ°çš„åºåˆ—ç­‰äºç›®æ ‡åºåˆ—ï¼Œç›´æ¥è¿”å›å½“å‰çš„å˜åŒ–æ¬¡æ•°ã€‚
4. å¦‚æœè¯¥åºåˆ—æœ‰æ•ˆä¸”æœªè®¿é—®ï¼Œåˆ™å°†å…¶åŠ å…¥é˜Ÿåˆ—ï¼Œç»§ç»­ä¸‹ä¸€æ­¥çš„éå†ã€‚
5. å¦‚æœé˜Ÿåˆ—ä¸ºç©ºä½†è¿˜æœªæ‰¾åˆ°ç›®æ ‡åºåˆ—ï¼Œè¿”å› `-1`ï¼Œè¡¨ç¤ºæ— æ³•åˆ°è¾¾ç›®æ ‡åºåˆ—ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(M * N)`ï¼Œå…¶ä¸­ `M` æ˜¯åŸºå› åºåˆ—çš„é•¿åº¦ï¼ˆ8ï¼‰ï¼Œ`N` æ˜¯åŸºå› åº“çš„å¤§å°ã€‚å¯¹äºæ¯ä¸ªåºåˆ—ï¼Œéƒ½æœ‰ 8 ä¸ªä½ç½®å¯ä»¥å˜åŒ–ï¼Œæ¯ä¸ªä½ç½®å¯ä»¥é€‰æ‹© 3 ç§ä¸åŒçš„å­—ç¬¦ï¼Œå› æ­¤æ—¶é—´å¤æ‚åº¦ç›¸å¯¹è¾ƒä½ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(N)`ã€‚

## ä»£ç 

```javascript
/**
 * @param {string} startGene
 * @param {string} endGene
 * @param {string[]} bank
 * @return {number}
 */
var minMutation = function (startGene, endGene, bank) {
	let bankSet = new Set(bank); // å°†bankè½¬ä¸ºsetï¼ŒæŸ¥æ‰¾æ›´å¿«
	if (!bankSet.has(endGene)) return -1;
	// æ‰€æœ‰å¯èƒ½çš„å­—ç¬¦
	const gene = ['A', 'G', 'C', 'T'];

	// BFS
	let queue = [startGene],
		visited = new Set([startGene]), // è®°å½•å·²è®¿é—®çš„åŸºå› åºåˆ—
		step = 0;

	while (queue.length) {
		const len = queue.length;

		for (let i = 0; i < len; i++) {
			const cur = queue.shift();
			// å¦‚æœæ–°çš„åŸºå› åºåˆ—å°±æ˜¯ç›®æ ‡åºåˆ—
			if (cur == endGene) {
				return step;
			}
			// ç”Ÿæˆæ–°çš„åŸºå› åºåˆ—
			for (let newGene of getAllMutation(cur)) {
				// å¦‚æœæ–°çš„åŸºå› åºåˆ—åœ¨åŸºå› åº“ä¸­ï¼Œä¸”æ²¡æœ‰è®¿é—®è¿‡
				if (!visited.has(newGene) && bankSet.has(newGene)) {
					queue.push(newGene);
					visited.add(newGene);
				}
			}
		}
		step++;
	}
	return -1;
};

// æ±‚å‡ºæ‰€æœ‰å¯èƒ½çš„åŸºå› çªå˜ç»“æœ
var getAllMutation = function (gene) {
	let res = [],
		chars = gene.split('');

	for (let i = 0; i < chars.length; i++) {
		const char = chars[i];
		for (let newChar of ['A', 'G', 'C', 'T']) {
			chars[i] = newChar;
			res.push(chars.join(''));
		}
		chars[i] = char;
	}
	return res;
};
```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 127 | [å•è¯æ¥é¾™](https://leetcode.com/problems/word-ladder) | [[âœ“]](/problem/0127.md) |  [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/outline/tag/breadth-first-search.md) [`å“ˆå¸Œè¡¨`](/outline/tag/hash-table.md) [`å­—ç¬¦ä¸²`](/outline/tag/string.md) | <font color=#ff334b>Hard</font> |

<style>
.blue {
    background-color: #096dd9;
    padding: 0.25rem 0.5rem;
    margin: 0;
    font-size: 0.85em;
    border-radius: 3px;
    color: white;
    font-weight: 500;
}
table th:first-of-type { width: 10%; }
table th:nth-of-type(2) { width: 35%; }
table th:nth-of-type(3) { width: 10%; }
table th:nth-of-type(4) { width: 35%; }
table th:nth-of-type(5) { width: 10%; }
</style>
