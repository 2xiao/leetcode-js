---
title: 2290. åˆ°è¾¾è§’è½éœ€è¦ç§»é™¤éšœç¢ç‰©çš„æœ€å°æ•°ç›®
description: LeetCode 2290. åˆ°è¾¾è§’è½éœ€è¦ç§»é™¤éšœç¢ç‰©çš„æœ€å°æ•°ç›®é¢˜è§£ï¼ŒMinimum Obstacle Removal to Reach Cornerï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 2290. åˆ°è¾¾è§’è½éœ€è¦ç§»é™¤éšœç¢ç‰©çš„æœ€å°æ•°ç›®
  - åˆ°è¾¾è§’è½éœ€è¦ç§»é™¤éšœç¢ç‰©çš„æœ€å°æ•°ç›®
  - Minimum Obstacle Removal to Reach Corner
  - è§£é¢˜æ€è·¯
  - å¹¿åº¦ä¼˜å…ˆæœç´¢
  - å›¾
  - æ•°ç»„
  - çŸ©é˜µ
  - æœ€çŸ­è·¯
  - å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰
---

# 2290. åˆ°è¾¾è§’è½éœ€è¦ç§»é™¤éšœç¢ç‰©çš„æœ€å°æ•°ç›®

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/tag/breadth-first-search.md) [`å›¾`](/tag/graph.md) [`æ•°ç»„`](/tag/array.md) [`çŸ©é˜µ`](/tag/matrix.md) [`æœ€çŸ­è·¯`](/tag/shortest-path.md) [`å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰`](/tag/heap-priority-queue.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner) [`LeetCode`](https://leetcode.com/problems/minimum-obstacle-removal-to-reach-corner)

## é¢˜ç›®

You are given a **0-indexed** 2D integer array `grid` of size `m x n`. Each
cell has one of two values:

- `0` represents an **empty** cell,
- `1` represents an **obstacle** that may be removed.

You can move up, down, left, or right from and to an empty cell.

Return _the**minimum** number of **obstacles** to **remove** so you can move
from the upper left corner _`(0, 0)`_to the lower right corner_`(m - 1, n -
1)`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2022/04/06/example1drawio-1.png)

> Input: grid = [[0,1,1],[1,1,0],[1,1,0]]
>
> Output: 2
>
> Explanation: We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).
>
> It can be shown that we need to remove at least 2 obstacles, so we return 2.
>
> Note that there may be other ways to remove 2 obstacles to create a path.

**Example 2:**

![](https://assets.leetcode.com/uploads/2022/04/06/example1drawio.png)

> Input: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]
>
> Output: 0
>
> Explanation: We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0.

**Constraints:**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 10^5`
- `2 <= m * n <= 10^5`
- `grid[i][j]` is either `0` **or** `1`.
- `grid[0][0] == grid[m - 1][n - 1] == 0`

## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ªä¸‹æ ‡ä» **0** å¼€å§‹çš„äºŒç»´æ•´æ•°æ•°ç»„ `grid` ï¼Œæ•°ç»„å¤§å°ä¸º `m x n` ã€‚æ¯ä¸ªå•å…ƒæ ¼éƒ½æ˜¯ä¸¤ä¸ªå€¼ä¹‹ä¸€ï¼š

- `0` è¡¨ç¤ºä¸€ä¸ª **ç©º** å•å…ƒæ ¼ï¼Œ
- `1` è¡¨ç¤ºä¸€ä¸ªå¯ä»¥ç§»é™¤çš„ **éšœç¢ç‰©** ã€‚

ä½ å¯ä»¥å‘ä¸Šã€ä¸‹ã€å·¦ã€å³ç§»åŠ¨ï¼Œä»ä¸€ä¸ªç©ºå•å…ƒæ ¼ç§»åŠ¨åˆ°å¦ä¸€ä¸ªç©ºå•å…ƒæ ¼ã€‚

ç°åœ¨ä½ éœ€è¦ä»å·¦ä¸Šè§’ `(0, 0)` ç§»åŠ¨åˆ°å³ä¸‹è§’ `(m - 1, n - 1)` ï¼Œè¿”å›éœ€è¦ç§»é™¤çš„éšœç¢ç‰©çš„ **æœ€å°** æ•°ç›®ã€‚

**ç¤ºä¾‹ 1ï¼š**

![](https://assets.leetcode.com/uploads/2022/04/06/example1drawio-1.png)

> **è¾“å…¥ï¼š** grid = [[0,1,1],[1,1,0],[1,1,0]]
>
> **è¾“å‡ºï¼š** 2
>
> **è§£é‡Šï¼š** å¯ä»¥ç§»é™¤ä½äº (0, 1) å’Œ (0, 2) çš„éšœç¢ç‰©æ¥åˆ›å»ºä» (0, 0) åˆ° (2, 2) çš„è·¯å¾„ã€‚
>
> å¯ä»¥è¯æ˜æˆ‘ä»¬è‡³å°‘éœ€è¦ç§»é™¤ä¸¤ä¸ªéšœç¢ç‰©ï¼Œæ‰€ä»¥è¿”å› 2 ã€‚
>
> æ³¨æ„ï¼Œå¯èƒ½å­˜åœ¨å…¶ä»–æ–¹å¼æ¥ç§»é™¤ 2 ä¸ªéšœç¢ç‰©ï¼Œåˆ›å»ºå‡ºå¯è¡Œçš„è·¯å¾„ã€‚

**ç¤ºä¾‹ 2ï¼š**

![](https://assets.leetcode.com/uploads/2022/04/06/example1drawio.png)

> **è¾“å…¥ï¼š** grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]
>
> **è¾“å‡ºï¼š** 0
>
> **è§£é‡Šï¼š** ä¸ç§»é™¤ä»»ä½•éšœç¢ç‰©å°±èƒ½ä» (0, 0) åˆ° (2, 4) ï¼Œæ‰€ä»¥è¿”å› 0 ã€‚

**æç¤ºï¼š**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 10^5`
- `2 <= m * n <= 10^5`
- `grid[i][j]` ä¸º `0` **æˆ–** `1`
- `grid[0][0] == grid[m - 1][n - 1] == 0`

## è§£é¢˜æ€è·¯

è¿™é“é¢˜å¯ä»¥ä½¿ç”¨ **0-1 BFS** æ¥æ±‚è§£ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦åœ¨ç§»åŠ¨æ—¶æœ€å°åŒ–ç§»é™¤éšœç¢ç‰©çš„æ•°é‡ã€‚

æ ¸å¿ƒæ€æƒ³æ˜¯å°†é—®é¢˜å»ºæ¨¡ä¸ºä¸€ä¸ªåŠ æƒå›¾ï¼Œå…¶ä¸­ï¼š

- æ¯ä¸ªç½‘æ ¼å•å…ƒæ ¼ `(i, j)` ä»£è¡¨å›¾çš„ä¸€ä¸ªèŠ‚ç‚¹ã€‚
- ä»ä¸€ä¸ªå•å…ƒæ ¼ç§»åŠ¨åˆ°ç›¸é‚»å•å…ƒæ ¼æ˜¯å›¾ä¸­çš„è¾¹ã€‚
  - å¦‚æœç›®æ ‡å•å…ƒæ ¼æ˜¯ç©ºå•å…ƒæ ¼ï¼Œåˆ™è¾¹çš„æƒé‡ä¸º `0`ã€‚
  - å¦‚æœç›®æ ‡å•å…ƒæ ¼æ˜¯éšœç¢ç‰©ï¼Œåˆ™è¾¹çš„æƒé‡ä¸º `1`ã€‚

åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œ**0-1 BFS** æ˜¯ä¸€ç§é«˜æ•ˆçš„æ–¹æ³•ï¼š

- ä½¿ç”¨åŒç«¯é˜Ÿåˆ—ï¼ˆDequeï¼‰è¿›è¡Œå¹¿åº¦ä¼˜å…ˆæœç´¢ã€‚
- **å…ˆæ‰©å±•æƒé‡ä¸º 0 çš„è¾¹ï¼ˆä¼˜å…ˆé˜Ÿåˆ—å‰éƒ¨ï¼‰**ï¼Œç„¶åæ‰©å±•æƒé‡ä¸º 1 çš„è¾¹ï¼ˆä¼˜å…ˆé˜Ÿåˆ—å°¾éƒ¨ï¼‰ã€‚
- è¿™æ ·å¯ä»¥ä¿è¯ä»èµ·ç‚¹åˆ°ç»ˆç‚¹æ—¶é‡åˆ°çš„éšœç¢ç‰©æ•°é‡æ˜¯æœ€å°çš„ã€‚

å…·ä½“ç®—æ³•æ­¥éª¤ï¼š

1. **åˆå§‹åŒ–é˜Ÿåˆ—å’Œè®¿é—®çŠ¶æ€**ï¼š

   - ä½¿ç”¨åŒç«¯é˜Ÿåˆ— `deque` å­˜å‚¨æœç´¢çŠ¶æ€ï¼Œå…ƒç´ ä¸º `[å½“å‰è¡Œ, å½“å‰åˆ—, å½“å‰ç§»é™¤çš„éšœç¢ç‰©æ•°é‡]`ã€‚
   - åˆ›å»ºä¸€ä¸ª `visited` æ•°ç»„è®°å½•æŸä¸ªä½ç½®æ˜¯å¦å·²ç»è®¿é—®è¿‡ï¼Œé¿å…é‡å¤è®¡ç®—ã€‚

2. **è¿›è¡Œ 0-1 BFS**ï¼š

   - ä»èµ·ç‚¹ `(0, 0)` å¼€å§‹ï¼Œå°†å…¶åŠ å…¥é˜Ÿåˆ—ï¼Œåˆå§‹ç§»é™¤éšœç¢ç‰©æ•°é‡ä¸º `0`ã€‚
   - æ¯æ¬¡ä»é˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªçŠ¶æ€ï¼Œå°è¯•å‘ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘ç§»åŠ¨ï¼š
     - å¦‚æœç§»åŠ¨åˆ°çš„å•å…ƒæ ¼æ˜¯ç©ºå•å…ƒæ ¼ï¼Œå°†æ–°çš„çŠ¶æ€åŠ å…¥é˜Ÿåˆ—çš„å‰ç«¯ã€‚
     - å¦‚æœç§»åŠ¨åˆ°çš„å•å…ƒæ ¼æ˜¯éšœç¢ç‰©ï¼Œå°†æ–°çš„çŠ¶æ€åŠ å…¥é˜Ÿåˆ—çš„åç«¯ã€‚
   - æ›´æ–°è®¿é—®çŠ¶æ€ä»¥é¿å…é‡å¤è®¿é—®ã€‚

3. **ç»ˆæ­¢æ¡ä»¶**ï¼š

   - å¦‚æœæŸæ¬¡æ‰©å±•åˆ°è¾¾äº†ç»ˆç‚¹ `(m-1, n-1)`ï¼Œåˆ™ç›´æ¥è¿”å›å½“å‰ç§»é™¤çš„éšœç¢ç‰©æ•°é‡ã€‚

4. **è¿”å›ç»“æœ**ï¼š
   - å¦‚æœé˜Ÿåˆ—ä¸ºç©ºä»æœªåˆ°è¾¾ç»ˆç‚¹ï¼Œè¯´æ˜ä¸å­˜åœ¨è·¯å¾„ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(m * n)`ï¼Œå…¶ä¸­ `m` æ˜¯è¡Œæ•°ï¼Œ`n` æ˜¯åˆ—æ•°ï¼Œæ¯ä¸ªå•å…ƒæ ¼æœ€å¤šä¼šè¢«è®¿é—®ä¸€æ¬¡ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(m * n)`ï¼Œä½¿ç”¨äº†ä¸€ä¸ª `visited` å“ˆå¸Œ Set æ¥è®°å½•è®¿é—®çŠ¶æ€ï¼Œç©ºé—´å¤æ‚åº¦ä¸º `O(m * n)`ã€‚å¦å¤–ï¼ŒåŒç«¯é˜Ÿåˆ—çš„ç©ºé—´å¤æ‚åº¦æœ€å¤šä¸º `O(m * n)`ã€‚

## ä»£ç 

```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var minimumObstacles = function (grid) {
	const m = grid.length,
		n = grid[0].length;
	const directions = [
		[1, 0],
		[-1, 0],
		[0, 1],
		[0, -1]
	]; // å››ä¸ªæ–¹å‘
	const deque = new Deque([[0, 0, 0]]); // åˆå§‹çŠ¶æ€ï¼šè¡Œã€åˆ—ã€ç§»é™¤éšœç¢ç‰©æ•°
	const visited = new Set(['0,0']);

	while (!deque.isEmpty()) {
		const [x, y, obstacles] = deque.popFront();

		// å¦‚æœåˆ°è¾¾ç»ˆç‚¹ï¼Œç›´æ¥è¿”å›å½“å‰ç§»é™¤éšœç¢ç‰©çš„æ•°é‡
		if (x === m - 1 && y === n - 1) return obstacles;

		for (const [dx, dy] of directions) {
			const nx = x + dx,
				ny = y + dy;

			// æ£€æŸ¥æ˜¯å¦è¶Šç•Œä»¥åŠæ˜¯å¦å·²è®¿é—®
			if (
				nx >= 0 &&
				nx < m &&
				ny >= 0 &&
				ny < n &&
				!visited.has(`${nx},${ny}`)
			) {
				visited.add(`${nx},${ny}`); // æ ‡è®°ä¸ºå·²è®¿é—®

				// ç©ºå•å…ƒæ ¼ä¼˜å…ˆå¤„ç†
				if (grid[nx][ny] === 0) {
					deque.pushFront([nx, ny, obstacles]);
				} else {
					deque.pushBack([nx, ny, obstacles + 1]);
				}
			}
		}
	}

	return -1; // ä¸å¯èƒ½åˆ°è¾¾ç»ˆç‚¹
};
```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ | åŠ›æ‰£ |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 1293 | ç½‘æ ¼ä¸­çš„æœ€çŸ­è·¯å¾„ |  |  [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/tag/breadth-first-search.md) [`æ•°ç»„`](/tag/array.md) [`çŸ©é˜µ`](/tag/matrix.md) | ğŸ”´ | [ğŸ€„ï¸](https://leetcode.cn/problems/shortest-path-in-a-grid-with-obstacles-elimination) [ğŸ”—](https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination) |