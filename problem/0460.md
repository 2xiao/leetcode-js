---
title: 460. LFU ç¼“å­˜
description: LeetCode 460. LFU ç¼“å­˜é¢˜è§£ï¼ŒLFU Cacheï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 460. LFU ç¼“å­˜
  - LFU ç¼“å­˜
  - LFU Cache
  - è§£é¢˜æ€è·¯
  - è®¾è®¡
  - å“ˆå¸Œè¡¨
  - é“¾è¡¨
  - åŒå‘é“¾è¡¨
---

# 460. LFU ç¼“å­˜

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`è®¾è®¡`](/tag/design.md) [`å“ˆå¸Œè¡¨`](/tag/hash-table.md) [`é“¾è¡¨`](/tag/linked-list.md) [`åŒå‘é“¾è¡¨`](/tag/doubly-linked-list.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/lfu-cache) [`LeetCode`](https://leetcode.com/problems/lfu-cache)

## é¢˜ç›®

Design and implement a data structure for a [Least Frequently Used
(LFU)](https://en.wikipedia.org/wiki/Least_frequently_used) cache.

Implement the `LFUCache` class:

- `LFUCache(int capacity)` Initializes the object with the `capacity` of the data structure.
- `int get(int key)` Gets the value of the `key` if the `key` exists in the cache. Otherwise, returns `-1`.
- `void put(int key, int value)` Update the value of the `key` if present, or inserts the `key` if not already present. When the cache reaches its `capacity`, it should invalidate and remove the **least frequently used** key before inserting a new item. For this problem, when there is a **tie** (i.e., two or more keys with the same frequency), the **least recently used** `key` would be invalidated.

To determine the least frequently used key, a **use counter** is maintained
for each key in the cache. The key with the smallest **use counter** is the
least frequently used key.

When a key is first inserted into the cache, its **use counter** is set to `1`
(due to the `put` operation). The **use counter** for a key in the cache is
incremented either a `get` or `put` operation is called on it.

The functions `get` and `put` must each run in `O(1)` average time complexity.

**Example 1:**

> **Input**
>
> ["LFUCache", "put", "put", "get", "put", "get", "get", "put", "get", "get", "get"]
>
> [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]
>
> **Output**
>
> [null, null, null, 1, null, -1, 3, null, -1, 3, 4]
>
> **Explanation**
>
> ```js
> // cnt(x) = the use counter for key x
>
> // cache=[] will show the last used order for tiebreakers (leftmost element is most recent)
>
> LFUCache lfu = new LFUCache(2);
>
> lfu.put(1, 1); // cache=[1,_], cnt(1)=1
>
> lfu.put(2, 2); // cache=[2,1], cnt(2)=1, cnt(1)=1
>
> lfu.get(1); // return 1
>
> // cache=[1,2], cnt(2)=1, cnt(1)=2
>
> lfu.put(3, 3); // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2.
>
> // cache=[3,1], cnt(3)=1, cnt(1)=2
>
> lfu.get(2); // return -1 (not found)
>
> lfu.get(3); // return 3
>
> // cache=[3,1], cnt(3)=2, cnt(1)=2
>
> lfu.put(4, 4); // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1.
>
> // cache=[4,3], cnt(4)=1, cnt(3)=2
>
> lfu.get(1); // return -1 (not found)
>
> lfu.get(3); // return 3
>
> // cache=[3,4], cnt(4)=1, cnt(3)=3
>
> lfu.get(4); // return 4
>
> // cache=[4,3], cnt(4)=2, cnt(3)=3
> ```

**Constraints:**

- `1 <= capacity <= 10^4`
- `0 <= key <= 10^5`
- `0 <= value <= 10^9`
- At most `2 * 10^5` calls will be made to `get` and `put`.

## é¢˜ç›®å¤§æ„

è¯·ä½ ä¸º
[æœ€ä¸ç»å¸¸ä½¿ç”¨ï¼ˆLFUï¼‰](https://baike.baidu.com/item/%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95)ç¼“å­˜ç®—æ³•è®¾è®¡å¹¶å®ç°æ•°æ®ç»“æ„ã€‚

å®ç° `LFUCache` ç±»ï¼š

- `LFUCache(int capacity)`: ç”¨æ•°æ®ç»“æ„çš„å®¹é‡ `capacity` åˆå§‹åŒ–å¯¹è±¡
- `int get(int key)`: å¦‚æœé”® `key` å­˜åœ¨äºç¼“å­˜ä¸­ï¼Œåˆ™è·å–é”®çš„å€¼ï¼Œå¦åˆ™è¿”å› `-1` ã€‚
- `void put(int key, int value)`: å¦‚æœé”® `key` å·²å­˜åœ¨ï¼Œåˆ™å˜æ›´å…¶å€¼ï¼›å¦‚æœé”®ä¸å­˜åœ¨ï¼Œè¯·æ’å…¥é”®å€¼å¯¹ã€‚å½“ç¼“å­˜è¾¾åˆ°å…¶å®¹é‡ `capacity` æ—¶ï¼Œåˆ™åº”è¯¥åœ¨æ’å…¥æ–°é¡¹ä¹‹å‰ï¼Œç§»é™¤æœ€ä¸ç»å¸¸ä½¿ç”¨çš„é¡¹ã€‚åœ¨æ­¤é—®é¢˜ä¸­ï¼Œå½“å­˜åœ¨å¹³å±€ï¼ˆå³ä¸¤ä¸ªæˆ–æ›´å¤šä¸ªé”®å…·æœ‰ç›¸åŒä½¿ç”¨é¢‘ç‡ï¼‰æ—¶ï¼Œåº”è¯¥å»é™¤ **æœ€ä¹…æœªä½¿ç”¨** çš„é”®ã€‚

ä¸ºäº†ç¡®å®šæœ€ä¸å¸¸ä½¿ç”¨çš„é”®ï¼Œå¯ä»¥ä¸ºç¼“å­˜ä¸­çš„æ¯ä¸ªé”®ç»´æŠ¤ä¸€ä¸ª **ä½¿ç”¨è®¡æ•°å™¨** ã€‚ä½¿ç”¨è®¡æ•°æœ€å°çš„é”®æ˜¯æœ€ä¹…æœªä½¿ç”¨çš„é”®ã€‚

å½“ä¸€ä¸ªé”®é¦–æ¬¡æ’å…¥åˆ°ç¼“å­˜ä¸­æ—¶ï¼Œå®ƒçš„ä½¿ç”¨è®¡æ•°å™¨è¢«è®¾ç½®ä¸º `1` (ç”±äº put æ“ä½œ)ã€‚å¯¹ç¼“å­˜ä¸­çš„é”®æ‰§è¡Œ `get` æˆ– `put`
æ“ä½œï¼Œä½¿ç”¨è®¡æ•°å™¨çš„å€¼å°†ä¼šé€’å¢ã€‚

å‡½æ•° `get` å’Œ `put` å¿…é¡»ä»¥ `O(1)` çš„å¹³å‡æ—¶é—´å¤æ‚åº¦è¿è¡Œã€‚

**ç¤ºä¾‹ï¼š**

> **è¾“å…¥ï¼š**
>
> ["LFUCache", "put", "put", "get", "put", "get", "get", "put", "get", "get", "get"]
>
> [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]
>
> **è¾“å‡ºï¼š**
>
> [null, null, null, 1, null, -1, 3, null, -1, 3, 4]
>
> **è§£é‡Šï¼š**
>
> ```js
> // cnt(x) = é”® x çš„ä½¿ç”¨è®¡æ•°
>
> // cache=[] å°†æ˜¾ç¤ºæœ€åä¸€æ¬¡ä½¿ç”¨çš„é¡ºåºï¼ˆæœ€å·¦è¾¹çš„å…ƒç´ æ˜¯æœ€è¿‘çš„ï¼‰
>
> LFUCache lfu = new LFUCache(2);
>
> lfu.put(1, 1); // cache=[1,_], cnt(1)=1
>
> lfu.put(2, 2); // cache=[2,1], cnt(2)=1, cnt(1)=1
>
> lfu.get(1); // è¿”å› 1
>
> // cache=[1,2], cnt(2)=1, cnt(1)=2
>
> lfu.put(3, 3); // å»é™¤é”® 2 ï¼Œå› ä¸º cnt(2)=1 ï¼Œä½¿ç”¨è®¡æ•°æœ€å°
>
> // cache=[3,1], cnt(3)=1, cnt(1)=2
>
> lfu.get(2); // è¿”å› -1ï¼ˆæœªæ‰¾åˆ°ï¼‰
>
> lfu.get(3); // è¿”å› 3
>
> // cache=[3,1], cnt(3)=2, cnt(1)=2
>
> lfu.put(4, 4); // å»é™¤é”® 1 ï¼Œ1 å’Œ 3 çš„ cnt ç›¸åŒï¼Œä½† 1 æœ€ä¹…æœªä½¿ç”¨
>
> // cache=[4,3], cnt(4)=1, cnt(3)=2
>
> lfu.get(1); // è¿”å› -1ï¼ˆæœªæ‰¾åˆ°ï¼‰
>
> lfu.get(3); // è¿”å› 3
>
> // cache=[3,4], cnt(4)=1, cnt(3)=3
>
> lfu.get(4); // è¿”å› 4
>
> // cache=[3,4], cnt(4)=2, cnt(3)=3
> ```

**æç¤ºï¼š**

- `1 <= capacity <= 10^4`
- `0 <= key <= 10^5`
- `0 <= value <= 10^9`
- æœ€å¤šè°ƒç”¨ `2 * 10^5` æ¬¡ `get` å’Œ `put` æ–¹æ³•

## è§£é¢˜æ€è·¯

#### æ ¸å¿ƒæ€è·¯

1. **åŒå‘é“¾è¡¨ (Doubly Linked List):**
   - æ¯ä¸ªé¢‘ç‡ä¸‹çš„é”®é›†åˆç”±ä¸€ä¸ªåŒå‘é“¾è¡¨ç®¡ç†ï¼Œæ–¹ä¾¿ O(1) åˆ é™¤å’Œæ’å…¥æ“ä½œã€‚
2. **æ•°æ®ç»“æ„ï¼š**
   - **å“ˆå¸Œè¡¨ 1:** `keyToNode`ï¼Œå°†é”®æ˜ å°„åˆ°é“¾è¡¨èŠ‚ç‚¹ã€‚
   - **å“ˆå¸Œè¡¨ 2:** `freqToList`ï¼Œå°†æ¯ä¸ªé¢‘ç‡æ˜ å°„åˆ°ä¸€ä¸ªåŒå‘é“¾è¡¨ã€‚
   - è®°å½•å½“å‰æœ€ä½é¢‘ç‡ `minFreq`ï¼Œä¾¿äºå¿«é€Ÿå®šä½åˆ é™¤é”®ã€‚

#### æ•°æ®ç»“æ„è®¾è®¡

```plaintext
LFUCache:
    keyToNode: { key: Node }       // æ¯ä¸ªé”®å¯¹åº”çš„èŠ‚ç‚¹
    freqToList: { freq: DLinkedList }  // æ¯ä¸ªé¢‘ç‡å¯¹åº”çš„åŒå‘é“¾è¡¨
    minFreq: å½“å‰æœ€ä½é¢‘ç‡
    capacity: ç¼“å­˜å®¹é‡

Node:
    key: é”®
    value: å€¼
    freq: é¢‘ç‡
    prev, next: æŒ‡å‘é“¾è¡¨å‰åèŠ‚ç‚¹

DLinkedList:
    head, tail: è™šæ‹Ÿå¤´å°¾èŠ‚ç‚¹
    size: å½“å‰é“¾è¡¨å¤§å°
    addNode(node): æ·»åŠ èŠ‚ç‚¹
    removeNode(node): åˆ é™¤èŠ‚ç‚¹
    removeLast(): åˆ é™¤é“¾è¡¨æœ€åä¸€ä¸ªèŠ‚ç‚¹
```

#### ä»£ç æ€è·¯

1. **åŒå‘é“¾è¡¨æ“ä½œï¼š**

   - `addNode`ï¼šåœ¨é“¾è¡¨å¤´éƒ¨æ’å…¥èŠ‚ç‚¹ã€‚
   - `removeNode`ï¼šç§»é™¤é“¾è¡¨ä¸­çš„èŠ‚ç‚¹ã€‚
   - `removeLast`ï¼šåˆ é™¤é“¾è¡¨å°¾éƒ¨èŠ‚ç‚¹ï¼ˆç”¨äºç§»é™¤æœ€å°‘é¢‘ç‡ä¸­æœ€æ—§çš„é”®ï¼‰ã€‚

2. **`get(key)`ï¼š**

   - æ£€æŸ¥ `key` æ˜¯å¦å­˜åœ¨ã€‚
   - å¦‚æœå­˜åœ¨ï¼Œæ›´æ–°èŠ‚ç‚¹é¢‘ç‡å¹¶è¿”å›å€¼ã€‚

3. **`put(key, value)`ï¼š**

   - å¦‚æœé”®å·²å­˜åœ¨ï¼Œæ›´æ–°å€¼å¹¶æ›´æ–°é¢‘ç‡ã€‚
   - å¦‚æœé”®ä¸å­˜åœ¨ï¼Œæ£€æŸ¥å®¹é‡æ˜¯å¦å·²æ»¡ï¼š
     - è‹¥æ»¡ï¼Œåˆ™ç§»é™¤æœ€ä½é¢‘ç‡ä¸­æœ€ä¹…æœªä½¿ç”¨çš„é”®ã€‚
   - æ’å…¥æ–°èŠ‚ç‚¹åˆ°é¢‘ç‡ä¸º 1 çš„é“¾è¡¨ã€‚

4. **`updateNode(node)`ï¼š**
   - ç§»é™¤èŠ‚ç‚¹çš„æ—§é¢‘ç‡ã€‚
   - æ›´æ–°èŠ‚ç‚¹é¢‘ç‡å¹¶æ’å…¥æ–°çš„é¢‘ç‡é“¾è¡¨ã€‚
   - å¦‚æœæ—§é¢‘ç‡é“¾è¡¨ä¸ºç©ºä¸”è¯¥é¢‘ç‡æ˜¯æœ€ä½é¢‘ç‡ï¼Œæ›´æ–° `minFreq`ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦ï¼š** `O(1)`ï¼Œå› ä¸ºå“ˆå¸Œè¡¨å’ŒåŒå‘é“¾è¡¨çš„æ“ä½œéƒ½æ˜¯å¸¸æ•°æ—¶é—´ã€‚
- **ç©ºé—´å¤æ‚åº¦ï¼š** `O(n)`ï¼Œå­˜å‚¨ç¼“å­˜æ•°æ®å’Œè¾…åŠ©æ•°æ®ç»“æ„ã€‚

## ä»£ç 

```javascript
class LFUCache {
	constructor(capacity) {
		this.capacity = capacity; // ç¼“å­˜å®¹é‡
		this.size = 0; // å½“å‰ç¼“å­˜å¤§å°
		this.minFreq = 0; // å½“å‰æœ€ä½é¢‘ç‡
		this.keyToNode = new Map(); // é”®åˆ°èŠ‚ç‚¹çš„æ˜ å°„
		this.freqToList = new Map(); // é¢‘ç‡åˆ°åŒå‘é“¾è¡¨çš„æ˜ å°„
	}

	get(key) {
		if (!this.keyToNode.has(key)) return -1;

		const node = this.keyToNode.get(key);
		this.updateNode(node); // æ›´æ–°èŠ‚ç‚¹é¢‘ç‡
		return node.value;
	}

	put(key, value) {
		if (this.capacity === 0) return;

		if (this.keyToNode.has(key)) {
			const node = this.keyToNode.get(key);
			node.value = value; // æ›´æ–°å€¼
			this.updateNode(node); // æ›´æ–°é¢‘ç‡
		} else {
			if (this.size === this.capacity) {
				// å®¹é‡å·²æ»¡ï¼Œç§»é™¤æœ€å°‘é¢‘ç‡çš„æœ€ä¹…æœªä½¿ç”¨èŠ‚ç‚¹
				const minFreqList = this.freqToList.get(this.minFreq);
				const toRemove = minFreqList.removeLast();
				this.keyToNode.delete(toRemove.key);
				this.size--;
			}

			// æ’å…¥æ–°èŠ‚ç‚¹
			const newNode = new Node(key, value);
			this.keyToNode.set(key, newNode);
			if (!this.freqToList.has(1)) {
				this.freqToList.set(1, new DLinkedList());
			}
			this.freqToList.get(1).addNode(newNode);
			this.minFreq = 1; // æ–°æ’å…¥èŠ‚ç‚¹çš„é¢‘ç‡ä¸º 1
			this.size++;
		}
	}

	updateNode(node) {
		const freq = node.freq;
		const list = this.freqToList.get(freq);
		list.removeNode(node); // ä»å½“å‰é¢‘ç‡é“¾è¡¨ä¸­ç§»é™¤

		if (list.size === 0 && freq === this.minFreq) {
			this.minFreq++; // æ›´æ–°æœ€ä½é¢‘ç‡
		}

		node.freq++; // å¢åŠ é¢‘ç‡
		if (!this.freqToList.has(node.freq)) {
			this.freqToList.set(node.freq, new DLinkedList());
		}
		this.freqToList.get(node.freq).addNode(node);
	}
}

class Node {
	constructor(key, value) {
		this.key = key;
		this.value = value;
		this.freq = 1;
		this.prev = null;
		this.next = null;
	}
}

class DLinkedList {
	constructor() {
		this.head = new Node(); // è™šæ‹Ÿå¤´èŠ‚ç‚¹
		this.tail = new Node(); // è™šæ‹Ÿå°¾èŠ‚ç‚¹
		this.head.next = this.tail;
		this.tail.prev = this.head;
		this.size = 0;
	}

	addNode(node) {
		// åœ¨å¤´éƒ¨æ·»åŠ èŠ‚ç‚¹
		node.next = this.head.next;
		node.prev = this.head;
		this.head.next.prev = node;
		this.head.next = node;
		this.size++;
	}

	removeNode(node) {
		// åˆ é™¤èŠ‚ç‚¹
		node.prev.next = node.next;
		node.next.prev = node.prev;
		this.size--;
	}

	removeLast() {
		// åˆ é™¤é“¾è¡¨æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼ˆçœŸå®èŠ‚ç‚¹ï¼‰
		if (this.size === 0) return null;
		const last = this.tail.prev;
		this.removeNode(last);
		return last;
	}
}
```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ | åŠ›æ‰£ |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 146 | LRU ç¼“å­˜ | [[âœ“]](/problem/0146.md) |  [`è®¾è®¡`](/tag/design.md) [`å“ˆå¸Œè¡¨`](/tag/hash-table.md) [`é“¾è¡¨`](/tag/linked-list.md) `1+` | ğŸŸ  | [ğŸ€„ï¸](https://leetcode.cn/problems/lru-cache) [ğŸ”—](https://leetcode.com/problems/lru-cache) |
| 588 | è®¾è®¡å†…å­˜æ–‡ä»¶ç³»ç»Ÿ ğŸ”’ |  |  [`è®¾è®¡`](/tag/design.md) [`å­—å…¸æ ‘`](/tag/trie.md) [`å“ˆå¸Œè¡¨`](/tag/hash-table.md) `2+` | ğŸ”´ | [ğŸ€„ï¸](https://leetcode.cn/problems/design-in-memory-file-system) [ğŸ”—](https://leetcode.com/problems/design-in-memory-file-system) |
