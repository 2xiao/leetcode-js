---
title: 2650. è®¾è®¡å¯å–æ¶ˆå‡½æ•°
description: LeetCode,2650. è®¾è®¡å¯å–æ¶ˆå‡½æ•°,è®¾è®¡å¯å–æ¶ˆå‡½æ•°,Design Cancellable Function,è§£é¢˜æ€è·¯
keywords:
  - LeetCode
  - 2650. è®¾è®¡å¯å–æ¶ˆå‡½æ•°
  - è®¾è®¡å¯å–æ¶ˆå‡½æ•°
  - Design Cancellable Function
  - è§£é¢˜æ€è·¯
---

# 2650. è®¾è®¡å¯å–æ¶ˆå‡½æ•°

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/design-cancellable-function) [`LeetCode`](https://leetcode.com/problems/design-cancellable-function)

## é¢˜ç›®

Sometimes you have a long running task, and you may wish to cancel it before
it completes. To help with this goal, write a function `cancellable` that
accepts a generator object and returns an array of two values: a **cancel
function** and a **promise**.

You may assume the generator function will only yield promises. It is your
function's responsibility to pass the values resolved by the promise back to
the generator. If the promise rejects, your function should throw that error
back to the generator.

If the cancel callback is called before the generator is done, your function
should throw an error back to the generator. That error should be the string
`"Cancelled"` (Not an `Error` object). If the error was caught, the returned
promise should resolve with the next value that was yielded or returned.
Otherwise, the promise should reject with the thrown error. No more code
should be executed.

When the generator is done, the promise your function returned should resolve
the value the generator returned. If, however, the generator throws an error,
the returned promise should reject with the error.

An example of how your code would be used:

```js
function* tasks() {
	const val = yield new Promise((resolve) => resolve(2 + 2));

	yield new Promise((resolve) => setTimeout(resolve, 100));

	return val + 1; // calculation shouldn't be done.
}

const [cancel, promise] = cancellable(tasks());

setTimeout(cancel, 50);

promise.catch(console.log); // logs "Cancelled" at t=50ms
```

If instead `cancel()` was not called or was called after `t=100ms`, the
promise would have resolved `5`.

**Example 1:**

> Input:

```js
generatorFunction = function* () {
	return 42;
};

cancelledAt = 100;
```

> Output: {"resolved": 42}

> Explanation:

```js
const generator = generatorFunction();

const [cancel, promise] = cancellable(generator);

setTimeout(cancel, 100);

promise.then(console.log); // resolves 42 at t=0ms
```

The generator immediately yields 42 and finishes. Because of that, the returned promise immediately resolves 42. Note that cancelling a finished generator does nothing.

**Example 2:**

> Input:

```js
generatorFunction = function* () {
	const msg = yield new Promise((res) => res('Hello'));

	throw `Error: ${msg}`;
};

cancelledAt = null;
```

> Output: {"rejected": "Error: Hello"}

> Explanation:

A promise is yielded. The function handles this by waiting for it to resolve and then passes the resolved value back to the generator. Then an error is thrown which has the effect of causing the promise to reject with the same thrown error.

**Example 3:**

> Input:

```js
generatorFunction = function* () {
	yield new Promise((res) => setTimeout(res, 200));

	return 'Success';
};

cancelledAt = 100;
```

> Output: {"rejected": "Cancelled"}

> Explanation:

While the function is waiting for the yielded promise to resolve, cancel() is called. This causes an error message to be sent back to the generator. Since this error is uncaught, the returned promise rejected with this error.

**Example 4:**

> Input:

```js
generatorFunction = function* () {
	let result = 0;

	yield new Promise((res) => setTimeout(res, 100));

	result += yield new Promise((res) => res(1));

	yield new Promise((res) => setTimeout(res, 100));

	result += yield new Promise((res) => res(1));

	return result;
};

cancelledAt = null;
```

> Output: {"resolved": 2}

> Explanation:

4 promises are yielded. Two of those promises have their values added to the result. After 200ms, the generator finishes with a value of 2, and that value is resolved by the returned promise.

**Example 5:**

> Input:

```js
generatorFunction = function* () {
	let result = 0;

	try {
		yield new Promise((res) => setTimeout(res, 100));

		result += yield new Promise((res) => res(1));

		yield new Promise((res) => setTimeout(res, 100));

		result += yield new Promise((res) => res(1));
	} catch (e) {
		return result;
	}

	return result;
};

cancelledAt = 150;
```

> Output: {"resolved": 1}

> Explanation:

The first two yielded promises resolve and cause the result to increment. However, at t=150ms, the generator is cancelled. The error sent to the generator is caught and the result is returned and finally resolved by the returned promise.

**Example 6:**

> Input:

```js
generatorFunction = function* () {
	try {
		yield new Promise((resolve, reject) => reject('Promise Rejected'));
	} catch (e) {
		let a = yield new Promise((resolve) => resolve(2));

		let b = yield new Promise((resolve) => resolve(2));

		return a + b;
	}
};

cancelledAt = null;
```

> Output: {"resolved": 4}

> Explanation:

The first yielded promise immediately rejects. This error is caught. Because the generator hasn't been cancelled, execution continues as usual. It ends up resolving 2 + 2 = 4.

**Constraints:**

- `cancelledAt == null or 0 <= cancelledAt <= 1000`
- `generatorFunction` returns a generator object

## é¢˜ç›®å¤§æ„

æœ‰æ—¶å€™ä½ ä¼šæœ‰ä¸€ä¸ªé•¿æ—¶é—´è¿è¡Œçš„ä»»åŠ¡ï¼Œå¹¶ä¸”ä½ å¯èƒ½å¸Œæœ›åœ¨å®ƒå®Œæˆä¹‹å‰å–æ¶ˆå®ƒã€‚ä¸ºäº†å®ç°è¿™ä¸ªç›®æ ‡ï¼Œè¯·ä½ ç¼–å†™ä¸€ä¸ªåä¸º `cancellable`
çš„å‡½æ•°ï¼Œå®ƒæ¥æ”¶ä¸€ä¸ªç”Ÿæˆå™¨å¯¹è±¡ï¼Œå¹¶è¿”å›ä¸€ä¸ªåŒ…å«ä¸¤ä¸ªå€¼çš„æ•°ç»„ï¼šä¸€ä¸ª **å–æ¶ˆå‡½æ•°** å’Œä¸€ä¸ª **promise** å¯¹è±¡ã€‚

ä½ å¯ä»¥å‡è®¾ç”Ÿæˆå™¨å‡½æ•°åªä¼šç”Ÿæˆ promise å¯¹è±¡ã€‚ä½ çš„å‡½æ•°è´Ÿè´£å°† promise å¯¹è±¡è§£æçš„å€¼ä¼ å›ç”Ÿæˆå™¨ã€‚å¦‚æœ promise
è¢«æ‹’ç»ï¼Œä½ çš„å‡½æ•°åº”å°†è¯¥é”™è¯¯æŠ›å›ç»™ç”Ÿæˆå™¨ã€‚

å¦‚æœåœ¨ç”Ÿæˆå™¨å®Œæˆä¹‹å‰è°ƒç”¨äº†å–æ¶ˆå›è°ƒå‡½æ•°ï¼Œåˆ™ä½ çš„å‡½æ•°åº”è¯¥å°†é”™è¯¯æŠ›å›ç»™ç”Ÿæˆå™¨ã€‚è¯¥é”™è¯¯åº”è¯¥æ˜¯å­—ç¬¦ä¸² `"Cancelled"`ï¼ˆè€Œä¸æ˜¯ä¸€ä¸ª `Error`
å¯¹è±¡ï¼‰ã€‚å¦‚æœé”™è¯¯è¢«æ•è·ï¼Œåˆ™è¿”å›çš„ promise åº”è¯¥è§£æä¸ºä¸‹ä¸€ä¸ªç”Ÿæˆæˆ–è¿”å›çš„å€¼ã€‚å¦åˆ™ï¼Œpromise åº”è¯¥è¢«æ‹’ç»å¹¶æŠ›å‡ºè¯¥é”™è¯¯ã€‚ä¸åº”æ‰§è¡Œä»»ä½•å…¶ä»–ä»£ç ã€‚

å½“ç”Ÿæˆå™¨å®Œæˆæ—¶ï¼Œæ‚¨çš„å‡½æ•°è¿”å›çš„ promise åº”è¯¥è§£æä¸ºç”Ÿæˆå™¨è¿”å›çš„å€¼ã€‚ä½†æ˜¯ï¼Œå¦‚æœç”Ÿæˆå™¨æŠ›å‡ºé”™è¯¯ï¼Œåˆ™è¿”å›çš„ promise åº”è¯¥æ‹’ç»å¹¶æŠ›å‡ºè¯¥é”™è¯¯ã€‚

**æç¤ºï¼š**

- `cancelledAt == null or 0 <= cancelledAt <= 1000`
- `generatorFunction` è¿”å›ä¸€ä¸ªç”Ÿæˆå™¨å¯¹è±¡

## è§£é¢˜æ€è·¯

1. **åˆ›å»ºå–æ¶ˆå‡½æ•°**ï¼š

   - é¦–å…ˆï¼Œå®šä¹‰ä¸€ä¸ªå–æ¶ˆå‡½æ•° `cancel`ï¼Œè¿™ä¸ªå‡½æ•°ä¼šåœ¨è¢«è°ƒç”¨æ—¶ä½¿ä¸€ä¸ª `Promise` è¢«æ‹’ç»ï¼Œæ‹’ç»åŸå› æ˜¯å­—ç¬¦ä¸² `"Cancelled"`ã€‚
   - ä½¿ç”¨ `Promise` çš„æ„é€ å‡½æ•°åˆ›å»ºä¸€ä¸ª `cancelPromise`ï¼Œå°†æ‹’ç»é€»è¾‘ç»‘å®šåˆ° `cancel` å‡½æ•°ä¸Šã€‚

2. **è®¾ç½® promise çš„å¼‚æ­¥æ‰§è¡Œ**ï¼š

   - å®šä¹‰ä¸€ä¸ªç«‹å³æ‰§è¡Œçš„å¼‚æ­¥å‡½æ•°ï¼Œç”¨äºå¤„ç†ç”Ÿæˆå™¨çš„æ‰§è¡Œã€‚
   - åœ¨å¼‚æ­¥å‡½æ•°å†…ï¼Œé€šè¿‡ `generator.next()` å¼€å§‹æ‰§è¡Œç”Ÿæˆå™¨ï¼Œå¹¶è·å–ç¬¬ä¸€ä¸ªç»“æœã€‚

3. **å¤„ç†ç”Ÿæˆå™¨çš„è¾“å‡º**ï¼š

   - ä½¿ç”¨ `Promise.race` æ¥å¤„ç†ç”Ÿæˆå™¨äº§ç”Ÿçš„ Promise å’Œ `cancelPromise`ã€‚è¿™æ„å‘³ç€å¦‚æœ `cancelPromise` è¢«æ‹’ç»ï¼Œç”Ÿæˆå™¨å°†ä¼šç«‹å³åœæ­¢æ‰§è¡Œã€‚
   - å¦‚æœç”Ÿæˆå™¨çš„å½“å‰ Promise è¢«è§£å†³ï¼Œä½¿ç”¨è¯¥å€¼è°ƒç”¨ `generator.next()` ç»§ç»­æ‰§è¡Œç”Ÿæˆå™¨ã€‚å¦‚æœå‘ç”Ÿé”™è¯¯ï¼Œåˆ™è°ƒç”¨ `generator.throw()` ä¼ é€’é”™è¯¯å¹¶ç»§ç»­ã€‚

4. **è¿”å›ç»“æœ**ï¼š
   - å½“ç”Ÿæˆå™¨å®Œæˆæ—¶ï¼Œå¼‚æ­¥å‡½æ•°è¿”å›çš„å€¼å°†æˆä¸ºè¿”å›çš„ Promise çš„è§£å†³å€¼ã€‚
   - æœ€åï¼Œè¿”å›åŒ…å«å–æ¶ˆå‡½æ•°å’Œ Promise çš„æ•°ç»„ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œå…¶ä¸­ `n` æ˜¯ç”Ÿæˆå™¨çš„æ­¥éª¤æ•°ã€‚æ¯æ¬¡è°ƒç”¨ `next()` æˆ– `throw()` éƒ½æ˜¯å¸¸é‡æ—¶é—´ `O(1)` æ“ä½œï¼Œå¤æ‚åº¦ä¸ç”Ÿæˆå™¨çš„æ‰§è¡Œæ­¥éª¤æ•°æˆæ­£æ¯”ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(1)`ï¼Œç©ºé—´å¤æ‚åº¦ä¸»è¦æ¥è‡ªäº Promise çš„ä½¿ç”¨å’Œç”Ÿæˆå™¨çš„çŠ¶æ€ï¼Œç”±äºç”Ÿæˆå™¨çš„çŠ¶æ€ä¼šä¿ç•™åœ¨å †æ ˆä¸­ï¼Œä¸”æ¯æ¬¡è°ƒç”¨ `next()` æˆ– `throw()` æ—¶éƒ½ä¼šåˆ›å»ºæ–°çš„ Promiseï¼Œå› æ­¤æ•´ä½“ç©ºé—´å¤æ‚åº¦ä¸º `O(1)`ï¼Œä¸éšè¾“å…¥å¤§å°å˜åŒ–ã€‚

## ä»£ç 

```javascript
/**
 * @param {Generator} generator
 * @return {[Function, Promise]}
 */
var cancellable = function (generator) {
	let cancel;
	const cancelPromise = new Promise((_, reject) => {
		cancel = () => reject('Cancelled');
	});
	// æ¯ä¸€ä¸ª promise rejection éƒ½éœ€è¦è¢« catch
	cancelPromise.catch(() => {});

	const promise = (async () => {
		let next = generator.next();
		while (!next.done) {
			try {
				next = generator.next(await Promise.race([next.value, cancelPromise]));
			} catch (error) {
				next = generator.throw(error);
			}
		}
		return next.value;
	})();
	return [cancel, promise];
};

/**
 * function* tasks() {
 *   const val = yield new Promise(resolve => resolve(2 + 2));
 *   yield new Promise(resolve => setTimeout(resolve, 100));
 *   return val + 1;
 * }
 * const [cancel, promise] = cancellable(tasks());
 * setTimeout(cancel, 50);
 * promise.catch(console.log); // logs "Cancelled" at t=50ms
 */
```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 2648 | [ç”Ÿæˆæ–æ³¢é‚£å¥‘æ•°åˆ—](https://leetcode.com/problems/generate-fibonacci-sequence) | [[âœ“]](/problem/2648.md) |  | <font color=#15bd66>Easy</font> |
| 2649 | [åµŒå¥—æ•°ç»„ç”Ÿæˆå™¨](https://leetcode.com/problems/nested-array-generator) | [[âœ“]](/problem/2649.md) |  | <font color=#ffb800>Medium</font> |