---
title: 464. æˆ‘èƒ½èµ¢å—
description: LeetCode 464. æˆ‘èƒ½èµ¢å—é¢˜è§£ï¼ŒCan I Winï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 464. æˆ‘èƒ½èµ¢å—
  - æˆ‘èƒ½èµ¢å—
  - Can I Win
  - è§£é¢˜æ€è·¯
  - ä½è¿ç®—
  - è®°å¿†åŒ–æœç´¢
  - æ•°å­¦
  - åŠ¨æ€è§„åˆ’
  - çŠ¶æ€å‹ç¼©
  - åšå¼ˆ
---

# 464. æˆ‘èƒ½èµ¢å—

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`ä½è¿ç®—`](/tag/bit-manipulation.md) [`è®°å¿†åŒ–æœç´¢`](/tag/memoization.md) [`æ•°å­¦`](/tag/math.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md) [`çŠ¶æ€å‹ç¼©`](/tag/bitmask.md) [`åšå¼ˆ`](/tag/game-theory.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/can-i-win) [`LeetCode`](https://leetcode.com/problems/can-i-win)

## é¢˜ç›®

In the "100 game" two players take turns adding, to a running total, any
integer from `1` to `10`. The player who first causes the running total to
**reach or exceed** 100 wins.

What if we change the game so that players **cannot** re-use integers?

For example, two players might take turns drawing from a common pool of
numbers from 1 to 15 without replacement until they reach a total >= 100.

Given two integers `maxChoosableInteger` and `desiredTotal`, return `true` if
the first player to move can force a win, otherwise, return `false`. Assume
both players play **optimally**.

**Example 1:**

> Input: maxChoosableInteger = 10, desiredTotal = 11
>
> Output: false
>
> Explanation:
>
> No matter which integer the first player choose, the first player will lose.
>
> The first player can choose an integer from 1 up to 10.
>
> If the first player choose 1, the second player can only choose integers from 2 up to 10.
>
> The second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.
>
> Same with other integers chosen by the first player, the second player will always win.

**Example 2:**

> Input: maxChoosableInteger = 10, desiredTotal = 0
>
> Output: true

**Example 3:**

> Input: maxChoosableInteger = 10, desiredTotal = 1
>
> Output: true

**Constraints:**

- `1 <= maxChoosableInteger <= 20`
- `0 <= desiredTotal <= 300`

## é¢˜ç›®å¤§æ„

åœ¨ "100 game" è¿™ä¸ªæ¸¸æˆä¸­ï¼Œä¸¤åç©å®¶è½®æµé€‰æ‹©ä» `1` åˆ° `10` çš„ä»»æ„æ•´æ•°ï¼Œç´¯è®¡æ•´æ•°å’Œï¼Œå…ˆä½¿å¾—ç´¯è®¡æ•´æ•°å’Œ **è¾¾åˆ°æˆ–è¶…è¿‡** 100
çš„ç©å®¶ï¼Œå³ä¸ºèƒœè€…ã€‚

å¦‚æœæˆ‘ä»¬å°†æ¸¸æˆè§„åˆ™æ”¹ä¸º â€œç©å®¶ **ä¸èƒ½** é‡å¤ä½¿ç”¨æ•´æ•°â€ å‘¢ï¼Ÿ

ä¾‹å¦‚ï¼Œä¸¤ä¸ªç©å®¶å¯ä»¥è½®æµä»å…¬å…±æ•´æ•°æ± ä¸­æŠ½å–ä» 1 åˆ° 15 çš„æ•´æ•°ï¼ˆä¸æ”¾å›ï¼‰ï¼Œç›´åˆ°ç´¯è®¡æ•´æ•°å’Œ >= 100ã€‚

ç»™å®šä¸¤ä¸ªæ•´æ•° `maxChoosableInteger` ï¼ˆæ•´æ•°æ± ä¸­å¯é€‰æ‹©çš„æœ€å¤§æ•°ï¼‰å’Œ `desiredTotal`ï¼ˆç´¯è®¡å’Œï¼‰ï¼Œè‹¥å…ˆå‡ºæ‰‹çš„ç©å®¶èƒ½ç¨³èµ¢åˆ™è¿”å›
`true` ï¼Œå¦åˆ™è¿”å› `false` ã€‚å‡è®¾ä¸¤ä½ç©å®¶æ¸¸æˆæ—¶éƒ½è¡¨ç° **æœ€ä½³** ã€‚

**ç¤ºä¾‹ 1ï¼š**

> **è¾“å…¥ï¼š** maxChoosableInteger = 10, desiredTotal = 11
>
> **è¾“å‡ºï¼š** false
>
> **è§£é‡Šï¼š** æ— è®ºç¬¬ä¸€ä¸ªç©å®¶é€‰æ‹©å“ªä¸ªæ•´æ•°ï¼Œä»–éƒ½ä¼šå¤±è´¥ã€‚
>
> ç¬¬ä¸€ä¸ªç©å®¶å¯ä»¥é€‰æ‹©ä» 1 åˆ° 10 çš„æ•´æ•°ã€‚
>
> å¦‚æœç¬¬ä¸€ä¸ªç©å®¶é€‰æ‹© 1ï¼Œé‚£ä¹ˆç¬¬äºŒä¸ªç©å®¶åªèƒ½é€‰æ‹©ä» 2 åˆ° 10 çš„æ•´æ•°ã€‚
>
> ç¬¬äºŒä¸ªç©å®¶å¯ä»¥é€šè¿‡é€‰æ‹©æ•´æ•° 10ï¼ˆé‚£ä¹ˆç´¯ç§¯å’Œä¸º 11 >= desiredTotalï¼‰ï¼Œä»è€Œå–å¾—èƒœåˆ©.
>
> åŒæ ·åœ°ï¼Œç¬¬ä¸€ä¸ªç©å®¶é€‰æ‹©ä»»æ„å…¶ä»–æ•´æ•°ï¼Œç¬¬äºŒä¸ªç©å®¶éƒ½ä¼šèµ¢ã€‚

**ç¤ºä¾‹ 2:**

> **è¾“å…¥ï¼š** maxChoosableInteger = 10, desiredTotal = 0
>
> **è¾“å‡ºï¼š** true

**ç¤ºä¾‹ 3:**

> **è¾“å…¥ï¼š** maxChoosableInteger = 10, desiredTotal = 1
>
> **è¾“å‡ºï¼š** true

**æç¤º:**

- `1 <= maxChoosableInteger <= 20`
- `0 <= desiredTotal <= 300`

## è§£é¢˜æ€è·¯

æœ¬é¢˜æ¶‰åŠ**çŠ¶æ€æœç´¢**å’Œ**è®°å¿†åŒ–æœç´¢**ï¼Œå¯ä»¥ä½¿ç”¨**é€’å½’ + å¤‡å¿˜å½• (Memoization)** æ¥ä¼˜åŒ–æœç´¢è¿‡ç¨‹ã€‚

1. **åŸºæœ¬æƒ…å†µå‰ªæ**ï¼š

   - å¦‚æœ `desiredTotal <= maxChoosableInteger`ï¼Œå…ˆæ‰‹ç›´æ¥å– `desiredTotal` èƒœåˆ©ï¼Œè¿”å› `true`ã€‚
   - å¦‚æœ `sum(1, ..., maxChoosableInteger) < desiredTotal`ï¼Œåˆ™æ— è®ºå¦‚ä½•éƒ½æ— æ³•è¾¾åˆ°ç›®æ ‡ï¼Œè¿”å› `false`ã€‚
   - å¦‚æœ `sum(1, ..., maxChoosableInteger) == desiredTotal`ï¼Œåˆ™å–å†³ `maxChoosableInteger` çš„å¥‡å¶æ€§ï¼Œæ­£å¥½å–å®Œæ‰€æœ‰æ•°å­—çš„ä¸€æ–¹è·èƒœã€‚

2. **çŠ¶æ€è¡¨ç¤º**ï¼š

   - ä½¿ç”¨ä¸€ä¸ª `used` ä½æ ‡è®°å“ªäº›æ•°å­—å·²è¢«é€‰è¿‡ï¼ˆå¯ä»¥ç”¨ `bitmask`ï¼‰ã€‚
   - é€’å½’æ£€æŸ¥å½“å‰çŠ¶æ€ä¸‹ï¼Œæ˜¯å¦å­˜åœ¨æŸä¸ªé€‰æ‹©å¯ä»¥å¯¼è‡´å¯¹æ‰‹å¿…è´¥ã€‚

3. **é€’å½’å®šä¹‰**ï¼š

   - è®¾ `canWin(used, total)` è¡¨ç¤ºå½“å‰ `used` çŠ¶æ€ä¸‹ï¼Œ**å½“å‰ç©å®¶** æ˜¯å¦æœ‰å¿…èƒœç­–ç•¥ï¼š
     - éå†æ‰€æœ‰æœªé€‰è¿‡çš„æ•°å­— `i`ï¼š
       - å¦‚æœ `i + total >= desiredTotal`ï¼Œå½“å‰ç©å®¶ç›´æ¥è·èƒœã€‚
       - å¦åˆ™ï¼Œå¯¹æ‰‹è¿›å…¥ `canWin(used | (1 << i), total + i)` çŠ¶æ€ï¼š
         - å¦‚æœå¯¹æ‰‹ **å¿…è´¥**ï¼Œåˆ™å½“å‰ç©å®¶å¿…èƒœã€‚

4. **è®°å¿†åŒ–æœç´¢**ï¼š
   - ä½¿ç”¨ `Map` å­˜å‚¨å·²è®¡ç®—è¿‡çš„ `used` çŠ¶æ€ï¼Œé¿å…é‡å¤æœç´¢ï¼Œæé«˜æ•ˆç‡ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(m * 2^m)`ï¼Œå…¶ä¸­ `m = maxChoosableInteger`ï¼Œæœ€åæƒ…å†µä¸‹ `m â‰¤ 20`ï¼Œä»ç„¶å¯è¡Œã€‚
  - çŠ¶æ€æ•°ï¼š`2^m`ï¼Œå³äºŒè¿›åˆ¶æ©ç çš„ä¸åŒçŠ¶æ€ã€‚
  - æ¯æ¬¡é€’å½’éå† `O(m)`ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(m)`ï¼Œä½¿ç”¨äº†ä¸€ä¸ªå“ˆå¸Œè¡¨å­˜å‚¨ `used` çŠ¶æ€ï¼Œé¿å…é‡å¤è®¡ç®—ã€‚

## ä»£ç 

```javascript
/**
 * @param {number} maxChoosableInteger
 * @param {number} desiredTotal
 * @return {boolean}
 */
var canIWin = function (maxChoosableInteger, desiredTotal) {
	const sum = (maxChoosableInteger * (maxChoosableInteger + 1)) / 2;
	if (desiredTotal <= maxChoosableInteger) return true;
	else if (desiredTotal > sum) return false;
	else if (sum == desiredTotal) return maxChoosableInteger % 2 == 1;

	const memo = new Map();

	const canWin = (used, total) => {
		if (memo.has(used)) return memo.get(used);

		for (let i = 1; i <= maxChoosableInteger; i++) {
			let mask = 1 << i;

			// å¦‚æœ i å·æ•°å­—æœªè¢«é€‰è¿‡
			if ((used & mask) === 0) {
				if (total + i >= desiredTotal || !canWin(used | mask, total + i)) {
					memo.set(used, true);
					return true;
				}
			}
		}

		memo.set(used, false);
		return false;
	};

	return canWin(0, 0);
};
```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ | åŠ›æ‰£ |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 294 | ç¿»è½¬æ¸¸æˆ II ğŸ”’ |  |  [`è®°å¿†åŒ–æœç´¢`](/tag/memoization.md) [`æ•°å­¦`](/tag/math.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md) `2+` | ğŸŸ  | [ğŸ€„ï¸](https://leetcode.cn/problems/flip-game-ii) [ğŸ”—](https://leetcode.com/problems/flip-game-ii) |
| 375 | çŒœæ•°å­—å¤§å° II | [[âœ“]](/problem/0375.md) |  [`æ•°å­¦`](/tag/math.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md) [`åšå¼ˆ`](/tag/game-theory.md) | ğŸŸ  | [ğŸ€„ï¸](https://leetcode.cn/problems/guess-number-higher-or-lower-ii) [ğŸ”—](https://leetcode.com/problems/guess-number-higher-or-lower-ii) |
| 486 | é¢„æµ‹èµ¢å®¶ |  |  [`é€’å½’`](/tag/recursion.md) [`æ•°ç»„`](/tag/array.md) [`æ•°å­¦`](/tag/math.md) `2+` | ğŸŸ  | [ğŸ€„ï¸](https://leetcode.cn/problems/predict-the-winner) [ğŸ”—](https://leetcode.com/problems/predict-the-winner) |
| 3222 | æ±‚å‡ºç¡¬å¸æ¸¸æˆçš„èµ¢å®¶ |  |  [`æ•°å­¦`](/tag/math.md) [`åšå¼ˆ`](/tag/game-theory.md) [`æ¨¡æ‹Ÿ`](/tag/simulation.md) | ğŸŸ¢ | [ğŸ€„ï¸](https://leetcode.cn/problems/find-the-winning-player-in-coin-game) [ğŸ”—](https://leetcode.com/problems/find-the-winning-player-in-coin-game) |
| 3238 | æ±‚å‡ºèƒœåˆ©ç©å®¶çš„æ•°ç›® |  |  [`æ•°ç»„`](/tag/array.md) [`å“ˆå¸Œè¡¨`](/tag/hash-table.md) [`è®¡æ•°`](/tag/counting.md) | ğŸŸ¢ | [ğŸ€„ï¸](https://leetcode.cn/problems/find-the-number-of-winning-players) [ğŸ”—](https://leetcode.com/problems/find-the-number-of-winning-players) |