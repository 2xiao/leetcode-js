# [518. é›¶é’±å…‘æ¢ II](https://leetcode.com/problems/coin-change-ii)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ•°ç»„`](/tag/array.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/coin-change-ii)

## é¢˜ç›®

You are given an integer array `coins` representing coins of different
denominations and an integer `amount` representing a total amount of money.

Return _the number of combinations that make up that amount_. If that amount
of money cannot be made up by any combination of the coins, return `0`.

You may assume that you have an infinite number of each kind of coin.

The answer is **guaranteed** to fit into a signed **32-bit** integer.

**Example 1:**

> Input: amount = 5, coins = [1,2,5]
>
> Output: 4
>
> Explanation: there are four ways to make up the amount:
>
> 5=5
>
> 5=2+2+1
>
> 5=2+1+1+1
>
> 5=1+1+1+1+1

**Example 2:**

> Input: amount = 3, coins = [2]
>
> Output: 0
>
> Explanation: the amount of 3 cannot be made up just with coins of 2.

**Example 3:**

> Input: amount = 10, coins = [10]
>
> Output: 1

**Constraints:**

- `1 <= coins.length <= 300`
- `1 <= coins[i] <= 5000`
- All the values of `coins` are **unique**.
- `0 <= amount <= 5000`

## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `coins` è¡¨ç¤ºä¸åŒé¢é¢çš„ç¡¬å¸ï¼Œå¦ç»™ä¸€ä¸ªæ•´æ•° `amount` è¡¨ç¤ºæ€»é‡‘é¢ã€‚

è¯·ä½ è®¡ç®—å¹¶è¿”å›å¯ä»¥å‡‘æˆæ€»é‡‘é¢çš„ç¡¬å¸ç»„åˆæ•°ã€‚å¦‚æœä»»ä½•ç¡¬å¸ç»„åˆéƒ½æ— æ³•å‡‘å‡ºæ€»é‡‘é¢ï¼Œè¿”å› 0 ã€‚

å‡è®¾æ¯ä¸€ç§é¢é¢çš„ç¡¬å¸æœ‰æ— é™ä¸ªã€‚

é¢˜ç›®æ•°æ®ä¿è¯ç»“æœç¬¦åˆ 32 ä½å¸¦ç¬¦å·æ•´æ•°ã€‚

**ç¤ºä¾‹ 1ï¼š**

> è¾“å…¥ï¼šamount = 5, coins = [1, 2, 5]
>
> è¾“å‡ºï¼š4
>
> è§£é‡Šï¼šæœ‰å››ç§æ–¹å¼å¯ä»¥å‡‘æˆæ€»é‡‘é¢ï¼š
>
> 5=5
>
> 5=2+2+1
>
> 5=2+1+1+1
>
> 5=1+1+1+1+1

**ç¤ºä¾‹ 2ï¼š**

> è¾“å…¥ï¼šamount = 3, coins = [2]
>
> è¾“å‡ºï¼š0
>
> è§£é‡Šï¼šåªç”¨é¢é¢ 2 çš„ç¡¬å¸ä¸èƒ½å‡‘æˆæ€»é‡‘é¢ 3 ã€‚

**ç¤ºä¾‹ 3ï¼š**

> è¾“å…¥ï¼šamount = 10, coins = [10]
>
> è¾“å‡ºï¼š1

## è§£é¢˜æ€è·¯

### æ€è·¯ä¸€ï¼šåŠ¨æ€è§„åˆ’

- ä½¿ç”¨äºŒç»´æ•°ç»„ `dp`ï¼Œå…¶ä¸­ `dp[i][j]` è¡¨ç¤ºåœ¨å‰ `i` ç§ç¡¬å¸ä¸­å‡‘æˆé‡‘é¢ `j` çš„ç»„åˆæ•°ã€‚
- åˆå§‹åŒ–ç¬¬ä¸€åˆ—ï¼Œè¡¨ç¤ºå‡‘æˆé‡‘é¢ä¸º 0 çš„ç»„åˆæ•°éƒ½ä¸º 1ã€‚
- çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š`dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]]`
  - å…¶ä¸­ï¼Œ`coins[i - 1]` è¡¨ç¤ºç¬¬ `i` ç§ç¡¬å¸çš„é¢å€¼ã€‚
- éå†ç¡¬å¸ç§ç±»å’Œé‡‘é¢ï¼Œæ ¹æ®çŠ¶æ€è½¬ç§»æ–¹ç¨‹æ›´æ–° `dp[i][j]` çš„å€¼ã€‚

  - å¯¹äºæ¯ä¸€ç§ç¡¬å¸ `coins[i - 1]`ï¼Œéå†é‡‘é¢ `j`ã€‚
  - å¦‚æœ `j - coins[i - 1] >= 0`ï¼Œåˆ™æ›´æ–° `dp[i][j]` çš„å€¼ï¼Œå¦åˆ™ä¿æŒ `dp[i][j]` ä¸å˜ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(n * amount)`ï¼Œå…¶ä¸­ `n` æ˜¯ç¡¬å¸çš„ç§ç±»ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(n * amount)`ï¼Œä½¿ç”¨äº†ä¸€ä¸ªäºŒç»´åŠ¨æ€è§„åˆ’æ•°ç»„ã€‚

---

### æ€è·¯äºŒï¼šå‹ç¼©çŠ¶æ€çš„åŠ¨æ€è§„åˆ’

- ä½¿ç”¨ä¸€ç»´æ•°ç»„ `dp`ï¼Œå…¶ä¸­ `dp[j]` è¡¨ç¤ºå‡‘æˆé‡‘é¢ `j` çš„ç»„åˆæ•°ã€‚
- åˆå§‹åŒ– `dp[0]` ä¸º 1ï¼Œè¡¨ç¤ºå‡‘æˆé‡‘é¢ä¸º 0 çš„ç»„åˆæ•°ä¸º 1ã€‚
- çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š`dp[j] += dp[j - coin]`ï¼Œå…¶ä¸­ï¼Œ`coin` è¡¨ç¤ºå½“å‰ç¡¬å¸çš„é¢å€¼ã€‚
- éå†ç¡¬å¸ç§ç±»å’Œé‡‘é¢ï¼Œæ ¹æ®çŠ¶æ€è½¬ç§»æ–¹ç¨‹æ›´æ–° `dp[j]` çš„å€¼ã€‚

  - å¯¹äºæ¯ä¸€ç§ç¡¬å¸ `coin`ï¼Œéå†é‡‘é¢ `j`ã€‚
  - å¦‚æœ `j - coin >= 0`ï¼Œåˆ™æ›´æ–° `dp[j]` çš„å€¼ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(n * amount)`ï¼Œå…¶ä¸­ `n` æ˜¯ç¡¬å¸çš„ç§ç±»ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(amount)`ï¼Œä½¿ç”¨äº†ä¸€ä¸ªä¸€ç»´åŠ¨æ€è§„åˆ’æ•°ç»„ã€‚

## ä»£ç 

::: code-tabs

@tab åŠ¨æ€è§„åˆ’

```javascript
/**
 * @param {number} amount
 * @param {number[]} coins
 * @return {number}
 */
var change = function (amount, coins) {
	const n = coins.length;
	const dp = new Array(n + 1).fill(0).map(() => new Array(amount + 1).fill(0));
	for (let i = 0; i <= n; i++) {
		dp[i][0] = 1;
	}
	for (let i = 1; i <= n; i++) {
		for (let j = 1; j <= amount; j++) {
			if (j - coins[i - 1] >= 0) {
				dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]];
			} else {
				dp[i][j] = dp[i - 1][j];
			}
		}
	}

	return dp[n][amount];
};
```

@tab å‹ç¼©çŠ¶æ€çš„åŠ¨æ€è§„åˆ’

```javascript
/**
 * @param {number} amount
 * @param {number[]} coins
 * @return {number}
 */
var change = function (amount, coins) {
	const dp = new Array(amount + 1).fill(0);
	dp[0] = 1;
	for (let coin of coins) {
		for (let j = 1; j <= amount; j++) {
			if (j - coin >= 0) {
				dp[j] += dp[j - coin];
			}
		}
	}

	return dp[amount];
};
```

:::

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 2218 | [ä»æ ˆä¸­å–å‡º K ä¸ªç¡¬å¸çš„æœ€å¤§é¢å€¼å’Œ](https://leetcode.com/problems/maximum-value-of-k-coins-from-piles) |  |  [`æ•°ç»„`](/tag/array.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md) [`å‰ç¼€å’Œ`](/tag/prefix-sum.md) | <font color=#ff334b>Hard</font> |
| 2585 | [è·å¾—åˆ†æ•°çš„æ–¹æ³•æ•°](https://leetcode.com/problems/number-of-ways-to-earn-points) |  |  [`æ•°ç»„`](/tag/array.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md) | <font color=#ff334b>Hard</font> |
| 2902 | [å’Œå¸¦é™åˆ¶çš„å­å¤šé‡é›†åˆçš„æ•°ç›®](https://leetcode.com/problems/count-of-sub-multisets-with-bounded-sum) |  |  [`æ•°ç»„`](/tag/array.md) [`å“ˆå¸Œè¡¨`](/tag/hash-table.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md) `1+` | <font color=#ff334b>Hard</font> |
| 2915 | [å’Œä¸ºç›®æ ‡å€¼çš„æœ€é•¿å­åºåˆ—çš„é•¿åº¦](https://leetcode.com/problems/length-of-the-longest-subsequence-that-sums-to-target) |  |  [`æ•°ç»„`](/tag/array.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md) | <font color=#ffb800>Medium</font> |
| 3183 | [è¾¾åˆ°æ€»å’Œçš„æ–¹æ³•æ•°é‡](https://leetcode.com/problems/the-number-of-ways-to-make-the-sum) |  |  [`æ•°ç»„`](/tag/array.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md) | <font color=#ffb800>Medium</font> |