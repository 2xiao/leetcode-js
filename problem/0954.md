# [954. äºŒå€æ•°å¯¹æ•°ç»„](https://leetcode.com/problems/array-of-doubled-pairs)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`è´ªå¿ƒ`](/outline/tag/greedy.md) [`æ•°ç»„`](/outline/tag/array.md) [`å“ˆå¸Œè¡¨`](/outline/tag/hash-table.md) [`æ’åº`](/outline/tag/sorting.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/array-of-doubled-pairs)

## é¢˜ç›®

Given an integer array of even length `arr`, return `true` _if it is possible
to reorder_`arr` _such that_`arr[2 * i + 1] = 2 * arr[2 * i]` _for every_`0 <=
i < len(arr) / 2` _, or_`false` _otherwise_.

**Example 1:**

> Input: arr = [3,1,3,6]
>
> Output: false

**Example 2:**

> Input: arr = [2,1,2,6]
>
> Output: false

**Example 3:**

> Input: arr = [4,-2,2,-4]
>
> Output: true
>
> Explanation: We can take two groups, [-2,-4] and [2,4] to form [-2,-4,2,4] or [2,4,-2,-4].

**Constraints:**

- `2 <= arr.length <= 3 * 10^4`
- `arr.length` is even.
- `-10^5 <= arr[i] <= 10^5`

## é¢˜ç›®å¤§æ„

ç»™å®šä¸€ä¸ªé•¿åº¦ä¸ºå¶æ•°çš„æ•´æ•°æ•°ç»„ `arr`ï¼Œåªæœ‰å¯¹ `arr` è¿›è¡Œé‡ç»„åå¯ä»¥æ»¡è¶³ â€œå¯¹äºæ¯ä¸ª `0 <= i < len(arr) / 2`ï¼Œéƒ½æœ‰ `arr[2 * i + 1] = 2 * arr[2 * i]`â€ æ—¶ï¼Œè¿”å› `true`ï¼›å¦åˆ™ï¼Œè¿”å› `false`ã€‚

## è§£é¢˜æ€è·¯

- ç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨ `count` æ¥ç»Ÿè®¡ `arr` ä¸­æ¯ä¸ªæ•°å­—çš„ä¸ªæ•°ï¼Œå³ `count[x]` è¡¨ç¤º `arr` ä¸­ `x` çš„ä¸ªæ•°ï¼›
- ç”¨ä¸€ä¸ªæ•°ç»„ `vals` è¡¨ç¤ºå»é‡åçš„æ‰€æœ‰æ•°å­—ï¼Œå¹¶å°†å…¶æŒ‰ç»å¯¹å€¼ä»å°åˆ°å¤§æ’åºï¼›
- éå† `vals`ï¼Œå‡è®¾ `x` ä¸º `arr` ä¸­ç»å¯¹å€¼æœ€å°çš„å…ƒç´ ï¼Œç”±äºæ²¡æœ‰ç»å¯¹å€¼æ¯” `x` æ›´å°çš„æ•°ï¼Œå› æ­¤ `x` åªèƒ½ä¸ `2x` åŒ¹é…ã€‚
- å¦‚æœæ­¤æ—¶ `count[2x]<count[x]`ï¼Œé‚£ä¹ˆä¼šæœ‰éƒ¨åˆ† `x` æ— æ³•æ‰¾åˆ°å®ƒçš„å¦ä¸€åŠï¼Œå³æ— æ³•æ»¡è¶³é¢˜ç›®è¦æ±‚ï¼›
- å¦åˆ™å°†æ‰€æœ‰ `x` å’Œ `count[x]` ä¸ª `2x` ä» `arr` ä¸­å»æ‰ï¼Œç»§ç»­åˆ¤æ–­å‰©ä½™å…ƒç´ æ˜¯å¦æ»¡è¶³é¢˜ç›®è¦æ±‚ã€‚
- ä¸æ–­é‡å¤æ­¤æ“ä½œï¼Œå¦‚æœæŸä¸ªæ—¶åˆ» `arr` ä¸ºç©ºï¼Œåˆ™è¯´æ˜ `arr` å¯ä»¥æ»¡è¶³é¢˜ç›®è¦æ±‚ã€‚

## ä»£ç 

```javascript
/**
 * @param {number[]} arr
 * @return {boolean}
 */
var canReorderDoubled = function (arr) {
	const count = new Map();
	for (let i of arr) {
		count.set(i, (count.get(i) || 0) + 1);
	}

	// Â å–å‡ºå»é‡åçš„æ•°å­—ã€‚å¹¶æŒ‰ç…§ç»å¯¹å€¼æ’åº
	const vals = [...count.keys()].sort((a, b) => Math.abs(a) - Math.abs(b));

	for (let x of vals) {
		// æ— æ³•æ‰¾åˆ°è¶³å¤Ÿçš„ 2x ä¸ x é…å¯¹
		if ((count.get(x * 2) || 0) < count.get(x)) return false;

		count.set(x * 2, (count.get(x * 2) || 0) - count.get(x));
	}
	return true;
};
```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 2007 | [ä»åŒå€æ•°ç»„ä¸­è¿˜åŸåŸæ•°ç»„](https://leetcode.com/problems/find-original-array-from-doubled-array) |  |  [`è´ªå¿ƒ`](/outline/tag/greedy.md) [`æ•°ç»„`](/outline/tag/array.md) [`å“ˆå¸Œè¡¨`](/outline/tag/hash-table.md) `1+` | <font color=#ffb800>Medium</font> |

<style>
.blue {
    background-color: #096dd9;
    padding: 0.25rem 0.5rem;
    margin: 0;
    font-size: 0.85em;
    border-radius: 3px;
    color: white;
    font-weight: 500;
}
table th:first-of-type { width: 10%; }
table th:nth-of-type(2) { width: 35%; }
table th:nth-of-type(3) { width: 10%; }
table th:nth-of-type(4) { width: 35%; }
table th:nth-of-type(5) { width: 10%; }
</style>
