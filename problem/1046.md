---
title: 1046. æœ€åä¸€å—çŸ³å¤´çš„é‡é‡
description: LeetCode 1046. æœ€åä¸€å—çŸ³å¤´çš„é‡é‡é¢˜è§£ï¼ŒLast Stone Weightï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 1046. æœ€åä¸€å—çŸ³å¤´çš„é‡é‡
  - æœ€åä¸€å—çŸ³å¤´çš„é‡é‡
  - Last Stone Weight
  - è§£é¢˜æ€è·¯
  - æ•°ç»„
  - å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰
---

# 1046. æœ€åä¸€å—çŸ³å¤´çš„é‡é‡

ğŸŸ¢ <font color=#15bd66>Easy</font>&emsp; ğŸ”–&ensp; [`æ•°ç»„`](/tag/array.md) [`å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰`](/tag/heap-priority-queue.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/last-stone-weight) [`LeetCode`](https://leetcode.com/problems/last-stone-weight)

## é¢˜ç›®

You are given an array of integers `stones` where `stones[i]` is the weight of
the `ith` stone.

We are playing a game with the stones. On each turn, we choose the **heaviest
two stones** and smash them together. Suppose the heaviest two stones have
weights `x` and `y` with `x <= y`. The result of this smash is:

- If `x == y`, both stones are destroyed, and
- If `x != y`, the stone of weight `x` is destroyed, and the stone of weight `y` has new weight `y - x`.

At the end of the game, there is **at most one** stone left.

Return _the weight of the last remaining stone_. If there are no stones left,
return `0`.

**Example 1:**

> Input: stones = [2,7,4,1,8,1]
>
> Output: 1
>
> Explanation:
>
> We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,
>
> we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,
>
> we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,
>
> we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone.

**Example 2:**

> Input: stones = [1]
>
> Output: 1

**Constraints:**

- `1 <= stones.length <= 30`
- `1 <= stones[i] <= 1000`

## é¢˜ç›®å¤§æ„

æœ‰ä¸€å †çŸ³å¤´ï¼Œæ¯å—çŸ³å¤´çš„é‡é‡éƒ½æ˜¯æ­£æ•´æ•°ã€‚

æ¯ä¸€å›åˆï¼Œä»ä¸­é€‰å‡ºä¸¤å—**æœ€é‡çš„** çŸ³å¤´ï¼Œç„¶åå°†å®ƒä»¬ä¸€èµ·ç²‰ç¢ã€‚å‡è®¾çŸ³å¤´çš„é‡é‡åˆ†åˆ«ä¸º `x` å’Œ `y`ï¼Œä¸” `x <= y`ã€‚é‚£ä¹ˆç²‰ç¢çš„å¯èƒ½ç»“æœå¦‚ä¸‹ï¼š

- å¦‚æœ `x == y`ï¼Œé‚£ä¹ˆä¸¤å—çŸ³å¤´éƒ½ä¼šè¢«å®Œå…¨ç²‰ç¢ï¼›
- å¦‚æœ `x != y`ï¼Œé‚£ä¹ˆé‡é‡ä¸º `x` çš„çŸ³å¤´å°†ä¼šå®Œå…¨ç²‰ç¢ï¼Œè€Œé‡é‡ä¸º `y` çš„çŸ³å¤´æ–°é‡é‡ä¸º `y-x`ã€‚

æœ€åï¼Œæœ€å¤šåªä¼šå‰©ä¸‹ä¸€å—çŸ³å¤´ã€‚è¿”å›æ­¤çŸ³å¤´çš„é‡é‡ã€‚å¦‚æœæ²¡æœ‰çŸ³å¤´å‰©ä¸‹ï¼Œå°±è¿”å› `0`ã€‚

**ç¤ºä¾‹ï¼š**

> **è¾“å…¥ï¼š**[2,7,4,1,8,1]
>
> **è¾“å‡ºï¼š** 1
>
> **è§£é‡Šï¼š**
>
> å…ˆé€‰å‡º 7 å’Œ 8ï¼Œå¾—åˆ° 1ï¼Œæ‰€ä»¥æ•°ç»„è½¬æ¢ä¸º [2,4,1,1,1]ï¼Œ
>
> å†é€‰å‡º 2 å’Œ 4ï¼Œå¾—åˆ° 2ï¼Œæ‰€ä»¥æ•°ç»„è½¬æ¢ä¸º [2,1,1,1]ï¼Œ
>
> æ¥ç€æ˜¯ 2 å’Œ 1ï¼Œå¾—åˆ° 1ï¼Œæ‰€ä»¥æ•°ç»„è½¬æ¢ä¸º [1,1,1]ï¼Œ
>
> æœ€åé€‰å‡º 1 å’Œ 1ï¼Œå¾—åˆ° 0ï¼Œæœ€ç»ˆæ•°ç»„è½¬æ¢ä¸º [1]ï¼Œè¿™å°±æ˜¯æœ€åå‰©ä¸‹é‚£å—çŸ³å¤´çš„é‡é‡ã€‚

**æç¤ºï¼š**

- `1 <= stones.length <= 30`
- `1 <= stones[i] <= 1000`

## è§£é¢˜æ€è·¯

1. **æ•°æ®ç»“æ„é€‰æ‹©**ï¼š

   - ç”±äºæ¯æ¬¡éƒ½éœ€è¦æ‰¾å‡º**æœ€é‡çš„ä¸¤å—çŸ³å¤´**ï¼Œå¯ä»¥ä½¿ç”¨**å¤§é¡¶å †**ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰æ¥å­˜å‚¨çŸ³å¤´é‡é‡ã€‚
   - å †å¯ä»¥å¿«é€Ÿå–å‡ºæœ€å¤§å€¼ï¼Œå¹¶æ”¯æŒåŠ¨æ€æ’å…¥æ“ä½œï¼Œé€‚åˆå¤„ç†è¿™ç§éœ€è¦é¢‘ç¹æ‰¾æœ€å¤§å€¼çš„é—®é¢˜ã€‚

2. **æ¨¡æ‹Ÿç²‰ç¢è¿‡ç¨‹**ï¼š

   - æ¯æ¬¡ä»å †ä¸­å–å‡ºæœ€é‡çš„ä¸¤å—çŸ³å¤´ `x` å’Œ `y`ï¼ˆå‡è®¾ `x <= y`ï¼‰ã€‚
   - å¦‚æœ `x == y`ï¼Œä¸¤å—çŸ³å¤´å®Œå…¨ç²‰ç¢ï¼Œä¸å†æ”¾å›å †ä¸­ã€‚
   - å¦‚æœ `x < y`ï¼Œå°†å‰©ä½™é‡é‡ `y - x` æ’å›å †ä¸­ã€‚
   - é‡å¤ä¸Šè¿°è¿‡ç¨‹ï¼Œç›´åˆ°å †ä¸­å‰©ä¸‹ 0 æˆ– 1 å—çŸ³å¤´ã€‚

3. **å¤„ç†ç‰¹æ®Šæƒ…å†µ**ï¼š
   - å¦‚æœæœ€åå †ä¸ºç©ºï¼Œè¿”å› 0ã€‚
   - å¦‚æœæœ€åå †ä¸­å‰©ä¸‹ä¸€å—çŸ³å¤´ï¼Œç›´æ¥è¿”å›å…¶é‡é‡ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(n log n)`
  - å †çš„åˆå§‹åŒ–çš„æ—¶é—´å¤æ‚åº¦ä¸º `O(n)`
  - æ¯æ¬¡å¾ªç¯ä¸­æœ‰ä¸¤ä¸ªæ“ä½œï¼ˆå–å‡ºä¸¤å—çŸ³å¤´å’Œæ’å…¥ä¸€å—çŸ³å¤´ï¼‰ï¼Œæ¯ä¸ªæ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¸º `O(log n)`ã€‚
  - æ€»å…±æœ‰ `n - 1` è½®æ“ä½œï¼Œå› æ­¤å¾ªç¯éƒ¨åˆ†çš„æ€»æ—¶é—´å¤æ‚åº¦ä¸º `O(n log n)`ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(n)`
  - å †å­˜å‚¨çš„ä¸»è¦å¼€é”€ä¸º `O(n)`
  - é€’å½’æ ˆçš„å¼€é”€ä¸º `O(log n)`
  - å› æ­¤ï¼Œæ€»ç©ºé—´å¤æ‚åº¦ä¸ºï¼š`O(n)`ã€‚

## ä»£ç 

```javascript
/**
 * @param {number[]} stones
 * @return {number}
 */
var lastStoneWeight = function (stones) {
	let heap = new MaxHeap(stones);
	while (heap.size() > 1) {
		// å–å‡ºæœ€é‡çš„ä¸¤å—çŸ³å¤´
		const max = heap.pop(); // æœ€å¤§
		const second = heap.pop(); // æ¬¡å¤§
		const diff = max - second;
		if (diff) {
			// å‰©ä½™çš„é‡é‡æ’å›å †ä¸­
			heap.insert(diff);
		}
	}
	// è¿”å›æœ€åå‰©ä¸‹çš„çŸ³å¤´é‡é‡ï¼Œæˆ–è€… 0ï¼ˆå¦‚æœæ²¡æœ‰çŸ³å¤´ï¼‰
	return heap.size() ? heap.toArray()[0] : 0;
};

class MaxHeap {
	constructor(arr = []) {
		this.heap = arr;
		for (let i = Math.floor(this.heap.length / 2); i >= 0; i--) {
			this.heapifyDown(i);
		}
	}

	insert(num) {
		this.heap.push(num);
		this.heapifyUp(this.heap.length - 1);
	}
	pop() {
		if (this.heap.length == 0) return null;
		const top = this.heap[0];
		const last = this.heap.pop();
		if (this.heap.length) {
			this.heap[0] = last;
			this.heapifyDown(0);
		}
		return top;
	}
	toArray() {
		return this.heap;
	}
	size() {
		return this.heap.length;
	}
	heapifyDown(i) {
		const left = i * 2 + 1;
		const right = i * 2 + 2;
		let max = i;
		if (left < this.heap.length && this.heap[max] < this.heap[left]) {
			max = left;
		}
		if (right < this.heap.length && this.heap[max] < this.heap[right]) {
			max = right;
		}
		if (max !== i) {
			[this.heap[max], this.heap[i]] = [this.heap[i], this.heap[max]];
			this.heapifyDown(max);
		}
	}
	heapifyUp(i) {
		while (i) {
			const parent = ((i - 1) / 2) | 0;
			if (this.heap[parent] < this.heap[i]) {
				[this.heap[parent], this.heap[i]] = [this.heap[i], this.heap[parent]];
				i = parent;
			} else {
				break;
			}
		}
	}
}
```
