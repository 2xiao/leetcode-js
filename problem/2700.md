---
title: 2700. ä¸¤ä¸ªå¯¹è±¡ä¹‹é—´çš„å·®å¼‚ ğŸ”’
description: LeetCode,2700. ä¸¤ä¸ªå¯¹è±¡ä¹‹é—´çš„å·®å¼‚ ğŸ”’,ä¸¤ä¸ªå¯¹è±¡ä¹‹é—´çš„å·®å¼‚,Differences Between Two Objects,è§£é¢˜æ€è·¯
keywords:
  - LeetCode
  - 2700. ä¸¤ä¸ªå¯¹è±¡ä¹‹é—´çš„å·®å¼‚ ğŸ”’
  - ä¸¤ä¸ªå¯¹è±¡ä¹‹é—´çš„å·®å¼‚
  - Differences Between Two Objects
  - è§£é¢˜æ€è·¯
---

# 2700. ä¸¤ä¸ªå¯¹è±¡ä¹‹é—´çš„å·®å¼‚ ğŸ”’

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/differences-between-two-objects) [`LeetCode`](https://leetcode.com/problems/differences-between-two-objects)

## é¢˜ç›®

Write a function that accepts two deeply nested objects or arrays `obj1` and
`obj2` and returns a new object representing their differences.

The function should compare the properties of the two objects and identify any
changes. The returned object should only contains keys where the value is
different from `obj1` to `obj2`.

For each changed key, the value should be represented as an array `[obj1
value, obj2 value]`. Keys that exist in one object but not in the other should
not be included in the returned object. The end result should be a deeply
nested object where each leaf value is a difference array.

When comparing two arrays, the indices of the arrays are considered to be
their keys.

You may assume that both objects are the output of `JSON.parse`.

**Example 1:**

> Input:
>
> obj1 = {}
>
> obj2 = { "a": 1, "b": 2 }
>
> Output: {}
>
> Explanation: There were no modifications made to obj1. New keys "a" and "b" appear in obj2, but keys that are added or removed should be ignored.

**Example 2:**

> Input:
>
> obj1 = { "a": 1, "v": 3, "x": [], "z": { "a": null } }
>
> obj2 = { "a": 2, "v": 4, "x": [], "z": { "a": 2 } }
>
> Output:
>
> { "a": [1, 2], "v": [3, 4], "z": { "a": [null, 2] } }
>
> Explanation: The keys "a", "v", and "z" all had changes applied. "a" was changed from 1 to 2. "v" was changed from 3 to 4. "z" had a change applied to a child object. "z.a" was changed from null to 2.

**Example 3:**

> Input:
>
> obj1 = { "a": 5, "v": 6, "z": [1, 2, 4, [2, 5, 7]] }
>
> obj2 = { "a": 5, "v": 7, "z": [1, 2, 3, [1]] }
>
> Output:
>
> { "v": [6, 7], "z": { "2": [4, 3], "3": { "0": [2, 1] } } }
>
> Explanation: In obj1 and obj2, the keys "v" and "z" have different assigned values. "a" is ignored because the value is unchanged. In the key "z", there is a nested array. Arrays are treated like objects where the indices are keys. There were two alterations to the the array: z[2] and z[3][0]. z[0] and z[1] were unchanged and thus not included. z[3][1] and z[3][2] were removed and thus not included.

**Example 4:**

> Input:
>
> obj1 = { "a": {"b": 1}, }
>
> obj2 = { "a": [5], }
>
> Output: { "a": [{"b": 1}, [5]] }
>
> Explanation: The key "a" exists in both objects. Since the two associated values have different types, they are placed in the difference array.

**Example 5:**

> Input:
>
> obj1 = { "a": [1, 2, {}], "b": false }
>
> obj2 = { "b": false, "a": [1, 2, {}] }
>
> Output: {}
>
> Explanation: Apart from a different ordering of keys, the two objects are identical so an empty object is returned.

**Constraints:**

- `obj1` and `obj2` are valid JSON objects or arrays
- `2 <= JSON.stringify(obj1).length <= 10^4`
- `2 <= JSON.stringify(obj2).length <= 10^4`

## é¢˜ç›®å¤§æ„

è¯·ä½ ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒæ¥æ”¶ä¸¤ä¸ªæ·±åº¦åµŒå¥—çš„å¯¹è±¡æˆ–æ•°ç»„ `obj1` å’Œ `obj2` ï¼Œå¹¶è¿”å›ä¸€ä¸ªæ–°å¯¹è±¡è¡¨ç¤ºå®ƒä»¬ä¹‹é—´å·®å¼‚ã€‚

è¯¥å‡½æ•°åº”è¯¥æ¯”è¾ƒè¿™ä¸¤ä¸ªå¯¹è±¡çš„å±æ€§ï¼Œå¹¶è¯†åˆ«ä»»ä½•å˜åŒ–ã€‚è¿”å›çš„å¯¹è±¡åº”ä»…åŒ…å«ä» `obj1` åˆ° `obj2` çš„å€¼ä¸åŒçš„é”®ã€‚

å¯¹äºæ¯ä¸ªå˜åŒ–çš„é”®ï¼Œå€¼åº”è¡¨ç¤ºä¸ºä¸€ä¸ªæ•°ç»„ `[obj1 value, obj2 value]`
ã€‚ä¸å­˜åœ¨äºä¸€ä¸ªå¯¹è±¡ä¸­ä½†å­˜åœ¨äºå¦ä¸€ä¸ªå¯¹è±¡ä¸­çš„é”®ä¸åº”åŒ…å«åœ¨è¿”å›çš„å¯¹è±¡ä¸­ã€‚åœ¨æ¯”è¾ƒä¸¤ä¸ªæ•°ç»„æ—¶ï¼Œæ•°ç»„çš„ç´¢å¼•è¢«è§†ä¸ºå®ƒä»¬çš„é”®ã€‚æœ€ç»ˆç»“æœåº”æ˜¯ä¸€ä¸ªæ·±åº¦åµŒå¥—çš„å¯¹è±¡ï¼Œå…¶ä¸­æ¯ä¸ªå¶å­çš„å€¼éƒ½æ˜¯ä¸€ä¸ªå·®å¼‚æ•°ç»„ã€‚

ä½ å¯ä»¥å‡è®¾è¿™ä¸¤ä¸ªå¯¹è±¡éƒ½æ˜¯ `JSON.parse` çš„è¾“å‡ºç»“æœã€‚

**æç¤ºï¼š**

- `obj1` å’Œ `obj2` éƒ½æ˜¯æœ‰æ•ˆçš„ JSON å¯¹è±¡æˆ–æ•°ç»„
- `2 <= JSON.stringify(obj1).length <= 10^4`
- `2 <= JSON.stringify(obj2).length <= 10^4`

## è§£é¢˜æ€è·¯

1. **ç±»å‹æ¯”è¾ƒ**ï¼š

   - é¦–å…ˆï¼Œæ£€æŸ¥ `obj1` å’Œ `obj2` çš„ç±»å‹ã€‚å¦‚æœå®ƒä»¬çš„ç±»å‹ä¸åŒï¼Œç›´æ¥è¿”å›ä¸€ä¸ªåŒ…å«ä¸¤ä¸ªå¯¹è±¡çš„æ•°ç»„ `[obj1, obj2]`ï¼Œè¿™ä¸€æ­¥ç¡®ä¿äº†åç»­çš„æ¯”è¾ƒæ˜¯åŸºäºç›¸åŒç±»å‹çš„å¯¹è±¡ã€‚

2. **åŸºæœ¬æ•°æ®ç±»å‹æ¯”è¾ƒ**ï¼š

   - å¦‚æœä¸¤ä¸ªå¯¹è±¡æ˜¯åŸºæœ¬æ•°æ®ç±»å‹ï¼ˆå³ä¸æ˜¯å¯¹è±¡æˆ–æ•°ç»„ï¼‰ï¼Œåˆ™ç›´æ¥æ¯”è¾ƒå®ƒä»¬çš„å€¼ã€‚
   - å¦‚æœå€¼ç›¸ç­‰ï¼Œè¿”å›ä¸€ä¸ªç©ºå¯¹è±¡ `{}`ï¼Œè¡¨ç¤ºæ²¡æœ‰å·®å¼‚ï¼›
   - å¦‚æœä¸ç›¸ç­‰ï¼Œè¿”å›ä¸€ä¸ªæ•°ç»„ `[obj1, obj2]`ï¼Œè¡¨ç¤ºä¸¤ä¸ªå€¼çš„å·®å¼‚ã€‚

3. **å¯¹è±¡æˆ–æ•°ç»„çš„å¤„ç†**ï¼š

   - å¯¹äºæ•°ç»„æˆ–å¯¹è±¡ï¼Œåˆå§‹åŒ–ä¸€ä¸ªç©ºå¯¹è±¡ `res` ç”¨äºå­˜å‚¨å·®å¼‚ç»“æœã€‚
   - ä½¿ç”¨ `Object.keys(obj1)` è·å– `obj1` çš„æ‰€æœ‰é”®ï¼Œå¹¶è¿‡æ»¤å‡ºåŒæ—¶å­˜åœ¨äº `obj2` ä¸­çš„å…¬å…±å±æ€§ `commonKeys`ã€‚

4. **é€’å½’æ¯”è¾ƒ**ï¼š

   - å¯¹äºæ¯ä¸ªå…¬å…±å±æ€§ï¼Œé€’å½’è°ƒç”¨ `objDiff` å‡½æ•°ä»¥è·å–å­å¯¹è±¡çš„å·®å¼‚ã€‚å¦‚æœè¿”å›çš„å·®å¼‚å¯¹è±¡ `subDiff` ä¸æ˜¯ç©ºçš„ï¼Œåˆ™å°†å…¶æ·»åŠ åˆ°ç»“æœå¯¹è±¡ `res` ä¸­ã€‚

5. **è¿”å›ç»“æœ**ï¼š
   - æœ€ç»ˆï¼Œè¿”å›ç»“æœå¯¹è±¡ `res`ï¼Œå®ƒåŒ…å«äº†æ‰€æœ‰ä¸åŒçš„é”®åŠå…¶å¯¹åº”çš„å·®å¼‚å€¼ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œå…¶ä¸­ `n` æ˜¯ä¸¤ä¸ªå¯¹è±¡çš„æ€»é”®æ•°ï¼Œéœ€è¦éå†å¯¹è±¡æ‰€æœ‰çš„é”®ï¼Œå¦‚æœå¯¹è±¡åµŒå¥—å±‚çº§å¾ˆæ·±ï¼Œé€’å½’è°ƒç”¨çš„æ·±åº¦ä¹Ÿä¼šå¢åŠ ï¼Œä½†åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œæ—¶é—´å¤æ‚åº¦ä¿æŒåœ¨ `O(n)`ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œä¸»è¦ç”±å­˜å‚¨å·®å¼‚çš„ç»“æœå¯¹è±¡ `res` å æ®ï¼Œéœ€è¦å­˜å‚¨æ‰€æœ‰ä¸åŒçš„å€¼ã€‚

## ä»£ç 

```javascript
/**
 * @param {Object|Array} obj1
 * @param {Object|Array} obj2
 * @return {Object}
 */
var objDiff = function (obj1, obj2) {
	// 1. è‹¥ obj1 å’Œ obj2 ç±»å‹ä¸åŒï¼Œç›´æ¥è¿”å› [obj1, obj2]
	if (type(obj1) !== type(obj2)) return [obj1, obj2];

	// 2. è‹¥æ˜¯åŸºæœ¬æ•°æ®ç±»å‹ï¼Œç›´æ¥æ¯”è¾ƒå€¼æ˜¯å¦ç›¸ç­‰
	if (!isObject(obj1)) return obj1 == obj2 ? {} : [obj1, obj2];

	// 3. è‹¥æ˜¯æ•°ç»„æˆ–å¯¹è±¡
	let res = {};

	// æ‰¾åˆ°ä¸¤ä¸ªå¯¹è±¡çš„å…¬å…±å±æ€§
	const commonKeys = Object.keys(obj1).filter((key) => key in obj2);
	commonKeys.forEach((key) => {
		// é€’å½’æ¯”è¾ƒ
		const subDiff = objDiff(obj1[key], obj2[key]);
		// è¿‡æ»¤æ‰å€¼ä¸ºç©ºçš„å±æ€§
		if (Object.keys(subDiff).length) res[key] = subDiff;
	});
	return res;
};

// è¿”å› obj çš„æ•°æ®ç±»å‹
function type(obj) {
	return Object.prototype.toString.call(obj).slice(8, -1);
}
// åˆ¤æ–­ obj æ˜¯å¦ä¸ºå¯¹è±¡å’Œæ•°ç»„
function isObject(obj) {
	return typeof obj == 'object' && obj !== null;
}
```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ | åŠ›æ‰£ |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 2628 | å®Œå…¨ç›¸ç­‰çš„ JSON å­—ç¬¦ä¸² ğŸ”’ | [[âœ“]](/problem/2628.md) |  | ğŸŸ  | [ğŸ€„ï¸](https://leetcode.cn/problems/json-deep-equal) [ğŸ”—](https://leetcode.com/problems/json-deep-equal) |
| 2633 | å°†å¯¹è±¡è½¬æ¢ä¸º JSON å­—ç¬¦ä¸² ğŸ”’ | [[âœ“]](/problem/2633.md) |  | ğŸŸ  | [ğŸ€„ï¸](https://leetcode.cn/problems/convert-object-to-json-string) [ğŸ”—](https://leetcode.com/problems/convert-object-to-json-string) |