---
title: 1266. è®¿é—®æ‰€æœ‰ç‚¹çš„æœ€å°æ—¶é—´
description: LeetCode 1266. è®¿é—®æ‰€æœ‰ç‚¹çš„æœ€å°æ—¶é—´é¢˜è§£ï¼ŒMinimum Time Visiting All Pointsï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 1266. è®¿é—®æ‰€æœ‰ç‚¹çš„æœ€å°æ—¶é—´
  - è®¿é—®æ‰€æœ‰ç‚¹çš„æœ€å°æ—¶é—´
  - Minimum Time Visiting All Points
  - è§£é¢˜æ€è·¯
  - å‡ ä½•
  - æ•°ç»„
  - æ•°å­¦
---

# 1266. è®¿é—®æ‰€æœ‰ç‚¹çš„æœ€å°æ—¶é—´

ğŸŸ¢ <font color=#15bd66>Easy</font>&emsp; ğŸ”–&ensp; [`å‡ ä½•`](/tag/geometry.md) [`æ•°ç»„`](/tag/array.md) [`æ•°å­¦`](/tag/math.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/minimum-time-visiting-all-points) [`LeetCode`](https://leetcode.com/problems/minimum-time-visiting-all-points)

## é¢˜ç›®

On a 2D plane, there are `n` points with integer coordinates `points[i] = [xi,
yi]`. Return _the**minimum time** in seconds to visit all the points in the
order given by _`points`.

You can move according to these rules:

- In `1` second, you can either:
  - move vertically by one unit,
  - move horizontally by one unit, or
  - move diagonally `sqrt(2)` units (in other words, move one unit vertically then one unit horizontally in `1` second).
- You have to visit the points in the same order as they appear in the array.
- You are allowed to pass through points that appear later in the order, but these do not count as visits.

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/11/14/1626_example_1.PNG)

> Input: points = [[1,1],[3,4],[-1,0]]
>
> Output: 7
>
> Explanation: One optimal path is **[1,1]** -> [2,2] -> [3,3] -> **[3,4]** -> [2,3] -> [1,2] -> [0,1] -> **[-1,0]**
>
> Time from [1,1] to [3,4] = 3 seconds
>
> Time from [3,4] to [-1,0] = 4 seconds
>
> Total time = 7 seconds

**Example 2:**

> Input: points = [[3,2],[-2,2]]
>
> Output: 5

**Constraints:**

- `points.length == n`
- `1 <= n <= 100`
- `points[i].length == 2`
- `-1000 <= points[i][0], points[i][1] <= 1000`

## é¢˜ç›®å¤§æ„

å¹³é¢ä¸Šæœ‰ `n` ä¸ªç‚¹ï¼Œç‚¹çš„ä½ç½®ç”¨æ•´æ•°åæ ‡è¡¨ç¤º `points[i] = [xi, yi]` ã€‚è¯·ä½ è®¡ç®—è®¿é—®æ‰€æœ‰è¿™äº›ç‚¹éœ€è¦çš„ **æœ€å°æ—¶é—´**
ï¼ˆä»¥ç§’ä¸ºå•ä½ï¼‰ã€‚

ä½ éœ€è¦æŒ‰ç…§ä¸‹é¢çš„è§„åˆ™åœ¨å¹³é¢ä¸Šç§»åŠ¨ï¼š

- æ¯ä¸€ç§’å†…ï¼Œä½ å¯ä»¥ï¼š

  - æ²¿æ°´å¹³æ–¹å‘ç§»åŠ¨ä¸€ä¸ªå•ä½é•¿åº¦ï¼Œæˆ–è€…
  - æ²¿ç«–ç›´æ–¹å‘ç§»åŠ¨ä¸€ä¸ªå•ä½é•¿åº¦ï¼Œæˆ–è€…
  - è·¨è¿‡å¯¹è§’çº¿ç§»åŠ¨ `sqrt(2)` ä¸ªå•ä½é•¿åº¦ï¼ˆå¯ä»¥çœ‹ä½œåœ¨ä¸€ç§’å†…å‘æ°´å¹³å’Œç«–ç›´æ–¹å‘å„ç§»åŠ¨ä¸€ä¸ªå•ä½é•¿åº¦ï¼‰ã€‚

- å¿…é¡»æŒ‰ç…§æ•°ç»„ä¸­å‡ºç°çš„é¡ºåºæ¥è®¿é—®è¿™äº›ç‚¹ã€‚
- åœ¨è®¿é—®æŸä¸ªç‚¹æ—¶ï¼Œå¯ä»¥ç»è¿‡è¯¥ç‚¹åé¢å‡ºç°çš„ç‚¹ï¼Œä½†ç»è¿‡çš„é‚£äº›ç‚¹ä¸ç®—ä½œæœ‰æ•ˆè®¿é—®ã€‚

**ç¤ºä¾‹ 1ï¼š**

![](https://assets.leetcode-cn.com/aliyun-lc-
upload/uploads/2019/11/24/1626_example_1.png)

> **è¾“å…¥ï¼š** points = [[1,1],[3,4],[-1,0]]
>
> **è¾“å‡ºï¼š** 7
>
> **è§£é‡Šï¼š** ä¸€æ¡æœ€ä½³çš„è®¿é—®è·¯å¾„æ˜¯ï¼š **[1,1]** -> [2,2] -> [3,3] -> **[3,4]** -> [2,3] -> [1,2] -> [0,1] -> **[-1,0]**
>
> ä» [1,1] åˆ° [3,4] éœ€è¦ 3 ç§’
>
> ä» [3,4] åˆ° [-1,0] éœ€è¦ 4 ç§’
>
> ä¸€å…±éœ€è¦ 7 ç§’

**ç¤ºä¾‹ 2ï¼š**

> **è¾“å…¥ï¼š** points = [[3,2],[-2,2]]
>
> **è¾“å‡ºï¼š** 5

**æç¤ºï¼š**

- `points.length == n`
- `1 <= n <= 100`
- `points[i].length == 2`
- `-1000 <= points[i][0], points[i][1] <= 1000`

## è§£é¢˜æ€è·¯

åœ¨äºŒç»´å¹³é¢ä¸Šï¼Œä»ä¸€ä¸ªç‚¹åˆ°å¦ä¸€ä¸ªç‚¹çš„æœ€çŸ­æ—¶é—´æ˜¯ä¸¤ä¸ªåæ ‡å·®å€¼çš„ **æœ€å¤§å€¼**ã€‚

å¦‚æœæ°´å¹³å·®å€¼ `dx` å’Œç«–ç›´å·®å€¼ `dy` çš„è¾ƒå¤§å€¼æ˜¯ `max(dx, dy)`ï¼Œåˆ™å¯¹è§’çº¿å¯ä»¥è¦†ç›–è¾ƒå°çš„å·®å€¼ï¼Œå‰©ä¸‹çš„å·®å€¼éœ€è¦æ°´å¹³æˆ–ç«–ç›´æ–¹å‘è¡¥è¶³ã€‚

1. éå†ç‚¹çš„åˆ—è¡¨ï¼Œä»ç¬¬ä¸€ä¸ªç‚¹å¼€å§‹è®¿é—®ã€‚
2. å¯¹äºæ¯å¯¹ç›¸é‚»ç‚¹ï¼š
   - è®¡ç®—æ°´å¹³è·ç¦» `dx` å’Œç«–ç›´è·ç¦» `dy`ï¼›
   - å¢åŠ  `max(dx, dy)` åˆ°ç»“æœä¸­ã€‚
3. è¿”å›æœ€ç»ˆç»“æœã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œå…¶ä¸­ `n` æ˜¯ç‚¹çš„æ•°é‡ï¼Œéå† `points` åˆ—è¡¨è®¡ç®—ç›¸é‚»ç‚¹ä¹‹é—´çš„è·ç¦»ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(1)`ï¼Œä»…ä½¿ç”¨å¸¸æ•°é¢å¤–ç©ºé—´å­˜å‚¨å˜é‡ã€‚

## ä»£ç 

```javascript
/**
 * @param {number[][]} points
 * @return {number}
 */
var minTimeToVisitAllPoints = function (points) {
	let res = 0;
	for (let i = 1; i < points.length; i++) {
		let dx = Math.abs(points[i - 1][0] - points[i][0]);
		let dy = Math.abs(points[i - 1][1] - points[i][1]);
		res += Math.max(dx, dy);
	}
	return res;
};
```
