---
title: 3203. åˆå¹¶ä¸¤æ£µæ ‘åçš„æœ€å°ç›´å¾„
description: LeetCode 3203. åˆå¹¶ä¸¤æ£µæ ‘åçš„æœ€å°ç›´å¾„é¢˜è§£ï¼ŒFind Minimum Diameter After Merging Two Treesï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 3203. åˆå¹¶ä¸¤æ£µæ ‘åçš„æœ€å°ç›´å¾„
  - åˆå¹¶ä¸¤æ£µæ ‘åçš„æœ€å°ç›´å¾„
  - Find Minimum Diameter After Merging Two Trees
  - è§£é¢˜æ€è·¯
  - æ ‘
  - æ·±åº¦ä¼˜å…ˆæœç´¢
  - å¹¿åº¦ä¼˜å…ˆæœç´¢
  - å›¾
---

# 3203. åˆå¹¶ä¸¤æ£µæ ‘åçš„æœ€å°ç›´å¾„

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`æ ‘`](/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/tag/breadth-first-search.md) [`å›¾`](/tag/graph.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/find-minimum-diameter-after-merging-two-trees) [`LeetCode`](https://leetcode.com/problems/find-minimum-diameter-after-merging-two-trees)

## é¢˜ç›®

There exist two **undirected** trees with `n` and `m` nodes, numbered from `0`
to `n - 1` and from `0` to `m - 1`, respectively. You are given two 2D integer
arrays `edges1` and `edges2` of lengths `n - 1` and `m - 1`, respectively,
where `edges1[i] = [ai, bi]` indicates that there is an edge between nodes
`ai` and `bi` in the first tree and `edges2[i] = [ui, vi]` indicates that
there is an edge between nodes `ui` and `vi` in the second tree.

You must connect one node from the first tree with another node from the
second tree with an edge.

Return the **minimum** possible **diameter** of the resulting tree.

The **diameter** of a tree is the length of the _longest_ path between any two
nodes in the tree.

**Example 1:**

> ![](https://assets.leetcode.com/uploads/2024/04/22/example11-transformed.png)
>
> **Input:** `edges1 = [[0,1],[0,2],[0,3]], edges2 = [[0,1]]`
>
> **Output:** 3
>
> **Explanation:**
>
> We can obtain a tree of diameter 3 by connecting node 0 from the first tree with any node from the second tree.

**Example 2:**

> ![](https://assets.leetcode.com/uploads/2024/04/22/example211.png)
>
> **Input:** `edges1 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]], edges2 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]]`
>
> **Output:** 5
>
> **Explanation:**
>
> We can obtain a tree of diameter 5 by connecting node 0 from the first tree with node 0 from the second tree.

**Constraints:**

- `1 <= n, m <= 10^5`
- `edges1.length == n - 1`
- `edges2.length == m - 1`
- `edges1[i].length == edges2[i].length == 2`
- `edges1[i] = [ai, bi]`
- `0 <= ai, bi < n`
- `edges2[i] = [ui, vi]`
- `0 <= ui, vi < m`
- The input is generated such that `edges1` and `edges2` represent valid trees.

## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸¤æ£µ **æ— å‘** æ ‘ï¼Œåˆ†åˆ«æœ‰ `n` å’Œ `m` ä¸ªèŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹ç¼–å·åˆ†åˆ«ä¸º `0` åˆ° `n - 1` å’Œ `0` åˆ° `m - 1`
ã€‚ç»™ä½ ä¸¤ä¸ªäºŒç»´æ•´æ•°æ•°ç»„ `edges1` å’Œ `edges2` ï¼Œé•¿åº¦åˆ†åˆ«ä¸º `n - 1` å’Œ `m - 1` ï¼Œå…¶ä¸­ `edges1[i] = [ai, bi]` è¡¨ç¤ºåœ¨ç¬¬ä¸€æ£µæ ‘ä¸­èŠ‚ç‚¹ `ai` å’Œ `bi` ä¹‹é—´æœ‰ä¸€æ¡è¾¹ï¼Œ`edges2[i] = [ui, vi]` è¡¨ç¤ºåœ¨ç¬¬äºŒæ£µæ ‘ä¸­èŠ‚ç‚¹ `ui` å’Œ
`vi` ä¹‹é—´æœ‰ä¸€æ¡è¾¹ã€‚

ä½ å¿…é¡»åœ¨ç¬¬ä¸€æ£µæ ‘å’Œç¬¬äºŒæ£µæ ‘ä¸­åˆ†åˆ«é€‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¹¶ç”¨ä¸€æ¡è¾¹è¿æ¥å®ƒä»¬ã€‚

è¯·ä½ è¿”å›æ·»åŠ è¾¹åå¾—åˆ°çš„æ ‘ä¸­ï¼Œ**æœ€å°ç›´å¾„** ä¸ºå¤šå°‘ã€‚

ä¸€æ£µæ ‘çš„ **ç›´å¾„** æŒ‡çš„æ˜¯æ ‘ä¸­ä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´çš„æœ€é•¿è·¯å¾„é•¿åº¦ã€‚

**ç¤ºä¾‹ 1ï¼š**

> ![](https://assets.leetcode.com/uploads/2024/04/22/example11-transformed.png)
>
> **è¾“å…¥ï¼š** `edges1 = [[0,1],[0,2],[0,3]], edges2 = [[0,1]]`
>
> **è¾“å‡ºï¼š** 3
>
> **è§£é‡Šï¼š**
>
> å°†ç¬¬ä¸€æ£µæ ‘ä¸­çš„èŠ‚ç‚¹ 0 ä¸ç¬¬äºŒæ£µæ ‘ä¸­çš„ä»»æ„èŠ‚ç‚¹è¿æ¥ï¼Œå¾—åˆ°ä¸€æ£µç›´å¾„ä¸º 3 çš„æ ‘ã€‚

**ç¤ºä¾‹ 2ï¼š**

> ![](https://assets.leetcode.com/uploads/2024/04/22/example211.png)
>
> **è¾“å…¥ï¼š** `edges1 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]], edges2 = [[0,1],[0,2],[0,3],[2,4],[2,5],[3,6],[2,7]]`
>
> **è¾“å‡ºï¼š** 5
>
> **è§£é‡Šï¼š**
>
> å°†ç¬¬ä¸€æ£µæ ‘ä¸­çš„èŠ‚ç‚¹ 0 å’Œç¬¬äºŒæ£µæ ‘ä¸­çš„èŠ‚ç‚¹ 0 è¿æ¥ï¼Œå¯ä»¥å¾—åˆ°ä¸€æ£µç›´å¾„ä¸º 5 çš„æ ‘ã€‚

**æç¤ºï¼š**

- `1 <= n, m <= 10^5`
- `edges1.length == n - 1`
- `edges2.length == m - 1`
- `edges1[i].length == edges2[i].length == 2`
- `edges1[i] = [ai, bi]`
- `0 <= ai, bi < n`
- `edges2[i] = [ui, vi]`
- `0 <= ui, vi < m`
- è¾“å…¥ä¿è¯ `edges1` å’Œ `edges2` åˆ†åˆ«è¡¨ç¤ºä¸€æ£µåˆæ³•çš„æ ‘ã€‚

## è§£é¢˜æ€è·¯

1. **æ ‘çš„ç›´å¾„è®¡ç®—**

   æ ‘çš„ç›´å¾„æ˜¯æŒ‡æ ‘ä¸­ä¸¤ç‚¹ä¹‹é—´çš„æœ€é•¿è·¯å¾„çš„é•¿åº¦ã€‚è®¡ç®—æ–¹æ³•å¦‚ä¸‹ï¼š

   - ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰éå†æ ‘çš„èŠ‚ç‚¹ã€‚
   - å¯¹æ¯ä¸ªèŠ‚ç‚¹ï¼Œè®°å½•å…¶åˆ°è¾¾çš„ **æœ€å¤§æ·±åº¦** å’Œ **æ¬¡å¤§æ·±åº¦**ã€‚
   - å½“å‰èŠ‚ç‚¹çš„ç›´å¾„å¯ä»¥é€šè¿‡æœ€å¤§æ·±åº¦å’Œæ¬¡å¤§æ·±åº¦çš„å’Œæ¥è®¡ç®—ï¼Œå³ `maxDepth + secondMaxDepth`ã€‚
   - åœ¨æ•´ä¸ª DFS è¿‡ç¨‹ä¸­ï¼ŒåŠ¨æ€ç»´æŠ¤å…¨å±€çš„æœ€å¤§ç›´å¾„ã€‚

   é€šè¿‡ `getDiameter` å‡½æ•°ï¼Œå¯ä»¥åˆ†åˆ«è®¡ç®—ä¸¤æ£µæ ‘çš„ç›´å¾„ `diameter1` å’Œ `diameter2`ã€‚

2. **åŠå¾„å’Œå‰©ä½™éƒ¨åˆ†è®¡ç®—**

   - **åŠå¾„è®¡ç®—ï¼š**  
     æ ‘çš„åŠå¾„æ˜¯ç›´å¾„çš„ä¸€åŠï¼Œå‘ä¸Šå–æ•´ã€‚å…¬å¼ä¸ºï¼š

     ```text
     radius = Math.ceil(diameter / 2)
     ```

     åŠå¾„è¡¨ç¤ºç›´å¾„ä¸­é—´çš„æŸä¸ªèŠ‚ç‚¹åˆ°ç›´å¾„ä¸¤ç«¯çš„æœ€è¿œè·ç¦»ã€‚

   - **å‰©ä½™éƒ¨åˆ†è®¡ç®—ï¼š**  
     å‰©ä½™éƒ¨åˆ†æ˜¯ç›´å¾„å‡å»åŠå¾„ï¼Œå…¬å¼ä¸ºï¼š
     ```text
     rest = diameter - radius
     ```

   å¯¹äºä¸¤æ£µæ ‘ï¼Œåˆ†åˆ«è®¡ç®—å…¶ `radius1`ã€`radius2` å’Œå¯¹åº”çš„å‰©ä½™éƒ¨åˆ† `rest1`ã€`rest2`ã€‚

3. **åˆå¹¶æ ‘çš„ç›´å¾„å¤„ç†é€»è¾‘**

   å½“å°†ä¸¤æ£µæ ‘é€šè¿‡æŸäº›è¾¹è¿æ¥æ—¶ï¼Œè¿æ¥ä¸¤æ£µæ ‘çš„ç›´å¾„ä¸­ç‚¹ï¼ˆå³é€šè¿‡åŠå¾„èŠ‚ç‚¹è¿æ¥ï¼‰æ—¶ï¼Œåˆå¹¶æ ‘çš„ç›´å¾„æ˜¯æœ€å°çš„ï¼š

   - å¦‚æœæ ‘ 1 çš„ç›´å¾„å°äºæ ‘ 2ï¼Œåˆ™å°†æ ‘ 1 çš„ä¸­ç‚¹æ·»åŠ åˆ°æ ‘ 2 çš„ä¸­ç‚¹ä½œä¸ºå…¶å­èŠ‚ç‚¹ï¼Œæ­¤æ—¶éœ€è¦è°ƒæ•´æ ‘ 1 çš„åŠå¾„ï¼š`radius1++`ï¼›
   - åä¹‹ï¼Œè°ƒæ•´æ ‘ 2 çš„åŠå¾„ï¼š`radius2++`ã€‚

   åˆå¹¶åæ ‘çš„ç›´å¾„ç­‰äºå››ä¸ªå­æ ‘ä¸­æœ€å¤§çš„ä¸¤ä¸ªéƒ¨åˆ†ä¹‹å’Œï¼Œå³ï¼š

   ```text
   max(radius1, rest1, radius2, rest2) + æ¬¡å¤§éƒ¨åˆ†
   ```

   å…·ä½“æ­¥éª¤ï¼š

   - å°† `radius1, rest1, radius2, rest2` æŒ‰é™åºæ’åˆ—ã€‚
   - å–å‰ä¸¤éƒ¨åˆ†ä¹‹å’Œä½œä¸ºåˆå¹¶åçš„æœ€å°ç›´å¾„ã€‚

4. **åˆå¹¶åçš„æœ€å°ç›´å¾„è®¡ç®—ç¤ºä¾‹**

   å‡è®¾ï¼š

   - æ ‘ 1 çš„ç›´å¾„ä¸º `6`ï¼Œåˆ™ `radius1 = 3, rest1 = 3`ï¼›
   - æ ‘ 2 çš„ç›´å¾„ä¸º `2`ï¼Œåˆ™ `radius2 = 1, rest2 = 1`ã€‚

   åœ¨åˆå¹¶æ—¶ï¼Œå°†æ ‘ 2 çš„ä¸­ç‚¹æ·»åŠ åˆ°æ ‘ 1 çš„ä¸­ç‚¹ä½œä¸ºå…¶å­èŠ‚ç‚¹ï¼š

   - æ ‘ 2 çš„åŠå¾„è°ƒæ•´ä¸º `2`ï¼š`radius1 = 2`ï¼›
   - æ’åºåä¸º `[3, 3, 2, 1]`ï¼Œå–å‰ä¸¤é¡¹ç›¸åŠ ï¼Œå¾—åˆ°åˆå¹¶åçš„æœ€å°ç›´å¾„ï¼š`3 + 3 = 6`ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦ï¼š** `O(n1 + n2)`ï¼Œå…¶ä¸­ `n1` å’Œ `n2` æ˜¯ä¸¤æ£µæ ‘çš„èŠ‚ç‚¹æ•°ï¼Œä½¿ç”¨ DFS åˆ†åˆ«éå†ä¸¤æ£µæ ‘ä¸€æ¬¡è®¡ç®—ç›´å¾„ã€‚
- **ç©ºé—´å¤æ‚åº¦ï¼š** `O(n1 + n2)`ï¼Œç”¨äºå­˜å‚¨å›¾çš„é‚»æ¥è¡¨ç»“æ„å’Œé€’å½’è°ƒç”¨æ ˆã€‚

## ä»£ç 

```javascript
/**
 * @param {number[][]} edges1
 * @param {number[][]} edges2
 * @return {number}
 */
var minimumDiameterAfterMerge = function (edges1, edges2) {
	const diameter1 = getDiameter(edges1);
	const diameter2 = getDiameter(edges2);

	// è®¡ç®—ä¸¤æ£µæ ‘çš„åŠå¾„
	let radius1 = Math.ceil(diameter1 / 2);
	let radius2 = Math.ceil(diameter2 / 2);

	// è®¡ç®—å‰©ä½™éƒ¨åˆ†
	const rest1 = diameter1 - radius1;
	const rest2 = diameter2 - radius2;

	// è°ƒæ•´è¾ƒå°åŠå¾„çš„æ ‘
	if (diameter1 < diameter2) {
		radius1++;
	} else {
		radius2++;
	}

	// å–æœ€å¤§çš„ä¸¤éƒ¨åˆ†
	const sorted = [radius1, rest1, radius2, rest2].sort((a, b) => b - a);
	return sorted[0] + sorted[1];
};

/**
 * @param {number[][]} edges
 * @return {number}
 */
var getDiameter = function (edges) {
	const n = edges.length;
	const graph = Array.from({ length: n + 1 }, () => []);

	// æ„å»ºå›¾
	for (let [a, b] of edges) {
		graph[a].push(b);
		graph[b].push(a);
	}

	let diameter = 0;

	// æ·±åº¦ä¼˜å…ˆæœç´¢è®¡ç®—ç›´å¾„
	const dfs = (node, parent) => {
		let maxDepth = 0,
			secondMaxDepth = 0;

		for (let neighbor of graph[node]) {
			if (neighbor !== parent) {
				const depth = dfs(neighbor, node) + 1;

				// æ›´æ–°æœ€å¤§å’Œæ¬¡å¤§æ·±åº¦
				if (depth > maxDepth) {
					secondMaxDepth = maxDepth;
					maxDepth = depth;
				} else if (depth > secondMaxDepth) {
					secondMaxDepth = depth;
				}
			}
		}

		diameter = Math.max(diameter, maxDepth + secondMaxDepth);
		return maxDepth;
	};

	dfs(0, -1);
	return diameter;
};
```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ | åŠ›æ‰£ |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 310 | æœ€å°é«˜åº¦æ ‘ |  |  [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/tag/breadth-first-search.md) [`å›¾`](/tag/graph.md) `1+` | ğŸŸ  | [ğŸ€„ï¸](https://leetcode.cn/problems/minimum-height-trees) [ğŸ”—](https://leetcode.com/problems/minimum-height-trees) |
| 1245 | æ ‘çš„ç›´å¾„ ğŸ”’ |  |  [`æ ‘`](/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/tag/breadth-first-search.md) `2+` | ğŸŸ  | [ğŸ€„ï¸](https://leetcode.cn/problems/tree-diameter) [ğŸ”—](https://leetcode.com/problems/tree-diameter) |