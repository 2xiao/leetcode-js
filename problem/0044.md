# [44. é€šé…ç¬¦åŒ¹é…](https://leetcode.com/problems/wildcard-matching)

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`è´ªå¿ƒ`](/tag/greedy.md) [`é€’å½’`](/tag/recursion.md) [`å­—ç¬¦ä¸²`](/tag/string.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/wildcard-matching)

## é¢˜ç›®

Given an input string (`s`) and a pattern (`p`), implement wildcard pattern
matching with support for `'?'` and `'*'` where:

- `'?'` Matches any single character.
- `'*'` Matches any sequence of characters (including the empty sequence).

The matching should cover the **entire** input string (not partial).

**Example 1:**

> Input: s = "aa", p = "a"
>
> Output: false
>
> Explanation: "a" does not match the entire string "aa".

**Example 2:**

> Input: s = "aa", p = "\*"
>
> Output: true
>
> Explanation: '\*' matches any sequence.

**Example 3:**

> Input: s = "cb", p = "?a"
>
> Output: false
>
> Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.

**Constraints:**

- `0 <= s.length, p.length <= 2000`
- `s` contains only lowercase English letters.
- `p` contains only lowercase English letters, `'?'` or `'*'`.

## é¢˜ç›®å¤§æ„

ç»™å®šä¸€ä¸ªè¾“å…¥å­—ç¬¦ä¸² (`s`) å’Œä¸€ä¸ªæ¨¡å¼ (`p`)ï¼Œè¯·å®ç°é€šé…ç¬¦åŒ¹é…ï¼Œæ”¯æŒ `?` å’Œ `*`ã€‚

- `?` å¯ä»¥åŒ¹é…ä»»ä½•å•ä¸ªå­—ç¬¦ã€‚
- `*` å¯ä»¥åŒ¹é…ä»»æ„å­—ç¬¦ä¸²ï¼ˆåŒ…æ‹¬ç©ºå­—ç¬¦ä¸²ï¼‰ã€‚

åŒ¹é…åº”è¯¥è¦†ç›–æ•´ä¸ªè¾“å…¥å­—ç¬¦ä¸²ï¼ˆè€Œä¸æ˜¯éƒ¨åˆ†åŒ¹é…ï¼‰ã€‚

## è§£é¢˜æ€è·¯

è¿™ä¸ªé—®é¢˜å¯ä»¥ä½¿ç”¨åŠ¨æ€è§„åˆ’æ¥è§£å†³ï¼Œå…·ä½“æ€è·¯å¦‚ä¸‹ï¼š

1. å®šä¹‰çŠ¶æ€ï¼š`dp[i][j]` è¡¨ç¤ºå­—ç¬¦ä¸² `s` çš„å‰ `i` ä¸ªå­—ç¬¦æ˜¯å¦èƒ½å¤ŸåŒ¹é…æ¨¡å¼ `p` çš„å‰ `j` ä¸ªå­—ç¬¦ã€‚

2. åˆå§‹åŒ–çŠ¶æ€ï¼š`dp[0][0]` è¡¨ç¤ºç©ºå­—ç¬¦ä¸²åŒ¹é…ç©ºæ¨¡å¼ï¼Œä¸º `True`ï¼›`dp[i][0]` è¡¨ç¤ºç©ºæ¨¡å¼ï¼Œä¸ç®¡å­—ç¬¦ä¸² `s` æœ‰å¤šé•¿ï¼Œéƒ½ä¸º `False`ã€‚

3. çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š

   - å½“ `p[j-1]` æ˜¯æ™®é€šå­—ç¬¦ä¸”å½“å‰å­—ç¬¦åŒ¹é…æ—¶ï¼Œ`dp[i][j] = dp[i-1][j-1]`ï¼Œè¡¨ç¤ºç»“æœä¸ä¹‹å‰çŠ¶æ€ç›¸åŒã€‚

   - å½“ `p[j-1]` æ˜¯ `'*'` æ—¶ï¼Œ`dp[i][j]` å¯ä»¥é€šè¿‡ä»¥ä¸‹ä¸‰ç§æƒ…å†µè·å¾—ï¼š

     - åŒ¹é…é›¶ä¸ªå­—ç¬¦ï¼š`dp[i][j] = dp[i][j-1]`
     - åŒ¹é…ä¸€ä¸ªå­—ç¬¦ï¼š`dp[i][j] = dp[i-1][j-1]`
     - åŒ¹é…å¤šä¸ªå­—ç¬¦ï¼š`dp[i][j] = dp[i-1][j]`

4. æœ€ç»ˆè¿”å› `dp[m][n]`ï¼Œå…¶ä¸­ `m` å’Œ `n` åˆ†åˆ«æ˜¯å­—ç¬¦ä¸² `s` å’Œæ¨¡å¼ `p` çš„é•¿åº¦ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š `O(m * n)`ï¼Œå…¶ä¸­ `m` å’Œ `n` åˆ†åˆ«æ˜¯å­—ç¬¦ä¸² `s` å’Œæ¨¡å¼ `p` çš„é•¿åº¦ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š `O(m * n)`

## ä»£ç 

```javascript
/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function (s, p) {
	const m = s.length;
	const n = p.length;
	const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(false));

	// ç©ºå­—ç¬¦ä¸²å’Œç©ºæ¨¡å¼åŒ¹é…
	dp[0][0] = true;

	// åˆå§‹åŒ– dp[0][j]ï¼Œå¤„ç† p ä¸­å¯èƒ½å‡ºç° '*' çš„æƒ…å†µ
	for (let j = 1; j <= n; j++) {
		if (p[j - 1] == '*') {
			dp[0][j] = dp[0][j - 1];
		}
	}

	for (let i = 1; i <= m; i++) {
		for (let j = 1; j <= n; j++) {
			if (s[i - 1] == p[j - 1] || p[j - 1] == '?') {
				dp[i][j] = dp[i - 1][j - 1];
			} else if (p[j - 1] == '*') {
				dp[i][j] = dp[i][j - 1] || dp[i - 1][j] || dp[i - 1][j - 1];
			}
		}
	}
	return dp[m][n];
};
```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 10 | [æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…](https://leetcode.com/problems/regular-expression-matching) | [[âœ“]](/problem/0010.md) |  [`é€’å½’`](/tag/recursion.md) [`å­—ç¬¦ä¸²`](/tag/string.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md) | <font color=#ff334b>Hard</font> |