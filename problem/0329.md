---
title: 329. çŸ©é˜µä¸­çš„æœ€é•¿é€’å¢è·¯å¾„
description: LeetCode 329. çŸ©é˜µä¸­çš„æœ€é•¿é€’å¢è·¯å¾„é¢˜è§£ï¼ŒLongest Increasing Path in a Matrixï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 329. çŸ©é˜µä¸­çš„æœ€é•¿é€’å¢è·¯å¾„
  - çŸ©é˜µä¸­çš„æœ€é•¿é€’å¢è·¯å¾„
  - Longest Increasing Path in a Matrix
  - è§£é¢˜æ€è·¯
  - æ·±åº¦ä¼˜å…ˆæœç´¢
  - å¹¿åº¦ä¼˜å…ˆæœç´¢
  - å›¾
  - æ‹“æ‰‘æ’åº
  - è®°å¿†åŒ–æœç´¢
  - æ•°ç»„
  - åŠ¨æ€è§„åˆ’
  - çŸ©é˜µ
---

# 329. çŸ©é˜µä¸­çš„æœ€é•¿é€’å¢è·¯å¾„

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/tag/breadth-first-search.md) [`å›¾`](/tag/graph.md) [`æ‹“æ‰‘æ’åº`](/tag/topological-sort.md) [`è®°å¿†åŒ–æœç´¢`](/tag/memoization.md) [`æ•°ç»„`](/tag/array.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md) [`çŸ©é˜µ`](/tag/matrix.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix) [`LeetCode`](https://leetcode.com/problems/longest-increasing-path-in-a-matrix)

## é¢˜ç›®

Given an `m x n` integers `matrix`, return _the length of the longest
increasing path in_ `matrix`.

From each cell, you can either move in four directions: left, right, up, or
down. You **may not** move **diagonally** or move **outside the boundary**
(i.e., wrap-around is not allowed).

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg)

> Input: matrix = [[9,9,4],[6,6,8],[2,1,1]]
>
> Output: 4
>
> Explanation: The longest increasing path is [1, 2, 6, 9].

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg)

> Input: matrix = [[3,4,5],[3,2,6],[2,2,1]]
>
> Output: 4
>
> Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.

**Example 3:**

> Input: matrix = [[1]]
>
> Output: 1

**Constraints:**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 200`
- `0 <= matrix[i][j] <= 2^31 - 1`

## é¢˜ç›®å¤§æ„

ç»™å®šä¸€ä¸ª `m x n` æ•´æ•°çŸ©é˜µ `matrix` ï¼Œæ‰¾å‡ºå…¶ä¸­ **æœ€é•¿é€’å¢è·¯å¾„** çš„é•¿åº¦ã€‚

å¯¹äºæ¯ä¸ªå•å…ƒæ ¼ï¼Œä½ å¯ä»¥å¾€ä¸Šï¼Œä¸‹ï¼Œå·¦ï¼Œå³å››ä¸ªæ–¹å‘ç§»åŠ¨ã€‚ ä½  **ä¸èƒ½** åœ¨ **å¯¹è§’çº¿** æ–¹å‘ä¸Šç§»åŠ¨æˆ–ç§»åŠ¨åˆ° **è¾¹ç•Œå¤–** ï¼ˆå³ä¸å…è®¸ç¯ç»•ï¼‰ã€‚

**ç¤ºä¾‹ 1ï¼š**

![](https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg)

> **è¾“å…¥ï¼š** matrix = [[9,9,4],[6,6,8],[2,1,1]]
>
> **è¾“å‡ºï¼š** 4
>
> **è§£é‡Šï¼š** æœ€é•¿é€’å¢è·¯å¾„ä¸º Â [1, 2, 6, 9]ã€‚

**ç¤ºä¾‹ 2ï¼š**

![](https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg)

> **è¾“å…¥ï¼š** matrix = [[3,4,5],[3,2,6],[2,2,1]]
>
> **è¾“å‡ºï¼š** 4
>
> **è§£é‡Šï¼š** æœ€é•¿é€’å¢è·¯å¾„æ˜¯ Â [3, 4, 5, 6]ã€‚æ³¨æ„ä¸å…è®¸åœ¨å¯¹è§’çº¿æ–¹å‘ä¸Šç§»åŠ¨ã€‚

**ç¤ºä¾‹ 3ï¼š**

> **è¾“å…¥ï¼š** matrix = [[1]]
>
> **è¾“å‡ºï¼š** 1

**æç¤ºï¼š**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 200`
- `0 <= matrix[i][j] <= 2^31 - 1`

## è§£é¢˜æ€è·¯

ä½¿ç”¨ **è®°å¿†åŒ–æœç´¢ + DFSï¼ˆæ·±åº¦ä¼˜å…ˆæœç´¢ï¼‰** è¿›è¡Œæ±‚è§£ï¼š

1. **å®šä¹‰ `dp[i][j]`**ï¼šè¡¨ç¤ºä» `(i, j)` ä½ç½®å‡ºå‘çš„**æœ€é•¿é€’å¢è·¯å¾„**ã€‚
2. **é€’å½’æœç´¢ `dfs(x, y)`**ï¼š
   - å¦‚æœ `dp[x][y]` å·²ç»è®¡ç®—è¿‡ï¼Œåˆ™ç›´æ¥è¿”å› `dp[x][y]`ã€‚
   - å¦åˆ™ï¼Œæšä¸¾å››ä¸ªæ–¹å‘ `(dx, dy)`ï¼Œå¦‚æœæ–°ä½ç½® `(nx, ny)` å¤„çš„å€¼ `matrix[nx][ny] > matrix[x][y]`ï¼Œé€’å½’è®¡ç®— `dfs(nx, ny)` å¹¶æ›´æ–° `dp[x][y]`ã€‚
   - æœ€ç»ˆ `dp[x][y] = max(æ‰€æœ‰å¯èƒ½è·¯å¾„é•¿åº¦) + 1`ã€‚
3. **éå†æ•´ä¸ªçŸ©é˜µ**ï¼Œè®¡ç®—æ¯ä¸ª `dp[i][j]` çš„æœ€å¤§å€¼ï¼Œå³ä¸ºç­”æ¡ˆã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(m * n)`ï¼Œæ¯ä¸ªå•å…ƒæ ¼æœ€å¤šè®¡ç®—ä¸€æ¬¡ï¼Œè®°å¿†åŒ–é¿å…é‡å¤è®¡ç®—ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(m * n)`ï¼Œç”¨äº `dp` æ•°ç»„çš„å­˜å‚¨ã€‚

## ä»£ç 

```javascript
/**
 * @param {number[][]} matrix
 * @return {number}
 */
var longestIncreasingPath = function (matrix) {
	const m = matrix.length;
	const n = matrix[0].length;
	const dp = new Array(m).fill().map(() => new Array(n).fill(0));
	let maxDepth = 1;

	const dfs = (x, y) => {
		if (dp[x][y] > 0) {
			return dp[x][y];
		}
		let depth = 1;
		const dirc = [
			[1, 0],
			[-1, 0],
			[0, 1],
			[0, -1]
		];
		for (let [dx, dy] of dirc) {
			const nx = x + dx;
			const ny = y + dy;
			if (
				nx >= 0 &&
				nx < m &&
				ny >= 0 &&
				ny < n &&
				matrix[nx][ny] > matrix[x][y]
			) {
				depth = Math.max(depth, dfs(nx, ny) + 1);
			}
		}
		dp[x][y] = depth;
		return depth;
	};
	for (let i = 0; i < m; i++) {
		for (let j = 0; j < n; j++) {
			maxDepth = Math.max(maxDepth, dfs(i, j));
		}
	}
	return maxDepth;
};
```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ | åŠ›æ‰£ |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 2328 | ç½‘æ ¼å›¾ä¸­é€’å¢è·¯å¾„çš„æ•°ç›® |  |  [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/tag/breadth-first-search.md) [`å›¾`](/tag/graph.md) `5+` | ğŸ”´ | [ğŸ€„ï¸](https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid) [ğŸ”—](https://leetcode.com/problems/number-of-increasing-paths-in-a-grid) |