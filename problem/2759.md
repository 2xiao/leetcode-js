# [2759. å°† JSON å­—ç¬¦ä¸²è½¬æ¢ä¸ºå¯¹è±¡ ğŸ”’](https://2xiao.github.io/leetcode-js/problem/2759.html)

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/convert-json-string-to-object) [`LeetCode`](https://leetcode.com/problems/convert-json-string-to-object)

## é¢˜ç›®

Given a string `str`, return parsed JSON `parsedStr`. You may assume the `str`
is a valid JSON string hence it only includes strings, numbers, arrays,
objects, booleans, and null. `str` will not include invisible characters and
escape characters.

Please solve it without using the built-in `JSON.parse` method.

**Example 1:**

> Input: str = '{"a":2,"b":[1,2,3]}'
>
> Output: {"a":2,"b":[1,2,3]}
>
> Explanation: Returns the object represented by the JSON string.

**Example 2:**

> Input: str = 'true'
>
> Output: true
>
> Explanation: Primitive types are valid JSON.

**Example 3:**

> Input: str = '[1,5,"false",{"a":2}]'
>
> Output: [1,5,"false",{"a":2}]
>
> Explanation: Returns the array represented by the JSON string.

**Constraints:**

- `str` is a valid JSON string
- `1 <= str.length <= 10^5`

## é¢˜ç›®å¤§æ„

ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² `str` ï¼Œè¿”å› JSON è§£æåçš„ `parsedStr` ã€‚ä½ å¯ä»¥å‡è®¾ `str` æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„ JSON
å­—ç¬¦ä¸²ï¼Œå› æ­¤å®ƒåªåŒ…å«å­—ç¬¦ä¸²ã€æ•°å­—ã€æ•°ç»„ã€å¯¹è±¡ã€å¸ƒå°”å€¼å’Œ nullã€‚`str` ä¸ä¼šåŒ…å«ä¸å¯è§å­—ç¬¦å’Œè½¬ä¹‰å­—ç¬¦ã€‚

è¯·åœ¨ä¸ä½¿ç”¨å†…ç½®çš„ `JSON.parse` æ–¹æ³•çš„æƒ…å†µä¸‹è§£å†³æ­¤é—®é¢˜ã€‚

**ç¤ºä¾‹ 1ï¼š**

> **è¾“å…¥ï¼š** str = '{"a":2,"b":[1,2,3]}'
>
> **è¾“å‡ºï¼š**{"a":2,"b":[1,2,3]}
>
> **è§£é‡Šï¼š** è¿”å›ç”± JSON å­—ç¬¦ä¸²è¡¨ç¤ºçš„å¯¹è±¡ã€‚

**ç¤ºä¾‹ 2ï¼š**

> **è¾“å…¥ï¼š** str = 'true'
>
> **è¾“å‡ºï¼š** true
>
> **è§£é‡Šï¼š** åŸå§‹ç±»å‹æ˜¯æœ‰æ•ˆçš„ JSONã€‚

**ç¤ºä¾‹ 3ï¼š**

> **è¾“å…¥ï¼š** str = '[1,5,"false",{"a":2}]'
>
> **è¾“å‡ºï¼š**[1,5,"false",{"a":2}]
>
> **è§£é‡Šï¼š** è¿”å›ç”± JSON å­—ç¬¦ä¸²è¡¨ç¤ºçš„æ•°ç»„ã€‚

**æç¤ºï¼š**

- `str` æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„ JSON å­—ç¬¦ä¸²
- `1 <= str.length <= 10^5`

## è§£é¢˜æ€è·¯

è¦å®ç°ä¸€ä¸ªè‡ªå®šä¹‰çš„ JSON è§£æå™¨ï¼Œå¯ä»¥åˆ©ç”¨é€’å½’é€æ­¥è§£æ JSON å­—ç¬¦ä¸²çš„å„ä¸ªéƒ¨åˆ†ã€‚è§£æè¿‡ç¨‹éœ€è¦ä»å¤´å¼€å§‹æ‰«æå­—ç¬¦ä¸²ï¼Œè¯†åˆ«å‡ºå­—ç¬¦ä¸²ã€æ•°å­—ã€å¯¹è±¡ã€æ•°ç»„ã€å¸ƒå°”å€¼å’Œ `null` çš„æ ¼å¼ã€‚

1. **è®¾ç½®åˆå§‹çŠ¶æ€**ï¼š

   - å®šä¹‰ä¸€ä¸ªå…¨å±€å˜é‡ `i`ï¼Œç”¨æ¥æŒ‡ç¤ºå½“å‰æ­£åœ¨è§£æçš„å­—ç¬¦ä¸² `str` ä¸­çš„ç´¢å¼•ä½ç½®ã€‚
   - `jsonParse` çš„æ ¸å¿ƒå‡½æ•°æ˜¯ `parseValue`ï¼Œç”¨äºè¯†åˆ«å½“å‰å­—ç¬¦å¹¶é€’å½’è°ƒç”¨å…¶ä»–è§£æå‡½æ•°æ¥å¤„ç†ä¸åŒçš„æ•°æ®ç±»å‹ã€‚

2. **è§£æä¸åŒçš„æ•°æ®ç±»å‹**ï¼š

   - **å¸ƒå°”å€¼ `true`**ï¼šå¦‚æœå½“å‰å­—ç¬¦ä¸º `'t'`ï¼Œè°ƒç”¨ `parseTrue`ï¼Œå°†æŒ‡é’ˆ `i` å‘å‰ç§»åŠ¨ 4 ä¸ªå­—ç¬¦ï¼ˆ`true`çš„é•¿åº¦ï¼‰ï¼Œå¹¶è¿”å› `true`ã€‚
   - **å¸ƒå°”å€¼ `false`**ï¼šå¦‚æœå½“å‰å­—ç¬¦ä¸º `'f'`ï¼Œè°ƒç”¨ `parseFalse`ï¼Œå°†æŒ‡é’ˆ `i` å‘å‰ç§»åŠ¨ 5 ä¸ªå­—ç¬¦ï¼ˆ`false`çš„é•¿åº¦ï¼‰ï¼Œå¹¶è¿”å› `false`ã€‚
   - **ç©ºå€¼ `null`**ï¼šå¦‚æœå½“å‰å­—ç¬¦ä¸º `'n'`ï¼Œè°ƒç”¨ `parseNull`ï¼Œå°†æŒ‡é’ˆ `i` å‘å‰ç§»åŠ¨ 4 ä¸ªå­—ç¬¦ï¼ˆ`null`çš„é•¿åº¦ï¼‰ï¼Œå¹¶è¿”å› `null`ã€‚

3. **å­—ç¬¦ä¸²è§£æ**ï¼š

   - å¦‚æœå½“å‰å­—ç¬¦ä¸ºåŒå¼•å· `"`ï¼Œè°ƒç”¨ `parseString` å‡½æ•°ã€‚
   - `parseString` å‡½æ•°åœ¨èµ·å§‹ä½ç½®è·³è¿‡ `"`ï¼Œç„¶åå¾ªç¯è¯»å–å­—ç¬¦ï¼Œç›´åˆ°å†æ¬¡é‡åˆ° `"`ï¼Œæ„é€ å­—ç¬¦ä¸²å¹¶è¿”å›ã€‚
   - æœ€åï¼ŒæŒ‡é’ˆ `i` å†æ¬¡å‘å‰ç§»åŠ¨ä¸€ä½ï¼Œè·³è¿‡ç»“å°¾çš„ `"`ã€‚

4. **æ•°å­—è§£æ**ï¼š

   - å¦‚æœå½“å‰å­—ç¬¦æ˜¯ `-` æˆ–æ•°å­—å­—ç¬¦ï¼Œè°ƒç”¨ `parseNumber` å‡½æ•°ã€‚
   - `parseNumber` ä»å½“å‰æŒ‡é’ˆä½ç½®å¼€å§‹æ£€æŸ¥å­—ç¬¦ï¼Œç›´åˆ°æ‰¾åˆ°æ•°å­—çš„ç»“æŸä½ç½®ï¼Œæ”¯æŒæ•´æ•°å’Œå°æ•°æ ¼å¼ã€‚
   - æœ€åï¼Œå°†æ•°å­—éƒ¨åˆ†è½¬åŒ–ä¸º `Number` ç±»å‹å¹¶è¿”å›ã€‚

5. **å¯¹è±¡è§£æ**ï¼š

   - å¦‚æœå½“å‰å­—ç¬¦æ˜¯ `{`ï¼Œè°ƒç”¨ `parseObject`ã€‚
   - `parseObject` ä¼šæ„å»ºä¸€ä¸ªç©ºå¯¹è±¡ï¼Œç„¶ååœ¨å¾ªç¯ä¸­ä¾æ¬¡è§£æé”®å€¼å¯¹ï¼š
     - è°ƒç”¨ `parseString` è§£æé”®åã€‚
     - è·³è¿‡å†’å· `:` åï¼Œè°ƒç”¨ `parseValue` è§£æå¯¹åº”çš„å€¼ã€‚
     - é‡åˆ° `,` æ—¶ç»§ç»­è§£æä¸‹ä¸€å¯¹é”®å€¼å¯¹ï¼Œé‡åˆ° `}` è¡¨ç¤ºå¯¹è±¡è§£æç»“æŸã€‚
   - ç©ºå¯¹è±¡ `{}` ç‰¹æ®Šæƒ…å†µï¼šå¦‚æœä¸‹ä¸€ä¸ªå­—ç¬¦ç›´æ¥æ˜¯ `}`ï¼Œåˆ™ç›´æ¥è¿”å›ç©ºå¯¹è±¡ã€‚

6. **æ•°ç»„è§£æ**ï¼š

   - å¦‚æœå½“å‰å­—ç¬¦æ˜¯ `[`ï¼Œè°ƒç”¨ `parseArray`ã€‚
   - `parseArray` ä¼šæ„å»ºä¸€ä¸ªç©ºæ•°ç»„ï¼Œç„¶ååœ¨å¾ªç¯ä¸­ä¾æ¬¡è§£ææ¯ä¸ªå…ƒç´ ï¼š
     - è°ƒç”¨ `parseValue` è§£æå½“å‰å…ƒç´ ï¼Œå¹¶å°†ç»“æœåŠ å…¥æ•°ç»„ã€‚
     - é‡åˆ° `,` æ—¶ç»§ç»­è§£æä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œé‡åˆ° `]` è¡¨ç¤ºæ•°ç»„è§£æç»“æŸã€‚
   - ç©ºæ•°ç»„ `[]` ç‰¹æ®Šæƒ…å†µï¼šå¦‚æœä¸‹ä¸€ä¸ªå­—ç¬¦ç›´æ¥æ˜¯ `]`ï¼Œåˆ™ç›´æ¥è¿”å›ç©ºæ•°ç»„ã€‚

7. **æ§åˆ¶æµ**ï¼š
   - `parseValue` å‡½æ•°æ ¹æ®å½“å‰å­—ç¬¦ç¡®å®šç±»å‹ï¼Œè°ƒç”¨ä¸åŒçš„è§£æå‡½æ•°è¿›è¡Œé€’å½’è§£æã€‚
   - é€šè¿‡é€’å½’ï¼Œæ¯ä¸ªæ•°æ®ç±»å‹å‡½æ•°ä¼šå¤„ç†å®ƒä»¬çš„åµŒå¥—æƒ…å†µï¼Œä¾‹å¦‚å¯¹è±¡å†…çš„æ•°ç»„ã€æ•°ç»„å†…çš„å¯¹è±¡ç­‰ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œå…¶ä¸­ `n` æ˜¯ JSON å­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œæ¯ä¸ªå­—ç¬¦åœ¨æ•´ä¸ªè§£æè¿‡ç¨‹ä¸­åªè®¿é—®ä¸€æ¬¡ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(d)`ï¼Œå…¶ä¸­ `d` æ˜¯å¯¹è±¡æˆ–æ•°ç»„çš„åµŒå¥—æ·±åº¦ï¼Œé€’å½’è°ƒç”¨æ ˆçš„æœ€å¤§æ·±åº¦å†³å®šäº†æ‰€éœ€çš„è¾…åŠ©ç©ºé—´ã€‚

## ä»£ç 

```javascript
/**
 * @param {string} str
 * @return {null|boolean|number|string|Array|Object}
 */
var jsonParse = function (str) {
	let i = 0;
	// è§£æå¸ƒå°”å€¼ true
	const parseTrue = () => {
		i += 4;
		return true;
	};
	// è§£æå¸ƒå°”å€¼ false
	const parseFalse = () => {
		i += 5;
		return false;
	};
	// è§£æç©ºå€¼ null
	const parseNull = () => {
		i += 4;
		return null;
	};
	// è§£æå­—ç¬¦ä¸²
	const parseString = () => {
		i++; // è·³è¿‡å¼€å§‹çš„åŒå¼•å·
		let result = '';
		while (str[i] !== '"') {
			result += str[i++];
		}
		i++; // è·³è¿‡ç»“æŸçš„åŒå¼•å·
		return result;
	};
	// è§£ææ•°å­—
	const parseNumber = () => {
		let start = i;
		if (str[i] === '-') i++;
		while (isDigit(str[i])) i++;
		if (str[i] === '.') {
			i++;
			while (isDigit(str[i])) i++;
		}
		return Number(str.slice(start, i));
	};
	// è§£æå¯¹è±¡
	const parseObject = () => {
		i++; // è·³è¿‡å¼€å§‹çš„ '{'
		let obj = {};
		// ç©ºå¯¹è±¡çš„æƒ…å†µ
		if (str[i] === '}') {
			i++;
			return obj;
		}
		while (true) {
			let key = parseString();
			i++; // è·³è¿‡å†’å· ':'
			obj[key] = parseValue();
			if (str[i] === '}') {
				i++;
				break;
			}
			i++; // è·³è¿‡é€—å· ','
		}
		return obj;
	};
	// è§£ææ•°ç»„
	const parseArray = () => {
		i++; // è·³è¿‡å·¦æ–¹æ‹¬å· '['
		let arr = [];
		// ç©ºæ•°ç»„çš„æƒ…å†µ
		if (str[i] === ']') {
			i++;
			return arr;
		}
		while (true) {
			arr.push(parseValue());
			if (str[i] === ']') {
				i++;
				break;
			}
			i++; // è·³è¿‡é€—å· ','
		}
		return arr;
	};

	const isDigit = (char) => {
		return char >= '0' && char <= '9';
	};

	const parseValue = () => {
		const c = str[i];
		if (c === '"') return parseString();
		if (c === '{') return parseObject();
		if (c === '[') return parseArray();
		if (c === 't') return parseTrue();
		if (c === 'f') return parseFalse();
		if (c === 'n') return parseNull();
		if (c === '-' || isDigit(c)) return parseNumber();
		throw new Error('Invalid JSON');
	};

	return parseValue();
};
let str = '{"a":2,"b":[1,2,3]}';
console.log(jsonParse(str));
```
