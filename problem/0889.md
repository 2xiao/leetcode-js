---
title: 889. æ ¹æ®å‰åºå’Œååºéå†æ„é€ äºŒå‰æ ‘
description: LeetCode 889. æ ¹æ®å‰åºå’Œååºéå†æ„é€ äºŒå‰æ ‘é¢˜è§£ï¼ŒConstruct Binary Tree from Preorder and Postorder Traversalï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 889. æ ¹æ®å‰åºå’Œååºéå†æ„é€ äºŒå‰æ ‘
  - æ ¹æ®å‰åºå’Œååºéå†æ„é€ äºŒå‰æ ‘
  - Construct Binary Tree from Preorder and Postorder Traversal
  - è§£é¢˜æ€è·¯
  - æ ‘
  - æ•°ç»„
  - å“ˆå¸Œè¡¨
  - åˆ†æ²»
  - äºŒå‰æ ‘
---

# 889. æ ¹æ®å‰åºå’Œååºéå†æ„é€ äºŒå‰æ ‘

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ ‘`](/tag/tree.md) [`æ•°ç»„`](/tag/array.md) [`å“ˆå¸Œè¡¨`](/tag/hash-table.md) [`åˆ†æ²»`](/tag/divide-and-conquer.md) [`äºŒå‰æ ‘`](/tag/binary-tree.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal) [`LeetCode`](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal)

## é¢˜ç›®

Given two integer arrays, `preorder` and `postorder` where `preorder` is the
preorder traversal of a binary tree of **distinct** values and `postorder` is
the postorder traversal of the same tree, reconstruct and return _the binary
tree_.

If there exist multiple answers, you can **return any** of them.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/07/24/lc-prepost.jpg)

> Input: preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]
>
> Output: [1,2,3,4,5,6,7]

**Example 2:**

> Input: preorder = [1], postorder = [1]
>
> Output: [1]

**Constraints:**

- `1 <= preorder.length <= 30`
- `1 <= preorder[i] <= preorder.length`
- All the values of `preorder` are **unique**.
- `postorder.length == preorder.length`
- `1 <= postorder[i] <= postorder.length`
- All the values of `postorder` are **unique**.
- It is guaranteed that `preorder` and `postorder` are the preorder traversal and postorder traversal of the same binary tree.

## é¢˜ç›®å¤§æ„

1. **å‰åºéå†** (`preorder`)ï¼š`[æ ¹, å·¦å­æ ‘, å³å­æ ‘]`
2. **ååºéå†** (`postorder`)ï¼š`[å·¦å­æ ‘, å³å­æ ‘, æ ¹]`
3. ç”±äºæ²¡æœ‰ **ä¸­åºéå†**ï¼Œæ— æ³•ç›´æ¥åŒºåˆ†å·¦ã€å³å­æ ‘çš„è¾¹ç•Œï¼Œä½†å¯ä»¥åˆ©ç”¨ `preorder[1]`ï¼ˆå‰åºçš„ç¬¬äºŒä¸ªå…ƒç´ ï¼‰æ¥ç¡®å®šå·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹åœ¨ `postorder` ä¸­çš„ä½ç½®ã€‚

- è®¾ `preorder[0]` æ˜¯æ ¹èŠ‚ç‚¹ `root`ï¼Œåˆ›å»º `TreeNode(root)`.
- `preorder[1]` æ˜¯å·¦å­æ ‘çš„æ ¹ï¼ŒæŸ¥æ‰¾ `postorder` ä¸­ `preorder[1]` çš„ä½ç½® `idx`ã€‚
- `postorder[0] ~ postorder[idx]` æ˜¯å·¦å­æ ‘ï¼Œ`postorder[idx+1] ~ postorder[n-2]` æ˜¯å³å­æ ‘ã€‚
- é€’å½’æ„é€ å·¦å³å­æ ‘ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œæ¯ä¸ªèŠ‚ç‚¹åªè®¿é—®ä¸€æ¬¡ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œé€’å½’æ ˆæ·±åº¦æœ€å¤š `O(n)`ã€‚

## ä»£ç 

```javascript
/**
 * @param {number[]} preorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */
var constructFromPrePost = function (preorder, postorder) {
	if (!preorder.length || !postorder.length) return null;
	let preIndex = 0;
	let postIndex = 0;

	const buildTree = () => {
		let root = new TreeNode(preorder[preIndex++]);
		if (root.val !== postorder[postIndex]) {
			root.left = buildTree();
		}

		if (root.val !== postorder[postIndex]) {
			root.right = buildTree();
		}

		postIndex++;
		return root;
	};

	return buildTree();
};
```
