---
title: 318. æœ€å¤§å•è¯é•¿åº¦ä¹˜ç§¯
description: LeetCode 318. æœ€å¤§å•è¯é•¿åº¦ä¹˜ç§¯é¢˜è§£ï¼ŒMaximum Product of Word Lengthsï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 318. æœ€å¤§å•è¯é•¿åº¦ä¹˜ç§¯
  - æœ€å¤§å•è¯é•¿åº¦ä¹˜ç§¯
  - Maximum Product of Word Lengths
  - è§£é¢˜æ€è·¯
  - ä½è¿ç®—
  - æ•°ç»„
  - å­—ç¬¦ä¸²
---

# 318. æœ€å¤§å•è¯é•¿åº¦ä¹˜ç§¯

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`ä½è¿ç®—`](/tag/bit-manipulation.md) [`æ•°ç»„`](/tag/array.md) [`å­—ç¬¦ä¸²`](/tag/string.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/maximum-product-of-word-lengths) [`LeetCode`](https://leetcode.com/problems/maximum-product-of-word-lengths)

## é¢˜ç›®

Given a string array `words`, return _the maximum value of_ `length(word[i]) *
length(word[j])` _where the two words do not share common letters_. If no such
two words exist, return `0`.

**Example 1:**

> Input: words = ["abcw","baz","foo","bar","xtfn","abcdef"]
>
> Output: 16
>
> Explanation: The two words can be "abcw", "xtfn".

**Example 2:**

> Input: words = ["a","ab","abc","d","cd","bcd","abcd"]
>
> Output: 4
>
> Explanation: The two words can be "ab", "cd".

**Example 3:**

> Input: words = ["a","aa","aaa","aaaa"]
>
> Output: 0
>
> Explanation: No such pair of words.

**Constraints:**

- `2 <= words.length <= 1000`
- `1 <= words[i].length <= 1000`
- `words[i]` consists only of lowercase English letters.

## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ `words` ï¼Œæ‰¾å‡ºå¹¶è¿”å› `length(words[i]) * length(words[j])`
çš„æœ€å¤§å€¼ï¼Œå¹¶ä¸”è¿™ä¸¤ä¸ªå•è¯ä¸å«æœ‰å…¬å…±å­—æ¯ã€‚å¦‚æœä¸å­˜åœ¨è¿™æ ·çš„ä¸¤ä¸ªå•è¯ï¼Œè¿”å› `0` ã€‚

**ç¤ºä¾‹ 1ï¼š**

> **è¾“å…¥ï¼š** words = ["abcw","baz","foo","bar","xtfn","abcdef"]
>
> **è¾“å‡ºï¼š**16
>
> **è§£é‡Š**ï¼š**è¿™ä¸¤ä¸ªå•è¯ä¸º** "abcw", "xtfn"ã€‚

**ç¤ºä¾‹ 2ï¼š**

> **è¾“å…¥ï¼š** words = ["a","ab","abc","d","cd","bcd","abcd"]
>
> **è¾“å‡ºï¼š**4
>
> **è§£é‡Š**ï¼š è¿™ä¸¤ä¸ªå•è¯ä¸º "ab", "cd"ã€‚

**ç¤ºä¾‹ 3ï¼š**

> **è¾“å…¥ï¼š** words = ["a","aa","aaa","aaaa"]
>
> **è¾“å‡ºï¼š**0
>
> **è§£é‡Š**ï¼šä¸å­˜åœ¨è¿™æ ·çš„ä¸¤ä¸ªå•è¯ã€‚

**æç¤ºï¼š**

- `2 <= words.length <= 1000`
- `1 <= words[i].length <= 1000`
- `words[i]` ä»…åŒ…å«å°å†™å­—æ¯

## è§£é¢˜æ€è·¯

1. **æ„é€ ä½æ©ç **ï¼š

   - å¯¹æ¯ä¸ªå•è¯ï¼Œéå†å…¶å­—ç¬¦ï¼Œæ ¹æ®å­—ç¬¦çš„ ASCII å€¼è®¡ç®—ç›¸åº”ä½çš„ä½ç½®ï¼Œå°†è¯¥ä½ç½®çš„äºŒè¿›åˆ¶ä½è®¾ä¸º 1ã€‚

2. **æ¯”è¾ƒä¸¤ä¸¤å•è¯**ï¼š

   - ç”¨ä¸¤å±‚å¾ªç¯æ¯”è¾ƒæ‰€æœ‰å•è¯å¯¹ã€‚
   - å¦‚æœä¸¤ä¸ªå•è¯çš„ä½æ©ç æŒ‰ä½ä¸çš„ç»“æœä¸º 0ï¼Œåˆ™è®¡ç®—å®ƒä»¬é•¿åº¦çš„ä¹˜ç§¯ï¼Œå¹¶æ›´æ–°æœ€å¤§å€¼ã€‚

3. **è¿”å›ç»“æœ**ï¼š
   - æœ€åè¿”å›æœ€å¤§ä¹˜ç§¯ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(n * L + n^2)`

  - æ„é€ ä½æ©ç ï¼šå¯¹æ¯ä¸ªå•è¯éå†å…¶å­—ç¬¦ï¼Œå¤æ‚åº¦ä¸º `O(n * L)`ï¼Œå…¶ä¸­ `n` æ˜¯å•è¯æ•°ï¼Œ`L` æ˜¯å•è¯çš„å¹³å‡é•¿åº¦ã€‚
  - æ¯”è¾ƒä¸¤ä¸¤å•è¯ï¼šä¸¤å±‚å¾ªç¯ï¼Œå¤æ‚åº¦ä¸º `O(n^2)`ã€‚
  - æ•´ä½“å¤æ‚åº¦ä¸º `O(n * L + n^2)`ã€‚

- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œå­˜å‚¨æ¯ä¸ªå•è¯çš„ä½æ©ç ã€‚

## ä»£ç 

```javascript
/**
 * @param {string[]} words
 * @return {number}
 */
var maxProduct = function (words) {
	// æ„é€ æ¯ä¸ªå•è¯çš„ä½æ©ç 
	const values = words.map((word) => {
		let mask = 0;
		for (let char of word) {
			mask |= 1 << (char.charCodeAt() - 97); // å°†å¯¹åº”å­—æ¯ä½ç½®çš„äºŒè¿›åˆ¶ä½è®¾ä¸º 1
		}
		return mask;
	});

	let maxProduct = 0;

	// æ¯”è¾ƒä¸¤ä¸¤å•è¯
	for (let i = 0; i < words.length; i++) {
		for (let j = i + 1; j < words.length; j++) {
			// å¦‚æœæ²¡æœ‰å…¬å…±å­—æ¯ï¼Œè®¡ç®—é•¿åº¦ä¹˜ç§¯
			if ((values[i] & values[j]) === 0) {
				maxProduct = Math.max(maxProduct, words[i].length * words[j].length);
			}
		}
	}

	return maxProduct;
};
```
