# [662. äºŒå‰æ ‘æœ€å¤§å®½åº¦](https://2xiao.github.io/leetcode-js/problem/0662.html)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ ‘`](/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/tag/breadth-first-search.md) [`äºŒå‰æ ‘`](/tag/binary-tree.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/maximum-width-of-binary-tree) [`LeetCode`](https://leetcode.com/problems/maximum-width-of-binary-tree)

## é¢˜ç›®

Given the `root` of a binary tree, return _the**maximum width** of the given
tree_.

The **maximum width** of a tree is the maximum **width** among all levels.

The **width** of one level is defined as the length between the end-nodes (the
leftmost and rightmost non-null nodes), where the null nodes between the end-
nodes that would be present in a complete binary tree extending down to that
level are also counted into the length calculation.

It is **guaranteed** that the answer will in the range of a **32-bit** signed
integer.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/05/03/width1-tree.jpg)

> Input: root = [1,3,2,5,3,null,9]
>
> Output: 4
>
> Explanation: The maximum width exists in the third level with length 4 (5,3,null,9).

**Example 2:**

![](https://assets.leetcode.com/uploads/2022/03/14/maximum-width-of-binary-
tree-v3.jpg)

> Input: root = [1,3,2,5,null,null,9,6,null,7]
>
> Output: 7
>
> Explanation: The maximum width exists in the fourth level with length 7 (6,null,null,null,null,null,7).

**Example 3:**

![](https://assets.leetcode.com/uploads/2021/05/03/width3-tree.jpg)

> Input: root = [1,3,2,5]
>
> Output: 2
>
> Explanation: The maximum width exists in the second level with length 2 (3,2).

**Constraints:**

- The number of nodes in the tree is in the range `[1, 3000]`.
- `-100 <= Node.val <= 100`

## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å›æ ‘çš„ **æœ€å¤§å®½åº¦** ã€‚

æ ‘çš„ **æœ€å¤§å®½åº¦** æ˜¯æ‰€æœ‰å±‚ä¸­æœ€å¤§çš„ **å®½åº¦** ã€‚

æ¯ä¸€å±‚çš„ **å®½åº¦** è¢«å®šä¹‰ä¸ºè¯¥å±‚æœ€å·¦å’Œæœ€å³çš„éç©ºèŠ‚ç‚¹ï¼ˆå³ï¼Œä¸¤ä¸ªç«¯ç‚¹ï¼‰ä¹‹é—´çš„é•¿åº¦ã€‚å°†è¿™ä¸ªäºŒå‰æ ‘è§†ä½œä¸æ»¡äºŒå‰æ ‘ç»“æ„ç›¸åŒï¼Œä¸¤ç«¯ç‚¹é—´ä¼šå‡ºç°ä¸€äº›å»¶ä¼¸åˆ°è¿™ä¸€å±‚çš„
`null` èŠ‚ç‚¹ï¼Œè¿™äº› `null` èŠ‚ç‚¹ä¹Ÿè®¡å…¥é•¿åº¦ã€‚

é¢˜ç›®æ•°æ®ä¿è¯ç­”æ¡ˆå°†ä¼šåœ¨ **32 ä½** å¸¦ç¬¦å·æ•´æ•°èŒƒå›´å†…ã€‚

**ç¤ºä¾‹ 1ï¼š**

![](https://assets.leetcode.com/uploads/2021/05/03/width1-tree.jpg)

> **è¾“å…¥ï¼š** root = [1,3,2,5,3,null,9]
>
> **è¾“å‡ºï¼š** 4
>
> **è§£é‡Šï¼š** æœ€å¤§å®½åº¦å‡ºç°åœ¨æ ‘çš„ç¬¬ 3 å±‚ï¼Œå®½åº¦ä¸º 4 (5,3,null,9) ã€‚

**ç¤ºä¾‹ 2ï¼š**

![](https://assets.leetcode.com/uploads/2022/03/14/maximum-width-of-binary-
tree-v3.jpg)

> **è¾“å…¥ï¼š** root = [1,3,2,5,null,null,9,6,null,7]
>
> **è¾“å‡ºï¼š** 7
>
> **è§£é‡Šï¼š** æœ€å¤§å®½åº¦å‡ºç°åœ¨æ ‘çš„ç¬¬ 4 å±‚ï¼Œå®½åº¦ä¸º 7 (6,null,null,null,null,null,7) ã€‚

**ç¤ºä¾‹ 3ï¼š**

![](https://assets.leetcode.com/uploads/2021/05/03/width3-tree.jpg)

> **è¾“å…¥ï¼š** root = [1,3,2,5]
>
> **è¾“å‡ºï¼š** 2
>
> **è§£é‡Šï¼š** æœ€å¤§å®½åº¦å‡ºç°åœ¨æ ‘çš„ç¬¬ 2 å±‚ï¼Œå®½åº¦ä¸º 2 (3,2) ã€‚

**æç¤ºï¼š**

- æ ‘ä¸­èŠ‚ç‚¹çš„æ•°ç›®èŒƒå›´æ˜¯ `[1, 3000]`
- `-100 <= Node.val <= 100`

## è§£é¢˜æ€è·¯

è¿™é“é¢˜å¯ä»¥é€šè¿‡å®½åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰æ¥è§£å†³ï¼Œå€ŸåŠ©é˜Ÿåˆ—ï¼Œå¯ä»¥åœ¨éå†è¿‡ç¨‹ä¸­è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„**ä½ç½®ç´¢å¼•**ï¼Œå¹¶é€šè¿‡è®¡ç®—è¯¥å±‚æœ€å·¦å’Œæœ€å³èŠ‚ç‚¹çš„ç´¢å¼•å·®å¼‚æ¥ç¡®å®šæœ€å¤§å®½åº¦ã€‚

ä¸ºäº†æ–¹ä¾¿è®¡ç®—èŠ‚ç‚¹ä¹‹é—´çš„è·ç¦»ï¼Œç»™æ¯ä¸ªèŠ‚ç‚¹åˆ†é…ä¸€ä¸ª**è™šæ‹Ÿç´¢å¼•**ã€‚å‡è®¾æ ¹èŠ‚ç‚¹çš„ç´¢å¼•ä¸º `0`ï¼Œå¯¹äºæŸä¸ªèŠ‚ç‚¹`i`ï¼Œå…¶å·¦å­©å­çš„ç´¢å¼•ä¸º`2*i + 1`ï¼Œå³å­©å­çš„ç´¢å¼•ä¸º`2*i + 2`ã€‚è¿™æ ·å°±å¯ä»¥åœ¨éå†çš„è¿‡ç¨‹ä¸­è®°å½•æ¯ä¸€å±‚çš„æœ€å·¦å’Œæœ€å³ç´¢å¼•ï¼Œæ¥è®¡ç®—è¯¥å±‚çš„å®½åº¦ï¼š`å®½åº¦ = æœ€å³ç´¢å¼• - æœ€å·¦ç´¢å¼• + 1`ã€‚

1. **åˆå§‹åŒ–**ï¼šä½¿ç”¨é˜Ÿåˆ—æ¥è¿›è¡Œå±‚åºéå†ï¼Œé˜Ÿåˆ—ä¸­çš„æ¯ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªäºŒå…ƒç»„ï¼ŒåŒ…å«èŠ‚ç‚¹å’ŒèŠ‚ç‚¹å¯¹åº”çš„ç´¢å¼•ä½ç½®ã€‚
2. **éå†æ ‘çš„æ¯ä¸€å±‚**ï¼šå¯¹äºæ¯ä¸€å±‚ï¼Œè®°å½•è¿™ä¸€å±‚çš„æœ€å·¦å’Œæœ€å³èŠ‚ç‚¹çš„ç´¢å¼•ã€‚
3. **æ›´æ–°æœ€å¤§å®½åº¦**ï¼šé€šè¿‡è®¡ç®—æ¯å±‚çš„å®½åº¦æ¥æ›´æ–°æœ€å¤§å®½åº¦ã€‚
4. **è¿”å›æœ€å¤§å®½åº¦**ï¼šéå†å®Œæˆåï¼Œè¿”å›è®°å½•çš„æœ€å¤§å®½åº¦ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œå…¶ä¸­ `n` æ˜¯äºŒå‰æ ‘ä¸­çš„èŠ‚ç‚¹æ•°é‡ã€‚æˆ‘ä»¬éœ€è¦éå†æ¯ä¸€ä¸ªèŠ‚ç‚¹ä¸€æ¬¡ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œåœ¨æœ€åæƒ…å†µä¸‹ï¼Œé˜Ÿåˆ—ä¸­ä¼šåŒ…å«æœ€å¤šä¸€æ•´å±‚çš„èŠ‚ç‚¹æ•°é‡ã€‚

## ä»£ç 

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var widthOfBinaryTree = function (root) {
	if (!root) return 0;
	let queue = [[root, 0]],
		res = 0,
		first,
		last;
	// BFS
	while (queue.length) {
		const len = queue.length;
		// è¿™ä¸€å±‚çš„æœ€å·¦èŠ‚ç‚¹çš„ç´¢å¼•
		const startIndex = queue[0][1];
		for (let i = 0; i < len; i++) {
			const [node, index] = queue.shift();

			// å‡å»è¿™ä¸€å±‚çš„æœ€å·¦èŠ‚ç‚¹çš„ç´¢å¼•ï¼Œé˜²æ­¢æº¢å‡º
			const curIndex = index - startIndex;

			// è®°å½•è¿™ä¸€å±‚çš„æœ€å·¦å’Œæœ€å³èŠ‚ç‚¹çš„ç´¢å¼•
			if (i == 0) first = curIndex;
			if (i == len - 1) last = curIndex;

			if (node.left) queue.push([node.left, curIndex * 2 + 1]);
			if (node.right) queue.push([node.right, curIndex * 2 + 2]);
		}
		res = Math.max(res, last - first + 1);
	}
	return res;
};
```
