---
title: 373. æŸ¥æ‰¾å’Œæœ€å°çš„ K å¯¹æ•°å­—
description: LeetCode,373. æŸ¥æ‰¾å’Œæœ€å°çš„ K å¯¹æ•°å­—,æŸ¥æ‰¾å’Œæœ€å°çš„ K å¯¹æ•°å­—,Find K Pairs with Smallest Sums,è§£é¢˜æ€è·¯,æ•°ç»„,å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰
keywords:
  - LeetCode
  - 373. æŸ¥æ‰¾å’Œæœ€å°çš„ K å¯¹æ•°å­—
  - æŸ¥æ‰¾å’Œæœ€å°çš„ K å¯¹æ•°å­—
  - Find K Pairs with Smallest Sums
  - è§£é¢˜æ€è·¯
  - æ•°ç»„
  - å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰
---

# 373. æŸ¥æ‰¾å’Œæœ€å°çš„ K å¯¹æ•°å­—

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ•°ç»„`](/tag/array.md) [`å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰`](/tag/heap-priority-queue.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums) [`LeetCode`](https://leetcode.com/problems/find-k-pairs-with-smallest-sums)

## é¢˜ç›®

You are given two integer arrays `nums1` and `nums2` sorted in **non-
decreasing order** and an integer `k`.

Define a pair `(u, v)` which consists of one element from the first array and
one element from the second array.

Return _the_ `k` _pairs_ `(u1, v1), (u2, v2), ..., (uk, vk)` _with the
smallest sums_.

**Example 1:**

> Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
>
> Output: [[1,2],[1,4],[1,6]]
>
> Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]

**Example 2:**

> Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
>
> Output: [[1,1],[1,1]]
>
> Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]

**Example 3:**

> Input: nums1 = [1,2], nums2 = [3], k = 3
>
> Output: [[1,3],[2,3]]
>
> Explanation: All possible pairs are returned from the sequence: [1,3],[2,3]

**Constraints:**

- `1 <= nums1.length, nums2.length <= 10^5`
- `-10^9 <= nums1[i], nums2[i] <= 10^9`
- `nums1` and `nums2` both are sorted in **non-decreasing order**.
- `1 <= k <= 10^4`
- `k <= nums1.length * nums2.length`

## é¢˜ç›®å¤§æ„

ç»™å®šä¸¤ä¸ªä»¥ **éé€’å‡é¡ºåºæ’åˆ—** çš„æ•´æ•°æ•°ç»„ `nums1` å’Œ `nums2` , ä»¥åŠä¸€ä¸ªæ•´æ•° `k` ã€‚

å®šä¹‰ä¸€å¯¹å€¼ `(u,v)`ï¼Œå…¶ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ æ¥è‡ª `nums1`ï¼Œç¬¬äºŒä¸ªå…ƒç´ æ¥è‡ª `nums2` ã€‚

è¯·æ‰¾åˆ°å’Œæœ€å°çš„ `k` ä¸ªæ•°å¯¹ `(u1,v1)`, `(u2,v2)` ... `(uk,vk)` ã€‚

## è§£é¢˜æ€è·¯

å¯ä»¥é€šè¿‡ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå †ï¼‰æ¥è§£å†³ã€‚æˆ‘ä»¬å¯ä»¥ç»´æŠ¤ä¸€ä¸ªå°é¡¶å †ï¼Œå †ä¸­å­˜å‚¨çš„æ˜¯æ¯ä¸€ä¸ªå¯èƒ½çš„æ•°å¯¹çš„å’Œï¼ŒåŒæ—¶è®°å½•è¿™ä¸ªæ•°å¯¹åœ¨ä¸¤ä¸ªæ•°ç»„ä¸­çš„ä½ç½®ã€‚æ¯æ¬¡å¼¹å‡ºå †é¡¶å…ƒç´ ï¼Œå¹¶å°†ä¸‹ä¸€ä¸ªå¯èƒ½çš„æ•°å¯¹å…¥å †ã€‚æœ€ç»ˆè¿”å›çš„ç»“æœæ•°ç»„å°±æ˜¯ä»å°åˆ°å¤§çš„å‰ `k` ä¸ªæ•°å¯¹ã€‚

1. æ„å»ºä¸€ä¸ªå°é¡¶å †ï¼Œå †ä¸­çš„æ¯ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ `(sum, i, j)`ï¼Œå…¶ä¸­ `sum` è¡¨ç¤º `nums1[i] + nums2[j]` çš„å’Œï¼Œ`i` å’Œ `j` åˆ†åˆ«è¡¨ç¤ºè¿™ä¸ªå’Œåœ¨ä¸¤ä¸ªæ•°ç»„ä¸­çš„ä½ç½®ã€‚
2. åˆå§‹åŒ–å †ä¸­å…ƒç´ ï¼Œå°† `(nums1[0] + nums2[0], 0, 0)` åŠ å…¥å †ä¸­ã€‚
3. é‡å¤ä»¥ä¸‹æ­¥éª¤ `k` æ¬¡ï¼š
   - å¼¹å‡ºå †é¡¶å…ƒç´  `(sum, i, j)`ï¼Œå°† `(nums1[i+1] + nums2[j], i+1, j)` å’Œ `(nums1[i] + nums2[j+1], i, j+1)` åˆ†åˆ«åŠ å…¥å †ä¸­ã€‚æ³¨æ„è¦ç¡®ä¿ `(i+1, j)` å’Œ `(i, j+1)` æ²¡æœ‰è¶…å‡ºæ•°ç»„èŒƒå›´ã€‚
   - å°†å¼¹å‡ºçš„å…ƒç´  `(nums1[i], nums2[j])` åŠ å…¥ç»“æœæ•°ç»„ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(k log k)`

  - **åˆå§‹å †çš„å»ºç«‹**ï¼šè¿™ä¸ªæ­¥éª¤éœ€è¦æ’å…¥ `k` ä¸ªå…ƒç´ ï¼Œæ¯æ¬¡æ’å…¥çš„æ—¶é—´å¤æ‚åº¦ä¸º `O(log k)`ï¼Œæ€»çš„æ’å…¥å¤æ‚åº¦ä¸º `O(k log k)`ã€‚
  - **å †æ“ä½œ**ï¼šä»å †ä¸­å¼¹å‡ºæœ€å°çš„å’Œï¼Œå¼¹å‡ºæ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¸º `O(log k)`ã€‚å°†æ–°çš„æ•°å¯¹åŠ å…¥åˆ°å †ä¸­ï¼Œæ’å…¥çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿæ˜¯ `O(log k)`ã€‚æœ€å¤šè¿›è¡Œ `k` æ¬¡å¼¹å‡ºå’Œæ’å…¥æ“ä½œï¼Œå› æ­¤æ€»çš„å †æ“ä½œæ—¶é—´å¤æ‚åº¦ä¸º `O(k log k)`ã€‚

- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(k)`ï¼Œåœ¨å †ä¸­æœ€å¤šä¼šåŒæ—¶å­˜å‚¨ `k` ä¸ªæ•°å¯¹ï¼Œå› æ­¤å †çš„ç©ºé—´å¤æ‚åº¦ä¸º `O(k)`ã€‚

## ä»£ç 

```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @param {number} k
 * @return {number[][]}
 */
var kSmallestPairs = function (nums1, nums2, k) {
	let heap = [];
	const add = (val) => {
		heap.push(val);
		heapifyUp(heap.length - 1);
	};
	const pop = () => {
		if (heap.length == 0) {
			return null;
		}
		const top = heap[0];
		const last = heap.pop();
		if (heap.length > 0) {
			heap[0] = last;
			heapifyDown(0);
		}
		return top;
	};
	const heapifyUp = (i) => {
		while (i) {
			const parent = Math.floor((i - 1) / 2);
			if (heap[i][0] < heap[parent][0]) {
				[heap[i], heap[parent]] = [heap[parent], heap[i]];
				i = parent;
			} else {
				break;
			}
		}
	};
	const heapifyDown = (i) => {
		const left = i * 2 + 1;
		const right = i * 2 + 2;
		let min = i;
		if (left < heap.length && heap[left][0] < heap[min][0]) {
			min = left;
		}
		if (right < heap.length && heap[right][0] < heap[min][0]) {
			min = right;
		}
		if (min !== i) {
			[heap[i], heap[min]] = [heap[min], heap[i]];
			heapifyDown(min);
		}
	};

	let res = [];
	if (!nums1 || !nums2 || nums1.length === 0 || nums2.length === 0 || k <= 0) {
		return res;
	}
	for (let i = 0; i < Math.min(nums1.length, k); i++) {
		add([nums1[i] + nums2[0], i, 0]);
	}

	while (k-- > 0 && heap.length > 0) {
		const [sum, i, j] = pop();
		res.push([nums1[i], nums2[j]]);

		if (j + 1 < nums2.length) {
			add([nums1[i] + nums2[j + 1], i, j + 1]);
		}
	}

	return res;
};
```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 378 | [æœ‰åºçŸ©é˜µä¸­ç¬¬ K å°çš„å…ƒç´ ](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix) | [[âœ“]](/problem/0378.md) |  [`æ•°ç»„`](/tag/array.md) [`äºŒåˆ†æŸ¥æ‰¾`](/tag/binary-search.md) [`çŸ©é˜µ`](/tag/matrix.md) `2+` | <font color=#ffb800>Medium</font> |
| 719 | [æ‰¾å‡ºç¬¬ K å°çš„æ•°å¯¹è·ç¦»](https://leetcode.com/problems/find-k-th-smallest-pair-distance) |  |  [`æ•°ç»„`](/tag/array.md) [`åŒæŒ‡é’ˆ`](/tag/two-pointers.md) [`äºŒåˆ†æŸ¥æ‰¾`](/tag/binary-search.md) `1+` | <font color=#ff334b>Hard</font> |
| 2040 | [ä¸¤ä¸ªæœ‰åºæ•°ç»„çš„ç¬¬ K å°ä¹˜ç§¯](https://leetcode.com/problems/kth-smallest-product-of-two-sorted-arrays) |  |  [`æ•°ç»„`](/tag/array.md) [`äºŒåˆ†æŸ¥æ‰¾`](/tag/binary-search.md) | <font color=#ff334b>Hard</font> |