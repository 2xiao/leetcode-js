# [2636. Promise å¯¹è±¡æ± ](https://leetcode.com/problems/promise-pool)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/promise-pool)

## é¢˜ç›®

Given an array of asynchronous functions `functions` and a pool limit `n`, return an asynchronous function `promisePool`. It should return a promise that resolves when all the input functions resolve.

Pool limit is defined as the maximum number promises that can be pending at once. `promisePool` should begin execution of as many functions as possible and continue executing new functions when old promises resolve. `promisePool` should execute `functions[i]` then `functions[i + 1]` then `functions[i + 2]`, etc. When the last promise resolves, `promisePool` should also resolve.

For example, if `n = 1`, `promisePool` will execute one function at a time in series. However, if `n = 2`, it first executes two functions. When either of the two functions resolve, a 3rd function should be executed (if available), and so on until there are no functions left to execute.

You can assume all functions never reject. It is acceptable for `promisePool` to return a promise that resolves any value.

**Example 1:**

> Input:
> functions = [
>
> () => new Promise(res => setTimeout(res, 300)),
> () => new Promise(res => setTimeout(res, 400)),
> () => new Promise(res => setTimeout(res, 200))
> ]
> n = 2
>
> Output: [[300,400,500],500]
>
> Explanation:
> Three functions are passed in. They sleep for 300ms, 400ms, and 200ms respectively.
> They resolve at 300ms, 400ms, and 500ms respectively. The returned promise resolves at 500ms.
>
> - At t=0, the first 2 functions are executed. The pool size limit of 2 is reached.
> - At t=300, the 1st function resolves, and the 3rd function is executed. Pool size is 2.
> - At t=400, the 2nd function resolves. There is nothing left to execute. Pool size is 1.
> - At t=500, the 3rd function resolves. Pool size is zero so the returned promise also resolves.

**Example 2:**

> Input:
> functions = [
>
> () => new Promise(res => setTimeout(res, 300)),
> () => new Promise(res => setTimeout(res, 400)),
> () => new Promise(res => setTimeout(res, 200))
> ]
> n = 5
>
> Output: [[300,400,200],400]
>
> Explanation:
> The three input promises resolve at 300ms, 400ms, and 200ms respectively.
> The returned promise resolves at 400ms.
>
> - At t=0, all 3 functions are executed. The pool limit of 5 is never met.
> - At t=200, the 3rd function resolves. Pool size is 2.
> - At t=300, the 1st function resolved. Pool size is 1.
> - At t=400, the 2nd function resolves. Pool size is 0, so the returned promise also resolves.

**Example 3:**

> Input:
> functions = [
>
> () => new Promise(res => setTimeout(res, 300)),
> () => new Promise(res => setTimeout(res, 400)),
> () => new Promise(res => setTimeout(res, 200))
> ]
> n = 1
>
> Output: [[300,700,900],900]
>
> Explanation:
> The three input promises resolve at 300ms, 700ms, and 900ms respectively.
> The returned promise resolves at 900ms.
>
> - At t=0, the 1st function is executed. Pool size is 1.
> - At t=300, the 1st function resolves and the 2nd function is executed. Pool size is 1.
> - At t=700, the 2nd function resolves and the 3rd function is executed. Pool size is 1.
> - At t=900, the 3rd function resolves. Pool size is 0 so the returned promise resolves.

Constraints:

`0 <= functions.length <= 10`
`1 <= n <= 10`

## é¢˜ç›®å¤§æ„

è¯·ä½ ç¼–å†™ä¸€ä¸ªå¼‚æ­¥å‡½æ•° `promisePool` ï¼Œå®ƒæ¥æ”¶ä¸€ä¸ªå¼‚æ­¥å‡½æ•°æ•°ç»„ `functions` å’Œ **æ± é™åˆ¶** `n`ã€‚å®ƒåº”è¯¥è¿”å›ä¸€ä¸ª promise å¯¹è±¡ï¼Œå½“æ‰€æœ‰è¾“å…¥å‡½æ•°éƒ½æ‰§è¡Œå®Œæ¯•åï¼Œpromise å¯¹è±¡å°±æ‰§è¡Œå®Œæ¯•ã€‚

**æ± é™åˆ¶** å®šä¹‰æ˜¯ä¸€æ¬¡å¯ä»¥æŒ‚èµ·çš„æœ€å¤š promise å¯¹è±¡çš„æ•°é‡ã€‚`promisePool` åº”è¯¥å¼€å§‹æ‰§è¡Œå°½å¯èƒ½å¤šçš„å‡½æ•°ï¼Œå¹¶åœ¨æ—§çš„ promise æ‰§è¡Œå®Œæ¯•åç»§ç»­æ‰§è¡Œæ–°å‡½æ•°ã€‚`promisePool` åº”è¯¥å…ˆæ‰§è¡Œ `functions[i]`ï¼Œå†æ‰§è¡Œ `functions[i + 1]`ï¼Œç„¶åæ‰§è¡Œ `functions[i + 2]`ï¼Œç­‰ç­‰ã€‚å½“æœ€åä¸€ä¸ª promise æ‰§è¡Œå®Œæ¯•æ—¶ï¼Œ`promisePool` ä¹Ÿåº”è¯¥æ‰§è¡Œå®Œæ¯•ã€‚

ä¾‹å¦‚ï¼Œå¦‚æœ `n = 1` , `promisePool` åœ¨åºåˆ—ä¸­æ¯æ¬¡æ‰§è¡Œä¸€ä¸ªå‡½æ•°ã€‚ç„¶è€Œï¼Œå¦‚æœ `n = 2` ï¼Œå®ƒé¦–å…ˆæ‰§è¡Œä¸¤ä¸ªå‡½æ•°ã€‚å½“ä¸¤ä¸ªå‡½æ•°ä¸­çš„ä»»ä½•ä¸€ä¸ªæ‰§è¡Œå®Œæ¯•åï¼Œå†æ‰§è¡Œç¬¬ä¸‰ä¸ªå‡½æ•°(å¦‚æœå®ƒæ˜¯å¯ç”¨çš„)ï¼Œä¾æ­¤ç±»æ¨ï¼Œç›´åˆ°æ²¡æœ‰å‡½æ•°è¦æ‰§è¡Œä¸ºæ­¢ã€‚

ä½ å¯ä»¥å‡è®¾æ‰€æœ‰çš„ `functions` éƒ½ä¸ä¼šè¢«æ‹’ç»ã€‚å¯¹äº `promisePool` æ¥è¯´ï¼Œè¿”å›ä¸€ä¸ªå¯ä»¥è§£æä»»ä½•å€¼çš„ promise éƒ½æ˜¯å¯ä»¥æ¥å—çš„ã€‚

## è§£é¢˜æ€è·¯

**æ± é™åˆ¶**çš„æ ¸å¿ƒæ˜¯æ§åˆ¶å¹¶å‘æ•°é‡ï¼Œå³åŒæ—¶åªèƒ½æœ‰æœ€å¤š `n` ä¸ªå¼‚æ­¥ä»»åŠ¡åœ¨æ‰§è¡Œï¼Œéœ€è¦åœ¨ä¸€ä¸ªä»»åŠ¡æ‰§è¡Œå®Œåï¼Œæ‰èƒ½å¯åŠ¨æ–°çš„ä»»åŠ¡ã€‚

1. å®šä¹‰ä¸€ä¸ªè°ƒåº¦å™¨å‡½æ•°`executeNext`ï¼Œå®ƒä¼šé€’å½’åœ°è°ƒç”¨è‡ªèº«ä»¥ç¡®ä¿æ‰€æœ‰ä»»åŠ¡æŒ‰é¡ºåºæ‰§è¡Œã€‚æ¯æ¬¡æ‰§è¡Œä¸€ä¸ªå‡½æ•°åï¼Œä¼šç»§ç»­æ‰§è¡Œä¸‹ä¸€ä¸ªå‡½æ•°ï¼Œç›´åˆ°å‡½æ•°æ•°ç»„ä¸ºç©ºã€‚

2. åˆ›å»ºå¹¶å‘æ± ï¼Œä½¿ç”¨ `Array(n).fill(null)` åˆ›å»ºä¸€ä¸ªé•¿åº¦ä¸º `n` çš„æ•°ç»„ï¼Œ`map` æ–¹æ³•ç”¨æ¥è°ƒç”¨ `executeNext`ï¼Œå³å¯åŠ¨ `n` ä¸ªå¹¶å‘ä»»åŠ¡ã€‚
3. `Promise.all` ä¼šç­‰å¾…æ‰€æœ‰å¹¶å‘ä»»åŠ¡å®Œæˆï¼Œç¡®ä¿ `promisePool` å‡½æ•°åœ¨æ‰€æœ‰ä»»åŠ¡éƒ½æ‰§è¡Œå®Œåæ‰ resolveã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**: `O(m)`ï¼Œå…¶ä¸­ `m` æ˜¯ `functions` çš„é•¿åº¦ã€‚æ¯ä¸ªä»»åŠ¡çš„æ‰§è¡Œæ—¶é—´å–å†³äºå„è‡ªçš„æ‰§è¡Œæ—¶é—´ï¼Œæ€»å…±ä¼šæ‰§è¡Œ `m` ä¸ªä»»åŠ¡ã€‚
- **ç©ºé—´å¤æ‚åº¦**: `O(n)`ï¼Œå› ä¸ºæœ€å¤šä¼šåŒæ—¶æ‰§è¡Œ `n` ä¸ªä»»åŠ¡ã€‚

## ä»£ç 

```javascript
/**
 * @param {Function[]} functions
 * @param {Number} n
 * @return {Function}
 */
var promisePool = async function (functions, n) {
	const executeNext = async () => {
		if (functions.length === 0) return; // æ‰€æœ‰å‡½æ•°éƒ½æ‰§è¡Œå®Œæ¯•
		const fn = functions.shift(); // å–å‡ºä¸‹ä¸€ä¸ªè¦æ‰§è¡Œçš„å‡½æ•°
		await fn(); // æ‰§è¡Œå‡½æ•°å¹¶ç­‰å¾…å…¶å®Œæˆ
		await executeNext(); // é€’å½’è°ƒç”¨ï¼Œå¤„ç†ä¸‹ä¸€ä¸ªä»»åŠ¡
	};

	// åˆ›å»º n ä¸ªå¹¶å‘ä»»åŠ¡ï¼Œå¼€å§‹æ‰§è¡Œ
	const pool = Array(n).fill(null).map(executeNext);

	// ç­‰å¾…æ‰€æœ‰å¹¶å‘ä»»åŠ¡éƒ½å®Œæˆ
	await Promise.all(pool);
};

/**
 * Example usage:
 * const sleep = (time) => new Promise(resolve => setTimeout(resolve, time));
 *
 * promisePool([() => sleep(500), () => sleep(400), () => sleep(300)], 2)
 *   .then(() => console.log('All functions done'));
 */
```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 2621 | [ç¡çœ å‡½æ•°](https://leetcode.com/problems/sleep) | [[âœ“]](/problem/2621.md) |  | <font color=#15bd66>Easy</font> |
| 2622 | [æœ‰æ—¶é—´é™åˆ¶çš„ç¼“å­˜](https://leetcode.com/problems/cache-with-time-limit) | [[âœ“]](/problem/2622.md) |  | <font color=#ffb800>Medium</font> |
| 2637 | [æœ‰æ—¶é—´é™åˆ¶çš„ Promise å¯¹è±¡](https://leetcode.com/problems/promise-time-limit) | [[âœ“]](/problem/2637.md) |  | <font color=#ffb800>Medium</font> |
| 2676 | [èŠ‚æµ](https://leetcode.com/problems/throttle) | [[âœ“]](/problem/2676.md) |  | <font color=#ffb800>Medium</font> |

<style>
.blue {
    background-color: #096dd9;
    padding: 0.25rem 0.5rem;
    margin: 0;
    font-size: 0.85em;
    border-radius: 3px;
    color: white;
    font-weight: 500;
}
table th:first-of-type { width: 10%; }
table th:nth-of-type(2) { width: 35%; }
table th:nth-of-type(3) { width: 10%; }
table th:nth-of-type(4) { width: 35%; }
table th:nth-of-type(5) { width: 10%; }
</style>
