---
title: 1462. è¯¾ç¨‹è¡¨ IV
description: LeetCode 1462. è¯¾ç¨‹è¡¨ IVé¢˜è§£ï¼ŒCourse Schedule IVï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 1462. è¯¾ç¨‹è¡¨ IV
  - è¯¾ç¨‹è¡¨ IV
  - Course Schedule IV
  - è§£é¢˜æ€è·¯
  - æ·±åº¦ä¼˜å…ˆæœç´¢
  - å¹¿åº¦ä¼˜å…ˆæœç´¢
  - å›¾
  - æ‹“æ‰‘æ’åº
---

# 1462. è¯¾ç¨‹è¡¨ IV

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/tag/breadth-first-search.md) [`å›¾`](/tag/graph.md) [`æ‹“æ‰‘æ’åº`](/tag/topological-sort.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/course-schedule-iv) [`LeetCode`](https://leetcode.com/problems/course-schedule-iv)

## é¢˜ç›®

There are a total of `numCourses` courses you have to take, labeled from `0`
to `numCourses - 1`. You are given an array `prerequisites` where
`prerequisites[i] = [ai, bi]` indicates that you **must** take course `ai`
first if you want to take course `bi`.

- For example, the pair `[0, 1]` indicates that you have to take course `0` before you can take course `1`.

Prerequisites can also be **indirect**. If course `a` is a prerequisite of
course `b`, and course `b` is a prerequisite of course `c`, then course `a` is
a prerequisite of course `c`.

You are also given an array `queries` where `queries[j] = [uj, vj]`. For the
`jth` query, you should answer whether course `uj` is a prerequisite of course
`vj` or not.

Return _a boolean array_`answer` _, where_`answer[j]`_is the answer to
the_`jth` _query._

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/05/01/courses4-1-graph.jpg)

> Input: numCourses = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]]
>
> Output: [false,true]
>
> Explanation: The pair [1, 0] indicates that you have to take course 1 before you can take course 0.
>
> Course 0 is not a prerequisite of course 1, but the opposite is true.

**Example 2:**

> Input: numCourses = 2, prerequisites = [], queries = [[1,0],[0,1]]
>
> Output: [false,false]
>
> Explanation: There are no prerequisites, and each course is independent.

**Example 3:**

![](https://assets.leetcode.com/uploads/2021/05/01/courses4-3-graph.jpg)

> Input: numCourses = 3, prerequisites = [[1,2],[1,0],[2,0]], queries = [[1,0],[1,2]]
>
> Output: [true,true]

**Constraints:**

- `2 <= numCourses <= 100`
- `0 <= prerequisites.length <= (numCourses * (numCourses - 1) / 2)`
- `prerequisites[i].length == 2`
- `0 <= ai, bi <= numCourses - 1`
- `ai != bi`
- All the pairs `[ai, bi]` are **unique**.
- The prerequisites graph has no cycles.
- `1 <= queries.length <= 10^4`
- `0 <= ui, vi <= numCourses - 1`
- `ui != vi`

## é¢˜ç›®å¤§æ„

ä½ æ€»å…±éœ€è¦ä¸Š `numCourses` é—¨è¯¾ï¼Œè¯¾ç¨‹ç¼–å·ä¾æ¬¡ä¸º `0` åˆ° `numCourses-1` ã€‚ä½ ä¼šå¾—åˆ°ä¸€ä¸ªæ•°ç»„ `prerequisite`
ï¼Œå…¶ä¸­ `prerequisites[i] = [ai, bi]` è¡¨ç¤ºå¦‚æœä½ æƒ³é€‰ `bi` è¯¾ç¨‹ï¼Œä½ **å¿…é¡»** å…ˆé€‰ `ai` è¯¾ç¨‹ã€‚

- æœ‰çš„è¯¾ä¼šæœ‰ç›´æ¥çš„å…ˆä¿®è¯¾ç¨‹ï¼Œæ¯”å¦‚å¦‚æœæƒ³ä¸Šè¯¾ç¨‹ `1` ï¼Œä½ å¿…é¡»å…ˆä¸Šè¯¾ç¨‹ `0` ï¼Œé‚£ä¹ˆä¼šä»¥ `[0,1]` æ•°å¯¹çš„å½¢å¼ç»™å‡ºå…ˆä¿®è¯¾ç¨‹æ•°å¯¹ã€‚

å…ˆå†³æ¡ä»¶ä¹Ÿå¯ä»¥æ˜¯ **é—´æ¥** çš„ã€‚å¦‚æœè¯¾ç¨‹ `a` æ˜¯è¯¾ç¨‹ `b` çš„å…ˆå†³æ¡ä»¶ï¼Œè¯¾ç¨‹ `b` æ˜¯è¯¾ç¨‹ `c` çš„å…ˆå†³æ¡ä»¶ï¼Œé‚£ä¹ˆè¯¾ç¨‹ `a` å°±æ˜¯è¯¾ç¨‹
`c` çš„å…ˆå†³æ¡ä»¶ã€‚

ä½ ä¹Ÿå¾—åˆ°ä¸€ä¸ªæ•°ç»„ `queries` ï¼Œå…¶ä¸­ `queries[j] = [uj, vj]`ã€‚å¯¹äºç¬¬ `j` ä¸ªæŸ¥è¯¢ï¼Œæ‚¨åº”è¯¥å›ç­”è¯¾ç¨‹ `uj` æ˜¯å¦æ˜¯è¯¾ç¨‹
`vj` çš„å…ˆå†³æ¡ä»¶ã€‚

è¿”å›ä¸€ä¸ªå¸ƒå°”æ•°ç»„ `answer` ï¼Œå…¶ä¸­ `answer[j]` æ˜¯ç¬¬ `j` ä¸ªæŸ¥è¯¢çš„ç­”æ¡ˆã€‚

**ç¤ºä¾‹ 1ï¼š**

![](https://assets.leetcode.com/uploads/2021/05/01/courses4-1-graph.jpg)

> **è¾“å…¥ï¼š** numCourses = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]]
>
> **è¾“å‡ºï¼š**[false,true]
>
> **è§£é‡Šï¼š**[1, 0] æ•°å¯¹è¡¨ç¤ºåœ¨ä½ ä¸Šè¯¾ç¨‹ 0 ä¹‹å‰å¿…é¡»å…ˆä¸Šè¯¾ç¨‹ 1ã€‚
>
> è¯¾ç¨‹ 0 ä¸æ˜¯è¯¾ç¨‹ 1 çš„å…ˆä¿®è¯¾ç¨‹ï¼Œä½†è¯¾ç¨‹ 1 æ˜¯è¯¾ç¨‹ 0 çš„å…ˆä¿®è¯¾ç¨‹ã€‚

**ç¤ºä¾‹ 2ï¼š**

> **è¾“å…¥ï¼š** numCourses = 2, prerequisites = [], queries = [[1,0],[0,1]]
>
> **è¾“å‡ºï¼š**[false,false]
>
> **è§£é‡Šï¼š** æ²¡æœ‰å…ˆä¿®è¯¾ç¨‹å¯¹ï¼Œæ‰€ä»¥æ¯é—¨è¯¾ç¨‹ä¹‹é—´æ˜¯ç‹¬ç«‹çš„ã€‚

**ç¤ºä¾‹ 3ï¼š**

![](https://assets.leetcode.com/uploads/2021/05/01/courses4-3-graph.jpg)

> **è¾“å…¥ï¼š** numCourses = 3, prerequisites = [[1,2],[1,0],[2,0]], queries = [[1,0],[1,2]]
>
> **è¾“å‡ºï¼š**[true,true]

**æç¤ºï¼š**

- `2 <= numCourses <= 100`
- `0 <= prerequisites.length <= (numCourses * (numCourses - 1) / 2)`
- `prerequisites[i].length == 2`
- `0 <= ai, bi <= numCourses - 1`
- `ai != bi`
- æ¯ä¸€å¯¹ `[ai, bi]` éƒ½ **ä¸åŒ**
- å…ˆä¿®è¯¾ç¨‹å›¾ä¸­æ²¡æœ‰ç¯ã€‚
- `1 <= queries.length <= 10^4`
- `0 <= ui, vi <= numCourses - 1`
- `ui != vi`

## è§£é¢˜æ€è·¯

æœ¬é—®é¢˜å¯ä»¥æŠ½è±¡ä¸ºåˆ¤æ–­æœ‰å‘å›¾ä¸­æŸèŠ‚ç‚¹æ˜¯å¦èƒ½åˆ°è¾¾å¦ä¸€ä¸ªèŠ‚ç‚¹ã€‚å…¸å‹çš„è§£å†³æ–¹æ¡ˆåŒ…æ‹¬ï¼š

- **æ·±åº¦ä¼˜å…ˆæœç´¢ (DFS) æˆ–å¹¿åº¦ä¼˜å…ˆæœç´¢ (BFS)ï¼š** æ¯æ¬¡æŸ¥è¯¢æ—¶ä»æºèŠ‚ç‚¹å‡ºå‘è¿›è¡Œæœç´¢ã€‚
- **é¢„å¤„ç†æ‰€æœ‰å¯è¾¾æ€§ (Floyd-Warshall æˆ–åŠ¨æ€è§„åˆ’)ï¼š** é€šè¿‡é¢„å¤„ç†å°†æ‰€æœ‰èŠ‚ç‚¹é—´çš„å¯è¾¾æ€§å­˜å‚¨ï¼Œé™ä½æŸ¥è¯¢æ—¶é—´å¤æ‚åº¦ã€‚

ç”±äºæŸ¥è¯¢æ¬¡æ•°å¯èƒ½è¾ƒå¤šï¼Œé¢„å¤„ç†æ–¹æ³•é€šå¸¸æ›´é«˜æ•ˆã€‚

---

### æ€è·¯ä¸€ï¼šFloyd-Warshall ç®—æ³•

1. ç”¨ä¸€ä¸ªäºŒç»´å¸ƒå°”æ•°ç»„ `reachable`ï¼Œå…¶ä¸­ `reachable[i][j]` è¡¨ç¤ºèŠ‚ç‚¹ `i` æ˜¯å¦èƒ½åˆ°è¾¾èŠ‚ç‚¹ `j`ã€‚
2. æ ¹æ® `prerequisites` åˆå§‹åŒ– `reachable` æ•°ç»„ã€‚
3. ä½¿ç”¨ Floyd-Warshall ç®—æ³•è¿›è¡Œä¸‰å±‚å¾ªç¯ï¼Œæ£€æŸ¥é€šè¿‡ä¸­é—´èŠ‚ç‚¹æ˜¯å¦å¯ä»¥è¿é€šï¼Œæ›´æ–°å¯è¾¾æ€§ã€‚
4. å¯¹æ¯ä¸ªæŸ¥è¯¢ç›´æ¥æŸ¥è¡¨å³å¯ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(n^3)`ï¼Œå…¶ä¸­ `n` æ˜¯è¯¾ç¨‹æ•°é‡ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(n^2)`ã€‚

---

### æ€è·¯äºŒï¼šæ·±åº¦ä¼˜å…ˆæœç´¢ (DFS) + ç¼“å­˜

**ç®—æ³•æ­¥éª¤ï¼š**

1. å°† `prerequisites` è½¬æ¢ä¸ºé‚»æ¥è¡¨ã€‚
2. ä½¿ç”¨ DFS åˆ¤æ–­èŠ‚ç‚¹ `u` æ˜¯å¦èƒ½åˆ°è¾¾èŠ‚ç‚¹ `v`ã€‚
3. ä½¿ç”¨ç¼“å­˜ (memoization) ä¼˜åŒ–å¤šæ¬¡æŸ¥è¯¢çš„é‡å¤è®¡ç®—ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(V + E + Q * V)`ï¼Œå…¶ä¸­ `V` æ˜¯è¯¾ç¨‹æ•°é‡ï¼Œ`E` æ˜¯å…ˆä¿®å…³ç³»æ•°é‡ï¼Œ`Q` æ˜¯æŸ¥è¯¢æ•°é‡ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(V + E)`ã€‚

---

### æ€è·¯ä¸‰ï¼šæ‹“æ‰‘æ’åº + åŠ¨æ€è§„åˆ’

1. ä½¿ç”¨æ‹“æ‰‘æ’åºè®¡ç®—è¯¾ç¨‹çš„æ‹“æ‰‘åºåˆ—ã€‚
2. é€šè¿‡åŠ¨æ€è§„åˆ’è®¡ç®—æ¯é—¨è¯¾ç¨‹çš„æ‰€æœ‰å…ˆä¿®è¯¾ç¨‹é›†åˆã€‚
3. ç›´æ¥æŸ¥è¯¢å…ˆä¿®é›†åˆå³å¯ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(V + E + Q * V)`ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(V^2)`ã€‚

## ä»£ç 

::: code-tabs
@tab Floyd-Warshall ç®—æ³•

```javascript
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @param {number[][]} queries
 * @return {boolean[]}
 */
var checkIfPrerequisite = function (numCourses, prerequisites, queries) {
	const reachable = Array.from({ length: numCourses }, () =>
		Array(numCourses).fill(false)
	);

	// Initialize direct prerequisites
	for (const [u, v] of prerequisites) {
		reachable[u][v] = true;
	}

	// Floyd-Warshall to find all reachable pairs
	for (let k = 0; k < numCourses; k++) {
		for (let i = 0; i < numCourses; i++) {
			for (let j = 0; j < numCourses; j++) {
				if (reachable[i][k] && reachable[k][j]) {
					reachable[i][j] = true;
				}
			}
		}
	}

	// Answer queries
	return queries.map(([u, v]) => reachable[u][v]);
};
```

@tab æ·±åº¦ä¼˜å…ˆæœç´¢ (DFS) + ç¼“å­˜

```javascript
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @param {number[][]} queries
 * @return {boolean[]}
 */
var checkIfPrerequisite = function (numCourses, prerequisites, queries) {
	const graph = Array.from({ length: numCourses }, () => []);
	const memo = Array.from({ length: numCourses }, () => new Map());

	// Build the graph
	for (const [u, v] of prerequisites) {
		graph[u].push(v);
	}

	// DFS function to check if u can reach v
	const dfs = (u, v) => {
		if (u === v) return true;
		if (memo[u].has(v)) return memo[u].get(v);

		for (const neighbor of graph[u]) {
			if (dfs(neighbor, v)) {
				memo[u].set(v, true);
				return true;
			}
		}

		memo[u].set(v, false);
		return false;
	};

	// Answer each query
	return queries.map(([u, v]) => dfs(u, v));
};
```

@tab æ‹“æ‰‘æ’åº + åŠ¨æ€è§„åˆ’

```javascript
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @param {number[][]} queries
 * @return {boolean[]}
 */
var checkIfPrerequisite = function (numCourses, prerequisites, queries) {
	const graph = Array.from({ length: numCourses }, () => []);
	const indegree = Array(numCourses).fill(0);
	const prereq = Array.from({ length: numCourses }, () => new Set());

	// Build the graph and calculate indegrees
	for (const [u, v] of prerequisites) {
		graph[u].push(v);
		indegree[v]++;
	}

	// Perform topological sort
	const queue = [];
	for (let i = 0; i < numCourses; i++) {
		if (indegree[i] === 0) {
			queue.push(i);
		}
	}

	while (queue.length > 0) {
		const course = queue.shift();
		for (const next of graph[course]) {
			prereq[next] = new Set([...prereq[next], ...prereq[course], course]);
			indegree[next]--;
			if (indegree[next] === 0) {
				queue.push(next);
			}
		}
	}

	// Answer queries
	return queries.map(([u, v]) => prereq[v].has(u));
};
```

:::
