---
title: 689. ä¸‰ä¸ªæ— é‡å å­æ•°ç»„çš„æœ€å¤§å’Œ
description: LeetCode 689. ä¸‰ä¸ªæ— é‡å å­æ•°ç»„çš„æœ€å¤§å’Œé¢˜è§£ï¼ŒMaximum Sum of 3 Non-Overlapping Subarraysï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 689. ä¸‰ä¸ªæ— é‡å å­æ•°ç»„çš„æœ€å¤§å’Œ
  - ä¸‰ä¸ªæ— é‡å å­æ•°ç»„çš„æœ€å¤§å’Œ
  - Maximum Sum of 3 Non-Overlapping Subarrays
  - è§£é¢˜æ€è·¯
  - æ•°ç»„
  - åŠ¨æ€è§„åˆ’
---

# 689. ä¸‰ä¸ªæ— é‡å å­æ•°ç»„çš„æœ€å¤§å’Œ

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`æ•°ç»„`](/tag/array.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/maximum-sum-of-3-non-overlapping-subarrays) [`LeetCode`](https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays)

## é¢˜ç›®

Given an integer array `nums` and an integer `k`, find three non-overlapping
subarrays of length `k` with maximum sum and return them.

Return the result as a list of indices representing the starting position of
each interval (**0-indexed**). If there are multiple answers, return the
lexicographically smallest one.

**Example 1:**

> Input: nums = [1,2,1,2,6,7,5,1], k = 2
>
> Output: [0,3,5]
>
> Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].
>
> We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.

**Example 2:**

> Input: nums = [1,2,1,2,1,2,1,2,1], k = 2
>
> Output: [0,2,4]

**Constraints:**

- `1 <= nums.length <= 2 * 10^4`
- `1 <= nums[i] < 216`
- `1 <= k <= floor(nums.length / 3)`

## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` å’Œä¸€ä¸ªæ•´æ•° `k` ï¼Œæ‰¾å‡ºä¸‰ä¸ªé•¿åº¦ä¸º `k` ã€äº’ä¸é‡å ã€ä¸”å…¨éƒ¨æ•°å­—å’Œï¼ˆ`3 * k`
é¡¹ï¼‰æœ€å¤§çš„å­æ•°ç»„ï¼Œå¹¶è¿”å›è¿™ä¸‰ä¸ªå­æ•°ç»„ã€‚

ä»¥ä¸‹æ ‡çš„æ•°ç»„å½¢å¼è¿”å›ç»“æœï¼Œæ•°ç»„ä¸­çš„æ¯ä¸€é¡¹åˆ†åˆ«æŒ‡ç¤ºæ¯ä¸ªå­æ•°ç»„çš„èµ·å§‹ä½ç½®ï¼ˆä¸‹æ ‡ä» **0** å¼€å§‹ï¼‰ã€‚å¦‚æœæœ‰å¤šä¸ªç»“æœï¼Œè¿”å›å­—å…¸åºæœ€å°çš„ä¸€ä¸ªã€‚

**ç¤ºä¾‹ 1ï¼š**

> **è¾“å…¥ï¼š** nums = [1,2,1,2,6,7,5,1], k = 2
>
> **è¾“å‡ºï¼š**[0,3,5]
>
> **è§£é‡Šï¼š** å­æ•°ç»„ [1, 2], [2, 6], [7, 5] å¯¹åº”çš„èµ·å§‹ä¸‹æ ‡ä¸º [0, 3, 5]ã€‚
>
> ä¹Ÿå¯ä»¥å– [2, 1], ä½†æ˜¯ç»“æœ [1, 3, 5] åœ¨å­—å…¸åºä¸Šæ›´å¤§ã€‚

**ç¤ºä¾‹ 2ï¼š**

> **è¾“å…¥ï¼š** nums = [1,2,1,2,1,2,1,2,1], k = 2
>
> **è¾“å‡ºï¼š**[0,2,4]

**æç¤ºï¼š**

- `1 <= nums.length <= 2 * 10^4`
- `1 <= nums[i] < 216`
- `1 <= k <= floor(nums.length / 3)`

## è§£é¢˜æ€è·¯

1. **æ»‘åŠ¨çª—å£**

- ä½¿ç”¨æ»‘åŠ¨çª—å£æ¥è®¡ç®—é•¿åº¦ä¸º `k` çš„å­æ•°ç»„çš„å’Œã€‚
- é€šè¿‡å‡å»çª—å£å·¦ç«¯å…ƒç´ ã€åŠ ä¸Šçª—å£å³ç«¯å…ƒç´ ï¼Œå¯ä»¥åœ¨ `O(1)` çš„æ—¶é—´å†…æ›´æ–°å½“å‰çª—å£çš„å’Œã€‚

2. **åŠ¨æ€è§„åˆ’æ€è·¯**

- ç»´æŠ¤ä¸‰ä¸ªå˜é‡åˆ†åˆ«å­˜å‚¨ï¼š
  - **æœ€ä½³çš„ä¸€ä¸ªå­æ•°ç»„å’ŒåŠèµ·å§‹ç´¢å¼•**ï¼ˆ`best_one_all` å’Œ `one_start`ï¼‰ã€‚
  - **æœ€ä½³çš„ä¸¤ä¸ªå­æ•°ç»„å’ŒåŠèµ·å§‹ç´¢å¼•**ï¼ˆ`best_two_all` å’Œ `two_start`ï¼‰ã€‚
  - **æœ€ä½³çš„ä¸‰ä¸ªå­æ•°ç»„å’ŒåŠèµ·å§‹ç´¢å¼•**ï¼ˆ`best_three_all` å’Œ `three_start`ï¼‰ã€‚
- æŒ‰é¡ºåºè®¡ç®—ä¸‰ä¸ªå­æ•°ç»„çš„èµ·å§‹ç´¢å¼•ï¼Œç¡®ä¿æ²¡æœ‰é‡å ï¼š
  - ç¬¬ä¸€ä¸ªå­æ•°ç»„èµ·å§‹ç´¢å¼•èŒƒå›´æ˜¯ `[0, nums.length - 3*k]`ã€‚
  - ç¬¬äºŒä¸ªå­æ•°ç»„èµ·å§‹ç´¢å¼•èŒƒå›´æ˜¯ `[k, nums.length - 2*k]`ã€‚
  - ç¬¬ä¸‰ä¸ªå­æ•°ç»„èµ·å§‹ç´¢å¼•èŒƒå›´æ˜¯ `[2*k, nums.length - k]`ã€‚

3. **æ›´æ–°é€»è¾‘**

- æ»‘åŠ¨çª—å£æ¯æ¬¡ç§»åŠ¨æ—¶æ›´æ–°ï¼š
  - å½“å‰ç¬¬ä¸€ä¸ªå­æ•°ç»„çš„å’ŒåŠèµ·å§‹ç´¢å¼•ï¼ˆå¦‚æœæ›´ä¼˜ï¼‰ã€‚
  - å½“å‰å‰ä¸¤ä¸ªå­æ•°ç»„çš„å’ŒåŠèµ·å§‹ç´¢å¼•ï¼ˆå¦‚æœæ›´ä¼˜ï¼‰ã€‚
  - å½“å‰ä¸‰ä¸ªå­æ•°ç»„çš„å’ŒåŠèµ·å§‹ç´¢å¼•ï¼ˆå¦‚æœæ›´ä¼˜ï¼‰ã€‚

4. **è¿”å›ç»“æœ**

- æœ€åè¿”å›è®°å½•çš„æœ€ä½³ä¸‰ä¸ªå­æ•°ç»„çš„èµ·å§‹ç´¢å¼•ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œå¯¹äºé•¿åº¦ä¸º `n` çš„æ•°ç»„ï¼Œæ»‘åŠ¨çª—å£ç§»åŠ¨æ¬¡æ•°ä¸º `O(n - 3k)`ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(1)`ï¼Œä»…ä½¿ç”¨å¸¸æ•°é¢å¤–ç©ºé—´å­˜å‚¨å­æ•°ç»„å’ŒåŠç´¢å¼•ã€‚

## ä»£ç 

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSumOfThreeSubarrays = function (nums, k) {
	let one_start = 0;
	let two_start = [0, k];
	let three_start = [0, k, 2 * k];

	let cur_one_sum = nums.slice(0, k).reduce((a, b) => a + b, 0);
	let cur_two_sum = nums.slice(k, 2 * k).reduce((a, b) => a + b, 0);
	let cur_three_sum = nums.slice(2 * k, 3 * k).reduce((a, b) => a + b, 0);

	let best_one_all = cur_one_sum;
	let best_two_all = cur_one_sum + cur_two_sum;
	let best_three_all = cur_one_sum + cur_two_sum + cur_three_sum;

	let one_start_i = 1;
	let two_start_i = k + 1;
	let three_start_i = k * 2 + 1;

	while (three_start_i <= nums.length - k) {
		cur_one_sum =
			cur_one_sum - nums[one_start_i - 1] + nums[one_start_i + k - 1];
		cur_two_sum =
			cur_two_sum - nums[two_start_i - 1] + nums[two_start_i + k - 1];
		cur_three_sum =
			cur_three_sum - nums[three_start_i - 1] + nums[three_start_i + k - 1];

		if (cur_one_sum > best_one_all) {
			best_one_all = cur_one_sum;
			one_start = one_start_i;
		}
		if (cur_two_sum + best_one_all > best_two_all) {
			best_two_all = cur_two_sum + best_one_all;
			two_start[0] = one_start;
			two_start[1] = two_start_i;
		}
		if (cur_three_sum + best_two_all > best_three_all) {
			best_three_all = cur_three_sum + best_two_all;
			three_start[0] = two_start[0];
			three_start[1] = two_start[1];
			three_start[2] = three_start_i;
		}
		one_start_i++;
		two_start_i++;
		three_start_i++;
	}
	return three_start;
};
```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ | åŠ›æ‰£ |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 123 | ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº III | [[âœ“]](/problem/0123.md) |  [`æ•°ç»„`](/tag/array.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md) | ğŸ”´ | [ğŸ€„ï¸](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii) [ğŸ”—](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii) |