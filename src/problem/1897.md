---
title: 1897. é‡æ–°åˆ†é…å­—ç¬¦ä½¿æ‰€æœ‰å­—ç¬¦ä¸²éƒ½ç›¸ç­‰
description: LeetCode 1897. é‡æ–°åˆ†é…å­—ç¬¦ä½¿æ‰€æœ‰å­—ç¬¦ä¸²éƒ½ç›¸ç­‰é¢˜è§£ï¼ŒRedistribute Characters to Make All Strings Equalï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 1897. é‡æ–°åˆ†é…å­—ç¬¦ä½¿æ‰€æœ‰å­—ç¬¦ä¸²éƒ½ç›¸ç­‰
  - é‡æ–°åˆ†é…å­—ç¬¦ä½¿æ‰€æœ‰å­—ç¬¦ä¸²éƒ½ç›¸ç­‰
  - Redistribute Characters to Make All Strings Equal
  - è§£é¢˜æ€è·¯
  - å“ˆå¸Œè¡¨
  - å­—ç¬¦ä¸²
  - è®¡æ•°
---

# 1897. é‡æ–°åˆ†é…å­—ç¬¦ä½¿æ‰€æœ‰å­—ç¬¦ä¸²éƒ½ç›¸ç­‰

ğŸŸ¢ <font color=#15bd66>Easy</font>&emsp; ğŸ”–&ensp; [`å“ˆå¸Œè¡¨`](/tag/hash-table.md) [`å­—ç¬¦ä¸²`](/tag/string.md) [`è®¡æ•°`](/tag/counting.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/redistribute-characters-to-make-all-strings-equal) [`LeetCode`](https://leetcode.com/problems/redistribute-characters-to-make-all-strings-equal)

## é¢˜ç›®

You are given an array of strings `words` (**0-indexed**).

In one operation, pick two **distinct** indices `i` and `j`, where `words[i]`
is a non-empty string, and move **any** character from `words[i]` to **any**
position in `words[j]`.

Return `true` _if you can make**every** string in _`words` _**equal** using **any** number of operations_,_and_`false` _otherwise_.

**Example 1:**

> Input: words = ["abc","aabc","bc"]
>
> Output: true
>
> Explanation: Move the first 'a' in words[1] to the front of words[2],
>
> to make words[1] = "abc" and words[2] = "abc".
>
> All the strings are now equal to "abc", so return true.

**Example 2:**

> Input: words = ["ab","a"]
>
> Output: false
>
> Explanation: It is impossible to make all the strings equal using the operation.

**Constraints:**

- `1 <= words.length <= 100`
- `1 <= words[i].length <= 100`
- `words[i]` consists of lowercase English letters.

## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ `words`ï¼ˆä¸‹æ ‡ **ä» 0 å¼€å§‹** è®¡æ•°ï¼‰ã€‚

åœ¨ä¸€æ­¥æ“ä½œä¸­ï¼Œéœ€å…ˆé€‰å‡ºä¸¤ä¸ª **ä¸åŒ** ä¸‹æ ‡ `i` å’Œ `j`ï¼Œå…¶ä¸­ `words[i]` æ˜¯ä¸€ä¸ªéç©ºå­—ç¬¦ä¸²ï¼Œæ¥ç€å°† `words[i]` ä¸­çš„
**ä»»ä¸€** å­—ç¬¦ç§»åŠ¨åˆ° `words[j]` ä¸­çš„ **ä»»ä¸€** ä½ç½®ä¸Šã€‚

å¦‚æœæ‰§è¡Œä»»æ„æ­¥æ“ä½œå¯ä»¥ä½¿ `words` ä¸­çš„æ¯ä¸ªå­—ç¬¦ä¸²éƒ½ç›¸ç­‰ï¼Œè¿”å› `true` ï¼›å¦åˆ™ï¼Œè¿”å› `false` ã€‚

**ç¤ºä¾‹ 1ï¼š**

> **è¾“å…¥ï¼š** words = ["abc","aabc","bc"]
>
> **è¾“å‡ºï¼š** true
>
> **è§£é‡Šï¼š** å°† words[1] ä¸­çš„ç¬¬ä¸€ä¸ª 'a' ç§»åŠ¨åˆ° words[2] çš„æœ€å‰é¢ã€‚
>
> ä½¿ words[1] = "abc" ä¸” words[2] = "abc" ã€‚
>
> æ‰€æœ‰å­—ç¬¦ä¸²éƒ½ç­‰äº "abc" ï¼Œæ‰€ä»¥è¿”å› true ã€‚

**ç¤ºä¾‹ 2ï¼š**

> **è¾“å…¥ï¼š** words = ["ab","a"]
>
> **è¾“å‡ºï¼š** false
>
> **è§£é‡Šï¼š** æ‰§è¡Œæ“ä½œæ— æ³•ä½¿æ‰€æœ‰å­—ç¬¦ä¸²éƒ½ç›¸ç­‰ã€‚

**æç¤ºï¼š**

- `1 <= words.length <= 100`
- `1 <= words[i].length <= 100`
- `words[i]` ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆ

## è§£é¢˜æ€è·¯

1. **ç»Ÿè®¡å­—ç¬¦é¢‘ç‡**

   ç”±äºè¾“å…¥ä¸­çš„å­—ç¬¦æ˜¯å°å†™è‹±æ–‡å­—æ¯ï¼ˆå›ºå®š 26 ä¸ªï¼‰ï¼Œå¯ä»¥ç”¨ä¸€ä¸ªé•¿åº¦ä¸º 26 çš„æ•°ç»„ `freq` æ¥ç»Ÿè®¡æ¯ä¸ªå­—ç¬¦å‡ºç°çš„æ€»é¢‘ç‡ï¼š

   - å°†å­—ç¬¦çš„ ASCII å€¼å‡å» `'a'` çš„ ASCII å€¼å¾—åˆ°å…¶ç´¢å¼•ï¼Œä¾‹å¦‚ `'a'` çš„ç´¢å¼•ä¸º 0ï¼Œ`'b'` çš„ç´¢å¼•ä¸º 1ï¼Œä¾æ­¤ç±»æ¨ã€‚
   - éå†æ‰€æœ‰å•è¯ï¼Œæ›´æ–°æ•°ç»„ä¸­ç›¸åº”ç´¢å¼•çš„é¢‘ç‡å€¼ã€‚

2. **æ£€æŸ¥é¢‘ç‡æ˜¯å¦æ»¡è¶³æ¡ä»¶**

   å°†ç»Ÿè®¡å¥½çš„é¢‘ç‡æ•°ç»„é€ä¸€æ£€æŸ¥ï¼š

   - å¦‚æœæŸä¸ªå­—ç¬¦çš„æ€»é¢‘ç‡ä¸èƒ½è¢«å•è¯çš„æ€»æ•° `n` æ•´é™¤ï¼Œåˆ™è¯´æ˜è¿™äº›å­—ç¬¦æ— æ³•å‡åˆ†åˆ°æ¯ä¸ªå•è¯ï¼Œç›´æ¥è¿”å› `false`ã€‚
   - å¦‚æœæ‰€æœ‰å­—ç¬¦çš„é¢‘ç‡éƒ½èƒ½è¢« `n` æ•´é™¤ï¼Œåˆ™è¿”å› `true`ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(k * m)`
  - éå†æ‰€æœ‰å•è¯ç»Ÿè®¡å­—ç¬¦é¢‘ç‡ï¼š`O(k * m)`ï¼Œå…¶ä¸­ `k` æ˜¯å•è¯æ•°ï¼Œ`m` æ˜¯å¹³å‡å•è¯é•¿åº¦ã€‚
  - æ£€æŸ¥é¢‘ç‡æ˜¯å¦æ»¡è¶³æ¡ä»¶ï¼šå›ºå®šé•¿åº¦ 26ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º `O(1)`ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(1)`ï¼Œä½¿ç”¨äº†é•¿åº¦ä¸º 26 çš„æ•°ç»„å­˜å‚¨å­—ç¬¦é¢‘ç‡ã€‚

## ä»£ç 

```javascript
/**
 * @param {string[]} words
 * @return {boolean}
 */
var makeEqual = function (words) {
	const n = words.length;
	const freq = new Array(26).fill(0); // ç”¨é•¿åº¦ä¸º 26 çš„æ•°ç»„ä»£æ›¿ Map

	// ç»Ÿè®¡æ‰€æœ‰å•è¯ä¸­æ¯ä¸ªå­—ç¬¦çš„å‡ºç°é¢‘ç‡
	for (let word of words) {
		for (let char of word) {
			freq[char.charCodeAt() - 97]++;
		}
	}

	// æ£€æŸ¥æ‰€æœ‰å­—ç¬¦çš„é¢‘ç‡æ˜¯å¦éƒ½èƒ½è¢« n æ•´é™¤
	for (let count of freq) {
		if (count % n !== 0) {
			return false;
		}
	}
	return true;
};
```
