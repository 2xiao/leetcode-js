# [1008. å‰åºéå†æ„é€ äºŒå‰æœç´¢æ ‘](https://2xiao.github.io/leetcode-js/problem/1008.html)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ ˆ`](/tag/stack.md) [`æ ‘`](/tag/tree.md) [`äºŒå‰æœç´¢æ ‘`](/tag/binary-search-tree.md) [`æ•°ç»„`](/tag/array.md) [`äºŒå‰æ ‘`](/tag/binary-tree.md) [`å•è°ƒæ ˆ`](/tag/monotonic-stack.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal) [`LeetCode`](https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal)

## é¢˜ç›®

Given an array of integers preorder, which represents the **preorder traversal** of a BST (i.e., **binary search tree** ), construct the tree and
return _its root_.

It is **guaranteed** that there is always possible to find a binary search
tree with the given requirements for the given test cases.

A **binary search tree** is a binary tree where for every node, any descendant
of `Node.left` has a value **strictly less than** `Node.val`, and any
descendant of `Node.right` has a value **strictly greater than** `Node.val`.

A **preorder traversal** of a binary tree displays the value of the node
first, then traverses `Node.left`, then traverses `Node.right`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/03/06/1266.png)

> Input: preorder = [8,5,1,7,10,12]
>
> Output: [8,5,10,1,7,null,12]

**Example 2:**

> Input: preorder = [1,3]
>
> Output: [1,null,3]

**Constraints:**

- `1 <= preorder.length <= 100`
- `1 <= preorder[i] <= 1000`
- All the values of `preorder` are **unique**.

## é¢˜ç›®å¤§æ„

ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œå®ƒè¡¨ç¤º BST(å³ äºŒå‰æœç´¢æ ‘ )çš„ å…ˆåºéå† ï¼Œæ„é€ æ ‘å¹¶è¿”å›å…¶æ ¹ã€‚

ä¿è¯ å¯¹äºç»™å®šçš„æµ‹è¯•ç”¨ä¾‹ï¼Œæ€»æ˜¯æœ‰å¯èƒ½æ‰¾åˆ°å…·æœ‰ç»™å®šéœ€æ±‚çš„äºŒå‰æœç´¢æ ‘ã€‚

äºŒå‰æœç´¢æ ‘ æ˜¯ä¸€æ£µäºŒå‰æ ‘ï¼Œå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹ï¼Œ `Node.left` çš„ä»»ä½•åä»£çš„å€¼ ä¸¥æ ¼å°äº `Node.val` , `Node.right` çš„ä»»ä½•åä»£çš„å€¼ ä¸¥æ ¼å¤§äº `Node.val`ã€‚

äºŒå‰æ ‘çš„ å‰åºéå† é¦–å…ˆæ˜¾ç¤ºèŠ‚ç‚¹çš„å€¼ï¼Œç„¶åéå†`Node.left`ï¼Œæœ€åéå†`Node.right`ã€‚

## è§£é¢˜æ€è·¯

æ„é€ äºŒå‰æ ‘ï¼Œå…ˆæ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œå†é€’å½’åœ°æ„é€ å·¦å³å­æ ‘ã€‚

æœ¬é¢˜ä¸­å·²çŸ¥äºŒå‰æœç´¢æ ‘çš„å…ˆåºéå†ï¼Œæ ¹èŠ‚ç‚¹å°±æ˜¯æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚

åªéœ€è¦å†æ‰¾å‡ºå·¦å³å­æ ‘åˆ†å‰²çš„åœ°æ–¹ï¼Œå°±å¯ä»¥é€’å½’æ„é€ å·¦å³å­æ ‘äº†ã€‚æ ¹æ®äºŒå‰æœç´¢æ ‘çš„ç‰¹ç‚¹ï¼Œå·¦å­æ ‘çš„æ‰€æœ‰å€¼éƒ½å°äºæ ¹èŠ‚ç‚¹ï¼Œæ‰€ä»¥åªéœ€éå†åç»­æ•°ç»„ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªæ¯”æ ¹èŠ‚ç‚¹å¤§çš„æ•°å€¼ï¼Œå³ä¸ºå³å­æ ‘å…ˆåºéå†çš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚

## ä»£ç 

```javascript
/**
 * @param {number[]} preorder
 * @return {TreeNode}
 */
var bstFromPreorder = function (preorder) {
	if (!preorder.length) return null;
	let root = new TreeNode(preorder[0]);
	let mid = 1;
	while (preorder[mid] < preorder[0]) {
		mid++;
	}
	root.left = bstFromPreorder(preorder.slice(1, mid));
	root.right = bstFromPreorder(preorder.slice(mid));
	return root;
};
```
