---
title: 2776. è½¬æ¢å›è°ƒå‡½æ•°ä¸º Promise å‡½æ•° ğŸ”’
description: LeetCode 2776. è½¬æ¢å›è°ƒå‡½æ•°ä¸º Promise å‡½æ•° ğŸ”’é¢˜è§£ï¼ŒConvert Callback Based Function to Promise Based Functionï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 2776. è½¬æ¢å›è°ƒå‡½æ•°ä¸º Promise å‡½æ•° ğŸ”’
  - è½¬æ¢å›è°ƒå‡½æ•°ä¸º Promise å‡½æ•°
  - Convert Callback Based Function to Promise Based Function
  - è§£é¢˜æ€è·¯
---

# 2776. è½¬æ¢å›è°ƒå‡½æ•°ä¸º Promise å‡½æ•° ğŸ”’

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/convert-callback-based-function-to-promise-based-function) [`LeetCode`](https://leetcode.com/problems/convert-callback-based-function-to-promise-based-function)

## é¢˜ç›®

Write a function that accepts another function `fn` and converts the callback-
based function into a promise-based function.

The function `fn` takes a callback as its first argument, along with any
additional arguments `args` passed as separate inputs.

The `promisify` function returns a new function that should return a promise.
The promise should resolve with the argument passed as the first parameter of
the callback when the callback is invoked without error, and reject with the
error when the callback is called with an error as the second argument.

The following is an example of a function that could be passed into
`promisify`.

```js
function sum(callback, a, b) {
	if (a < 0 || b < 0) {
		const err = Error('a and b must be positive');
		callback(undefined, err);
	} else {
		callback(a + b);
	}
}
```

This is the equivalent code based on promises:

```js
async function sum(a, b) {
	if (a < 0 || b < 0) {
		throw Error('a and b must be positive');
	} else {
		return a + b;
	}
}
```

**Example 1:**

> Input:
>
> ```js
> fn = (callback, a, b, c) => {
> 	callback(a * b * c);
> };
> args = [1, 2, 3];
> ```
>
> Output: {"resolved": 6}
>
> Explanation:
>
> ```js
> const asyncFunc = promisify(fn);
> asyncFunc(1, 2, 3).then(console.log); // 6
> ```
>
> fn is called with a callback as the first argument and args as the rest. The promise based version of fn resolves a value of 6 when called with (1, 2, 3).

**Example 2:**

> Input:
>
> ```js
> fn = (callback, a, b, c) => {
> 	callback(a * b * c, 'Promise Rejected');
> };
>
> args = [4, 5, 6];
> ```
>
> Output: {"rejected": "Promise Rejected"}
>
> Explanation:
>
> ```js
> const asyncFunc = promisify(fn);
> asyncFunc(4, 5, 6).catch(console.log); // "Promise Rejected"
> ```
>
> fn is called with a callback as the first argument and args as the rest. As the second argument, the callback accepts an error message, so when fn is called, the promise is rejected with a error message provided in the callback. Note that it did not matter what was passed as the first argument into the callback.

**Constraints:**

- `1 <= args.length <= 100`
- `0 <= args[i] <= 10^4`

## é¢˜ç›®å¤§æ„

ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œæ¥å—å¦ä¸€ä¸ªå‡½æ•° `fn` ï¼Œå¹¶å°†åŸºäºå›è°ƒå‡½æ•°çš„å‡½æ•°è½¬æ¢ä¸ºåŸºäº Promise çš„å‡½æ•°ã€‚

`promisify` å‡½æ•°æ¥å—ä¸€ä¸ªå‡½æ•° `fn` ï¼Œ`fn` å°†å›è°ƒå‡½æ•°ä½œä¸ºå…¶ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œå¹¶ä¸”è¿˜å¯ä»¥æ¥å—å…¶ä»–é¢å¤–çš„å‚æ•°ã€‚

`promisify` è¿”å›ä¸€ä¸ªæ–°å‡½æ•°ï¼Œæ–°å‡½æ•°ä¼šè¿”å›ä¸€ä¸ª Promise å¯¹è±¡ã€‚å½“å›è°ƒå‡½æ•°è¢«æˆåŠŸè°ƒç”¨æ—¶ï¼Œæ–°å‡½æ•°è¿”å›çš„ Promise
å¯¹è±¡åº”è¯¥ä½¿ç”¨åŸå§‹å‡½æ•°çš„ç»“æœè¿›è¡Œè§£æï¼›å½“å›è°ƒå‡½æ•°è¢«è°ƒç”¨å‡ºç°é”™è¯¯æ—¶ï¼Œè¿”å›çš„ Promise å¯¹è±¡åº”è¯¥è¢«æ‹’ç»å¹¶æºå¸¦é”™è¯¯ä¿¡æ¯ã€‚æœ€ç»ˆè¿”å›çš„åŸºäº Promise
çš„å‡½æ•°åº”è¯¥æ¥å—é¢å¤–çš„å‚æ•°ä½œä¸ºè¾“å…¥ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªå¯ä»¥ä¼ é€’ç»™ `promisify` çš„å‡½æ•°ç¤ºä¾‹ï¼š

```js
function sum(callback, a, b) {
	if (a < 0 || b < 0) {
		const err = Error('a and b must be positive');
		callback(undefined, err);
	} else {
		callback(a + b);
	}
}
```

è¿™æ˜¯åŸºäº Promise çš„ç­‰æ•ˆä»£ç ï¼š

```js
async function sum(a, b) {
	if (a < 0 || b < 0) {
		throw Error('a and b must be positive');
	} else {
		return a + b;
	}
}
```

**ç¤ºä¾‹ 1ï¼š**

> **è¾“å…¥ï¼š**
>
> ```js
> fn = (callback, a, b, c) => {
> 	return callback(a * b * c);
> };
>
> args = [1, 2, 3];
> ```
>
> **è¾“å‡ºï¼š**{"resolved": 6}
>
> **è§£é‡Šï¼š**
>
> ```js
> const asyncFunc = promisify(fn);
> asyncFunc(1, 2, 3).then(console.log); // 6
> ```
>
> fn ä»¥å›è°ƒå‡½æ•°ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°å’Œ args ä½œä¸ºå…¶ä½™å‚æ•°è¿›è¡Œè°ƒç”¨ã€‚å½“ä½¿ç”¨ (1, 2, 3) è°ƒç”¨æ—¶ï¼ŒåŸºäº Promise çš„ fn å°†è§£æä¸ºå€¼ 6ã€‚

**ç¤ºä¾‹ 2ï¼š**

> **è¾“å…¥ï¼š**
>
> ```js
> fn = (callback, a, b, c) => {
> 	callback(a * b * c, 'Promise Rejected');
> };
>
> args = [4, 5, 6];
> ```
>
> **è¾“å‡ºï¼š**{"rejected": "Promise Rejected"}
>
> **è§£é‡Šï¼š**
>
> ```js
> const asyncFunc = promisify(fn);
> asyncFunc(4, 5, 6).catch(console.log); // "Promise Rejected"
> ```
>
> fn ä»¥å›è°ƒå‡½æ•°ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°å’Œ args ä½œä¸ºå…¶ä½™å‚æ•°è¿›è¡Œè°ƒç”¨ã€‚åœ¨å›è°ƒå‡½æ•°çš„ç¬¬äºŒä¸ªå‚æ•°ä¸­ï¼Œæ¥å—ä¸€ä¸ªé”™è¯¯æ¶ˆæ¯ï¼Œå› æ­¤å½“è°ƒç”¨ fn æ—¶ï¼ŒPromise è¢«æ‹’ç»å¹¶æºå¸¦å›è°ƒå‡½æ•°ä¸­æä¾›çš„é”™è¯¯æ¶ˆæ¯ã€‚è¯·æ³¨æ„ï¼Œä¸ç®¡å°†ä»€ä¹ˆä½œä¸ºå›è°ƒå‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°ä¼ é€’éƒ½æ— å…³ç´§è¦ã€‚

**æç¤ºï¼š**

- `1 <= args.length <= 100`
- `0 <= args[i] <= 10^4`

## è§£é¢˜æ€è·¯

1. **ç†è§£å›è°ƒå‡½æ•°ç»“æ„**ï¼š

   - `fn` æ¥å—å›è°ƒå‡½æ•° `callback` ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ï¼Œå…¶ä½™å‚æ•°ä½œä¸ºæ‰§è¡Œ `fn` çš„è¾“å…¥å‚æ•°ã€‚
   - å›è°ƒå‡½æ•°çš„å½¢å¼ä¸º `callback(result, error)`ï¼Œå¦‚æœ `error` ä¸ä¸ºç©ºï¼Œåˆ™è¡¨ç¤ºå‡½æ•°æ‰§è¡Œå¤±è´¥ï¼Œå¦åˆ™è¡¨ç¤ºæˆåŠŸã€‚

2. **åŒ…è£…ä¸º Promise**ï¼š

   - åˆ›å»ºå¹¶è¿”å›ä¸€ä¸ªæ–°å‡½æ•°ï¼Œè¯¥å‡½æ•°è¿”å›ä¸€ä¸ª Promiseã€‚
   - è¯¥å‡½æ•°ä½¿ç”¨ `fn` è¿›è¡Œè°ƒç”¨ï¼Œå¹¶ä¼ é€’ä¸€ä¸ªè‡ªå®šä¹‰å›è°ƒå‡½æ•° `callback` ä»¥åŠé™¤ `callback` ä»¥å¤–çš„å…¶ä»–å‚æ•°ã€‚

3. **å¤„ç† Promise è§£æå’Œæ‹’ç»**ï¼š

   - è‡ªå®šä¹‰ `callback` æ£€æŸ¥å›è°ƒå‡½æ•°çš„ç¬¬äºŒä¸ªå‚æ•° `error`ã€‚
   - å¦‚æœ `error` å­˜åœ¨ï¼Œåˆ™æ‹’ç» Promiseï¼›å¦åˆ™ï¼Œå°†ç¬¬ä¸€ä¸ªå‚æ•° `result` ä¼ é€’ç»™ `resolve`ï¼Œå®ç°æˆåŠŸè§£æã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(1)`ï¼Œåˆ›å»ºå’Œè¿”å› Promise çš„æ—¶é—´æ˜¯å¸¸æ•°çº§åˆ«ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(1)`ï¼Œä»…åˆ›å»ºä¸€ä¸ª Promise å¯¹è±¡å’Œå›è°ƒå‡½æ•°ï¼Œç©ºé—´éœ€æ±‚æ’å®šã€‚

## ä»£ç 

```javascript
/**
 * @param {Function} fn
 * @return {Promise<any>}
 */
var promisify = function (fn) {};
	return function (...args) {
		return new Promise((resolve, reject) => {
			const callback = (result, error) => {
				if (error) {
					reject(error);
				} else {
					resolve(result);
				}
			};
			fn(callback, ...args);
		});
	};
}

/**
 * const asyncFunc = promisify(callback => callback(42));
 * asyncFunc().then(console.log); // 42
 */
```
