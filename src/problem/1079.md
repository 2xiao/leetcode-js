---
title: 1079. æ´»å­—å°åˆ·
description: LeetCode 1079. æ´»å­—å°åˆ·é¢˜è§£ï¼ŒLetter Tile Possibilitiesï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 1079. æ´»å­—å°åˆ·
  - æ´»å­—å°åˆ·
  - Letter Tile Possibilities
  - è§£é¢˜æ€è·¯
  - å“ˆå¸Œè¡¨
  - å­—ç¬¦ä¸²
  - å›æº¯
  - è®¡æ•°
---

# 1079. æ´»å­—å°åˆ·

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`å“ˆå¸Œè¡¨`](/tag/hash-table.md) [`å­—ç¬¦ä¸²`](/tag/string.md) [`å›æº¯`](/tag/backtracking.md) [`è®¡æ•°`](/tag/counting.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/letter-tile-possibilities) [`LeetCode`](https://leetcode.com/problems/letter-tile-possibilities)

## é¢˜ç›®

You have `n` `tiles`, where each tile has one letter `tiles[i]` printed on
it.

Return _the number of possible non-empty sequences of letters_ you can make
using the letters printed on those `tiles`.

**Example 1:**

> Input: tiles = "AAB"
>
> Output: 8
>
> Explanation: The possible sequences are "A", "B", "AA", "AB", "BA", "AAB", "ABA", "BAA".

**Example 2:**

> Input: tiles = "AAABBC"
>
> Output: 188

**Example 3:**

> Input: tiles = "V"
>
> Output: 1

**Constraints:**

- `1 <= tiles.length <= 7`
- `tiles` consists of uppercase English letters.

## é¢˜ç›®å¤§æ„

ä½ æœ‰ä¸€å¥—æ´»å­—å­—æ¨¡ `tiles`ï¼Œå…¶ä¸­æ¯ä¸ªå­—æ¨¡ä¸Šéƒ½åˆ»æœ‰ä¸€ä¸ªå­—æ¯ `tiles[i]`ã€‚è¿”å›ä½ å¯ä»¥å°å‡ºçš„éç©ºå­—æ¯åºåˆ—çš„æ•°ç›®ã€‚

**æ³¨æ„ï¼š** æœ¬é¢˜ä¸­ï¼Œæ¯ä¸ªæ´»å­—å­—æ¨¡åªèƒ½ä½¿ç”¨ä¸€æ¬¡ã€‚

**ç¤ºä¾‹ 1ï¼š**

> **è¾“å…¥ï¼š** "AAB"
>
> **è¾“å‡ºï¼š** 8
>
> **è§£é‡Šï¼š** å¯èƒ½çš„åºåˆ—ä¸º "A", "B", "AA", "AB", "BA", "AAB", "ABA", "BAA"ã€‚

**ç¤ºä¾‹ 2ï¼š**

> **è¾“å…¥ï¼š** "AAABBC"
>
> **è¾“å‡ºï¼š** 188

**ç¤ºä¾‹ 3ï¼š**

> **è¾“å…¥ï¼š** "V"
>
> **è¾“å‡ºï¼š** 1

**æç¤ºï¼š**

- `1 <= tiles.length <= 7`
- `tiles` ç”±å¤§å†™è‹±æ–‡å­—æ¯ç»„æˆ

## è§£é¢˜æ€è·¯

æœ¬é¢˜çš„ç›®æ ‡æ˜¯è®¡ç®—å‡º `tiles` ä¸­æ‰€æœ‰å¯èƒ½çš„æ’åˆ—æ•°ï¼ŒåŒ…æ‹¬é•¿åº¦ä¸åŒçš„æ’åˆ—ã€‚ç”±äº `tiles` å¯èƒ½åŒ…å«é‡å¤å­—ç¬¦ï¼Œç›´æ¥ä½¿ç”¨å…¨æ’åˆ—çš„æ–¹å¼ä¼šå¯¼è‡´é‡å¤è®¡ç®—ï¼Œå› æ­¤é‡‡ç”¨**å›æº¯ + è®¡æ•°æ•°ç»„**çš„æ–¹å¼ã€‚

1. **é¢„å¤„ç†å­—ç¬¦é¢‘æ¬¡**

ç”±äº `tiles` åªåŒ…å«å¤§å†™è‹±æ–‡å­—æ¯ï¼ˆA-Zï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨**é•¿åº¦ä¸º 26 çš„æ•°ç»„** `count` æ¥è®°å½•æ¯ä¸ªå­—ç¬¦çš„å‡ºç°æ¬¡æ•°ï¼š

- ä¾‹å¦‚ `tiles = "AAB"`ï¼Œé‚£ä¹ˆ `count = [2, 1, 0, 0, ..., 0]`ã€‚

2. **å›æº¯ç”Ÿæˆæ’åˆ—**

é€’å½’å‡½æ•° `backtrack(count)` è´Ÿè´£æ„é€ æ‰€æœ‰å¯èƒ½çš„æ’åˆ—ï¼š

1. **éå† 26 ä¸ªå­—æ¯**ï¼Œå¦‚æœ `count[i] > 0`ï¼Œè¡¨ç¤ºè¯¥å­—æ¯å¯ä»¥ä½¿ç”¨ï¼š
   - é€‰æ‹©è¯¥å­—æ¯ï¼Œå°†å…¶ `count[i]--`ï¼ˆæ ‡è®°å·²ä½¿ç”¨ï¼‰ã€‚
   - é€’å½’è°ƒç”¨ `backtrack(count)` è®¡ç®—å½“å‰çŠ¶æ€ä¸‹çš„æ‰€æœ‰å¯èƒ½æ’åˆ—æ•°ã€‚
   - é€’å½’è¿”å›åï¼Œå°† `count[i]++` å¤åŸï¼Œè¿›è¡Œä¸‹ä¸€æ¬¡å°è¯•ï¼ˆ**å›æº¯**ï¼‰ã€‚
2. æ¯æ¬¡é€‰æ‹©ä¸€ä¸ªå­—æ¯éƒ½ä¼šç”Ÿæˆä¸€ä¸ªæ–°çš„æ’åˆ—ï¼Œå› æ­¤ `total += 1 + backtrack(count)`ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(n!)`ï¼Œ

  - `tiles` é•¿åº¦ä¸º `n`ï¼Œæœ€åæƒ…å†µä¸‹ `tiles` ä¸­æ‰€æœ‰å­—ç¬¦ä¸åŒï¼Œåˆ™é—®é¢˜ç­‰ä»·äºå…¨æ’åˆ—ï¼Œå¤æ‚åº¦æ¥è¿‘ `O(n!)`ã€‚
  - ä½†ç”±äºå­˜åœ¨**é‡å¤å­—ç¬¦**ï¼Œå®é™…å¤æ‚åº¦è¿œå°äº `O(n!)`ï¼Œå¤§çº¦ `O(k^n)`ï¼Œå…¶ä¸­ `k` ä¸ºä¸åŒå­—ç¬¦çš„ä¸ªæ•°ï¼Œæœ€å¤§ä¸º 26ã€‚

- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(n)`
  - `count` æ•°ç»„å›ºå®šä¸º 26ï¼Œ`O(1)`ã€‚
  - é€’å½’æ·±åº¦æœ€å¤š `O(n)`ï¼Œå› æ­¤æ€»ç©ºé—´å¤æ‚åº¦ä¸º `O(n)`ã€‚

## ä»£ç 

```javascript
/**
 * @param {string} tiles
 * @return {number}
 */
var numTilePossibilities = function (tiles) {
	let count = new Array(26).fill(0);
	for (let tile of tiles) {
		count[tile.charCodeAt() - 65]++;
	}
	const backtrack = (count) => {
		let total = 0;
		for (let i = 0; i < 26; i++) {
			if (count[i] == 0) {
				continue;
			}
			count[i]--;
			total += 1 + backtrack(count);
			count[i]++;
		}
		return total;
	};
	return backtrack(count);
};
```
