---
title: 368. æœ€å¤§æ•´é™¤å­é›†
description: LeetCode 368. æœ€å¤§æ•´é™¤å­é›†é¢˜è§£ï¼ŒLargest Divisible Subsetï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 368. æœ€å¤§æ•´é™¤å­é›†
  - æœ€å¤§æ•´é™¤å­é›†
  - Largest Divisible Subset
  - è§£é¢˜æ€è·¯
  - æ•°ç»„
  - æ•°å­¦
  - åŠ¨æ€è§„åˆ’
  - æ’åº
---

# 368. æœ€å¤§æ•´é™¤å­é›†

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ•°ç»„`](/tag/array.md) [`æ•°å­¦`](/tag/math.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md) [`æ’åº`](/tag/sorting.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/largest-divisible-subset) [`LeetCode`](https://leetcode.com/problems/largest-divisible-subset)

## é¢˜ç›®

Given a set of **distinct** positive integers `nums`, return the largest
subset `answer` such that every pair `(answer[i], answer[j])` of elements in
this subset satisfies:

- `answer[i] % answer[j] == 0`, or
- `answer[j] % answer[i] == 0`

If there are multiple solutions, return any of them.

**Example 1:**

> Input: nums = [1,2,3]
>
> Output: [1,2]
>
> Explanation: [1,3] is also accepted.

**Example 2:**

> Input: nums = [1,2,4,8]
>
> Output: [1,2,4,8]

**Constraints:**

- `1 <= nums.length <= 1000`
- `1 <= nums[i] <= 2 * 10^9`
- All the integers in `nums` are **unique**.

## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ªç”± **æ— é‡å¤** æ­£æ•´æ•°ç»„æˆçš„é›†åˆ `nums` ï¼Œè¯·ä½ æ‰¾å‡ºå¹¶è¿”å›å…¶ä¸­æœ€å¤§çš„æ•´é™¤å­é›† `answer` ï¼Œå­é›†ä¸­æ¯ä¸€å…ƒç´ å¯¹
`(answer[i], answer[j])` éƒ½åº”å½“æ»¡è¶³ï¼š

- `answer[i] % answer[j] == 0` ï¼Œæˆ–
- `answer[j] % answer[i] == 0`

å¦‚æœå­˜åœ¨å¤šä¸ªæœ‰æ•ˆè§£å­é›†ï¼Œè¿”å›å…¶ä¸­ä»»ä½•ä¸€ä¸ªå‡å¯ã€‚

**ç¤ºä¾‹ 1ï¼š**

> **è¾“å…¥ï¼š** nums = [1,2,3]
>
> **è¾“å‡ºï¼š**[1,2]
>
> **è§£é‡Šï¼š**[1,3] ä¹Ÿä¼šè¢«è§†ä¸ºæ­£ç¡®ç­”æ¡ˆã€‚

**ç¤ºä¾‹ 2ï¼š**

> **è¾“å…¥ï¼š** nums = [1,2,4,8]
>
> **è¾“å‡ºï¼š**[1,2,4,8]

**æç¤ºï¼š**

- `1 <= nums.length <= 1000`
- `1 <= nums[i] <= 2 * 10^9`
- `nums` ä¸­çš„æ‰€æœ‰æ•´æ•° **äº’ä¸ç›¸åŒ**

## è§£é¢˜æ€è·¯

1. **æ’åºæ•°ç»„**

   - å¯¹ `nums` è¿›è¡Œå‡åºæ’åºï¼Œä»¥ç¡®ä¿åœ¨åç»­éå†ä¸­å¯ä»¥åˆ©ç”¨æ•´é™¤æ€§è´¨ã€‚

2. **åŠ¨æ€è§„åˆ’æ±‚è§£**

   - å®šä¹‰ `dp[i]` è¡¨ç¤ºä»¥ `nums[i]` ç»“å°¾çš„æœ€å¤§æ•´é™¤å­é›†çš„é•¿åº¦ã€‚
   - é€šè¿‡é¢å¤–çš„ `parent[i]` æ•°ç»„è®°å½•å‰é©±èŠ‚ç‚¹ç´¢å¼•ï¼Œä»è€Œé¿å…å›æº¯æ—¶é‡å¤åˆ¤æ–­æ•´é™¤æ¡ä»¶ã€‚
   - ä½¿ç”¨åŒå±‚å¾ªç¯ï¼Œéå† `nums` ä¸­çš„æ¯ä¸€å¯¹å…ƒç´ ï¼š
     - å¯¹äºæ¯ä¸ª `nums[i]`ï¼Œéå† `nums[0]` åˆ° `nums[i - 1]`ï¼Œå¦‚æœæ»¡è¶³ `nums[i] % nums[j] === 0`ï¼š
     - åˆ™æ›´æ–° `dp[i] = max(dp[i], dp[j] + 1)`ï¼Œè¡¨ç¤ºé€šè¿‡ `nums[j]` æ‰©å±•å‡ºæ›´é•¿çš„å­é›†ã€‚
     - è®°å½•è·¯å¾„ `parent[i] = j`ï¼Œä»¥ä¾¿å›æº¯ç”Ÿæˆç»“æœã€‚

3. **å›æº¯æ„å»ºç»“æœ**

   - æ ¹æ® `dp` æ•°ç»„æ‰¾åˆ°æœ€å¤§æ•´é™¤å­é›†çš„ç»ˆç‚¹ç´¢å¼• `maxIdx`ã€‚
   - é€šè¿‡å›æº¯ `parent` æ•°ç»„ç›´æ¥ç”Ÿæˆç»“æœå­é›†ã€‚
   - ä» `parent[maxIdx]` ä¾æ¬¡å›æº¯ï¼Œå°†ç¬¦åˆæ¡ä»¶çš„å…ƒç´ åŠ å…¥ç»“æœå­é›†ã€‚

4. **è¿”å›ç»“æœ**
   - æœ€åè¿”å›å­é›† `res`ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(n^2)`ï¼Œå¤–å±‚éå†æ¯ä¸ªå…ƒç´ ï¼Œå†…å±‚æ£€æŸ¥æ‰€æœ‰å‰é©±èŠ‚ç‚¹ï¼Œå½¢æˆäºŒé‡å¾ªç¯ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œéœ€è¦é¢å¤–çš„ `dp` å’Œ `parent` æ•°ç»„ã€‚

## ä»£ç 

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var largestDivisibleSubset = function (nums) {
	nums.sort((a, b) => a - b);
	const n = nums.length;
	const dp = new Array(n).fill(1);
	const parent = new Array(n).fill(-1); // è®°å½•å‰é©±ç´¢å¼•
	let maxSize = 1,
		maxIdx = 0;
	for (let i = 1; i < n; i++) {
		for (let j = 0; j < i; j++) {
			if (nums[i] % nums[j] == 0 && dp[i] < dp[j] + 1) {
				dp[i] = dp[j] + 1;
				parent[i] = j;
			}
		}
		if (dp[i] > maxSize) {
			maxSize = dp[i];
			maxIdx = i;
		}
	}

	let res = [];
	// ç›´æ¥é€šè¿‡ parent æ•°ç»„å›æº¯
	for (let i = maxIdx; i >= 0; i = parent[i]) {
		res.push(nums[i]);
		if (parent[i] == -1) break;
	}
	return res;
};
```
