---
title: 1352. æœ€å K ä¸ªæ•°çš„ä¹˜ç§¯
description: LeetCode 1352. æœ€å K ä¸ªæ•°çš„ä¹˜ç§¯é¢˜è§£ï¼ŒProduct of the Last K Numbersï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 1352. æœ€å K ä¸ªæ•°çš„ä¹˜ç§¯
  - æœ€å K ä¸ªæ•°çš„ä¹˜ç§¯
  - Product of the Last K Numbers
  - è§£é¢˜æ€è·¯
  - è®¾è®¡
  - é˜Ÿåˆ—
  - æ•°ç»„
  - æ•°å­¦
  - æ•°æ®æµ
---

# 1352. æœ€å K ä¸ªæ•°çš„ä¹˜ç§¯

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`è®¾è®¡`](/tag/design.md) [`é˜Ÿåˆ—`](/tag/queue.md) [`æ•°ç»„`](/tag/array.md) [`æ•°å­¦`](/tag/math.md) [`æ•°æ®æµ`](/tag/data-stream.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/product-of-the-last-k-numbers) [`LeetCode`](https://leetcode.com/problems/product-of-the-last-k-numbers)

## é¢˜ç›®

Design an algorithm that accepts a stream of integers and retrieves the
product of the last `k` integers of the stream.

Implement the `ProductOfNumbers` class:

- `ProductOfNumbers()` Initializes the object with an empty stream.
- `void add(int num)` Appends the integer `num` to the stream.
- `int getProduct(int k)` Returns the product of the last `k` numbers in the current list. You can assume that always the current list has at least `k` numbers.

The test cases are generated so that, at any time, the product of any
contiguous sequence of numbers will fit into a single 32-bit integer without
overflowing.

**Example:**

> **Input**
>
> ["ProductOfNumbers","add","add","add","add","add","getProduct","getProduct","getProduct","add","getProduct"]
>
> [[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]
>
> **Output**
>
> [null,null,null,null,null,null,20,40,0,null,32]
>
> **Explanation**
>
> ```js
> ProductOfNumbers productOfNumbers = new ProductOfNumbers();
>
> productOfNumbers.add(3); // [3]
>
> productOfNumbers.add(0); // [3,0]
>
> productOfNumbers.add(2); // [3,0,2]
>
> productOfNumbers.add(5); // [3,0,2,5]
>
> productOfNumbers.add(4); // [3,0,2,5,4]
>
> productOfNumbers.getProduct(2); // return 20. The product of the last 2 numbers is 5 \* 4 = 20
>
> productOfNumbers.getProduct(3); // return 40. The product of the last 3 numbers is 2 \* 5 \* 4 = 40
>
> productOfNumbers.getProduct(4); // return 0. The product of the last 4 numbers is 0 \* 2 \* 5 \* 4 = 0
>
> productOfNumbers.add(8); // [3,0,2,5,4,8]
>
> productOfNumbers.getProduct(2); // return 32. The product of the last 2 numbers is 4 \* 8 = 32
> ```

**Constraints:**

- `0 <= num <= 100`
- `1 <= k <= 4 * 10^4`
- At most `4 * 10^4` calls will be made to `add` and `getProduct`.
- The product of the stream at any point in time will fit in a **32-bit** integer.

## é¢˜ç›®å¤§æ„

è¯·ä½ å®ç°ä¸€ä¸ªã€Œæ•°å­—ä¹˜ç§¯ç±»ã€`ProductOfNumbers`ï¼Œè¦æ±‚æ”¯æŒä¸‹è¿°ä¸¤ç§æ–¹æ³•ï¼š

1. `add(int num)`

- å°†æ•°å­— `num` æ·»åŠ åˆ°å½“å‰æ•°å­—åˆ—è¡¨çš„æœ€åé¢ã€‚

2. `getProduct(int k)`

- è¿”å›å½“å‰æ•°å­—åˆ—è¡¨ä¸­ï¼Œæœ€å `k` ä¸ªæ•°å­—çš„ä¹˜ç§¯ã€‚
- ä½ å¯ä»¥å‡è®¾å½“å‰åˆ—è¡¨ä¸­å§‹ç»ˆ **è‡³å°‘** åŒ…å« `k` ä¸ªæ•°å­—ã€‚

é¢˜ç›®æ•°æ®ä¿è¯ï¼šä»»ä½•æ—¶å€™ï¼Œä»»ä¸€è¿ç»­æ•°å­—åºåˆ—çš„ä¹˜ç§¯éƒ½åœ¨ 32-bit æ•´æ•°èŒƒå›´å†…ï¼Œä¸ä¼šæº¢å‡ºã€‚

**ç¤ºä¾‹ï¼š**

> **è¾“å…¥ï¼š**
>
> ["ProductOfNumbers","add","add","add","add","add","getProduct","getProduct","getProduct","add","getProduct"]
>
> [[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]
>
> **è¾“å‡ºï¼š**
>
> [null,null,null,null,null,null,20,40,0,null,32]
>
> **è§£é‡Šï¼š**
>
> ```js
> ProductOfNumbers productOfNumbers = new ProductOfNumbers();
>
> productOfNumbers.add(3); // [3]
>
> productOfNumbers.add(0); // [3,0]
>
> productOfNumbers.add(2); // [3,0,2]
>
> productOfNumbers.add(5); // [3,0,2,5]
>
> productOfNumbers.add(4); // [3,0,2,5,4]
>
> productOfNumbers.getProduct(2); // è¿”å› 20 ã€‚æœ€å 2 ä¸ªæ•°å­—çš„ä¹˜ç§¯æ˜¯ 5 \* 4 = 20
>
> productOfNumbers.getProduct(3); // è¿”å› 40 ã€‚æœ€å 3 ä¸ªæ•°å­—çš„ä¹˜ç§¯æ˜¯ 2 \* 5 \* 4 = 40
>
> productOfNumbers.getProduct(4); // è¿”å› 0 ã€‚æœ€å 4 ä¸ªæ•°å­—çš„ä¹˜ç§¯æ˜¯ 0 \* 2 \* 5 \* 4 = 0
>
> productOfNumbers.add(8); // [3,0,2,5,4,8]
>
> productOfNumbers.getProduct(2); // è¿”å› 32 ã€‚æœ€å 2 ä¸ªæ•°å­—çš„ä¹˜ç§¯æ˜¯ 4 \* 8 = 32
> ```

**æç¤ºï¼š**

- `add` å’Œ `getProduct` ä¸¤ç§æ“ä½œåŠ èµ·æ¥æ€»å…±ä¸ä¼šè¶…è¿‡ `40000` æ¬¡ã€‚
- `0 <= num <= 100`
- `1 <= k <= 40000`

## è§£é¢˜æ€è·¯

1. **ä½¿ç”¨å‰ç¼€ä¹˜ç§¯ï¼ˆPrefix Productï¼‰ä¼˜åŒ–è®¡ç®—**ï¼š

   - ç»´æŠ¤ä¸€ä¸ª `arr` æ•°ç»„ï¼Œå…¶ä¸­ `arr[i]` å­˜å‚¨çš„æ˜¯å‰ `i` ä¸ªæ•°å­—çš„ç´¯ç§¯ä¹˜ç§¯ï¼ˆprefix productï¼‰ã€‚
   - è¿™æ ·ï¼Œåœ¨æŸ¥è¯¢æœ€å `k` ä¸ªæ•°çš„ä¹˜ç§¯æ—¶ï¼Œå¯ä»¥ç›´æ¥ç”¨ **é™¤æ³•** è®¡ç®—ï¼š
     `getProduct(k) = arr[size]/arr[size - k]`
     è¿™ä¸€æŠ€å·§å¯ä»¥ **O(1)** è®¡ç®—ä¹˜ç§¯ï¼Œé¿å…æš´åŠ›éå†è®¡ç®—ï¼Œæå‡æŸ¥è¯¢æ•ˆç‡ã€‚

2. **å¤„ç† `0` çš„æƒ…å†µ**ï¼š
   - ç”±äºé™¤æ³•ä¸é€‚ç”¨äº 0ï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†ã€‚å½“é‡åˆ° `num == 0` æ—¶ï¼Œæ•°ç»„ `arr` éœ€è¦é‡ç½®ä¸º `[1]`ï¼Œå¹¶å°† `size` è®¾ä¸º `0`ï¼Œç›¸å½“äºæ¸…ç©ºä¹‹å‰çš„è®°å½•ã€‚
   - è¿™æ˜¯å› ä¸º `0` ä¼šç ´åå‰ç¼€ä¹˜ç§¯çš„è¿è´¯æ€§ï¼ˆ0 ä¹˜ä»»ä½•æ•°éƒ½ä¸º 0ï¼‰ï¼Œå› æ­¤ä¹‹å‰çš„æ‰€æœ‰è®¡ç®—ç»“æœéƒ½ä¸å†æœ‰æ•ˆã€‚

#### å¤æ‚åº¦åˆ†æ

- **`add(num)` æ“ä½œ**:

  - **æ—¶é—´å¤æ‚åº¦ï¼š** `O(1)`ï¼Œå› ä¸ºåªéœ€è¦åœ¨ `arr` æœ«å°¾è¿½åŠ ä¸€ä¸ªå…ƒç´ ã€‚
  - **ç©ºé—´å¤æ‚åº¦ï¼š** `O(n)`ï¼Œ`n` æ˜¯è°ƒç”¨ `add()` çš„æ¬¡æ•°ã€‚

- **`getProduct(k)` æ“ä½œ**:
  - **æ—¶é—´å¤æ‚åº¦ï¼š** `O(1)`ï¼Œå› ä¸ºè®¡ç®—ä¹˜ç§¯åªéœ€ä¸€æ¬¡é™¤æ³•è¿ç®—ã€‚
  - **ç©ºé—´å¤æ‚åº¦ï¼š** `O(1)`ï¼Œå› ä¸ºä¸ä¼šä½¿ç”¨é¢å¤–çš„å­˜å‚¨ç©ºé—´ã€‚

## ä»£ç 

```javascript
var ProductOfNumbers = function () {
	this.arr = [1];
	this.size = 0;
};

/**
 * @param {number} num
 * @return {void}
 */
ProductOfNumbers.prototype.add = function (num) {
	if (num == 0) {
		this.arr = [1];
		this.size = 0;
	} else {
		this.arr.push(this.arr[this.size] * num);
		this.size++;
	}
};

/**
 * @param {number} k
 * @return {number}
 */
ProductOfNumbers.prototype.getProduct = function (k) {
	if (k > this.size) return 0;
	return this.arr[this.size] / this.arr[this.size - k];
};
```
