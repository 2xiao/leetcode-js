---
title: 1657. ç¡®å®šä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦æ¥è¿‘
description: LeetCode 1657. ç¡®å®šä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦æ¥è¿‘é¢˜è§£ï¼ŒDetermine if Two Strings Are Closeï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 1657. ç¡®å®šä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦æ¥è¿‘
  - ç¡®å®šä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦æ¥è¿‘
  - Determine if Two Strings Are Close
  - è§£é¢˜æ€è·¯
  - å“ˆå¸Œè¡¨
  - å­—ç¬¦ä¸²
  - è®¡æ•°
  - æ’åº
---

# 1657. ç¡®å®šä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦æ¥è¿‘

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`å“ˆå¸Œè¡¨`](/tag/hash-table.md) [`å­—ç¬¦ä¸²`](/tag/string.md) [`è®¡æ•°`](/tag/counting.md) [`æ’åº`](/tag/sorting.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/determine-if-two-strings-are-close) [`LeetCode`](https://leetcode.com/problems/determine-if-two-strings-are-close)

## é¢˜ç›®

Two strings are considered **close** if you can attain one from the other
using the following operations:

- Operation 1: Swap any two **existing** characters.
- For example, `a _b_ cd _e_ -> a _e_ cd _b_`
- Operation 2: Transform **every** occurrence of one **existing** character into another **existing** character, and do the same with the other character.
- For example, `_aa_ c _abb_ -> _bb_ c _baa_` (all `a`'s turn into `b`'s, and all `b`'s turn into `a`'s)

You can use the operations on either string as many times as necessary.

Given two strings, `word1` and `word2`, return `true` _if_`word1` _and_`word2`
_are**close** , and _`false` _otherwise._

**Example 1:**

> Input: word1 = "abc", word2 = "bca"
>
> Output: true
>
> Explanation: You can attain word2 from word1 in 2 operations.
>
> Apply Operation 1: "a _bc_ " -> "a _cb_ "
>
> Apply Operation 1: "_a_ c _b_ " -> "_b_ c _a_ "

**Example 2:**

> Input: word1 = "a", word2 = "aa"
>
> Output: false
>
> Explanation: It is impossible to attain word2 from word1, or vice versa, in any number of operations.

**Example 3:**

> Input: word1 = "cabbba", word2 = "abbccc"
>
> Output: true
>
> Explanation: You can attain word2 from word1 in 3 operations.
>
> Apply Operation 1: "ca _b_ bb _a_ " -> "ca _a_ bb _b_ "
>
> Apply Operation 2: "_c_ aa _bbb_ " -> "_b_ aa _ccc_ "
>
> Apply Operation 2: "_baa_ ccc" -> "_abb_ ccc"

**Constraints:**

- `1 <= word1.length, word2.length <= 10^5`
- `word1` and `word2` contain only lowercase English letters.

## é¢˜ç›®å¤§æ„

å¦‚æœå¯ä»¥ä½¿ç”¨ä»¥ä¸‹æ“ä½œä»ä¸€ä¸ªå­—ç¬¦ä¸²å¾—åˆ°å¦ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œåˆ™è®¤ä¸ºä¸¤ä¸ªå­—ç¬¦ä¸² **æ¥è¿‘** ï¼š

- æ“ä½œ 1ï¼šäº¤æ¢ä»»æ„ä¸¤ä¸ª **ç°æœ‰** å­—ç¬¦ã€‚
  - ä¾‹å¦‚ï¼Œ`a _b_ cd _e_ -> a _e_ cd _b_`
- æ“ä½œ 2ï¼šå°†ä¸€ä¸ª **ç°æœ‰** å­—ç¬¦çš„æ¯æ¬¡å‡ºç°è½¬æ¢ä¸ºå¦ä¸€ä¸ª **ç°æœ‰** å­—ç¬¦ï¼Œå¹¶å¯¹å¦ä¸€ä¸ªå­—ç¬¦æ‰§è¡Œç›¸åŒçš„æ“ä½œã€‚
  - ä¾‹å¦‚ï¼Œ` _aa_ c _abb_ -> _bb_ c _baa_`ï¼ˆæ‰€æœ‰ `a` è½¬åŒ–ä¸º `b` ï¼Œè€Œæ‰€æœ‰çš„ `b` è½¬æ¢ä¸º `a` ï¼‰

ä½ å¯ä»¥æ ¹æ®éœ€è¦å¯¹ä»»æ„ä¸€ä¸ªå­—ç¬¦ä¸²å¤šæ¬¡ä½¿ç”¨è¿™ä¸¤ç§æ“ä½œã€‚

ç»™ä½ ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œ`word1` å’Œ `word2` ã€‚å¦‚æœ `word1` å’Œ `word2` æ¥è¿‘ ï¼Œå°±è¿”å› `true`ï¼›å¦åˆ™ï¼Œè¿”å› `false` ã€‚

**ç¤ºä¾‹ 1ï¼š**

> **è¾“å…¥ï¼š** word1 = "abc", word2 = "bca"
>
> **è¾“å‡ºï¼š** true
>
> **è§£é‡Šï¼š** 2 æ¬¡æ“ä½œä» word1 è·å¾— word2 ã€‚
>
> æ‰§è¡Œæ“ä½œ 1ï¼š"a _bc_ " -> "a _cb_ "
>
> æ‰§è¡Œæ“ä½œ 1ï¼š"_a_ c _b_ " -> "_b_ c _a_ "

**ç¤ºä¾‹ 2ï¼š**

> **è¾“å…¥ï¼š** word1 = "a", word2 = "aa"
>
> **è¾“å‡ºï¼š** false
>
> **è§£é‡Šï¼š** ä¸ç®¡æ‰§è¡Œå¤šå°‘æ¬¡æ“ä½œï¼Œéƒ½æ— æ³•ä» word1 å¾—åˆ° word2 ï¼Œåä¹‹äº¦ç„¶ã€‚

**ç¤ºä¾‹ 3ï¼š**

> **è¾“å…¥ï¼š** word1 = "cabbba", word2 = "abbccc"
>
> **è¾“å‡ºï¼š** true
>
> **è§£é‡Šï¼š** 3 æ¬¡æ“ä½œä» word1 è·å¾— word2 ã€‚
>
> æ‰§è¡Œæ“ä½œ 1ï¼š"ca _b_ bb _a_ " -> "ca _a_ bb _b_ "
>
> æ‰§è¡Œæ“ä½œ 2ï¼š"_c_ aa _bbb_ " -> "_b_ aa _ccc_ "
>
> æ‰§è¡Œæ“ä½œ 2ï¼š"_baa_ ccc" -> "_abb_ ccc"

**æç¤ºï¼š**

- `1 <= word1.length, word2.length <= 10^5`
- `word1` å’Œ `word2` ä»…åŒ…å«å°å†™è‹±æ–‡å­—æ¯

## è§£é¢˜æ€è·¯

1. **é•¿åº¦æ£€æŸ¥**ï¼š

   - é¦–å…ˆæ£€æŸ¥ `word1` å’Œ `word2` çš„é•¿åº¦ã€‚å¦‚æœå®ƒä»¬çš„é•¿åº¦ä¸åŒï¼Œåˆ™ç›´æ¥è¿”å› `false`ã€‚

2. **å­—ç¬¦ç»Ÿè®¡**ï¼š

   - å®šä¹‰ä¸€ä¸ªè¾…åŠ©å‡½æ•° `count(str)` æ¥ç»Ÿè®¡å­—ç¬¦ä¸²ä¸­æ¯ä¸ªå­—ç¬¦çš„å‡ºç°æ¬¡æ•°ã€‚
   - ä½¿ç”¨ `Map` æ¥å­˜å‚¨å­—ç¬¦åŠå…¶å¯¹åº”çš„å‡ºç°æ¬¡æ•°ã€‚
   - åœ¨ç»Ÿè®¡æ—¶ï¼Œéå†å­—ç¬¦ä¸²ä¸­çš„æ¯ä¸ªå­—ç¬¦ï¼Œå°†å…¶æ·»åŠ åˆ° `Map` ä¸­ï¼Œå¹¶æ›´æ–°å…¶è®¡æ•°ã€‚

3. **ç”Ÿæˆå”¯ä¸€æ ‡è¯†**ï¼š

   - åœ¨ `count` å‡½æ•°ä¸­ï¼Œå°† `Map` çš„é”®ï¼ˆå­—ç¬¦ï¼‰å’Œå¯¹åº”çš„å€¼ï¼ˆå‡ºç°æ¬¡æ•°ï¼‰åˆ†åˆ«æå–å‡ºæ¥ï¼Œå¹¶è¿›è¡Œæ’åºã€‚
   - å°†å­—ç¬¦å’Œé¢‘ç‡æ•°ç»„è½¬æ¢ä¸ºä»¥é€—å·åˆ†éš”çš„å­—ç¬¦ä¸²ï¼Œä½œä¸ºå”¯ä¸€æ ‡è¯†ã€‚

4. **æ¯”è¾ƒç»“æœ**ï¼š
   - è°ƒç”¨ `count` å‡½æ•°åˆ†åˆ«å¯¹ `word1` å’Œ `word2` è¿›è¡Œç»Ÿè®¡ï¼Œå¹¶æ¯”è¾ƒå®ƒä»¬çš„å­—ç¬¦å’Œé¢‘ç‡æ ‡è¯†ã€‚å¦‚æœä¸¤è€…ç›¸åŒï¼Œè¿”å› `true`ï¼›å¦åˆ™è¿”å› `false`ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œå…¶ä¸­ `n` æ˜¯å­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œç»Ÿè®¡å­—ç¬¦çš„æ—¶é—´æ˜¯ `O(n)`ã€‚è™½ç„¶åœ¨æ’åºå­—ç¬¦å’Œé¢‘ç‡æ—¶ï¼Œæ¯æ¬¡æ“ä½œéƒ½æ˜¯ `O(m log m)`ï¼Œå…¶ä¸­ `m` æ˜¯ä¸åŒå­—ç¬¦çš„æ•°é‡ï¼Œä½†æ˜¯ç”±äºå­—ç¬¦é›†æœ‰é™ï¼ˆå‡è®¾æœ€å¤šæœ‰ 26 ä¸ªå°å†™å­—æ¯ï¼‰ï¼Œè¿™åœ¨å®é™…æƒ…å†µä¸‹æ˜¯å¸¸æ•°çº§åˆ«çš„ï¼Œå› æ­¤æ•´ä½“å¤æ‚åº¦è¿‘ä¼¼ä¸º `O(n)`ã€‚

- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(1)`ï¼Œåœ¨æœ€åçš„æƒ…å†µä¸‹ï¼Œå¯èƒ½éœ€è¦å­˜å‚¨æ‰€æœ‰å­—ç¬¦åŠå…¶å‡ºç°æ¬¡æ•°ï¼Œç©ºé—´å¤æ‚åº¦å–å†³äºå­—ç¬¦é›†çš„å¤§å°ï¼Œä½†ä»ç„¶æ˜¯å¸¸æ•°çº§åˆ«ã€‚

## ä»£ç 

```javascript
/**
 * @param {string} word1
 * @param {string} word2
 * @return {boolean}
 */
var closeStrings = function (word1, word2) {
	if (word1.length !== word2.length) return false;
	const count = (str) => {
		let map = new Map();
		for (let char of str) {
			map.set(char, (map.get(char) || 0) + 1);
		}
		return [...map.keys(), ...map.values()].sort().join(',');
	};
	return count(word1) == count(word2);
};
```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ | åŠ›æ‰£ |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 859 | äº²å¯†å­—ç¬¦ä¸² | [[âœ“]](/problem/0859.md) |  [`å“ˆå¸Œè¡¨`](/tag/hash-table.md) [`å­—ç¬¦ä¸²`](/tag/string.md) | ğŸŸ¢ | [ğŸ€„ï¸](https://leetcode.cn/problems/buddy-strings) [ğŸ”—](https://leetcode.com/problems/buddy-strings) |
| 1247 | äº¤æ¢å­—ç¬¦ä½¿å¾—å­—ç¬¦ä¸²ç›¸åŒ |  |  [`è´ªå¿ƒ`](/tag/greedy.md) [`æ•°å­¦`](/tag/math.md) [`å­—ç¬¦ä¸²`](/tag/string.md) | ğŸŸ  | [ğŸ€„ï¸](https://leetcode.cn/problems/minimum-swaps-to-make-strings-equal) [ğŸ”—](https://leetcode.com/problems/minimum-swaps-to-make-strings-equal) |
| 1347 | åˆ¶é€ å­—æ¯å¼‚ä½è¯çš„æœ€å°æ­¥éª¤æ•° |  |  [`å“ˆå¸Œè¡¨`](/tag/hash-table.md) [`å­—ç¬¦ä¸²`](/tag/string.md) [`è®¡æ•°`](/tag/counting.md) | ğŸŸ  | [ğŸ€„ï¸](https://leetcode.cn/problems/minimum-number-of-steps-to-make-two-strings-anagram) [ğŸ”—](https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram) |