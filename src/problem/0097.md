# [97. äº¤é”™å­—ç¬¦ä¸²](https://leetcode.com/problems/interleaving-string)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`å­—ç¬¦ä¸²`](/tag/string.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/interleaving-string)

## é¢˜ç›®

Given strings `s1`, `s2`, and `s3`, find whether `s3` is formed by an
**interleaving** of `s1` and `s2`.

An **interleaving** of two strings `s` and `t` is a configuration where `s`
and `t` are divided into `n` and `m` substrings respectively, such that:

- `s = s1 + s2 + ... + sn`
- `t = t1 + t2 + ... + tm`
- `|n - m| <= 1`
- The **interleaving** is `s1 + t1 + s2 + t2 + s3 + t3 + ...` or `t1 + s1 + t2 + s2 + t3 + s3 + ...`

**Note:** `a + b` is the concatenation of strings `a` and `b`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg)

> Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
>
> Output: true
>
> Explanation: One way to obtain s3 is:
>
> Split s1 into s1 = "aa" + "bc" + "c", and s2 into s2 = "dbbc" + "a".
>
> Interleaving the two splits, we get "aa" + "dbbc" + "bc" + "a" + "c" = "aadbbcbcac".
>
> Since s3 can be obtained by interleaving s1 and s2, we return true.

**Example 2:**

> Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
>
> Output: false
>
> Explanation: Notice how it is impossible to interleave s2 with any other string to obtain s3.

**Example 3:**

> Input: s1 = "", s2 = "", s3 = ""
>
> Output: true

**Constraints:**

- `0 <= s1.length, s2.length <= 100`
- `0 <= s3.length <= 200`
- `s1`, `s2`, and `s3` consist of lowercase English letters.

**Follow up:** Could you solve it using only `O(s2.length)` additional memory
space?

## é¢˜ç›®å¤§æ„

## è§£é¢˜æ€è·¯

### æ€è·¯ä¸€ï¼šåŠ¨æ€è§„åˆ’

1. **åŠ¨æ€è§„åˆ’**ï¼š

   - ä½¿ç”¨ä¸€ä¸ªäºŒç»´å¸ƒå°”æ•°ç»„ `dp`ï¼Œå…¶ä¸­ `dp[i][j]` è¡¨ç¤º `s3` çš„å‰ `i + j` ä¸ªå­—ç¬¦å¯ä»¥ç”± `s1` çš„å‰ `i` ä¸ªå­—ç¬¦å’Œ `s2` çš„å‰ `j` ä¸ªå­—ç¬¦äº¤é”™å½¢æˆã€‚

2. **çŠ¶æ€è½¬ç§»**ï¼š

   - åˆå§‹åŒ– `dp[0][0]` ä¸º `true`ï¼Œè¡¨ç¤ºç©ºå­—ç¬¦ä¸²å¯ä»¥ç”±ä¸¤ä¸ªç©ºå­—ç¬¦ä¸²äº¤é”™å½¢æˆã€‚
   - ç„¶åå¡«å…… `dp` è¡¨ï¼š
     - å¦‚æœ `s1[i-1]` å’Œ `s3[i+j-1]` ç›¸ç­‰ï¼Œåˆ™ `dp[i][j]` å¯ä»¥ä» `dp[i-1][j]` è½¬ç§»è€Œæ¥ã€‚
     - å¦‚æœ `s2[j-1]` å’Œ `s3[i+j-1]` ç›¸ç­‰ï¼Œåˆ™ `dp[i][j]` å¯ä»¥ä» `dp[i][j-1]` è½¬ç§»è€Œæ¥ã€‚

3. **æœ€ç»ˆç»“æœ**ï¼š
   - `dp[s1.length][s2.length]` è¡¨ç¤º `s3` æ˜¯å¦å¯ä»¥ç”± `s1` å’Œ `s2` äº¤é”™å½¢æˆã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(m * n)`ï¼Œéœ€è¦å¡«å……æ•´ä¸ª `dp` æ•°ç»„ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(m * n)`ï¼Œä½¿ç”¨çš„ DP æ•°ç»„ã€‚

---

### æ€è·¯äºŒï¼šåŠ¨æ€è§„åˆ’+å‹ç¼©çŠ¶æ€

è¦é€šè¿‡ä½¿ç”¨ä¸€ç»´æ•°ç»„ä»£æ›¿äºŒç»´æ•°ç»„ï¼Œå¯ä»¥å°†æ€è·¯ä¸€çš„ç©ºé—´å¤æ‚åº¦ä¼˜åŒ–åˆ° `O(n)`ã€‚

- æˆ‘ä»¬åªéœ€è¦ä¿ç•™å½“å‰è¡Œçš„ä¿¡æ¯ï¼Œå› æ­¤å¯ä»¥ç”¨ä¸€ä¸ªé•¿åº¦ä¸º `n + 1` çš„ä¸€ç»´æ•°ç»„æ¥å­˜å‚¨çŠ¶æ€ã€‚
- åˆ›å»ºä¸€ä¸ªé•¿åº¦ä¸º `n + 1` çš„ä¸€ç»´æ•°ç»„ `dp`ï¼Œå¹¶åˆå§‹åŒ– `dp[0]` ä¸º `true`ã€‚
- å¤„ç† `s2` çš„å­—ç¬¦ï¼Œåˆå§‹åŒ– `dp` çš„ç¬¬ä¸€è¡Œã€‚
- å¤„ç† `s1` çš„å­—ç¬¦ï¼Œæ›´æ–° `dp` æ•°ç»„ã€‚
- åœ¨æ›´æ–°æ—¶ï¼Œä»åå‘å‰æ›´æ–°ï¼Œä»¥é˜²æ­¢è¦†ç›–ä¹‹å‰çš„æ•°æ®ã€‚ä½¿ç”¨å½“å‰ `dp[j]` å’Œ `dp[j - 1]` æ¥åˆ¤æ–­æ˜¯å¦å¯ä»¥äº¤é”™å½¢æˆ `s3` çš„ç›¸åº”éƒ¨åˆ†ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(m * n)`ï¼Œä¸ä¹‹å‰ç›¸åŒã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œé€šè¿‡ä½¿ç”¨ä¸€ç»´æ•°ç»„ä»£æ›¿äºŒç»´æ•°ç»„æ¥å‡å°‘ç©ºé—´ä½¿ç”¨ã€‚

### æ€»ç»“ï¼š

## ä»£ç 

:::: code-tabs

@tab åŠ¨æ€è§„åˆ’

```javascript
/**
 * @param {string} s1
 * @param {string} s2
 * @param {string} s3
 * @return {boolean}
 */
var isInterleave = function (s1, s2, s3) {
	const m = s1.length,
		n = s2.length;

	if (m + n !== s3.length) return false;

	let dp = new Array(m + 1).fill(0).map((i) => new Array(n + 1).fill(false));
	dp[0][0] = true;

	for (let i = 0; i <= m; i++) {
		for (let j = 0; j <= n; j++) {
			if (i > 0 && s1[i - 1] == s3[i - 1 + j]) {
				dp[i][j] = dp[i][j] || dp[i - 1][j];
			}
			if (j > 0 && s2[j - 1] == s3[i + j - 1]) {
				dp[i][j] = dp[i][j] || dp[i][j - 1];
			}
		}
	}

	return dp[m][n];
};
```

@tab åŠ¨æ€è§„åˆ’+å‹ç¼©çŠ¶æ€

```javascript
/**
 * @param {string} s1
 * @param {string} s2
 * @param {string} s3
 * @return {boolean}
 */
var isInterleave = function (s1, s2, s3) {
	const m = s1.length,
		n = s2.length;
	if (m + n !== s3.length) return false;

	let dp = new Array(n + 1);
	dp[0] = true;

	for (let j = 0; j <= n; j++) {
		dp[j] = j === 0 || (dp[j - 1] && s2[j - 1] === s3[j - 1]);
	}

	for (let i = 1; i <= m; i++) {
		dp[0] = dp[0] && s1[i - 1] === s3[i - 1];
		for (let j = 1; j <= n; j++) {
			dp[j] =
				(dp[j] && s1[i - 1] === s3[i + j - 1]) ||
				(dp[j - 1] && s2[j - 1] === s3[i + j - 1]);
		}
	}

	return dp[n];
};
```

::::
