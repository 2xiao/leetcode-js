---
title: 1466. é‡æ–°è§„åˆ’è·¯çº¿
description: LeetCode 1466. é‡æ–°è§„åˆ’è·¯çº¿é¢˜è§£ï¼ŒReorder Routes to Make All Paths Lead to the City Zeroï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 1466. é‡æ–°è§„åˆ’è·¯çº¿
  - é‡æ–°è§„åˆ’è·¯çº¿
  - Reorder Routes to Make All Paths Lead to the City Zero
  - è§£é¢˜æ€è·¯
  - æ·±åº¦ä¼˜å…ˆæœç´¢
  - å¹¿åº¦ä¼˜å…ˆæœç´¢
  - å›¾
---

# 1466. é‡æ–°è§„åˆ’è·¯çº¿

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/tag/breadth-first-search.md) [`å›¾`](/tag/graph.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero) [`LeetCode`](https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero)

## é¢˜ç›®

There are `n` cities numbered from `0` to `n - 1` and `n - 1` roads such that
there is only one way to travel between two different cities (this network
form a tree). Last year, The ministry of transport decided to orient the roads
in one direction because they are too narrow.

Roads are represented by `connections` where `connections[i] = [ai, bi]`
represents a road from city `ai` to city `bi`.

This year, there will be a big event in the capital (city `0`), and many
people want to travel to this city.

Your task consists of reorienting some roads such that each city can visit the
city `0`. Return the **minimum** number of edges changed.

It's **guaranteed** that each city can reach city `0` after reorder.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/05/13/sample_1_1819.png)

> Input: n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]
>
> Output: 3
>
> Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/05/13/sample_2_1819.png)

> Input: n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]
>
> Output: 2
>
> Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).

**Example 3:**

> Input: n = 3, connections = [[1,0],[2,0]]
>
> Output: 0

**Constraints:**

- `2 <= n <= 5 * 10^4`
- `connections.length == n - 1`
- `connections[i].length == 2`
- `0 <= ai, bi <= n - 1`
- `ai != bi`

## é¢˜ç›®å¤§æ„

`n` åº§åŸå¸‚ï¼Œä» `0` åˆ° `n-1` ç¼–å·ï¼Œå…¶é—´å…±æœ‰ `n-1`
æ¡è·¯çº¿ã€‚å› æ­¤ï¼Œè¦æƒ³åœ¨ä¸¤åº§ä¸åŒåŸå¸‚ä¹‹é—´æ—…è¡Œåªæœ‰å”¯ä¸€ä¸€æ¡è·¯çº¿å¯ä¾›é€‰æ‹©ï¼ˆè·¯çº¿ç½‘å½¢æˆä¸€é¢—æ ‘ï¼‰ã€‚å»å¹´ï¼Œäº¤é€šè¿è¾“éƒ¨å†³å®šé‡æ–°è§„åˆ’è·¯çº¿ï¼Œä»¥æ”¹å˜äº¤é€šæ‹¥å µçš„çŠ¶å†µã€‚

è·¯çº¿ç”¨ `connections` è¡¨ç¤ºï¼Œå…¶ä¸­ `connections[i] = [a, b]` è¡¨ç¤ºä»åŸå¸‚ `a` åˆ° `b` çš„ä¸€æ¡æœ‰å‘è·¯çº¿ã€‚

ä»Šå¹´ï¼ŒåŸå¸‚ 0 å°†ä¼šä¸¾åŠä¸€åœºå¤§å‹æ¯”èµ›ï¼Œå¾ˆå¤šæ¸¸å®¢éƒ½æƒ³å‰å¾€åŸå¸‚ 0 ã€‚

è¯·ä½ å¸®åŠ©é‡æ–°è§„åˆ’è·¯çº¿æ–¹å‘ï¼Œä½¿æ¯ä¸ªåŸå¸‚éƒ½å¯ä»¥è®¿é—®åŸå¸‚ 0 ã€‚è¿”å›éœ€è¦å˜æ›´æ–¹å‘çš„æœ€å°è·¯çº¿æ•°ã€‚

é¢˜ç›®æ•°æ® **ä¿è¯** æ¯ä¸ªåŸå¸‚åœ¨é‡æ–°è§„åˆ’è·¯çº¿æ–¹å‘åéƒ½èƒ½åˆ°è¾¾åŸå¸‚ 0 ã€‚

**ç¤ºä¾‹ 1ï¼š**

**![](https://assets.leetcode-cn.com/aliyun-lc-
upload/uploads/2020/05/30/sample_1_1819.png)**

> **è¾“å…¥ï¼š** n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]
>
> **è¾“å‡ºï¼š** 3
>
> **è§£é‡Šï¼š** æ›´æ”¹ä»¥çº¢è‰²æ˜¾ç¤ºçš„è·¯çº¿çš„æ–¹å‘ï¼Œä½¿æ¯ä¸ªåŸå¸‚éƒ½å¯ä»¥åˆ°è¾¾åŸå¸‚ 0 ã€‚

**ç¤ºä¾‹ 2ï¼š**

**![](https://assets.leetcode-cn.com/aliyun-lc-
upload/uploads/2020/05/30/sample_2_1819.png)**

> **è¾“å…¥ï¼š** n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]
>
> **è¾“å‡ºï¼š** 2
>
> **è§£é‡Šï¼š** æ›´æ”¹ä»¥çº¢è‰²æ˜¾ç¤ºçš„è·¯çº¿çš„æ–¹å‘ï¼Œä½¿æ¯ä¸ªåŸå¸‚éƒ½å¯ä»¥åˆ°è¾¾åŸå¸‚ 0 ã€‚

**ç¤ºä¾‹ 3ï¼š**

> **è¾“å…¥ï¼š** n = 3, connections = [[1,0],[2,0]]
>
> **è¾“å‡ºï¼š** 0

**æç¤ºï¼š**

- `2 <= n <= 5 * 10^4`
- `connections.length == n-1`
- `connections[i].length == 2`
- `0 <= connections[i][0], connections[i][1] <= n-1`
- `connections[i][0] != connections[i][1]`

## è§£é¢˜æ€è·¯

å¯ä»¥å°†é—®é¢˜è½¬åŒ–ä¸ºä¸€ä¸ª **æ— å‘å›¾çš„éå†é—®é¢˜**ï¼š

- é¢˜ç›®ç»™å‡ºä¸€ä¸ªåŒ…å« `n` ä¸ªåŸå¸‚å’Œ `n-1` æ¡é“è·¯çš„ **æœ‰å‘å›¾**ï¼Œè¿™äº›é“è·¯å¯èƒ½ä¸æ˜¯éƒ½æŒ‡å‘åŸå¸‚ 0ã€‚
- ç›®æ ‡æ˜¯è°ƒæ•´æœ€å°‘çš„é“è·¯æ–¹å‘ï¼Œä½¿æ‰€æœ‰è·¯å¾„éƒ½èƒ½ä»ä»»æ„åŸå¸‚åˆ°è¾¾åŸå¸‚ 0ï¼Œä½¿åŸå¸‚ 0 æˆä¸ºå”¯ä¸€çš„æ ¹èŠ‚ç‚¹ã€‚

1. æ–°å»ºä¸€ä¸ª **æ— å‘å›¾**ï¼Œå°†æ¯æ¡æœ‰å‘è¾¹ `[city1, city2]` è½¬åŒ–ä¸ºæ— å‘è¾¹ï¼Œå¹¶ç”¨æ­£è´Ÿ `1` è®°å½•è¾¹çš„æ–¹å‘ï¼š
   - å¦‚æœè¾¹çš„æ–¹å‘æ˜¯ **ä» `city1` æŒ‡å‘ `city2`**ï¼Œæ ‡è®°ä¸ºæ­£å‘è¾¹ `(+1)`ã€‚
   - å¦‚æœè¾¹çš„æ–¹å‘æ˜¯ **ä» `city2` æŒ‡å‘ `city1`**ï¼Œæ ‡è®°ä¸ºåå‘è¾¹ `(-1)`ã€‚
2. ä½¿ç”¨ **æ·±åº¦ä¼˜å…ˆæœç´¢ (DFS)** æˆ– **å¹¿åº¦ä¼˜å…ˆæœç´¢ (BFS)** éå†å›¾ï¼š
   - ä»åŸå¸‚ 0 å‡ºå‘ï¼Œæ²¿ç€æ‰€æœ‰é‚»å±…é€’å½’éå†ã€‚
   - å¦‚æœé‡åˆ°æ­£å‘è¾¹ï¼Œåˆ™éœ€è¦åè½¬è¾¹ï¼Œè®¡æ•°åŠ  1ã€‚
   - å¦‚æœæ˜¯åå‘è¾¹ï¼Œåˆ™æ— éœ€åè½¬ã€‚
3. éå†å®Œæˆåï¼Œç»Ÿè®¡éœ€è¦åè½¬çš„è¾¹çš„æ•°é‡ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦ï¼š** `O(n)`ï¼Œæ„å»ºé‚»æ¥è¡¨éœ€è¦ `O(n)`ï¼ŒDFS æˆ– BFS éå†éœ€è¦ `O(n)`ã€‚
- **ç©ºé—´å¤æ‚åº¦ï¼š** `O(n)`ï¼Œé‚»æ¥è¡¨ã€è®¿é—®æ•°ç»„å’Œé€’å½’æ ˆ/é˜Ÿåˆ—çš„å¤§å°éƒ½æ˜¯ `O(n)`ã€‚

## ä»£ç 

::: code-tabs

@tab æ·±åº¦ä¼˜å…ˆæœç´¢ (DFS) è§£æ³•

```javascript
/**
 * @param {number} n
 * @param {number[][]} connections
 * @return {number}
 */
var minReorder = function (n, connections) {
	// æ„å»ºé‚»æ¥è¡¨ï¼Œè®°å½•è¾¹çš„æ–¹å‘
	let graph = new Array(n).fill().map(() => new Array());
	for (let [city1, city2] of connections) {
		graph[city1].push([city2, 1]); // æ­£å‘è¾¹
		graph[city2].push([city1, -1]); // åå‘è¾¹
	}

	let count = 0;
	const visited = new Array(n).fill(false);

	const dfs = (node) => {
		visited[node] = true;
		for (let [neighbor, direction] of graph[node]) {
			if (!visited[neighbor]) {
				if (direction === 1) count++; // æ­£å‘è¾¹éœ€è¦åè½¬
				dfs(neighbor);
			}
		}
	};

	dfs(0); // ä»èŠ‚ç‚¹ 0 å¼€å§‹ DFS éå†
	return count;
};
```

@tab å¹¿åº¦ä¼˜å…ˆæœç´¢ (BFS) è§£æ³•

```javascript
/**
 * @param {number} n
 * @param {number[][]} connections
 * @return {number}
 */
var minReorder = function (n, connections) {
	// æ„å»ºé‚»æ¥è¡¨ï¼Œè®°å½•è¾¹çš„æ–¹å‘
	let graph = new Array(n).fill().map(() => new Array());
	for (let [city1, city2] of connections) {
		graph[city1].push([city2, 1]); // æ­£å‘è¾¹
		graph[city2].push([city1, -1]); // åå‘è¾¹
	}

	let count = 0;
	const visited = new Array(n).fill(false);
	const queue = [0];
	visited[0] = true;

	while (queue.length) {
		const node = queue.shift();
		for (let [neighbor, direction] of graph[node]) {
			if (!visited[neighbor]) {
				if (direction === 1) count++; // æ­£å‘è¾¹éœ€è¦åè½¬
				visited[neighbor] = true;
				queue.push(neighbor);
			}
		}
	}

	return count;
};
```

:::

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ | åŠ›æ‰£ |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 2858 | å¯ä»¥åˆ°è¾¾æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„æœ€å°‘è¾¹åè½¬æ¬¡æ•° |  |  [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/tag/breadth-first-search.md) [`å›¾`](/tag/graph.md) `1+` | ğŸ”´ | [ğŸ€„ï¸](https://leetcode.cn/problems/minimum-edge-reversals-so-every-node-is-reachable) [ğŸ”—](https://leetcode.com/problems/minimum-edge-reversals-so-every-node-is-reachable) |