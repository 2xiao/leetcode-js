---
title: 1417. é‡æ–°æ ¼å¼åŒ–å­—ç¬¦ä¸²
description: LeetCode 1417. é‡æ–°æ ¼å¼åŒ–å­—ç¬¦ä¸²é¢˜è§£ï¼ŒReformat The Stringï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 1417. é‡æ–°æ ¼å¼åŒ–å­—ç¬¦ä¸²
  - é‡æ–°æ ¼å¼åŒ–å­—ç¬¦ä¸²
  - Reformat The String
  - è§£é¢˜æ€è·¯
  - å­—ç¬¦ä¸²
---

# 1417. é‡æ–°æ ¼å¼åŒ–å­—ç¬¦ä¸²

ğŸŸ¢ <font color=#15bd66>Easy</font>&emsp; ğŸ”–&ensp; [`å­—ç¬¦ä¸²`](/tag/string.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/reformat-the-string) [`LeetCode`](https://leetcode.com/problems/reformat-the-string)

## é¢˜ç›®

You are given an alphanumeric string `s`. (**Alphanumeric string** is a string
consisting of lowercase English letters and digits).

You have to find a permutation of the string where no letter is followed by
another letter and no digit is followed by another digit. That is, no two
adjacent characters have the same type.

Return _the reformatted string_ or return **an empty string** if it is
impossible to reformat the string.

**Example 1:**

> Input: s = "a0b1c2"
>
> Output: "0a1b2c"
>
> Explanation: No two adjacent characters have the same type in "0a1b2c". "a0b1c2", "0a1b2c", "0c2a1b" are also valid permutations.

**Example 2:**

> Input: s = "leetcode"
>
> Output: ""
>
> Explanation: "leetcode" has only characters so we cannot separate them by digits.

**Example 3:**

> Input: s = "1229857369"
>
> Output: ""
>
> Explanation: "1229857369" has only digits so we cannot separate them by characters.

**Constraints:**

- `1 <= s.length <= 500`
- `s` consists of only lowercase English letters and/or digits.

## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ªæ··åˆäº†æ•°å­—å’Œå­—æ¯çš„å­—ç¬¦ä¸² `s`ï¼Œå…¶ä¸­çš„å­—æ¯å‡ä¸ºå°å†™è‹±æ–‡å­—æ¯ã€‚

è¯·ä½ å°†è¯¥å­—ç¬¦ä¸²é‡æ–°æ ¼å¼åŒ–ï¼Œä½¿å¾—ä»»æ„ä¸¤ä¸ªç›¸é‚»å­—ç¬¦çš„ç±»å‹éƒ½ä¸åŒã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå­—æ¯åé¢åº”è¯¥è·Ÿç€æ•°å­—ï¼Œè€Œæ•°å­—åé¢åº”è¯¥è·Ÿç€å­—æ¯ã€‚

è¯·ä½ è¿”å› **é‡æ–°æ ¼å¼åŒ–å** çš„å­—ç¬¦ä¸²ï¼›å¦‚æœæ— æ³•æŒ‰è¦æ±‚é‡æ–°æ ¼å¼åŒ–ï¼Œåˆ™è¿”å›ä¸€ä¸ª **ç©ºå­—ç¬¦ä¸²** ã€‚

**ç¤ºä¾‹ 1ï¼š**

> **è¾“å…¥ï¼š** s = "a0b1c2"
>
> **è¾“å‡ºï¼š** "0a1b2c"
>
> **è§£é‡Šï¼š** "0a1b2c" ä¸­ä»»æ„ä¸¤ä¸ªç›¸é‚»å­—ç¬¦çš„ç±»å‹éƒ½ä¸åŒã€‚ "a0b1c2", "0a1b2c", "0c2a1b" ä¹Ÿæ˜¯æ»¡è¶³é¢˜ç›®è¦æ±‚çš„ç­”æ¡ˆã€‚

**ç¤ºä¾‹ 2ï¼š**

> **è¾“å…¥ï¼š** s = "leetcode"
>
> **è¾“å‡ºï¼š** ""
>
> **è§£é‡Šï¼š** "leetcode" ä¸­åªæœ‰å­—æ¯ï¼Œæ‰€ä»¥æ— æ³•æ»¡è¶³é‡æ–°æ ¼å¼åŒ–çš„æ¡ä»¶ã€‚

**ç¤ºä¾‹ 3ï¼š**

> **è¾“å…¥ï¼š** s = "1229857369"
>
> **è¾“å‡ºï¼š** ""
>
> **è§£é‡Šï¼š** "1229857369" ä¸­åªæœ‰æ•°å­—ï¼Œæ‰€ä»¥æ— æ³•æ»¡è¶³é‡æ–°æ ¼å¼åŒ–çš„æ¡ä»¶ã€‚

**ç¤ºä¾‹ 4ï¼š**

> **è¾“å…¥ï¼š** s = "covid2019"
>
> **è¾“å‡ºï¼š** "c2o0v1i9d"

**ç¤ºä¾‹ 5ï¼š**

> **è¾“å…¥ï¼š** s = "ab123"
>
> **è¾“å‡ºï¼š** "1a2b3"

**æç¤ºï¼š**

- `1 <= s.length <= 500`
- `s` ä»…ç”±å°å†™è‹±æ–‡å­—æ¯å’Œ/æˆ–æ•°å­—ç»„æˆã€‚

## è§£é¢˜æ€è·¯

1. **åˆ†ç±»å­—ç¬¦**ï¼š

   - éå†å­—ç¬¦ä¸² `s`ï¼Œå°†å…¶ä¸­çš„æ•°å­—å­˜å…¥æ•°ç»„ `digit`ï¼Œå­—æ¯å­˜å…¥æ•°ç»„ `alphabet`ã€‚
   - ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ `/^[0-9]$/` åˆ¤æ–­å­—ç¬¦æ˜¯å¦ä¸ºæ•°å­—ã€‚

2. **æ£€æŸ¥æ˜¯å¦å¯é‡æ’**ï¼š

   - å¦‚æœæ•°å­—ä¸å­—æ¯çš„æ•°é‡å·®ç»å¯¹å€¼å¤§äº 1ï¼Œåˆ™æ— æ³•äº¤æ›¿æ’åˆ—ï¼Œè¿”å›ç©ºå­—ç¬¦ä¸² `""`ã€‚

3. **äº¤æ›¿æ’åˆ—**ï¼š

   - æ ¹æ® `digit` å’Œ `alphabet` çš„é•¿åº¦å†³å®šå“ªä¸€ç»„å…ˆå¼€å§‹ï¼ˆé•¿çš„é‚£ç»„å…ˆï¼‰ã€‚
   - éå†è¾ƒé•¿æ•°ç»„ï¼ŒåŒæ—¶ä»ä¸¤ç»„ä¸­äº¤æ›¿æ‹¼æ¥å­—ç¬¦ã€‚

4. **æ‹¼æ¥ç»“æœ**ï¼š

   - å°†äº¤æ›¿æ‹¼æ¥çš„ç»“æœå­˜å‚¨åˆ°å­—ç¬¦ä¸² `res` ä¸­ã€‚
   - å¦‚æœæŸç»„é•¿åº¦å¤šå‡ºä¸€ä¸ªå­—ç¬¦ï¼Œä¼šè‡ªåŠ¨æ‹¼æ¥åˆ°æœ«å°¾ã€‚

5. **è¿”å›ç»“æœ**ï¼š
   - è¿”å›æœ€ç»ˆçš„ `res`ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œå…¶ä¸­ `n` æ˜¯å­—ç¬¦ä¸² `s` çš„é•¿åº¦ï¼Œéå†å­—ç¬¦ä¸²ä¸€æ¬¡ï¼Œæ‹¼æ¥ç»“æœä¹Ÿåªéœ€çº¿æ€§æ—¶é—´ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œéœ€è¦å­˜å‚¨ä¸¤ä¸ªæ•°ç»„ `digit` å’Œ `alphabet`ã€‚

## ä»£ç 

```javascript
/**
 * @param {string} s
 * @return {string}
 */
var reformat = function (s) {
	let digit = [];
	let alphabet = [];

	// åˆ†ç±»å­—ç¬¦
	for (let char of s) {
		if (/^[0-9]$/.test(char)) {
			digit.push(char);
		} else {
			alphabet.push(char);
		}
	}

	// æ£€æŸ¥æ˜¯å¦å¯é‡æ’
	if (Math.abs(digit.length - alphabet.length) > 1) return '';

	// äº¤æ›¿æ’åˆ—
	let res = '';
	let longer = digit.length >= alphabet.length ? digit : alphabet;
	let shorter = digit.length < alphabet.length ? digit : alphabet;

	for (let i = 0; i < longer.length; i++) {
		res += longer[i];
		if (shorter[i]) {
			res += shorter[i];
		}
	}

	return res;
};
```
