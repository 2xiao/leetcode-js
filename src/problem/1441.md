# [1441. ç”¨æ ˆæ“ä½œæ„å»ºæ•°ç»„](https://leetcode.com/problems/build-an-array-with-stack-operations)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ ˆ`](/outline/tag/stack.md) [`æ•°ç»„`](/outline/tag/array.md) [`æ¨¡æ‹Ÿ`](/outline/tag/simulation.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/build-an-array-with-stack-operations)

## é¢˜ç›®

You are given an integer array `target` and an integer `n`.

You have an empty stack with the two following operations:

  * **`"Push"`**: pushes an integer to the top of the stack.
  * **`"Pop"`**: removes the integer on the top of the stack.

You also have a stream of the integers in the range `[1, n]`.

Use the two stack operations to make the numbers in the stack (from the bottom
to the top) equal to `target`. You should follow the following rules:

  * If the stream of the integers is not empty, pick the next integer from the stream and push it to the top of the stack.
  * If the stack is not empty, pop the integer at the top of the stack.
  * If, at any moment, the elements in the stack (from the bottom to the top) are equal to `target`, do not read new integers from the stream and do not do more operations on the stack.

Return _the stack operations needed to build_`target` following the mentioned
rules. If there are multiple valid answers, return **any of them**.



**Example 1:**

> Input: target = [1,3], n = 3
> 
> Output: ["Push","Push","Pop","Push"]
> 
> Explanation: Initially the stack s is empty. The last element is the top of the stack.
> 
> Read 1 from the stream and push it to the stack. s = [1].
> 
> Read 2 from the stream and push it to the stack. s = [1,2].
> 
> Pop the integer on the top of the stack. s = [1].
> 
> Read 3 from the stream and push it to the stack. s = [1,3].

**Example 2:**

> Input: target = [1,2,3], n = 3
> 
> Output: ["Push","Push","Push"]
> 
> Explanation: Initially the stack s is empty. The last element is the top of the stack.
> 
> Read 1 from the stream and push it to the stack. s = [1].
> 
> Read 2 from the stream and push it to the stack. s = [1,2].
> 
> Read 3 from the stream and push it to the stack. s = [1,2,3].

**Example 3:**

> Input: target = [1,2], n = 4
> 
> Output: ["Push","Push"]
> 
> Explanation: Initially the stack s is empty. The last element is the top of the stack.
> 
> Read 1 from the stream and push it to the stack. s = [1].
> 
> Read 2 from the stream and push it to the stack. s = [1,2].
> 
> Since the stack (from the bottom to the top) is equal to target, we stop the stack operations.
> 
> The answers that read integer 3 from the stream are not accepted.

**Constraints:**

  * `1 <= target.length <= 100`
  * `1 <= n <= 100`
  * `1 <= target[i] <= n`
  * `target` is strictly increasing.


## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ªæ•°ç»„ `target` å’Œä¸€ä¸ªæ•´æ•° `n`ã€‚æ¯æ¬¡è¿­ä»£ï¼Œéœ€è¦ä» `list = { 1 , 2 , 3 ..., n }` ä¸­ä¾æ¬¡è¯»å–ä¸€ä¸ªæ•°å­—ã€‚

è¯·ä½¿ç”¨ä¸‹è¿°æ“ä½œæ¥æ„å»ºç›®æ ‡æ•°ç»„ `target` ï¼š

- `"Push"`ï¼šä» `list` ä¸­è¯»å–ä¸€ä¸ªæ–°å…ƒç´ ï¼Œ å¹¶å°†å…¶æ¨å…¥æ•°ç»„ä¸­ã€‚
- `"Pop"`ï¼šåˆ é™¤æ•°ç»„ä¸­çš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚
- å¦‚æœç›®æ ‡æ•°ç»„æ„å»ºå®Œæˆï¼Œå°±åœæ­¢è¯»å–æ›´å¤šå…ƒç´ ã€‚
- é¢˜ç›®æ•°æ®ä¿è¯ç›®æ ‡æ•°ç»„ä¸¥æ ¼é€’å¢ï¼Œå¹¶ä¸”åªåŒ…å« `1` åˆ° `n` ä¹‹é—´çš„æ•°å­—ã€‚

## è§£é¢˜æ€è·¯

æ“ä½œçš„å¯¹è±¡æ˜¯ `1` åˆ° `n` æŒ‰é¡ºåºæ’åˆ—çš„æ•°å­—ï¼Œå› ä¸º `target` ä¸­æ•°å­—æ˜¯ä¸¥æ ¼é€’å¢çš„ï¼Œå› æ­¤åªè¦éå† `1 ~ n` ï¼Œæ¯æ¬¡æ“ä½œä¸€ä¸ªæ•°å­—æ—¶ï¼Œä¸ `target` çš„ç¬¬ `idx` ä¸ªå…ƒç´ å¯¹æ¯”ï¼š

- å¦‚æœå®ƒä¸ `target[idx]` ç›¸ç­‰ï¼Œåˆ™åªéœ€è¦å°†å®ƒ `Push` å…¥æ ˆå³å¯ï¼Œ`idx++`ï¼›
- å¦‚æœå®ƒä¸ `target[idx]` ä¸­ï¼Œå¯ä»¥å…ˆå°†å…¶ `Push` å…¥æ ˆï¼Œç´§æ¥ç€ `Pop` å‡ºæ ˆï¼›
- å½“ `idx` ä¸ `target` çš„é•¿åº¦ç›¸ç­‰æ—¶ï¼Œè¯´æ˜ç›®æ ‡æ•°ç»„å·²ç»æ„å»ºå®Œæˆï¼Œè°ƒå‡ºå¾ªç¯ï¼›

## ä»£ç 

```javascript
/**
 * @param {number[]} target
 * @param {number} n
 * @return {string[]}
 */
var buildArray = function (target, n) {
  let idx = 0;
  let res = [];
  for (let i = 1; i <= n; i++) {
    if (target[idx] != i) {
      res.push("Push");
      res.push("Pop");
    } else if (target[idx] === i) {
      res.push("Push");
      idx++;
    }
    if (idx === target.length) break;
  }
  return res;
};
```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 2869 | [æ”¶é›†å…ƒç´ çš„æœ€å°‘æ“ä½œæ¬¡æ•°](https://leetcode.com/problems/minimum-operations-to-collect-elements) |  |  [`ä½è¿ç®—`](/outline/tag/bit-manipulation.md) [`æ•°ç»„`](/outline/tag/array.md) [`å“ˆå¸Œè¡¨`](/outline/tag/hash-table.md) | <font color=#15bd66>Easy</font> |

<style>
.blue {
    background-color: #096dd9;
    padding: 0.25rem 0.5rem;
    margin: 0;
    font-size: 0.85em;
    border-radius: 3px;
    color: white;
    font-weight: 500;
}
table th:first-of-type { width: 10%; }
table th:nth-of-type(2) { width: 35%; }
table th:nth-of-type(3) { width: 10%; }
table th:nth-of-type(4) { width: 35%; }
table th:nth-of-type(5) { width: 10%; }
</style>
