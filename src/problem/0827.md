---
title: 827. æœ€å¤§äººå·¥å²›
description: LeetCode 827. æœ€å¤§äººå·¥å²›é¢˜è§£ï¼ŒMaking A Large Islandï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 827. æœ€å¤§äººå·¥å²›
  - æœ€å¤§äººå·¥å²›
  - Making A Large Island
  - è§£é¢˜æ€è·¯
  - æ·±åº¦ä¼˜å…ˆæœç´¢
  - å¹¿åº¦ä¼˜å…ˆæœç´¢
  - å¹¶æŸ¥é›†
  - æ•°ç»„
  - çŸ©é˜µ
---

# 827. æœ€å¤§äººå·¥å²›

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/tag/breadth-first-search.md) [`å¹¶æŸ¥é›†`](/tag/union-find.md) [`æ•°ç»„`](/tag/array.md) [`çŸ©é˜µ`](/tag/matrix.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/making-a-large-island) [`LeetCode`](https://leetcode.com/problems/making-a-large-island)

## é¢˜ç›®

You are given an `n x n` binary matrix `grid`. You are allowed to change **at
most one** `0` to be `1`.

Return _the size of the largest**island** in_ `grid` _after applying this
operation_.

An **island** is a 4-directionally connected group of `1`s.

**Example 1:**

> Input: grid = [[1,0],[0,1]]
>
> Output: 3
>
> Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.

**Example 2:**

> Input: grid = [[1,1],[1,0]]
>
> Output: 4
>
> Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 4.

**Example 3:**

> Input: grid = [[1,1],[1,1]]
>
> Output: 4
>
> Explanation: Can't change any 0 to 1, only one island with area = 4.

**Constraints:**

- `n == grid.length`
- `n == grid[i].length`
- `1 <= n <= 500`
- `grid[i][j]` is either `0` or `1`.

## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ªå¤§å°ä¸º `n x n` äºŒè¿›åˆ¶çŸ©é˜µ `grid` ã€‚**æœ€å¤š** åªèƒ½å°†ä¸€æ ¼ `0` å˜æˆ `1` ã€‚

è¿”å›æ‰§è¡Œæ­¤æ“ä½œåï¼Œ`grid` ä¸­æœ€å¤§çš„å²›å±¿é¢ç§¯æ˜¯å¤šå°‘ï¼Ÿ

**å²›å±¿** ç”±ä¸€ç»„ä¸Šã€ä¸‹ã€å·¦ã€å³å››ä¸ªæ–¹å‘ç›¸è¿çš„ `1` å½¢æˆã€‚

**ç¤ºä¾‹ 1:**

> **è¾“å…¥:** grid = [[1, 0], [0, 1]]
>
> **è¾“å‡º:** 3
>
> **è§£é‡Š:** å°†ä¸€æ ¼ 0 å˜æˆ 1ï¼Œæœ€ç»ˆè¿é€šä¸¤ä¸ªå°å²›å¾—åˆ°é¢ç§¯ä¸º 3 çš„å²›å±¿ã€‚

**ç¤ºä¾‹ 2:**

> **è¾“å…¥:** grid =\*\*\*\*[[1, 1], [1, 0]]
>
> **è¾“å‡º:** 4
>
> **è§£é‡Š:** å°†ä¸€æ ¼ 0 å˜æˆ 1ï¼Œå²›å±¿çš„é¢ç§¯æ‰©å¤§ä¸º 4ã€‚

**ç¤ºä¾‹ 3:**

> **è¾“å…¥:** grid = [[1, 1], [1, 1]]
>
> **è¾“å‡º:** 4
>
> **è§£é‡Š:** æ²¡æœ‰ 0 å¯ä»¥è®©æˆ‘ä»¬å˜æˆ 1ï¼Œé¢ç§¯ä¾ç„¶ä¸º 4ã€‚

**æç¤ºï¼š**

- `n == grid.length`
- `n == grid[i].length`
- `1 <= n <= 500`
- `grid[i][j]` ä¸º `0` æˆ– `1`

## è§£é¢˜æ€è·¯

- **1ï¼šæ ‡è®°æ‰€æœ‰å²›å±¿**  
  ä½¿ç”¨ `DFS` éå†ç½‘æ ¼ï¼Œå°†æ¯ä¸ªå²›å±¿èµ‹äºˆå”¯ä¸€ç¼–å· `islandId`(ä» 2 å¼€å§‹ç´¯åŠ )ï¼ŒåŒæ—¶è®¡ç®—å…¶é¢ç§¯å¹¶å­˜å‚¨åˆ° `islandSize` ä¸­ã€‚

- **2ï¼šè®°å½•æœ€å¤§åˆå§‹å²›å±¿é¢ç§¯**  
  å¦‚æœæ²¡æœ‰ `0`ï¼Œç›´æ¥è¿”å›æ‰€æœ‰å²›å±¿çš„é¢ç§¯æœ€å¤§å€¼ã€‚

- **3ï¼šæ¨¡æ‹Ÿæ”¹å˜ `0` ä¸º `1`**
  - éå†ç½‘æ ¼ä¸­æ‰€æœ‰çš„ `0` ä½ç½®ã€‚
  - æ£€æŸ¥è¯¥ä½ç½®å‘¨å›´çš„ç›¸é‚»å²›å±¿ï¼Œé¿å…é‡å¤è®¡ç®—åŒä¸€å²›å±¿é¢ç§¯ã€‚
  - å°†ç›¸é‚»å²›å±¿çš„é¢ç§¯ç›¸åŠ ï¼Œå¹¶è®¡ç®—æœ€å¤§å¯èƒ½çš„æ–°å²›å±¿é¢ç§¯ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(n^2)`

  - éå†ç½‘æ ¼æ ‡è®°å²›å±¿ï¼š`O(n^2)`
  - éå† `0` å¹¶è®¡ç®—æœ€å¤§é¢ç§¯ï¼š`O(n^2)`

- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(n^2)`ï¼Œä¸»è¦ç”¨äºå­˜å‚¨å²›å±¿æ ‡è®°å’Œé˜Ÿåˆ—ã€‚

## ä»£ç 

```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var largestIsland = function (grid) {
	const n = grid.length;
	const dirc = [
		[1, 0],
		[-1, 0],
		[0, 1],
		[0, -1]
	]; // æ–¹å‘æ•°ç»„
	let islandId = 2; // ä»2å¼€å§‹æ ‡è®°å²›å±¿
	let islandSize = new Map();

	// DFS æ ‡è®°å²›å±¿å¹¶è®¡ç®—é¢ç§¯
	const dfs = (i, j, id) => {
		let queue = [[i, j]];
		let size = 0;
		grid[i][j] = id;

		while (queue.length) {
			let [x, y] = queue.pop();
			size++;
			for (let [dx, dy] of dirc) {
				const nx = x + dx;
				const ny = y + dy;
				if (nx >= 0 && nx < n && ny >= 0 && ny < n && grid[nx][ny] == 1) {
					grid[nx][ny] = id;
					queue.push([nx, ny]);
				}
			}
		}
		return size;
	};

	// æ ‡è®°æ‰€æœ‰å²›å±¿å¹¶è®¡ç®—åˆå§‹å²›å±¿é¢ç§¯
	for (let i = 0; i < n; i++) {
		for (let j = 0; j < n; j++) {
			if (grid[i][j] == 1) {
				islandSize.set(islandId, dfs(i, j, islandId));
				islandId++;
			}
		}
	}

	// åˆå§‹åŒ–æœ€å¤§å²›å±¿é¢ç§¯
	let maxIsland = Math.max(...islandSize.values(), 0);

	// éå†æ¯ä¸ªæ°´åŸŸï¼ˆ0ï¼‰ï¼Œå°è¯•è¿æ¥ç›¸é‚»å²›å±¿
	for (let i = 0; i < n; i++) {
		for (let j = 0; j < n; j++) {
			if (grid[i][j] == 0) {
				let seen = new Set();
				let newSize = 1;
				for (let [dx, dy] of dirc) {
					const nx = i + dx;
					const ny = j + dy;
					if (nx >= 0 && nx < n && ny >= 0 && ny < n && grid[nx][ny] > 1) {
						let id = grid[nx][ny];
						if (!seen.has(id)) {
							seen.add(id);
							newSize += islandSize.get(id);
						}
					}
				}
				maxIsland = Math.max(maxIsland, newSize);
			}
		}
	}

	return maxIsland;
};
```
