---
title: 2542. æœ€å¤§å­åºåˆ—çš„åˆ†æ•°
description: LeetCode 2542. æœ€å¤§å­åºåˆ—çš„åˆ†æ•°é¢˜è§£ï¼ŒMaximum Subsequence Scoreï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 2542. æœ€å¤§å­åºåˆ—çš„åˆ†æ•°
  - æœ€å¤§å­åºåˆ—çš„åˆ†æ•°
  - Maximum Subsequence Score
  - è§£é¢˜æ€è·¯
  - è´ªå¿ƒ
  - æ•°ç»„
  - æ’åº
  - å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰
---

# 2542. æœ€å¤§å­åºåˆ—çš„åˆ†æ•°

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`è´ªå¿ƒ`](/tag/greedy.md) [`æ•°ç»„`](/tag/array.md) [`æ’åº`](/tag/sorting.md) [`å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰`](/tag/heap-priority-queue.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/maximum-subsequence-score) [`LeetCode`](https://leetcode.com/problems/maximum-subsequence-score)

## é¢˜ç›®

You are given two **0-indexed** integer arrays `nums1` and `nums2` of equal
length `n` and a positive integer `k`. You must choose a **subsequence** of
indices from `nums1` of length `k`.

For chosen indices `i0`, `i1`, ..., `ik - 1`, your **score** is defined as:

- The sum of the selected elements from `nums1` multiplied with the **minimum** of the selected elements from `nums2`.
- It can defined simply as: `(nums1[i0] + nums1[i1] +...+ nums1[ik - 1]) * min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])`.

Return _the **maximum** possible score._

A **subsequence** of indices of an array is a set that can be derived from the
set `{0, 1, ..., n-1}` by deleting some or no elements.

**Example 1:**

> Input: nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3
>
> Output: 12
>
> Explanation:
>
> The four possible subsequence scores are:
>
> - We choose the indices 0, 1, and 2 with score = `(1+3+3) * min(2,1,3) = 7`.
> - We choose the indices 0, 1, and 3 with score = `(1+3+2) * min(2,1,4) = 6`.
> - We choose the indices 0, 2, and 3 with score = `(1+3+2) * min(2,3,4) = 12`.
> - We choose the indices 1, 2, and 3 with score = `(3+3+2) * min(1,3,4) = 8`.
>
> Therefore, we return the max score, which is 12.

**Example 2:**

> Input: nums1 = [4,2,3,1,1], nums2 = [7,5,10,9,6], k = 1
>
> Output: 30
>
> Explanation:
>
> Choosing index 2 is optimal: `nums1[2] * nums2[2] = 3 * 10 = 30` is the maximum possible score.

**Constraints:**

- `n == nums1.length == nums2.length`
- `1 <= n <= 10^5`
- `0 <= nums1[i], nums2[j] <= 10^5`
- `1 <= k <= n`

## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸¤ä¸ªä¸‹æ ‡ä» **0** å¼€å§‹çš„æ•´æ•°æ•°ç»„ `nums1` å’Œ `nums2` ï¼Œä¸¤è€…é•¿åº¦éƒ½æ˜¯ `n` ï¼Œå†ç»™ä½ ä¸€ä¸ªæ­£æ•´æ•° `k` ã€‚ä½ å¿…é¡»ä»
`nums1` ä¸­é€‰ä¸€ä¸ªé•¿åº¦ä¸º `k` çš„ **å­åºåˆ—** å¯¹åº”çš„ä¸‹æ ‡ã€‚

å¯¹äºé€‰æ‹©çš„ä¸‹æ ‡ `i0` ï¼Œ`i1` ï¼Œ...ï¼Œ `ik - 1` ï¼Œä½ çš„ **åˆ†æ•°** å®šä¹‰å¦‚ä¸‹ï¼š

- `nums1` ä¸­ä¸‹æ ‡å¯¹åº”å…ƒç´ æ±‚å’Œï¼Œä¹˜ä»¥ `nums2` ä¸­ä¸‹æ ‡å¯¹åº”å…ƒç´ çš„ **æœ€å°å€¼** ã€‚
- ç”¨å…¬å¼è¡¨ç¤ºï¼š `(nums1[i0] + nums1[i1] +...+ nums1[ik - 1]) * min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])` ã€‚

è¯·ä½ è¿”å› **æœ€å¤§** å¯èƒ½çš„åˆ†æ•°ã€‚

ä¸€ä¸ªæ•°ç»„çš„ **å­åºåˆ—** ä¸‹æ ‡æ˜¯é›†åˆ `{0, 1, ..., n-1}` ä¸­åˆ é™¤è‹¥å¹²å…ƒç´ å¾—åˆ°çš„å‰©ä½™é›†åˆï¼Œä¹Ÿå¯ä»¥ä¸åˆ é™¤ä»»ä½•å…ƒç´ ã€‚

**ç¤ºä¾‹ 1ï¼š**

> **è¾“å…¥ï¼š** nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3
>
> **è¾“å‡ºï¼š** 12
>
> **è§£é‡Šï¼š**
>
> å››ä¸ªå¯èƒ½çš„å­åºåˆ—åˆ†æ•°ä¸ºï¼š
>
> - é€‰æ‹©ä¸‹æ ‡ 0 ï¼Œ1 å’Œ 2 ï¼Œå¾—åˆ°åˆ†æ•° `(1+3+3) * min(2,1,3) = 7`ã€‚
> - é€‰æ‹©ä¸‹æ ‡ 0 ï¼Œ1 å’Œ 3 ï¼Œå¾—åˆ°åˆ†æ•° `(1+3+2) * min(2,1,4) = 6`ã€‚
> - é€‰æ‹©ä¸‹æ ‡ 0 ï¼Œ2 å’Œ 3 ï¼Œå¾—åˆ°åˆ†æ•° `(1+3+2) * min(2,3,4) = 12`ã€‚
> - é€‰æ‹©ä¸‹æ ‡ 1 ï¼Œ2 å’Œ 3 ï¼Œå¾—åˆ°åˆ†æ•° `(3+3+2) * min(1,3,4) = 8`ã€‚
>
> æ‰€ä»¥æœ€å¤§åˆ†æ•°ä¸º 12 ã€‚

**ç¤ºä¾‹ 2ï¼š**

> **è¾“å…¥ï¼š** nums1 = [4,2,3,1,1], nums2 = [7,5,10,9,6], k = 1
>
> **è¾“å‡ºï¼š** 30
>
> **è§£é‡Šï¼š**
>
> é€‰æ‹©ä¸‹æ ‡ 2 æœ€ä¼˜ï¼š`nums1[2] * nums2[2] = 3 * 10 = 30` æ˜¯æœ€å¤§å¯èƒ½åˆ†æ•°ã€‚

**æç¤ºï¼š**

- `n == nums1.length == nums2.length`
- `1 <= n <= 10^5`
- `0 <= nums1[i], nums2[j] <= 10^5`
- `1 <= k <= n`

## è§£é¢˜æ€è·¯

1. **æŒ‰æƒé‡æ’åº**ï¼šå°† `nums2` çš„å€¼ä½œä¸ºæ’åºä¾æ®ï¼Œä»å¤§åˆ°å°æ’åºï¼Œè¿™æ ·ç¡®ä¿æˆ‘ä»¬ä¼˜å…ˆå¤„ç†è¾ƒå¤§çš„æœ€å°æƒé‡å€¼ã€‚

2. **ç»´æŠ¤æœ€å¤§å­åºåˆ—å’Œ**ï¼š

   - ä½¿ç”¨ä¸€ä¸ªå¤§å°ä¸º `k` çš„**æœ€å°å †**å­˜å‚¨å½“å‰é€‰å®šçš„ `nums1` ä¸­çš„æ•°å­—ã€‚
   - ä¿æŒå †ä¸­æœ‰ `k` ä¸ªæ•°æ—¶ï¼Œå…¶æ€»å’Œå³ä¸ºå½“å‰çš„æœ€å¤§å­åºåˆ—å’Œã€‚

3. **è®¡ç®—åˆ†æ•°**ï¼š
   - éå† `nums2` çš„æƒé‡æ•°ç»„ï¼Œå¯¹äºæ¯ä¸ªæƒé‡ï¼Œå°è¯•å°†å¯¹åº”çš„ `nums1` ä¸­çš„æ•°å­—åŠ å…¥å †ï¼š
     - å¦‚æœå †å¤§å°å°äº `k`ï¼Œç›´æ¥åŠ å…¥ã€‚
     - å¦‚æœå †å¤§å°ç­‰äº `k`ï¼Œç”¨å½“å‰å€¼æ›¿æ¢å †é¡¶ï¼ˆæœ€å°å€¼ï¼‰ä»¥å°è¯•å¢åŠ æ€»å’Œï¼Œå¹¶æ›´æ–°æœ€å¤§å¾—åˆ†ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(n log n + n log k)`

  - **æ’åº**ï¼šå¯¹ `nums2` é™åºæ’åºï¼Œæ—¶é—´å¤æ‚åº¦ä¸º `O(n log n)`ã€‚
  - **å †æ“ä½œ**ï¼šéå†æ¯ä¸ªå…ƒç´ æ—¶ï¼Œå †ä¸­æ’å…¥æˆ–ç§»é™¤çš„æ“ä½œä¸º `O(log k)`ï¼Œæ€»å…±æœ‰ `n` ä¸ªå…ƒç´ ï¼Œå› æ­¤æ—¶é—´å¤æ‚åº¦ä¸º `O(n log k)`ã€‚
  - æ€»æ—¶é—´å¤æ‚åº¦ï¼š`O(n log n + n log k)`ã€‚

- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(n + k)`
  - å­˜å‚¨å †çš„ç©ºé—´å¤æ‚åº¦ä¸º `O(k)`ã€‚
  - å­˜å‚¨æ’åºåçš„æ•°ç»„éœ€è¦ `O(n)`ã€‚
  - æ€»ç©ºé—´å¤æ‚åº¦ä¸º `O(n + k)`ã€‚

## ä»£ç 

```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @param {number} k
 * @return {number}
 */
var maxScore = function (nums1, nums2, k) {
	// å°† nums2 çš„æƒé‡å’Œå¯¹åº”çš„ nums1 ç»„åˆï¼Œå¹¶æŒ‰æƒé‡é™åºæ’åº
	const pairs = nums1.map((num, idx) => [num, nums2[idx]]);
	pairs.sort((a, b) => b[1] - a[1]);

	let curSum = 0; // å½“å‰å †ä¸­æ•°å­—çš„å’Œ
	let maxScore = 0; // æœ€å¤§å¾—åˆ†
	let minHeap = new MinHeap(); // æœ€å°å †

	// éå†æ¯ä¸ªæƒé‡
	for (let i = 0; i < pairs.length; i++) {
		const [num1, num2] = pairs[i];

		// å°†å½“å‰ num1 åŠ å…¥å †
		minHeap.insert(num1);
		curSum += num1;

		// å¦‚æœå †ä¸­å…ƒç´ å·²ç»è¾¾åˆ° k ä¸ªï¼Œè®¡ç®—å¾—åˆ†
		if (minHeap.size() == k) {
			maxScore = Math.max(maxScore, curSum * num2);
			curSum -= minHeap.pop();
		}
	}

	return maxScore;
};

class MinHeap {
	constructor() {
		this.heap = [];
	}
	insert(num) {
		this.heap.push(num);
		this.heapifyUp(this.heap.length - 1);
	}
	pop() {
		if (this.heap.length == 0) return null;
		const top = this.heap[0];
		const last = this.heap.pop();
		if (this.heap.length) {
			this.heap[0] = last;
			this.heapifyDown(0);
		}
		return top;
	}
	size() {
		return this.heap.length;
	}
	heapifyUp(i) {
		while (i) {
			const parent = ((i - 1) / 2) | 0;
			if (this.heap[parent] > this.heap[i]) {
				[this.heap[i], this.heap[parent]] = [this.heap[parent], this.heap[i]];
				i = parent;
			} else {
				break;
			}
		}
	}
	heapifyDown(i) {
		let left = i * 2 + 1,
			right = i * 2 + 2,
			min = i;
		if (left < this.heap.length && this.heap[left] < this.heap[min]) {
			min = left;
		}
		if (right < this.heap.length && this.heap[right] < this.heap[min]) {
			min = right;
		}
		if (min !== i) {
			[this.heap[i], this.heap[min]] = [this.heap[min], this.heap[i]];
			this.heapifyDown(min);
		}
	}
}
```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ | åŠ›æ‰£ |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 502 | IPO | [[âœ“]](/problem/0502.md) |  [`è´ªå¿ƒ`](/tag/greedy.md) [`æ•°ç»„`](/tag/array.md) [`æ’åº`](/tag/sorting.md) `1+` | ğŸ”´ | [ğŸ€„ï¸](https://leetcode.cn/problems/ipo) [ğŸ”—](https://leetcode.com/problems/ipo) |
| 857 | é›‡ä½£ K åå·¥äººçš„æœ€ä½æˆæœ¬ |  |  [`è´ªå¿ƒ`](/tag/greedy.md) [`æ•°ç»„`](/tag/array.md) [`æ’åº`](/tag/sorting.md) `1+` | ğŸ”´ | [ğŸ€„ï¸](https://leetcode.cn/problems/minimum-cost-to-hire-k-workers) [ğŸ”—](https://leetcode.com/problems/minimum-cost-to-hire-k-workers) |