# [1106. è§£æå¸ƒå°”è¡¨è¾¾å¼](https://leetcode.com/problems/parsing-a-boolean-expression)

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`æ ˆ`](/tag/stack.md) [`é€’å½’`](/tag/recursion.md) [`å­—ç¬¦ä¸²`](/tag/string.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/parsing-a-boolean-expression)

## é¢˜ç›®

A **boolean expression** is an expression that evaluates to either `true` or
`false`. It can be in one of the following shapes:

- `'t'` that evaluates to `true`.
- `'f'` that evaluates to `false`.
- `'!(subExpr)'` that evaluates to **the logical NOT** of the inner expression `subExpr`.
- `'&(subExpr1, subExpr2, ..., subExprn)'` that evaluates to **the logical AND** of the inner expressions `subExpr1, subExpr2, ..., subExprn` where `n >= 1`.
- `'|(subExpr1, subExpr2, ..., subExprn)'` that evaluates to **the logical OR** of the inner expressions `subExpr1, subExpr2, ..., subExprn` where `n >= 1`.

Given a string `expression` that represents a **boolean expression** , return
_the evaluation of that expression_.

It is **guaranteed** that the given expression is valid and follows the given
rules.

**Example 1:**

> Input: expression = "&(|(f))"
>
> Output: false
>
> Explanation:
>
> First, evaluate |(f) --> f. The expression is now "&(f)".
>
> Then, evaluate &(f) --> f. The expression is now "f".
>
> Finally, return false.

**Example 2:**

> Input: expression = "|(f,f,f,t)"
>
> Output: true
>
> Explanation: The evaluation of (false OR false OR false OR true) is true.

**Example 3:**

> Input: expression = "!(&(f,t))"
>
> Output: true
>
> Explanation:
>
> First, evaluate &(f,t) --> (false AND true) --> false --> f. The expression is now "!(f)".
>
> Then, evaluate !(f) --> NOT false --> true. We return true.

**Constraints:**

- `1 <= expression.length <= 2 * 10^4`
- expression[i] is one following characters: `'('`, `')'`, `'&'`, `'|'`, `'!'`, `'t'`, `'f'`, and `','`.

## é¢˜ç›®å¤§æ„

**å¸ƒå°”è¡¨è¾¾å¼** æ˜¯è®¡ç®—ç»“æœä¸æ˜¯ `true` å°±æ˜¯ `false` çš„è¡¨è¾¾å¼ã€‚æœ‰æ•ˆçš„è¡¨è¾¾å¼éœ€éµå¾ªä»¥ä¸‹çº¦å®šï¼š

- `'t'`ï¼Œè¿ç®—ç»“æœä¸º `true`
- `'f'`ï¼Œè¿ç®—ç»“æœä¸º `false`
- `'!(subExpr)'`ï¼Œè¿ç®—è¿‡ç¨‹ä¸ºå¯¹å†…éƒ¨è¡¨è¾¾å¼ `subExpr` è¿›è¡Œ **é€»è¾‘é** ï¼ˆNOTï¼‰è¿ç®—
- `'&(subExpr1, subExpr2, ..., subExprn)'`ï¼Œè¿ç®—è¿‡ç¨‹ä¸ºå¯¹ 2 ä¸ªæˆ–ä»¥ä¸Šå†…éƒ¨è¡¨è¾¾å¼ `subExpr1, subExpr2, ..., subExprn` è¿›è¡Œ **é€»è¾‘ä¸** ï¼ˆANDï¼‰è¿ç®—
- `'|(subExpr1, subExpr2, ..., subExprn)'`ï¼Œè¿ç®—è¿‡ç¨‹ä¸ºå¯¹ 2 ä¸ªæˆ–ä»¥ä¸Šå†…éƒ¨è¡¨è¾¾å¼ `subExpr1, subExpr2, ..., subExprn` è¿›è¡Œ **é€»è¾‘æˆ–** ï¼ˆORï¼‰è¿ç®—

ç»™ä½ ä¸€ä¸ªä»¥å­—ç¬¦ä¸²å½¢å¼è¡¨è¿°çš„
[å¸ƒå°”è¡¨è¾¾å¼](https://baike.baidu.com/item/%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F/1574380?fr=aladdin)
`expression`ï¼Œè¿”å›è¯¥å¼çš„è¿ç®—ç»“æœã€‚

é¢˜ç›®æµ‹è¯•ç”¨ä¾‹æ‰€ç»™å‡ºçš„è¡¨è¾¾å¼å‡ä¸ºæœ‰æ•ˆçš„å¸ƒå°”è¡¨è¾¾å¼ï¼Œéµå¾ªä¸Šè¿°çº¦å®šã€‚

**æç¤ºï¼š**

- `1 <= expression.length <= 2 * 10^4`
- `expression[i]` ä¸º `'('`ã€`')'`ã€`'&'`ã€`'|'`ã€`'!'`ã€`'t'`ã€`'f'` å’Œ `','` ä¹‹ä¸€

## è§£é¢˜æ€è·¯

åˆ©ç”¨æ ˆæ¥å¤„ç†å¸ƒå°”è¡¨è¾¾å¼ï¼Œä»¥ä¾¿å¤„ç†åµŒå¥—çš„è¡¨è¾¾å¼å’Œæ“ä½œç¬¦ä¼˜å…ˆçº§ã€‚

ä»å·¦åˆ°å³éå†è¡¨è¾¾å¼çš„æ¯ä¸ªå­—ç¬¦ã€‚

- å¦‚æœå­—ç¬¦æ˜¯ `,`ï¼Œåˆ™è·³è¿‡ï¼ˆä¸éœ€è¦å¤„ç†é€—å·ï¼‰ã€‚
- å¦‚æœå­—ç¬¦æ˜¯ `t` æˆ– `f`ï¼Œå°†å…¶è½¬æ¢ä¸ºå¸ƒå°”å€¼å¹¶å‹å…¥æ ˆä¸­ã€‚
- å¦‚æœå­—ç¬¦æ˜¯ `(` ã€ `&` ã€ `|` ã€ `!`ï¼Œå°†å…¶å‹å…¥æ ˆä¸­ã€‚
- å¦‚æœå­—ç¬¦æ˜¯ `)`ï¼Œåˆ™å¼€å§‹è®¡ç®—æœ€è¿‘ä¸€ä¸ªæ‹¬å·ä¸­çš„è¡¨è¾¾å¼ï¼Œå¹¶å°†è®¡ç®—ç»“æœå‹å…¥æ ˆä¸­ï¼š

  - é¦–å…ˆå¼¹å‡ºæ“ä½œæ•°åˆ°ä¸€ä¸ªæ•°ç»„ `values`ï¼Œç›´åˆ°æ‰¾åˆ°å¯¹åº”çš„å·¦æ‹¬å· `(`ï¼›
  - å¼¹å‡ºæ ˆé¡¶çš„æ“ä½œç¬¦ï¼ˆ`&`ã€`|` æˆ– `!`ï¼‰ã€‚
  - æ ¹æ®æ“ä½œç¬¦è¿›è¡Œç›¸åº”çš„å¸ƒå°”è¿ç®—ï¼š

    - å¯¹äº `&`ï¼Œä½¿ç”¨ `every` æ–¹æ³•åˆ¤æ–­æ‰€æœ‰å€¼æ˜¯å¦ä¸º `true`ã€‚
    - å¯¹äº `|`ï¼Œä½¿ç”¨ `some` æ–¹æ³•åˆ¤æ–­æ˜¯å¦è‡³å°‘æœ‰ä¸€ä¸ªå€¼ä¸º `true`ã€‚
    - å¯¹äº `!`ï¼Œç›´æ¥å¯¹ç¬¬ä¸€ä¸ªå€¼å–åã€‚

  - éå†ç»“æŸåï¼Œæ ˆä¸­çš„å”¯ä¸€å…ƒç´ å³ä¸ºè¡¨è¾¾å¼çš„æœ€ç»ˆç»“æœã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œå…¶ä¸­ `n` æ˜¯è¡¨è¾¾å¼çš„é•¿åº¦ã€‚æ¯ä¸ªå­—ç¬¦éƒ½è¢«å¤„ç†ä¸€æ¬¡ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œåœ¨æœ€åæƒ…å†µä¸‹ï¼Œæ ˆçš„ç©ºé—´å¤æ‚åº¦ä¸º `O(n)`ã€‚

## ä»£ç 

```javascript
/**
 * @param {string} expression
 * @return {boolean}
 */
var parseBoolExpr = function (expression) {
	let stack = [];

	for (let i = 0; i < expression.length; i++) {
		const char = expression[i];
		if (char == ',') {
			continue; // è·³è¿‡é€—å·
		} else if (char === 't' || char === 'f') {
			stack.push(char === 't'); // å°† 't' å’Œ 'f' è½¬æ¢ä¸ºå¸ƒå°”å€¼
		} else if (char == ')') {
			let values = [];
			while (stack.length && stack[stack.length - 1] !== '(') {
				values.push(stack.pop());
			}

			stack.pop(); // ç§»é™¤ '('
			const sign = stack.pop(); // è·å–æ“ä½œç¬¦

			if (sign == '&') {
				stack.push(values.every(Boolean)); // é€»è¾‘ä¸
			} else if (sign == '|') {
				stack.push(values.some(Boolean)); // é€»è¾‘æˆ–
			} else {
				stack.push(!values[0]); // é€»è¾‘é
			}
		} else {
			stack.push(char); // å°†æ‹¬å·æˆ–æ“ä½œç¬¦å‹å…¥æ ˆ
		}
	}
	return stack[0]; // æœ€ç»ˆç»“æœ
};
```
