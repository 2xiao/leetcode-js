---
title: 1926. è¿·å®«ä¸­ç¦»å…¥å£æœ€è¿‘çš„å‡ºå£
description: LeetCode 1926. è¿·å®«ä¸­ç¦»å…¥å£æœ€è¿‘çš„å‡ºå£é¢˜è§£ï¼ŒNearest Exit from Entrance in Mazeï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 1926. è¿·å®«ä¸­ç¦»å…¥å£æœ€è¿‘çš„å‡ºå£
  - è¿·å®«ä¸­ç¦»å…¥å£æœ€è¿‘çš„å‡ºå£
  - Nearest Exit from Entrance in Maze
  - è§£é¢˜æ€è·¯
  - å¹¿åº¦ä¼˜å…ˆæœç´¢
  - æ•°ç»„
  - çŸ©é˜µ
---

# 1926. è¿·å®«ä¸­ç¦»å…¥å£æœ€è¿‘çš„å‡ºå£

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/tag/breadth-first-search.md) [`æ•°ç»„`](/tag/array.md) [`çŸ©é˜µ`](/tag/matrix.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze) [`LeetCode`](https://leetcode.com/problems/nearest-exit-from-entrance-in-maze)

## é¢˜ç›®

You are given an `m x n` matrix `maze` (**0-indexed**) with empty cells
(represented as `'.'`) and walls (represented as `'+'`). You are also given
the `entrance` of the maze, where `entrance = [entrancerow, entrancecol]`
denotes the row and column of the cell you are initially standing at.

In one step, you can move one cell **up** , **down** , **left** , or
**right**. You cannot step into a cell with a wall, and you cannot step
outside the maze. Your goal is to find the **nearest exit** from the
`entrance`. An **exit** is defined as an **empty cell** that is at the
**border** of the `maze`. The `entrance` **does not count** as an exit.

Return _the**number of steps** in the shortest path from the _`entrance` _to
the nearest exit, or_`-1` _if no such path exists_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/06/04/nearest1-grid.jpg)

> Input: maze = [["+","+",".","+"],[".",".",".","+"],["+","+","+","."]], entrance = [1,2]
>
> Output: 1
>
> Explanation: There are 3 exits in this maze at [1,0], [0,2], and [2,3].
>
> Initially, you are at the entrance cell [1,2].
>
> - You can reach [1,0] by moving 2 steps left.
> - You can reach [0,2] by moving 1 step up.
>
> It is impossible to reach [2,3] from the entrance.
>
> Thus, the nearest exit is [0,2], which is 1 step away.

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/06/04/nearesr2-grid.jpg)

> Input: maze = [["+","+","+"],[".",".","."],["+","+","+"]], entrance = [1,0]
>
> Output: 2
>
> Explanation: There is 1 exit in this maze at [1,2].
>
> [1,0] does not count as an exit since it is the entrance cell.
>
> Initially, you are at the entrance cell [1,0].
>
> - You can reach [1,2] by moving 2 steps right.
>
> Thus, the nearest exit is [1,2], which is 2 steps away.

**Example 3:**

![](https://assets.leetcode.com/uploads/2021/06/04/nearest3-grid.jpg)

> Input: maze = [[".","+"]], entrance = [0,0]
>
> Output: -1
>
> Explanation: There are no exits in this maze.

**Constraints:**

- `maze.length == m`
- `maze[i].length == n`
- `1 <= m, n <= 100`
- `maze[i][j]` is either `'.'` or `'+'`.
- `entrance.length == 2`
- `0 <= entrancerow < m`
- `0 <= entrancecol < n`
- `entrance` will always be an empty cell.

## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ª `m x n` çš„è¿·å®«çŸ©é˜µ `maze` ï¼ˆ**ä¸‹æ ‡ä» 0 å¼€å§‹** ï¼‰ï¼ŒçŸ©é˜µä¸­æœ‰ç©ºæ ¼å­ï¼ˆç”¨ `'.'` è¡¨ç¤ºï¼‰å’Œå¢™ï¼ˆç”¨ `'+'`
è¡¨ç¤ºï¼‰ã€‚åŒæ—¶ç»™ä½ è¿·å®«çš„å…¥å£ `entrance` ï¼Œç”¨ `entrance = [entrancerow, entrancecol]`
è¡¨ç¤ºä½ ä¸€å¼€å§‹æ‰€åœ¨æ ¼å­çš„è¡Œå’Œåˆ—ã€‚

æ¯ä¸€æ­¥æ“ä½œï¼Œä½ å¯ä»¥å¾€ **ä¸Š** ï¼Œ**ä¸‹** ï¼Œ**å·¦** æˆ–è€… **å³** ç§»åŠ¨ä¸€ä¸ªæ ¼å­ã€‚ä½ ä¸èƒ½è¿›å…¥å¢™æ‰€åœ¨çš„æ ¼å­ï¼Œä½ ä¹Ÿä¸èƒ½ç¦»å¼€è¿·å®«ã€‚ä½ çš„ç›®æ ‡æ˜¯æ‰¾åˆ°ç¦»
`entrance` **æœ€è¿‘** çš„å‡ºå£ã€‚**å‡ºå£** çš„å«ä¹‰æ˜¯ `maze` **è¾¹ç•Œ** ä¸Šçš„ **ç©ºæ ¼å­** ã€‚`entrance` æ ¼å­
**ä¸ç®—** å‡ºå£ã€‚

è¯·ä½ è¿”å›ä» `entrance` åˆ°æœ€è¿‘å‡ºå£çš„æœ€çŸ­è·¯å¾„çš„ **æ­¥æ•°** ï¼Œå¦‚æœä¸å­˜åœ¨è¿™æ ·çš„è·¯å¾„ï¼Œè¯·ä½ è¿”å› `-1` ã€‚

**ç¤ºä¾‹ 1ï¼š**

![](https://assets.leetcode.com/uploads/2021/06/04/nearest1-grid.jpg)

> **è¾“å…¥ï¼š** maze = [["+","+",".","+"],[".",".",".","+"],["+","+","+","."]], entrance = [1,2]
>
> **è¾“å‡ºï¼š** 1
>
> **è§£é‡Šï¼š** æ€»å…±æœ‰ 3 ä¸ªå‡ºå£ï¼Œåˆ†åˆ«ä½äº (1,0)ï¼Œ(0,2) å’Œ (2,3) ã€‚
>
> ä¸€å¼€å§‹ï¼Œä½ åœ¨å…¥å£æ ¼å­ (1,2) å¤„ã€‚
>
> - ä½ å¯ä»¥å¾€å·¦ç§»åŠ¨ 2 æ­¥åˆ°è¾¾ (1,0) ã€‚
> - ä½ å¯ä»¥å¾€ä¸Šç§»åŠ¨ 1 æ­¥åˆ°è¾¾ (0,2) ã€‚
>
> ä»å…¥å£å¤„æ²¡æ³•åˆ°è¾¾ (2,3) ã€‚
>
> æ‰€ä»¥ï¼Œæœ€è¿‘çš„å‡ºå£æ˜¯ (0,2) ï¼Œè·ç¦»ä¸º 1 æ­¥ã€‚

**ç¤ºä¾‹ 2ï¼š**

![](https://assets.leetcode.com/uploads/2021/06/04/nearesr2-grid.jpg)

> **è¾“å…¥ï¼š** maze = [["+","+","+"],[".",".","."],["+","+","+"]], entrance = [1,0]
>
> **è¾“å‡ºï¼š** 2
>
> **è§£é‡Šï¼š** è¿·å®«ä¸­åªæœ‰ 1 ä¸ªå‡ºå£ï¼Œåœ¨ (1,2) å¤„ã€‚
>
> (1,0) ä¸ç®—å‡ºå£ï¼Œå› ä¸ºå®ƒæ˜¯å…¥å£æ ¼å­ã€‚
>
> åˆå§‹æ—¶ï¼Œä½ åœ¨å…¥å£ä¸æ ¼å­ (1,0) å¤„ã€‚
>
> - ä½ å¯ä»¥å¾€å³ç§»åŠ¨ 2 æ­¥åˆ°è¾¾ (1,2) å¤„ã€‚
>
> æ‰€ä»¥ï¼Œæœ€è¿‘çš„å‡ºå£ä¸º (1,2) ï¼Œè·ç¦»ä¸º 2 æ­¥ã€‚

**ç¤ºä¾‹ 3ï¼š**

![](https://assets.leetcode.com/uploads/2021/06/04/nearest3-grid.jpg)

> **è¾“å…¥ï¼š** maze = [[".","+"]], entrance = [0,0]
>
> **è¾“å‡ºï¼š** -1
>
> **è§£é‡Šï¼š** è¿™ä¸ªè¿·å®«ä¸­æ²¡æœ‰å‡ºå£ã€‚

**æç¤ºï¼š**

- `maze.length == m`
- `maze[i].length == n`
- `1 <= m, n <= 100`
- `maze[i][j]` è¦ä¹ˆæ˜¯ `'.'` ï¼Œè¦ä¹ˆæ˜¯ `'+'` ã€‚
- `entrance.length == 2`
- `0 <= entrancerow < m`
- `0 <= entrancecol < n`
- `entrance` ä¸€å®šæ˜¯ç©ºæ ¼å­ã€‚

## è§£é¢˜æ€è·¯

å¯ä»¥å°†è¿·å®«æŠ½è±¡ä¸ºå›¾ï¼Œç½‘æ ¼çš„æ¯ä¸ªç©ºæ ¼å­ '.' æ˜¯å›¾çš„èŠ‚ç‚¹ï¼Œç›¸é‚»çš„ä¸Šä¸‹å·¦å³æ–¹å‘å¯ä»¥çœ‹ä½œè¾¹ï¼Œè¡¨ç¤ºå¯ä»¥ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚

åˆ©ç”¨ **å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰** éå†å›¾ï¼Œå› ä¸º BFS ä¼šä¼˜å…ˆæ‰¾åˆ°è·ç¦»å…¥å£æœ€è¿‘çš„å‡ºå£ã€‚åŒæ—¶è®°å½•å·²è®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œé¿å…é‡å¤éå†ã€‚

1. åˆå§‹åŒ–é˜Ÿåˆ— `queue`ï¼Œå­˜å‚¨å½“å‰èŠ‚ç‚¹åæ ‡åŠå…¶åˆ°å…¥å£çš„æ­¥æ•° `[row, col, steps]`ã€‚
2. å°†å…¥å£åæ ‡åŠ å…¥é˜Ÿåˆ—å¹¶æ ‡è®°ä¸ºå·²è®¿é—®ã€‚
3. å¼€å§‹ BFSï¼š
   - æ¯æ¬¡ä»é˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªèŠ‚ç‚¹ã€‚
   - éå†å…¶ä¸Šä¸‹å·¦å³çš„ç›¸é‚»èŠ‚ç‚¹ï¼š
     - å¦‚æœè¯¥èŠ‚ç‚¹æ˜¯å‡ºå£ï¼Œè¿”å›æ­¥æ•°ã€‚
     - å¦‚æœè¯¥èŠ‚ç‚¹æ˜¯æœªè®¿é—®çš„ç©ºæ ¼å­ï¼Œåˆ™åŠ å…¥é˜Ÿåˆ—å¹¶æ ‡è®°ä¸ºå·²è®¿é—®ã€‚
4. å¦‚æœæ‰€æœ‰èŠ‚ç‚¹éƒ½éå†å®Œï¼Œä»æ— å‡ºå£ï¼Œåˆ™è¿”å› -1ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(m * n)`ï¼Œå…¶ä¸­ `m` å’Œ `n` åˆ†åˆ«æ˜¯è¿·å®«çš„è¡Œæ•°å’Œåˆ—æ•°ã€‚ä½¿ç”¨ BFS éå†è¿·å®«æ—¶ï¼Œæ¯ä¸ªèŠ‚ç‚¹æœ€å¤šè¢«è®¿é—®ä¸€æ¬¡ï¼Œæ€»è®¿é—®çš„èŠ‚ç‚¹æ•°ä¸º `O(m * n)`ï¼Œæ¯æ¬¡è®¿é—®ä¼šæ£€æŸ¥å…¶æœ€å¤š 4 ä¸ªé‚»å±…ï¼ˆä¸Šä¸‹å·¦å³ï¼‰ï¼Œé‚»å±…æ£€æŸ¥çš„æ¬¡æ•°ä¸èŠ‚ç‚¹æ•°æˆæ¯”ä¾‹ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(m * n)`ã€‚
  - é˜Ÿåˆ—ç©ºé—´ï¼šåœ¨æœ€åæƒ…å†µä¸‹ï¼Œé˜Ÿåˆ—ä¸­å¯èƒ½åŒæ—¶å­˜å‚¨æ‰€æœ‰æœªè®¿é—®èŠ‚ç‚¹ã€‚
  - æ ‡è®°ç©ºé—´ï¼šç›´æ¥åœ¨è¾“å…¥çš„ `maze` ä¸­æ ‡è®°å·²è®¿é—®èŠ‚ç‚¹ï¼Œå› æ­¤ä¸éœ€è¦é¢å¤–çš„è®¿é—®æ ‡è®°æ•°ç»„ã€‚

## ä»£ç 

```javascript
/**
 * @param {character[][]} maze
 * @param {number[]} entrance
 * @return {number}
 */
var nearestExit = function (maze, entrance) {
	const rows = maze.length;
	const cols = maze[0].length;
	const directions = [
		[-1, 0], // ä¸Š
		[1, 0], // ä¸‹
		[0, -1], // å·¦
		[0, 1] // å³
	];

	// åˆå§‹åŒ–é˜Ÿåˆ—å’Œè®¿é—®æ ‡è®°
	const queue = [[entrance[0], entrance[1], 0]]; // [row, col, steps]
	maze[entrance[0]][entrance[1]] = '+'; // æ ‡è®°å…¥å£ä¸ºå·²è®¿é—®

	while (queue.length > 0) {
		const [row, col, steps] = queue.shift();

		for (const [dr, dc] of directions) {
			const newRow = row + dr;
			const newCol = col + dc;

			// æ£€æŸ¥æ–°ä½ç½®æ˜¯å¦æœ‰æ•ˆä¸”æœªè®¿é—®
			if (
				newRow >= 0 &&
				newRow < rows &&
				newCol >= 0 &&
				newCol < cols &&
				maze[newRow][newCol] === '.'
			) {
				// æ£€æŸ¥æ˜¯å¦ä¸ºå‡ºå£
				if (
					newRow === 0 ||
					newRow === rows - 1 ||
					newCol === 0 ||
					newCol === cols - 1
				) {
					return steps + 1;
				}

				// æ ‡è®°ä¸ºå·²è®¿é—®å¹¶åŠ å…¥é˜Ÿåˆ—
				maze[newRow][newCol] = '+';
				queue.push([newRow, newCol, steps + 1]);
			}
		}
	}

	return -1; // æ²¡æœ‰æ‰¾åˆ°å‡ºå£
};
```
