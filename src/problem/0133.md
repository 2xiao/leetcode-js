---
title: 133. å…‹éš†å›¾
description: LeetCode,133. å…‹éš†å›¾,å…‹éš†å›¾,Clone Graph,è§£é¢˜æ€è·¯,æ·±åº¦ä¼˜å…ˆæœç´¢,å¹¿åº¦ä¼˜å…ˆæœç´¢,å›¾,å“ˆå¸Œè¡¨
keywords:
  - LeetCode
  - 133. å…‹éš†å›¾
  - å…‹éš†å›¾
  - Clone Graph
  - è§£é¢˜æ€è·¯
  - æ·±åº¦ä¼˜å…ˆæœç´¢
  - å¹¿åº¦ä¼˜å…ˆæœç´¢
  - å›¾
  - å“ˆå¸Œè¡¨
---

# 133. å…‹éš†å›¾

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/tag/breadth-first-search.md) [`å›¾`](/tag/graph.md) [`å“ˆå¸Œè¡¨`](/tag/hash-table.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/clone-graph) [`LeetCode`](https://leetcode.com/problems/clone-graph)

## é¢˜ç›®

Given a reference of a node in a
**[connected](<https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph>)**
undirected graph.

Return a [**deep copy**](https://en.wikipedia.org/wiki/Object_copying#Deep_copy) (clone) of the
graph.

Each node in the graph contains a value (`int`) and a list (`List[Node]`) of
its neighbors.

    class Node {
      public int val;
      public List<Node> neighbors;
    }

**Test case format:**

For simplicity, each node's value is the same as the node's index (1-indexed).
For example, the first node with `val == 1`, the second node with `val == 2`,
and so on. The graph is represented in the test case using an adjacency list.

**An adjacency list** is a collection of unordered **lists** used to represent
a finite graph. Each list describes the set of neighbors of a node in the
graph.

The given node will always be the first node with `val = 1`. You must return
the **copy of the given node** as a reference to the cloned graph.

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/11/04/133_clone_graph_question.png)

> Input: adjList = [[2,4],[1,3],[2,4],[1,3]]
>
> Output: [[2,4],[1,3],[2,4],[1,3]]
>
> Explanation: There are 4 nodes in the graph.
>
> 1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
>
> 2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
>
> 3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
>
> 4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/01/07/graph.png)

> Input: adjList = [[]]
>
> Output: [[]]
>
> Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.

**Example 3:**

> Input: adjList = []
>
> Output: []
>
> Explanation: This an empty graph, it does not have any nodes.

**Constraints:**

- The number of nodes in the graph is in the range `[0, 100]`.
- `1 <= Node.val <= 100`
- `Node.val` is unique for each node.
- There are no repeated edges and no self-loops in the graph.
- The Graph is connected and all nodes can be visited starting from the given node.

## é¢˜ç›®å¤§æ„

ç»™ä½ æ— å‘ **è¿é€š** å›¾ä¸­ä¸€ä¸ªèŠ‚ç‚¹çš„å¼•ç”¨ï¼Œè¯·ä½ è¿”å›è¯¥å›¾çš„ **æ·±æ‹·è´**ï¼ˆå…‹éš†ï¼‰ã€‚

å›¾ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹éƒ½åŒ…å«å®ƒçš„å€¼ `valï¼ˆintï¼‰` å’Œå…¶é‚»å±…çš„åˆ—è¡¨ï¼ˆ`list[Node]`ï¼‰ã€‚

    class Node {
      public int val;
      public List<Node> neighbors;
    }

æµ‹è¯•ç”¨ä¾‹æ ¼å¼ï¼š

ç®€å•èµ·è§ï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½å’Œå®ƒçš„ç´¢å¼•ç›¸åŒã€‚ä¾‹å¦‚ï¼Œç¬¬ä¸€ä¸ªèŠ‚ç‚¹å€¼ä¸º `1`ï¼ˆ`val = 1`ï¼‰ï¼Œç¬¬äºŒä¸ªèŠ‚ç‚¹å€¼ä¸º `2`ï¼ˆ`val = 2`ï¼‰ï¼Œä»¥æ­¤ç±»æ¨ã€‚è¯¥å›¾åœ¨æµ‹è¯•ç”¨ä¾‹ä¸­ä½¿ç”¨é‚»æ¥åˆ—è¡¨è¡¨ç¤ºã€‚

**é‚»æ¥åˆ—è¡¨** æ˜¯ç”¨äºè¡¨ç¤ºæœ‰é™å›¾çš„æ— åºåˆ—è¡¨çš„é›†åˆã€‚æ¯ä¸ªåˆ—è¡¨éƒ½æè¿°äº†å›¾ä¸­èŠ‚ç‚¹çš„é‚»å±…é›†ã€‚

ç»™å®šèŠ‚ç‚¹å°†å§‹ç»ˆæ˜¯å›¾ä¸­çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆå€¼ä¸º `1`ï¼‰ã€‚ä½ å¿…é¡»å°† **ç»™å®šèŠ‚ç‚¹çš„æ‹·è´** ä½œä¸ºå¯¹å…‹éš†å›¾çš„å¼•ç”¨è¿”å›ã€‚

**æç¤ºï¼š**

- èŠ‚ç‚¹æ•°ä¸è¶…è¿‡ `100` ã€‚
- æ¯ä¸ªèŠ‚ç‚¹å€¼ `Node.val` éƒ½æ˜¯å”¯ä¸€çš„ï¼Œ`1 <= Node.val <= 100`ã€‚
- æ— å‘å›¾æ˜¯ä¸€ä¸ªç®€å•å›¾ï¼Œè¿™æ„å‘³ç€å›¾ä¸­æ²¡æœ‰é‡å¤çš„è¾¹ï¼Œä¹Ÿæ²¡æœ‰è‡ªç¯ã€‚
- ç”±äºå›¾æ˜¯æ— å‘çš„ï¼Œå¦‚æœèŠ‚ç‚¹ `p` æ˜¯èŠ‚ç‚¹ `q` çš„é‚»å±…ï¼Œé‚£ä¹ˆèŠ‚ç‚¹ `q` ä¹Ÿå¿…é¡»æ˜¯èŠ‚ç‚¹ `p` çš„é‚»å±…ã€‚
- å›¾æ˜¯è¿é€šå›¾ï¼Œä½ å¯ä»¥ä»ç»™å®šèŠ‚ç‚¹è®¿é—®åˆ°æ‰€æœ‰èŠ‚ç‚¹ã€‚

## è§£é¢˜æ€è·¯

å…‹éš†å›¾çš„å¸¸è§è§£æ³•æ˜¯ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰æˆ–å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰ã€‚ä»¥æ·±åº¦ä¼˜å…ˆæœç´¢ä¸ºä¾‹ï¼Œå¯ä»¥é€šè¿‡é€’å½’å®ç°å›¾çš„å…‹éš†ã€‚åœ¨é€’å½’çš„è¿‡ç¨‹ä¸­ï¼Œä½¿ç”¨ `visited` å“ˆå¸Œè¡¨æ¥è®°å½•å·²ç»è®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œé¿å…é‡å¤éå†ã€‚

1. ä½¿ç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨ `visited` æ¥å­˜å‚¨åŸå›¾èŠ‚ç‚¹å’Œå…‹éš†å›¾èŠ‚ç‚¹çš„æ˜ å°„å…³ç³»ã€‚é”®ä¸ºåŸå›¾èŠ‚ç‚¹ï¼Œå€¼ä¸ºå…‹éš†å›¾èŠ‚ç‚¹ã€‚
2. å®šä¹‰ä¸€ä¸ª DFS å‡½æ•°ï¼Œè¾“å…¥ä¸ºåŸå›¾èŠ‚ç‚¹ `node`ï¼Œåœ¨å‡½æ•°ä¸­è¿›è¡Œå¦‚ä¸‹æ“ä½œï¼š
   - å¦‚æœ `node` ä¸ºç©ºï¼Œç›´æ¥è¿”å› `null`ã€‚
   - å¦‚æœ `node` åœ¨ `visited` ä¸­ï¼Œè¯´æ˜å·²ç»è®¿é—®è¿‡ï¼Œç›´æ¥è¿”å›å¯¹åº”çš„å…‹éš†å›¾èŠ‚ç‚¹ã€‚
   - å¦åˆ™ï¼Œåˆ›å»ºä¸€ä¸ªå…‹éš†å›¾èŠ‚ç‚¹ï¼Œå¹¶å°†å…¶æ”¾å…¥ `visited` ä¸­ï¼Œé”®ä¸º `node`ï¼Œå€¼ä¸º `cloneNode`ã€‚
   - å¯¹ `node` çš„é‚»å±…è¿›è¡Œé€’å½’è°ƒç”¨ DFSï¼Œå¹¶å°†ç»“æœæ·»åŠ åˆ° `visited.get(node)` çš„é‚»å±…åˆ—è¡¨ä¸­ã€‚
3. æœ€åè¿”å›å…‹éš†å›¾çš„èµ·å§‹èŠ‚ç‚¹ã€‚

å½“ç„¶ä¹Ÿæœ‰äººå†™ DFS æ—¶ä¸ä¹ æƒ¯è¿”å›å€¼ï¼Œè¿™æ ·æ›´æ¸…æ™°æ˜“æ‡‚ä¸€äº›ï¼Œè¯¦è§è§£æ³•äºŒã€‚

## ä»£ç 

::: code-tabs

@tab DFS

```javascript
/**
 * // Definition for a Node.
 * function Node(val, neighbors) {
 *    this.val = val === undefined ? 0 : val;
 *    this.neighbors = neighbors === undefined ? [] : neighbors;
 * };
 */

/**
 * @param {Node} node
 * @return {Node}
 */
var cloneGraph = function (node) {
	if (!node) return null;
	let visited = new Map();
	const dfs = (node) => {
		if (!node) return null;
		if (visited.has(node)) return visited.get(node);
		visited.set(node, new Node(node.val));
		for (let i of node.neighbors) {
			visited.get(node).neighbors.push(dfs(i));
		}
		return visited.get(node);
	};

	return dfs(node);
};
```

@tab DFS æ— è¿”å›å€¼ç‰ˆ

```javascript
/**
 * @param {_Node} node
 * @return {_Node}
 */
var cloneGraph = function (node) {
	let copy = new Map();

	const dfs = (node) => {
		if (!node) return;
		if (copy.has(node)) return;
		copy.set(node, new Node(node.val));

		for (let item of node.neighbors) {
			dfs(item);
			copy.get(node).neighbors.push(copy.get(item));
		}
	};

	dfs(node);
	return copy.get(node);
};
```

:::

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ | åŠ›æ‰£ |
| :------: | :------ | :------: | :------ | :------ | :------: |
| 138 | éšæœºé“¾è¡¨çš„å¤åˆ¶ | [[âœ“]](/problem/0138.md) |  [`å“ˆå¸Œè¡¨`](/tag/hash-table.md) [`é“¾è¡¨`](/tag/linked-list.md) | ğŸŸ  | [ğŸ€„ï¸](https://leetcode.cn/problems/copy-list-with-random-pointer) [ğŸ”—](https://leetcode.com/problems/copy-list-with-random-pointer) |
| 1485 | å…‹éš†å«éšæœºæŒ‡é’ˆçš„äºŒå‰æ ‘ ğŸ”’ |  |  [`æ ‘`](/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/tag/breadth-first-search.md) `2+` | ğŸŸ  | [ğŸ€„ï¸](https://leetcode.cn/problems/clone-binary-tree-with-random-pointer) [ğŸ”—](https://leetcode.com/problems/clone-binary-tree-with-random-pointer) |
| 1490 | å…‹éš† N å‰æ ‘ ğŸ”’ |  |  [`æ ‘`](/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/tag/breadth-first-search.md) `1+` | ğŸŸ  | [ğŸ€„ï¸](https://leetcode.cn/problems/clone-n-ary-tree) [ğŸ”—](https://leetcode.com/problems/clone-n-ary-tree) |