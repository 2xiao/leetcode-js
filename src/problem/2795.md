---
title: 2795. å¹¶è¡Œæ‰§è¡Œ Promise ä»¥è·å–ç‹¬æœ‰çš„ç»“æœ ğŸ”’
description: LeetCode,2795. å¹¶è¡Œæ‰§è¡Œ Promise ä»¥è·å–ç‹¬æœ‰çš„ç»“æœ ğŸ”’,å¹¶è¡Œæ‰§è¡Œ Promise ä»¥è·å–ç‹¬æœ‰çš„ç»“æœ,Parallel Execution of Promises for Individual Results Retrieval,è§£é¢˜æ€è·¯
keywords:
  - LeetCode
  - 2795. å¹¶è¡Œæ‰§è¡Œ Promise ä»¥è·å–ç‹¬æœ‰çš„ç»“æœ ğŸ”’
  - å¹¶è¡Œæ‰§è¡Œ Promise ä»¥è·å–ç‹¬æœ‰çš„ç»“æœ
  - Parallel Execution of Promises for Individual Results Retrieval
  - è§£é¢˜æ€è·¯
---

# 2795. å¹¶è¡Œæ‰§è¡Œ Promise ä»¥è·å–ç‹¬æœ‰çš„ç»“æœ ğŸ”’

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/parallel-execution-of-promises-for-individual-results-retrieval) [`LeetCode`](https://leetcode.com/problems/parallel-execution-of-promises-for-individual-results-retrieval)

## é¢˜ç›®

Given an array `functions`, return a promise `promise`. `functions` is an
array of functions that return promises `fnPromise.` Each `fnPromise` can be
resolved or rejected.

If `fnPromise` is resolved:

`obj = { status: "fulfilled", value: resolved value }`

If `fnPromise` is rejected:

`obj = { status: "rejected", reason: reason of rejection (catched error message) }`

The `promise` should resolve with an array of these objects `obj`. Each `obj`
in the array should correspond to the promises in the original array function,
**maintaining the same order**.

Try to implement it without using the built-in method `Promise.allSettled()`.

**Example 1:**

> Input:
>
> ```js
> functions = [
> 	() => new Promise((resolve) => setTimeout(() => resolve(15), 100))
> ];
> ```
>
> Output:
>
> `{"t":100,"values":[{"status":"fulfilled","value":15}]}`
>
> Explanation:
>
> ```js
> const time = performance.now();
> const promise = promiseAllSettled(functions);
> promise.then((res) => {
> 	const out = { t: Math.floor(performance.now() - time), values: res };
> 	console.log(out); // {"t":100,"values":[{"status":"fulfilled","value":15}]}
> });
> ```
>
> The returned promise resolves within 100 milliseconds. Since promise from the array functions is fulfilled, the resolved value of the returned promise is set to [{"status":"fulfilled","value":15}].

**Example 2:**

> Input:
>
> ```js
> functions = [
> 	() => new Promise((resolve) => setTimeout(() => resolve(20), 100)),
> 	() => new Promise((resolve) => setTimeout(() => resolve(15), 100))
> ];
> ```
>
> Output:
>
> ```js
> {
>   "t":100,
>   "values": [
>       {"status":"fulfilled","value":20},
>       {"status":"fulfilled","value":15}
>   ]
> }
> ```
>
> Explanation: The returned promise resolves within 100 milliseconds, because the resolution time is determined by the promise that takes the longest time to fulfill. Since promises from the array functions are fulfilled, the resolved value of the returned promise is set to [{"status":"fulfilled","value":20},{"status":"fulfilled","value":15}].

**Example 3:**

> Input:
>
> ```js
> functions = [
> 	() => new Promise((resolve) => setTimeout(() => resolve(30), 200)),
> 	() =>
> 		new Promise((resolve, reject) => setTimeout(() => reject('Error'), 100))
> ];
> ```
>
> Output:
>
> ```js
> {
>   "t":200,
>   "values": [
>   {"status":"fulfilled","value":30},
>   {"status":"rejected","reason":"Error"}
>   ]
> }
> ```
>
> Explanation: The returned promise resolves within 200 milliseconds, as its resolution time is determined by the promise that takes the longest time to fulfill. Since one promise from the array function is fulfilled and another is rejected, the resolved value of the returned promise is set to an array containing objects in the following order: [{"status":"fulfilled","value":30}, {"status":"rejected","reason":"Error"}]. Each object in the array corresponds to the promises in the original array function, maintaining the same order.

**Constraints:**

- `1 <= functions.length <= 10`

## é¢˜ç›®å¤§æ„

ç»™å®šä¸€ä¸ªæ•°ç»„ `functions`ï¼Œè¿”å›ä¸€ä¸ª promise å¯¹è±¡ `promise`ã€‚`functions` æ˜¯ä¸€ä¸ªè¿”å›å¤šä¸ª promise å¯¹è±¡
`fnPromise` çš„å‡½æ•°æ•°ç»„ã€‚æ¯ä¸ª `fnPromise` å¯ä»¥è¢«è§£æï¼ˆresolvedï¼‰æˆ–æ‹’ç»ï¼ˆrejectedï¼‰ã€‚

å¦‚æœ `fnPromise` è¢«è§£æï¼š

`obj = { status: "fulfilled", value: resolved value }`

å¦‚æœ `fnPromise` è¢«æ‹’ç»ï¼š

`obj = { status: "rejected", reason: æ‹’ç»çš„åŸå› ï¼ˆæ•è·çš„é”™è¯¯æ¶ˆæ¯ï¼‰}`

è¯¥ `promise` åº”è¯¥è¿”å›ä¸€ä¸ªåŒ…å«è¿™äº›å¯¹è±¡ `obj` çš„æ•°ç»„ã€‚æ•°ç»„ä¸­çš„æ¯ä¸ª `obj` åº”è¯¥å¯¹åº”åŸå§‹å‡½æ•°æ•°ç»„ä¸­çš„å¤šä¸ª promise
å¯¹è±¡ï¼Œå¹¶ä¿æŒç›¸åŒçš„é¡ºåºã€‚

è¯·åœ¨ä¸ä½¿ç”¨å†…ç½®æ–¹æ³• `Promise.allSettled()` çš„æƒ…å†µä¸‹å®ç°å®ƒã€‚

**ç¤ºä¾‹ 1ï¼š**

> **è¾“å…¥ï¼š**
>
> ```js
> functions = [
> 	() => new Promise((resolve) => setTimeout(() => resolve(15), 100))
> ];
> ```
>
> **è¾“å‡ºï¼š**
>
> `{"t":100,"values":[{"status":"fulfilled","value":15}]}`
>
> **è§£é‡Šï¼š**
>
> ```js
> const time = performance.now();
> const promise = promiseAllSettled(functions);
> promise.then((res) => {
> 	const out = { t: Math.floor(performance.now() - time), values: res };
> 	console.log(out); // {"t":100,"values":[{"status":"fulfilled","value":15}]}
> });
> ```
>
> è¿”å›çš„ promise åœ¨ 100 æ¯«ç§’å†…è§£æã€‚ç”±äºå‡½æ•°æ•°ç»„ä¸­çš„ promise è¢«è§£æï¼Œè¿”å›çš„ promise çš„è§£æå€¼è®¾ç½®ä¸º[{"status":"fulfilled","value":15}]ã€‚

**ç¤ºä¾‹ 2ï¼š**

> **è¾“å…¥ï¼š**
>
> ```js
> functions = [
> 	() => new Promise((resolve) => setTimeout(() => resolve(20), 100)),
> 	() => new Promise((resolve) => setTimeout(() => resolve(15), 100))
> ];
> ```
>
> **è¾“å‡ºï¼š**
>
> ```js
> {
>   "t":100,
>   "values": [
>       {"status":"fulfilled","value":20},
>       {"status":"fulfilled","value":15}
>   ]
> }
> ```
>
> **è§£é‡Šï¼š** è¿”å›çš„ promise åœ¨ 100 æ¯«ç§’å†…è§£æï¼Œå› ä¸ºè§£ææ—¶é—´å–å†³äºéœ€è¦æœ€é•¿æ—¶é—´æ¥è§£æçš„ promiseã€‚ç”±äºå‡½æ•°æ•°ç»„ä¸­çš„ promises è¢«è§£æï¼Œè¿”å›çš„ promise çš„è§£æå€¼è®¾ç½®ä¸º[{"status":"fulfilled","value":20},{"status":"fulfilled","value":15}]ã€‚

**ç¤ºä¾‹ 3ï¼š**

> **è¾“å…¥ï¼š**
>
> ```js
> functions = [
> 	() => new Promise((resolve) => setTimeout(() => resolve(30), 200)),
> 	() =>
> 		new Promise((resolve, reject) => setTimeout(() => reject('Error'), 100))
> ];
> ```
>
> **è¾“å‡ºï¼š**
>
> ```js
> {
>   "t":200,
>   "values": [
>       {"status":"fulfilled","value":30},
>       {"status":"rejected","reason":"Error"}
>   ]
> }
> ```
>
> **è§£é‡Šï¼š** è¿”å›çš„ promise åœ¨ 200 æ¯«ç§’å†…è§£æï¼Œå› ä¸ºè§£ææ—¶é—´å–å†³äºéœ€è¦æœ€é•¿æ—¶é—´æ¥è§£æçš„ promiseã€‚ç”±äºå‡½æ•°æ•°ç»„ä¸­çš„ä¸€ä¸ª promise è¢«è§£æï¼Œå¦ä¸€ä¸ªè¢«æ‹’ç»ï¼Œè¿”å›çš„ promise çš„è§£æå€¼è®¾ç½®ä¸º[{"status":"fulfilled","value":30},{"status":"rejected","reason":"Error"}]ã€‚æ•°ç»„ä¸­çš„æ¯ä¸ªå¯¹è±¡å¯¹åº”åŸå§‹å‡½æ•°æ•°ç»„ä¸­çš„ promiseï¼Œå¹¶ä¿æŒç›¸åŒçš„é¡ºåºã€‚

**æç¤ºï¼š**

- `1 <= functions.length <= 10`

## è§£é¢˜æ€è·¯

### æ€è·¯ä¸€ï¼šforEach

1. **åˆ›å»ºä¸€ä¸ªæ–°çš„ `Promise` å¯¹è±¡**ï¼šå®šä¹‰ `promiseAllSettled` å‡½æ•°ï¼Œè¿”å›ä¸€ä¸ª `Promise`ï¼Œç¡®ä¿åœ¨æ‰€æœ‰ `functions` æ•°ç»„ä¸­çš„ `Promise` çŠ¶æ€éƒ½å·²ç¡®å®šï¼ˆæ— è®ºæ˜¯æˆåŠŸè¿˜æ˜¯å¤±è´¥ï¼‰æ—¶ï¼Œç»Ÿä¸€è¿”å›ç»“æœã€‚

2. **éå† `functions` æ•°ç»„**ï¼šä½¿ç”¨ `forEach` éå†æ¯ä¸ªè¿”å› `Promise` çš„å‡½æ•° `fn`ã€‚æ¯ä¸ª `fn` ä¼šè¢«è°ƒç”¨ä»¥åˆ›å»ºä¸€ä¸ªæ–°çš„ `Promise` å¯¹è±¡ã€‚

3. **å¤„ç†æ¯ä¸ª `Promise` çš„çŠ¶æ€**ï¼š

   - å¦‚æœ `Promise` è¢«è§£æï¼Œåˆ™åœ¨ `result` æ•°ç»„ä¸­å¯¹åº”ä½ç½® `i` å­˜å…¥ `{ status: 'fulfilled', value: res }`ã€‚
   - å¦‚æœ `Promise` è¢«æ‹’ç»ï¼Œåˆ™åœ¨ `result` æ•°ç»„ä¸­å­˜å…¥ `{ status: 'rejected', reason: err }`ã€‚
   - ä¸ç®¡ `Promise` æ˜¯è§£æè¿˜æ˜¯æ‹’ç»ï¼Œ`count` éƒ½ä¼šå¢åŠ ï¼Œç”¨äºè®°å½•å·²å¤„ç†çš„ `Promise` æ•°é‡ã€‚

4. **æ£€æŸ¥æ‰€æœ‰ `Promise` æ˜¯å¦å·²å¤„ç†**ï¼š
   - æ¯æ¬¡æœ‰ä¸€ä¸ª `Promise` çš„çŠ¶æ€ç¡®å®šåï¼Œéƒ½ä¼šæ£€æŸ¥ `count` æ˜¯å¦ç­‰äº `functions.length`ã€‚
   - ä¸€æ—¦ `count` è¾¾åˆ° `functions.length`ï¼Œè¡¨ç¤ºæ‰€æœ‰ `Promise` çŠ¶æ€éƒ½å·²ç¡®å®šï¼Œè°ƒç”¨ `resolve(result)` å°† `result` æ•°ç»„ä¼ å›ï¼Œä»¥ä¿è¯ `promiseAllSettled` è§£æå¹¶è¿”å›æœ€ç»ˆç»“æœã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œå…¶ä¸­ `n` æ˜¯ `functions` æ•°ç»„çš„é•¿åº¦ï¼Œæ¯ä¸ªå‡½æ•°è°ƒç”¨ä¸€æ¬¡ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œéœ€è¦å­˜å‚¨æ‰€æœ‰çš„ `Promise` ç»“æœå¯¹è±¡ã€‚

### æ€è·¯äºŒï¼šPromise.all

1. **å®šä¹‰ `promiseAllSettled` å‡½æ•°**ï¼š
   å‡½æ•°æ¥å—ä¸€ä¸ª `Promise` æ•°ç»„å¹¶è¿”å›ä¸€ä¸ªæ–°çš„ `Promise`ï¼Œè¯¥ `Promise` ä¼šç­‰å¾…æ‰€æœ‰è¾“å…¥çš„ `Promise` å®Œæˆï¼Œæ— è®ºå®ƒä»¬æ˜¯ `resolved` è¿˜æ˜¯ `rejected`ã€‚
2. **éå†æ‰€æœ‰ `Promise` çš„çŠ¶æ€**ï¼š
   å¯¹äºæ¯ä¸ª `Promise`ï¼Œä½¿ç”¨ `.then` å’Œ `.catch` æ–¹æ³•åˆ†åˆ«å¤„ç†æˆåŠŸå’Œå¤±è´¥çš„æƒ…å†µï¼Œç¡®ä¿å°†ç»“æœä»¥ `{ status, value/reason }` æ ¼å¼å­˜å‚¨ã€‚
3. **ç­‰å¾…æ‰€æœ‰ `Promise` å®Œæˆ**ï¼š
   ä½¿ç”¨ `Promise.all` åŒ…è£¹æ¯ä¸ªå¤„ç†åçš„ `Promise`ï¼Œç¡®ä¿æ‰€æœ‰ `Promise` çŠ¶æ€éƒ½è¢«æ”¶é›†åæ‰è¿”å›ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œå…¶ä¸­ `n` æ˜¯ `functions` çš„é•¿åº¦ï¼Œæ¯ä¸ªå‡½æ•°è°ƒç”¨ä¸€æ¬¡ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œç”¨äºå­˜å‚¨ `promises` æ•°ç»„çš„çŠ¶æ€ã€‚

## ä»£ç 

:::code-tabs
@tab forEach

```javascript
/**
 * @param {Array<Function>}
 * @return {Promise<any>}
 */
var promiseAllSettled = function (functions) {
	return new Promise((resolve) => {
		let result = [],
			count = 0;
		functions.forEach((fn, i) =>
			fn()
				.then((res) => {
					result[i] = { status: 'fulfilled', value: res };
					count++;
				})
				.catch((err) => {
					result[i] = { status: 'rejected', reason: err };
					count++;
				})
				.then(() => {
					if (count == functions.length) {
						resolve(result);
					}
				})
		);
	});
};
```

@tab Promise.all

```javascript
/**
 * @param {Array<Function>}
 * @return {Promise<any>}
 */
var promiseAllSettled = function (functions) {
	const promises = functions.map((fn) =>
		fn().then(
			(value) => ({ status: 'fulfilled', value }),
			(reason) => ({ status: 'rejected', reason })
		)
	);
	return Promise.all(promises);
};
```

:::
