---
title: 2825. å¾ªç¯å¢é•¿ä½¿å­—ç¬¦ä¸²å­åºåˆ—ç­‰äºå¦ä¸€ä¸ªå­—ç¬¦ä¸²
description: LeetCode 2825. å¾ªç¯å¢é•¿ä½¿å­—ç¬¦ä¸²å­åºåˆ—ç­‰äºå¦ä¸€ä¸ªå­—ç¬¦ä¸²é¢˜è§£ï¼ŒMake String a Subsequence Using Cyclic Incrementsï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 2825. å¾ªç¯å¢é•¿ä½¿å­—ç¬¦ä¸²å­åºåˆ—ç­‰äºå¦ä¸€ä¸ªå­—ç¬¦ä¸²
  - å¾ªç¯å¢é•¿ä½¿å­—ç¬¦ä¸²å­åºåˆ—ç­‰äºå¦ä¸€ä¸ªå­—ç¬¦ä¸²
  - Make String a Subsequence Using Cyclic Increments
  - è§£é¢˜æ€è·¯
  - åŒæŒ‡é’ˆ
  - å­—ç¬¦ä¸²
---

# 2825. å¾ªç¯å¢é•¿ä½¿å­—ç¬¦ä¸²å­åºåˆ—ç­‰äºå¦ä¸€ä¸ªå­—ç¬¦ä¸²

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`åŒæŒ‡é’ˆ`](/tag/two-pointers.md) [`å­—ç¬¦ä¸²`](/tag/string.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/make-string-a-subsequence-using-cyclic-increments) [`LeetCode`](https://leetcode.com/problems/make-string-a-subsequence-using-cyclic-increments)

## é¢˜ç›®

You are given two **0-indexed** strings `str1` and `str2`.

In an operation, you select a **set** of indices in `str1`, and for each index
`i` in the set, increment `str1[i]` to the next character **cyclically**. That
is `'a'` becomes `'b'`, `'b'` becomes `'c'`, and so on, and `'z'` becomes
`'a'`.

Return `true` _if it is possible to make_`str2` _a subsequence of_`str1` _by
performing the operation**at most once**_ , _and_ `false` _otherwise_.

**Note:** A subsequence of a string is a new string that is formed from the
original string by deleting some (possibly none) of the characters without
disturbing the relative positions of the remaining characters.

**Example 1:**

> Input: str1 = "abc", str2 = "ad"
>
> Output: true
>
> Explanation: Select index 2 in str1.
>
> Increment str1[2] to become 'd'.
>
> Hence, str1 becomes "abd" and str2 is now a subsequence. Therefore, true is returned.

**Example 2:**

> Input: str1 = "zc", str2 = "ad"
>
> Output: true
>
> Explanation: Select indices 0 and 1 in str1.
>
> Increment str1[0] to become 'a'.
>
> Increment str1[1] to become 'd'.
>
> Hence, str1 becomes "ad" and str2 is now a subsequence. Therefore, true is returned.

**Example 3:**

> Input: str1 = "ab", str2 = "d"
>
> Output: false
>
> Explanation: In this example, it can be shown that it is impossible to make str2 a subsequence of str1 using the operation at most once.
>
> Therefore, false is returned.

**Constraints:**

- `1 <= str1.length <= 10^5`
- `1 <= str2.length <= 10^5`
- `str1` and `str2` consist of only lowercase English letters.

## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ªä¸‹æ ‡ä» **0** å¼€å§‹çš„å­—ç¬¦ä¸² `str1` å’Œ `str2` ã€‚

ä¸€æ¬¡æ“ä½œä¸­ï¼Œä½ é€‰æ‹© `str1` ä¸­çš„è‹¥å¹²ä¸‹æ ‡ã€‚å¯¹äºé€‰ä¸­çš„æ¯ä¸€ä¸ªä¸‹æ ‡ `i` ï¼Œä½ å°† `str1[i]` **å¾ªç¯** é€’å¢ï¼Œå˜æˆä¸‹ä¸€ä¸ªå­—ç¬¦ã€‚ä¹Ÿå°±æ˜¯è¯´
`'a'` å˜æˆ `'b'` ï¼Œ`'b'` å˜æˆ `'c'` ï¼Œä»¥æ­¤ç±»æ¨ï¼Œ`'z'` å˜æˆ `'a'` ã€‚

å¦‚æœæ‰§è¡Œä»¥ä¸Šæ“ä½œ **è‡³å¤šä¸€æ¬¡** ï¼Œå¯ä»¥è®© `str2` æˆä¸º `str1` çš„å­åºåˆ—ï¼Œè¯·ä½ è¿”å› `true` ï¼Œå¦åˆ™è¿”å› `false` ã€‚

**æ³¨æ„ï¼š** ä¸€ä¸ªå­—ç¬¦ä¸²çš„å­åºåˆ—æŒ‡çš„æ˜¯ä»åŸå­—ç¬¦ä¸²ä¸­åˆ é™¤ä¸€äº›ï¼ˆå¯ä»¥ä¸€ä¸ªå­—ç¬¦ä¹Ÿä¸åˆ ï¼‰å­—ç¬¦åï¼Œå‰©ä¸‹å­—ç¬¦æŒ‰ç…§åŸæœ¬å…ˆåé¡ºåºç»„æˆçš„æ–°å­—ç¬¦ä¸²ã€‚

**ç¤ºä¾‹ 1ï¼š**

> **è¾“å…¥ï¼š** str1 = "abc", str2 = "ad"
>
> **è¾“å‡ºï¼š** true
>
> **è§£é‡Šï¼š** é€‰æ‹© str1 ä¸­çš„ä¸‹æ ‡ 2 ã€‚
>
> å°† str1[2] å¾ªç¯é€’å¢ï¼Œå¾—åˆ° 'd' ã€‚
>
> å› æ­¤ï¼Œstr1 å˜æˆ "abd" ä¸” str2 ç°åœ¨æ˜¯ä¸€ä¸ªå­åºåˆ—ã€‚æ‰€ä»¥è¿”å› true ã€‚

**ç¤ºä¾‹ 2ï¼š**

> **è¾“å…¥ï¼š** str1 = "zc", str2 = "ad"
>
> **è¾“å‡ºï¼š** true
>
> **è§£é‡Šï¼š** é€‰æ‹© str1 ä¸­çš„ä¸‹æ ‡ 0 å’Œ 1 ã€‚
>
> å°† str1[0] å¾ªç¯é€’å¢å¾—åˆ° 'a' ã€‚
>
> å°† str1[1] å¾ªç¯é€’å¢å¾—åˆ° 'd' ã€‚
>
> å› æ­¤ï¼Œstr1 å˜æˆ "ad" ä¸” str2 ç°åœ¨æ˜¯ä¸€ä¸ªå­åºåˆ—ã€‚æ‰€ä»¥è¿”å› true ã€‚

**ç¤ºä¾‹ 3ï¼š**

> **è¾“å…¥ï¼š** str1 = "ab", str2 = "d"
>
> **è¾“å‡ºï¼š** false
>
> **è§£é‡Šï¼š** è¿™ä¸ªä¾‹å­ä¸­ï¼Œæ²¡æ³•åœ¨æ‰§è¡Œä¸€æ¬¡æ“ä½œçš„å‰æä¸‹ï¼Œå°† str2 å˜ä¸º str1 çš„å­åºåˆ—ã€‚
>
> æ‰€ä»¥è¿”å› false ã€‚

**æç¤ºï¼š**

- `1 <= str1.length <= 10^5`
- `1 <= str2.length <= 10^5`
- `str1` å’Œ `str2` åªåŒ…å«å°å†™è‹±æ–‡å­—æ¯ã€‚

## è§£é¢˜æ€è·¯

**å­—ç¬¦æ¯”è¾ƒè§„åˆ™**

å¯¹äº `str1[i]` å’Œ `str2[j]`ï¼Œå¦‚æœï¼š

- `str1[i] == str2[j]`ï¼ŒåŒ¹é…æˆåŠŸã€‚
- `(str1[i] + 1) % 26 == str2[j]`ï¼Œè¡¨ç¤º `str1[i]` é€šè¿‡ä¸€æ¬¡å¾ªç¯é€’å¢å¯ä»¥å˜æˆ `str2[j]`ã€‚

**åŒæŒ‡é’ˆæ³•**

- æŒ‡é’ˆ `prev1` éå† `str1`ã€‚
- æŒ‡é’ˆ `prev2` éå† `str2`ã€‚
- æ¯æ¬¡å½“ `str1[prev1]` æ»¡è¶³ä¸Šè¿°åŒ¹é…è§„åˆ™æ—¶ï¼Œå°† `prev2` å‘å‰ç§»åŠ¨ä¸€ä½ï¼Œè¡¨ç¤º `str2[prev2]` æ‰¾åˆ°äº†å¯¹åº”çš„å­—ç¬¦ã€‚
- å¦‚æœæœ€å `prev2` èƒ½éå†å®Œ `str2`ï¼Œåˆ™è¯´æ˜ `str2` æ˜¯ `str1` çš„å­åºåˆ—ã€‚

**ç®—æ³•æ­¥éª¤**

1. åˆå§‹åŒ–æŒ‡é’ˆ `prev1` å’Œ `prev2` å‡ä¸º 0ã€‚
2. éå† `str1`ï¼Œå¯¹å½“å‰å­—ç¬¦è¿›è¡Œåˆ¤æ–­ï¼š
   - å¦‚æœ `str1[prev1]` ä¸ `str2[prev2]` åŒ¹é…ï¼Œç§»åŠ¨ `prev2`ã€‚
   - æ— è®ºæ˜¯å¦åŒ¹é…ï¼ŒæŒ‡é’ˆ `prev1` æ€»æ˜¯å‘å³ç§»åŠ¨ã€‚
3. æ£€æŸ¥ `prev2` æ˜¯å¦ç­‰äº `str2.length`ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™è¿”å› `true`ï¼›å¦åˆ™è¿”å› `false`ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œå…¶ä¸­ `n = str1.length`ï¼Œæ¯ä¸ªå­—ç¬¦æœ€å¤šéå†ä¸€æ¬¡ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(1)`ï¼Œä½¿ç”¨äº†å›ºå®šæ•°é‡çš„å˜é‡ã€‚

## ä»£ç 

```javascript
/**
 * @param {string} str1
 * @param {string} str2
 * @return {boolean}
 */
var canMakeSubsequence = function (str1, str2) {
	let prev1 = 0,
		prev2 = 0;
	while (prev1 < str1.length && prev2 < str2.length) {
		if (
			str1[prev1] == str2[prev2] ||
			(str1.charCodeAt(prev1) + 1 - str2.charCodeAt(prev2)) % 26 == 0
		) {
			prev2++;
		}
		prev1++;
	}
	return prev2 == str2.length;
};
```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ | åŠ›æ‰£ |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 392 | åˆ¤æ–­å­åºåˆ— | [[âœ“]](/problem/0392.md) |  [`åŒæŒ‡é’ˆ`](/tag/two-pointers.md) [`å­—ç¬¦ä¸²`](/tag/string.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md) | ğŸŸ¢ | [ğŸ€„ï¸](https://leetcode.cn/problems/is-subsequence) [ğŸ”—](https://leetcode.com/problems/is-subsequence) |
