# [474. ä¸€å’Œé›¶](https://leetcode.com/problems/ones-and-zeroes)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ•°ç»„`](/tag/array.md) [`å­—ç¬¦ä¸²`](/tag/string.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/ones-and-zeroes)

## é¢˜ç›®

You are given an array of binary strings `strs` and two integers `m` and `n`.

Return _the size of the largest subset of`strs` such that there are **at
most** _`m` **`0` _' s and _`n` **`1` _' s in the subset_.

A set `x` is a **subset** of a set `y` if all elements of `x` are also
elements of `y`.

**Example 1:**

> Input: strs = ["10","0001","111001","1","0"], m = 5, n = 3
>
> Output: 4
>
> Explanation: The largest subset with at most 5 0's and 3 1's is {"10", "0001", "1", "0"}, so the answer is 4.
>
> Other valid but smaller subsets include {"0001", "1"} and {"10", "1", "0"}.
>
> {"111001"} is an invalid subset because it contains 4 1's, greater than the maximum of 3.

**Example 2:**

> Input: strs = ["10","0","1"], m = 1, n = 1
>
> Output: 2
>
> Explanation: The largest subset is {"0", "1"}, so the answer is 2.

**Constraints:**

- `1 <= strs.length <= 600`
- `1 <= strs[i].length <= 100`
- `strs[i]` consists only of digits `'0'` and `'1'`.
- `1 <= m, n <= 100`

## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ªäºŒè¿›åˆ¶å­—ç¬¦ä¸²æ•°ç»„ `strs` å’Œä¸¤ä¸ªæ•´æ•° `m` å’Œ `n` ã€‚

è¯·ä½ æ‰¾å‡ºå¹¶è¿”å› `strs` çš„æœ€å¤§å­é›†çš„é•¿åº¦ï¼Œè¯¥å­é›†ä¸­ **æœ€å¤š** æœ‰ `m` ä¸ª `0` å’Œ `n` ä¸ª `1` ã€‚

å¦‚æœ `x` çš„æ‰€æœ‰å…ƒç´ ä¹Ÿæ˜¯ `y` çš„å…ƒç´ ï¼Œé›†åˆ `x` æ˜¯é›†åˆ `y` çš„ å­é›† ã€‚

**ç¤ºä¾‹ 1ï¼š**

> è¾“å…¥ï¼šstrs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
>
> è¾“å‡ºï¼š4
>
> è§£é‡Šï¼šæœ€å¤šæœ‰ 5 ä¸ª 0 å’Œ 3 ä¸ª 1 çš„æœ€å¤§å­é›†æ˜¯ {"10","0001","1","0"} ï¼Œå› æ­¤ç­”æ¡ˆæ˜¯ 4 ã€‚
>
> å…¶ä»–æ»¡è¶³é¢˜æ„ä½†è¾ƒå°çš„å­é›†åŒ…æ‹¬ {"0001","1"} å’Œ {"10","1","0"} ã€‚{"111001"} ä¸æ»¡è¶³é¢˜æ„ï¼Œå› ä¸ºå®ƒå« 4 ä¸ª 1 ï¼Œå¤§äº n çš„å€¼ 3 ã€‚

**ç¤ºä¾‹ 2ï¼š**

> è¾“å…¥ï¼šstrs = ["10", "0", "1"], m = 1, n = 1
>
> è¾“å‡ºï¼š2
>
> è§£é‡Šï¼šæœ€å¤§çš„å­é›†æ˜¯ {"0", "1"} ï¼Œæ‰€ä»¥ç­”æ¡ˆæ˜¯ 2 ã€‚

## è§£é¢˜æ€è·¯

### æ€è·¯ä¸€ï¼šåŠ¨æ€è§„åˆ’

è¿™ä¸ªé—®é¢˜å¯ä»¥ä½¿ç”¨åŠ¨æ€è§„åˆ’æ¥è§£å†³ï¼Œä¸ 0-1 èƒŒåŒ…é—®é¢˜æœ‰ä¸€äº›ç›¸ä¼¼ä¹‹å¤„ã€‚

å¯ä»¥å®šä¹‰ä¸€ä¸ªä¸‰ç»´åŠ¨æ€è§„åˆ’æ•°ç»„ `dp`ï¼Œå…¶ä¸­ `dp[i][j][k]` è¡¨ç¤ºåœ¨å‰ `i` ä¸ªå­—ç¬¦ä¸²ä¸­ä½¿ç”¨ `j` ä¸ª '0' å’Œ `k` ä¸ª '1' çš„æ¡ä»¶ä¸‹ï¼Œæœ€å¤§å­é›†çš„é•¿åº¦ã€‚

åŠ¨æ€è§„åˆ’çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹å¦‚ä¸‹ï¼š

`dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j-zeros][k-ones] + 1)`

å…¶ä¸­ï¼Œ`zeros` è¡¨ç¤ºç¬¬ `i` ä¸ªå­—ç¬¦ä¸²ä¸­ '0' çš„ä¸ªæ•°ï¼Œ`ones` è¡¨ç¤ºç¬¬ `i` ä¸ªå­—ç¬¦ä¸²ä¸­ '1' çš„ä¸ªæ•°ã€‚

æ¥ä¸‹æ¥ï¼Œéå†æ¯ä¸ªå­—ç¬¦ä¸²ï¼Œæ›´æ–°åŠ¨æ€è§„åˆ’æ•°ç»„ï¼Œæœ€åè¿”å› `dp[len][m][n]`ï¼Œè¡¨ç¤ºä½¿ç”¨æœ€å¤š `m` ä¸ª '0' å’Œ `n` ä¸ª '1' æ¡ä»¶ä¸‹å¾—åˆ°çš„æœ€å¤§å­—ç¬¦ä¸²æ•°ç›®ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(len * m * n)`ï¼Œå…¶ä¸­ `len` æ˜¯å­—ç¬¦ä¸²æ•°ç»„çš„é•¿åº¦ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(len * m * n)`ã€‚

---

### æ€è·¯äºŒï¼šå‹ç¼©çŠ¶æ€çš„åŠ¨æ€è§„åˆ’

æ³¨æ„åˆ° `dp[i][j][k]` éƒ½æ˜¯é€šè¿‡ä¸Šä¸€è¡Œ `dp[i-1][..][..]` è½¬ç§»è¿‡æ¥çš„ï¼Œå†ä¹‹å‰æ‰€æœ‰è¡Œçš„æ•°æ®éƒ½ä¸ä¼šå†ä½¿ç”¨äº†ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹åŠ¨æ€è§„åˆ’è¿›è¡ŒçŠ¶æ€å‹ç¼©ï¼Œå°†ä¸‰ç»´ `dp` æ•°ç»„å‹ç¼©ä¸ºäºŒç»´ï¼ŒèŠ‚çº¦ç©ºé—´å¤æ‚åº¦ï¼š

- `dp[j][k]` è¡¨ç¤ºåœ¨å½“å‰å…ƒç´ ä¸­ï¼Œä½¿ç”¨ `j` ä¸ª '0' å’Œ `k` ä¸ª '1' çš„æ¡ä»¶ä¸‹ï¼Œæœ€å¤§å­é›†çš„é•¿åº¦ï¼›
- éå† `strs` æ•°ç»„ä¸­çš„æ¯ä¸ªå­—ç¬¦ä¸² `str`ï¼Œå¹¶æ›´æ–° `dp` æ•°ç»„ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ `j` å’Œ `k` åº”è¯¥ä»åå¾€å‰åå‘éå†ï¼Œç¡®ä¿äº†æˆ‘ä»¬åœ¨æ›´æ–°å½“å‰çŠ¶æ€æ—¶æ‰€ä¾èµ–çš„çŠ¶æ€å·²ç»è¢«æ­£ç¡®è®¡ç®—ï¼›
- çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š`dp[j][k] = max(dp[j][k], dp[j - zeros][k - ones] + 1)`ï¼›
- æœ€ç»ˆç»“æœå­˜å‚¨åœ¨ `dp[m][n]` ä¸­ï¼›

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(len * m * n)`ï¼Œå…¶ä¸­ `len` æ˜¯å­—ç¬¦ä¸²æ•°ç»„çš„é•¿åº¦ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(m * n)`ã€‚

## ä»£ç 

::: code-tabs

@tab åŠ¨æ€è§„åˆ’

```javascript
/**
 * @param {string[]} strs
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var findMaxForm = function (strs, m, n) {
	const len = strs.length;
	const dp = new Array(len + 1)
		.fill(0)
		.map(() => new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0)));

	for (let i = 1; i <= len; i++) {
		const zeros = [...strs[i - 1]].filter((i) => i == '0').length;
		const ones = strs[i - 1].length - zeros;
		for (let j = m; j >= 0; j--) {
			for (let k = n; k >= 0; k--) {
				if (zeros > j || ones > k) {
					dp[i][j][k] = dp[i - 1][j][k];
				} else {
					dp[i][j][k] = Math.max(
						dp[i - 1][j][k],
						dp[i - 1][j - zeros][k - ones] + 1
					);
				}
			}
		}
	}
	return dp[len][m][n];
};
```

@tab å‹ç¼©çŠ¶æ€çš„åŠ¨æ€è§„åˆ’

```javascript
/**
 * @param {string[]} strs
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var findMaxForm = function (strs, m, n) {
	const len = strs.length;
	const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));
	for (let str of strs) {
		const zeros = [...str].filter((i) => i == '0').length;
		const ones = str.length - zeros;

		for (let j = m; j >= 0; j--) {
			for (let k = n; k >= 0; k--) {
				if (j >= zeros && k >= ones) {
					dp[j][k] = Math.max(dp[j][k], dp[j - zeros][k - ones] + 1);
				}
			}
		}
	}
	return dp[m][n];
};
```

:::

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 600 | [ä¸å«è¿ç»­1çš„éè´Ÿæ•´æ•°](https://leetcode.com/problems/non-negative-integers-without-consecutive-ones) |  |  [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md) | <font color=#ff334b>Hard</font> |
| 2031 | [1 æ¯” 0 å¤šçš„å­æ•°ç»„ä¸ªæ•°](https://leetcode.com/problems/count-subarrays-with-more-ones-than-zeros) |  |  [`æ ‘çŠ¶æ•°ç»„`](/tag/binary-indexed-tree.md) [`çº¿æ®µæ ‘`](/tag/segment-tree.md) [`æ•°ç»„`](/tag/array.md) `4+` | <font color=#ffb800>Medium</font> |
| 2155 | [åˆ†ç»„å¾—åˆ†æœ€é«˜çš„æ‰€æœ‰ä¸‹æ ‡](https://leetcode.com/problems/all-divisions-with-the-highest-score-of-a-binary-array) |  |  [`æ•°ç»„`](/tag/array.md) | <font color=#ffb800>Medium</font> |

<style>
.blue {
    background-color: #096dd9;
    padding: 0.25rem 0.5rem;
    margin: 0;
    font-size: 0.85em;
    border-radius: 3px;
    color: white;
    font-weight: 500;
}
table th:first-of-type { width: 10%; }
table th:nth-of-type(2) { width: 35%; }
table th:nth-of-type(3) { width: 10%; }
table th:nth-of-type(4) { width: 35%; }
table th:nth-of-type(5) { width: 10%; }
</style>
