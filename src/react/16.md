# 16. å®ç° Noop Renderer

::: info æ‘˜è¦

- å®ç° Noop Renderer
- æ‰“åŒ… Noop Renderer
- æµ‹è¯• useEffect

ç›¸å…³ä»£ç å¯åœ¨ [`git tag v1.16`](https://github.com/2xiao/my-react/tree/v1.16) æŸ¥çœ‹

:::

`react-noop-renderer` å’Œ `react-dom` éƒ½æ˜¯ React æä¾›çš„æ¸²æŸ“å™¨ï¼Œç”¨äºå°† React ç»„ä»¶æ¸²æŸ“åˆ°ä¸åŒçš„ç¯å¢ƒä¸­ã€‚

`react-dom` ä¸»è¦ç”¨äºåœ¨æµè§ˆå™¨ç¯å¢ƒä¸­æ¸²æŸ“ React ç»„ä»¶ï¼Œå®ƒæä¾›äº†ä¸€ç³»åˆ—æ–¹æ³•æ¥å°†ç»„ä»¶æŒ‚è½½åˆ° DOM ä¸Šï¼Œå¹¶å¤„ç†äº‹ä»¶ã€æ›´æ–°ç­‰ç›¸å…³æ“ä½œï¼›

è€Œ `react-noop-renderer` åˆ™ä¸»è¦ç”¨äºåœ¨éæµè§ˆå™¨ç¯å¢ƒä¸­è¿›è¡Œæµ‹è¯•å’Œè°ƒè¯•ï¼Œå®ƒä¸ä¾èµ–äºçœŸå®çš„ DOMï¼Œä¹Ÿä¸çœŸæ­£æ“ä½œ DOMï¼Œè€Œæ˜¯æä¾›äº†ä¸€ç§æ¨¡æ‹Ÿçš„æ¸²æŸ“ç¯å¢ƒï¼Œå¯ä»¥åœ¨ Node.js ç­‰ç¯å¢ƒä¸­è¿›è¡Œæ¸²æŸ“å’Œæµ‹è¯• React ç»„ä»¶ï¼Œè¿™å¯¹äºç¼–å†™å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ä»¥åŠæœåŠ¡å™¨ç«¯æ¸²æŸ“ç­‰åœºæ™¯éå¸¸æœ‰ç”¨ã€‚

ç°åœ¨æˆ‘ä»¬å°±æ¥å®ç° `react-noop-renderer` åŒ…ï¼Œå¹¶æµ‹è¯•ä¸€ä¸‹ `react-reconciler` åœ¨éæµè§ˆå™¨ç¯å¢ƒä¸­çš„æ‰§è¡Œç»“æœã€‚

## 1. å®ç° Noop Renderer

`react-noop-renderer` åŒ…å’Œ `react-dom` åŒ…å¾ˆåƒï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥æ‹·è´ä¸€ä»½ `react-dom` åŒ…ï¼Œç„¶åå¯¹å…¶ä¸­æ¶‰åŠ DOM æ“ä½œçš„éƒ¨åˆ†è¿›è¡Œä¿®æ”¹å³å¯ã€‚

å¯¹äº hostConfig æ¥è¯´ï¼Œè¦åšä»¥ä¸‹æ›´æ”¹ï¼š

- ä¿®æ”¹ `Instance`ã€`TextInstance` å’Œ `Container` çš„æ•°æ®ç»“æ„ï¼Œæ¨¡æ‹Ÿå…ƒç´ èŠ‚ç‚¹ã€æ–‡æœ¬èŠ‚ç‚¹ã€æ ¹å®¹å™¨çš„ç›¸åº”å­—æ®µï¼›
- ç»´æŠ¤ `instanceCounter` è®¡æ•°å™¨ï¼Œæ¥ä¸ºæ¯ä¸ªå®ä¾‹åˆ†é…å”¯ä¸€çš„ idï¼›
- è°ƒæ•´ `appendInitialChild` å’Œ `appendChildToContainer` ç­‰æ–¹æ³•ï¼Œå°† DOM æ“ä½œæ”¹é€ æˆæ•°ç»„çš„ `splice` ã€ `push` ç­‰æ“ä½œï¼›

::: details ğŸ‘‰ æŸ¥çœ‹ä»£ç  ğŸ‘ˆ

```ts
// packages/react-noop-renderer/src/hostConfig.ts
import { FiberNode } from 'react-reconciler/src/fiber';
import { HostText } from 'react-reconciler/src/workTags';
import { Props } from 'shared/ReactTypes';

export interface Container {
	rootID: number;
	children: (Instance | TextInstance)[];
}

export interface Instance {
	id: number;
	type: string;
	children: (Instance | TextInstance)[];
	parent: number;
	props: Props;
}

export interface TextInstance {
	text: string;
	id: number;
	parent: number;
}

let instanceCounter = 0;

export const createInstance = (type: string, props: Props): Instance => {
	const instance = {
		id: instanceCounter++,
		type,
		children: [],
		parent: -1,
		props
	};
	return instance;
};

export const appendInitialChild = (
	parent: Instance | Container,
	child: Instance
) => {
	const prevParentID = child.parent;
	const parentID = 'rootID' in parent ? parent.rootID : parent.id;

	if (prevParentID !== -1 && prevParentID !== parentID) {
		throw new Error('ä¸èƒ½é‡å¤æŒ‚è½½child');
	}
	child.parent = parentID;
	parent.children.push(child);
};

export const createTextInstance = (content: string) => {
	const instance = {
		text: content,
		id: instanceCounter++,
		parent: -1
	};
	return instance;
};

export const appendChildToContainer = (child: Instance, parent: Container) => {
	const prevParentID = child.parent;

	if (prevParentID !== -1 && prevParentID !== parent.rootID) {
		throw new Error('ä¸èƒ½é‡å¤æŒ‚è½½child');
	}
	child.parent = parent.rootID;
	parent.children.push(child);
};

export function insertChildToContainer(
	child: Instance,
	container: Container,
	before: Instance
) {
	const beforeIndex = container.children.indexOf(before);
	if (beforeIndex === -1) {
		throw new Error('beforeèŠ‚ç‚¹ä¸å­˜åœ¨');
	}
	const index = container.children.indexOf(child);
	if (index !== -1) {
		container.children.splice(index, 1);
	}
	container.children.splice(beforeIndex, 0, child);
}

export function commitUpdate(fiber: FiberNode) {
	switch (fiber.tag) {
		case HostText:
			const text = fiber.memoizedProps?.content;
			return commitTextUpdate(fiber.stateNode, text);
		default:
			if (__DEV__) {
				console.warn('æœªå®ç°çš„ commitUpdate ç±»å‹', fiber);
			}
			break;
	}
}

export const commitTextUpdate = (
	textInstance: TextInstance,
	content: string
) => {
	textInstance.text = content;
};

export const removeChild = (
	child: Instance | TextInstance,
	container: Container
) => {
	const index = container.children.indexOf(child);
	if (index === -1) {
		throw new Error('child not found');
	}
	container.children.splice(index, 1);
};

export const scheduleMicroTask =
	typeof queueMicrotask === 'function'
		? queueMicrotask
		: typeof Promise === 'function'
		? (callback: (...args: any) => void) => Promise.resolve(null).then(callback)
		: setTimeout;
```

:::

åœ¨ `root.ts` ä¸­å®ç°åˆ›å»ºæ ¹å®¹å™¨ã€æ›´æ–°æ ¹å®¹å™¨ç­‰åŠŸèƒ½ï¼Œè¿˜é¢å¤–å®ç°äº† `getChildren` å’Œ `getChildrenAsJSX` ä¸¤ä¸ªæ–¹æ³•ï¼Œç”¨äºè·å–æ ¹å®¹å™¨çš„å­èŠ‚ç‚¹åŠå°†å­èŠ‚ç‚¹è½¬æ¢ä¸º JSXï¼š

- **createRoot** å‡½æ•°ï¼š

  - `createRoot` å‡½æ•°ç”¨äºåˆ›å»ºä¸€ä¸ª React æ ¹å®¹å™¨ç®¡ç†å™¨ã€‚
  - åœ¨ `createRoot` å‡½æ•°å†…éƒ¨ï¼Œé¦–å…ˆåˆ›å»ºä¸€ä¸ª `container` å¯¹è±¡ï¼ŒåŒ…å«ä¸€ä¸ª `rootID` å’Œä¸€ä¸ªç©ºçš„ `children` æ•°ç»„ã€‚ç„¶åé€šè¿‡ `createContainer` å‡½æ•°åˆ›å»ºä¸€ä¸ª Fiber æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œå¹¶å°† `container` å¯¹è±¡ä½œä¸ºæ ¹èŠ‚ç‚¹çš„å®ä¾‹ã€‚

- **render** æ–¹æ³•ï¼š

  - `render` æ–¹æ³•ç”¨äºæ¸²æŸ“ React å…ƒç´ åˆ°æ ¹å®¹å™¨ä¸Šï¼Œè°ƒç”¨ `updateContainer` å‡½æ•°è¿›è¡Œæ›´æ–°æ“ä½œã€‚

- **getChildren** æ–¹æ³•ï¼š

  - `getChildren` æ–¹æ³•ç”¨äºè·å–æŒ‡å®šå®¹å™¨æˆ–å®ä¾‹çš„å­èŠ‚ç‚¹ã€‚
  - å¦‚æœä¼ å…¥çš„å‚æ•°å­˜åœ¨ä¸”æœ‰å­èŠ‚ç‚¹ï¼Œåˆ™è¿”å›å­èŠ‚ç‚¹æ•°ç»„ï¼Œå¦åˆ™è¿”å› nullã€‚

- **getChildrenAsJSX** æ–¹æ³•ï¼š

  - `getChildrenAsJSX` æ–¹æ³•ç”¨äºå°†å­èŠ‚ç‚¹æ•°ç»„è½¬æ¢ä¸º JSX å…ƒç´ ã€‚
  - é¦–å…ˆé€šè¿‡ `childToJSX` å‡½æ•°å°†å­èŠ‚ç‚¹æ•°ç»„è½¬æ¢ä¸º JSX å…ƒç´ ã€‚å¦‚æœå­èŠ‚ç‚¹æ•°ç»„åªåŒ…å«ä¸€ä¸ªå­èŠ‚ç‚¹ï¼Œåˆ™å°†å…¶ç›´æ¥è¿”å›ï¼›å¦‚æœå­èŠ‚ç‚¹æ•°ç»„åŒ…å«å¤šä¸ªå­èŠ‚ç‚¹ï¼Œåˆ™å°†å…¶åŒ…è£…ä¸ºä¸€ä¸ª `React.Fragment` å…ƒç´ ã€‚
  - æœ€ç»ˆè¿”å›ä¸€ä¸ªç¬¦åˆ React å…ƒç´ ç»“æ„çš„å¯¹è±¡ã€‚

- **childToJSX** å‡½æ•°ï¼š

  - `childToJSX` å‡½æ•°ç”¨äºå°†å­èŠ‚ç‚¹å¯¹è±¡æˆ–æ–‡æœ¬èŠ‚ç‚¹è½¬æ¢ä¸º JSX å…ƒç´ ã€‚
  - å¦‚æœå­èŠ‚ç‚¹æ˜¯æ–‡æœ¬èŠ‚ç‚¹ï¼Œåˆ™ç›´æ¥è¿”å›æ–‡æœ¬å†…å®¹ã€‚
  - å¦‚æœå­èŠ‚ç‚¹æ˜¯æ•°ç»„ï¼Œåˆ™é€’å½’è°ƒç”¨ `childToJSX` å‡½æ•°å¤„ç†æ•°ç»„ä¸­çš„æ¯ä¸ªå­èŠ‚ç‚¹ã€‚
  - å¦‚æœå­èŠ‚ç‚¹æ˜¯å®ä¾‹å¯¹è±¡ï¼ˆä»£è¡¨ React å…ƒç´ èŠ‚ç‚¹ï¼‰ï¼Œåˆ™æ ¹æ®å®ä¾‹çš„ç±»å‹ã€props å’Œå­èŠ‚ç‚¹é€’å½’æ„å»ºå¯¹åº”çš„ JSX å…ƒç´ ã€‚
  - å¦‚æœå­èŠ‚ç‚¹æ˜¯æ–‡æœ¬å®ä¾‹å¯¹è±¡ï¼Œåˆ™ç›´æ¥è¿”å›å…¶æ–‡æœ¬å†…å®¹ã€‚

- **\_Scheduler**ï¼š
  - å°† `Scheduler` å¯¼å…¥å¹¶æš´éœ²ç»™æ ¹å®¹å™¨ç®¡ç†å™¨ï¼Œä½¿å…¶åœ¨ React ä¸­å¯ä»¥ä½¿ç”¨è°ƒåº¦å™¨æ¥æ§åˆ¶æ›´æ–°çš„ä¼˜å…ˆçº§å’Œæ—¶é—´ã€‚

::: details ğŸ‘‰ æŸ¥çœ‹ä»£ç  ğŸ‘ˆ

```ts
// packages/react-noop-renderer/src/root.ts
import {
	createContainer,
	updateContainer
} from 'react-reconciler/src/fiberReconciler';
import { Container, Instance } from './hostConfig';
import { ReactElementType } from 'shared/ReactTypes';
import { REACT_ELEMENT_TYPE, REACT_FRAGMENT_TYPE } from 'shared/ReactSymbols';
import * as Scheduler from 'scheduler';

let idCounter = 0;
export function createRoot() {
	const container: Container = {
		rootID: idCounter++,
		children: []
	};
	const root = createContainer(container);

	function getChildren(parent: Container | Instance) {
		if (parent) {
			return parent.children;
		}
		return null;
	}

	function getChildrenAsJSX(root: Container) {
		const children = childToJSX(getChildren(root));
		if (Array.isArray(children)) {
			return {
				$$typeof: REACT_ELEMENT_TYPE,
				type: REACT_FRAGMENT_TYPE,
				key: null,
				ref: null,
				props: { children },
				__mark: 'erxiao'
			};
		}
		return children;
	}

	function childToJSX(child: any): any {
		// æ–‡æœ¬èŠ‚ç‚¹
		if (typeof child === 'string' || typeof child === 'number') {
			return child;
		}

		// æ•°ç»„
		if (Array.isArray(child)) {
			if (child.length === 0) return null;
			if (child.length === 1) return childToJSX(child[0]);
			const children = child.map(childToJSX);

			if (
				children.every(
					(child) => typeof child === 'string' || typeof child === 'number'
				)
			) {
				return children.join('');
			}
			return children;
		}

		// Instance
		if (Array.isArray(child.children)) {
			const instance: Instance = child;
			const children = childToJSX(instance.children);
			const props = instance.props;

			if (children !== null) {
				props.children = children;
			}

			return {
				$$typeof: REACT_ELEMENT_TYPE,
				type: instance.type,
				key: null,
				ref: null,
				props,
				__mark: 'erxiao'
			};
		}

		// TextInstance
		return child.text;
	}

	return {
		_Scheduler: Scheduler,
		render(element: ReactElementType) {
			return updateContainer(element, root);
		},
		getChildren() {
			return getChildren(container);
		},
		getChildrenAsJSX() {
			return getChildrenAsJSX(container);
		}
	};
}
```

:::

å¯¹äºå¦‚ä¸‹çš„ç»„ä»¶ï¼Œç»ç”± Noop-Renderer æ¸²æŸ“åå¾—åˆ°çš„æ ‘çŠ¶ç»“æ„å¦‚ä¸‹ï¼ˆå¯¹æ ‡ DOM æ ‘ï¼‰ï¼š

::: code-tabs
@tab jsx

```js
import React from 'react';
import ReactNoop from 'react-noop-renderer';

function Child() {
	return 'I am child';
}
function App() {
	return (
		<div>
			<Child />
			<div>hello world</div>
		</div>
	);
}
const root = ReactNoop.createRoot();
root.render(<App />);
```

@tab getChildren()

```ts
root.getChildren();

[
	{
		id: 7,
		parent: 1,
		children: [
			{ text: 'I am child', id: 4, parent: 7 },
			{
				children: [{ text: 'hello world', id: 5, parent: 6 }],
				id: 6,
				parent: 7,
				type: 'div'
			}
		],
		type: 'div'
	}
];
```

@tab getChildrenAsJSX()

```ts
root.getChildrenAsJSX();

{
	$$typeof: Symbol(react.element),
	key: null,
	props: {
		children: [
			'I am child',
			{
				$$typeof: Symbol(react.element),
				key: null,
				props: { children: 'hello world' },
				ref: null,
				type: 'div',
				__mark: 'erxiao'
			}
		]
	},
	ref: null,
	type: 'div',
	__mark: 'erxiao'
};
```

:::

## 2. æ‰“åŒ… Noop Renderer

`react-noop-renderer` åŒ…çš„æ‰“åŒ…æµç¨‹å’Œ `react-dom` åŒ…ç±»ä¼¼ï¼Œæ–°å»º `rollup/react-noop-renderer.config.js` æ–‡ä»¶ï¼š

::: details ğŸ‘‰ æŸ¥çœ‹ä»£ç  ğŸ‘ˆ

```js
import { getPackageJSON, resolvePkgPath, getBaseRollupPlugins } from './utils';
import generatePackageJson from 'rollup-plugin-generate-package-json';
import alias from '@rollup/plugin-alias';

const { name, module, peerDependencies } = getPackageJSON(
	'react-noop-renderer'
);
// react-noop-renderer åŒ…çš„è·¯å¾„
const pkgPath = resolvePkgPath(name);
// react-noop-renderer åŒ…çš„äº§ç‰©è·¯å¾„
const pkgDistPath = resolvePkgPath(name, true);

export default [
	// react-noop-renderer
	{
		input: `${pkgPath}/${module}`,
		output: [
			{
				file: `${pkgDistPath}/index.js`,
				name: 'ReactNoopRenderer',
				format: 'umd'
			}
		],
		external: [...Object.keys(peerDependencies), 'scheduler'],
		plugins: [
			...getBaseRollupPlugins({
				typescript: {
					exclude: ['./packages/react-dom/**/*'],
					tsconfigOverride: {
						compilerOptions: {
							paths: {
								hostConfig: [`./${name}/src/hostConfig.ts`]
							}
						}
					}
				}
			}),
			// webpack resolve alias
			alias({
				entries: {
					hostConfig: `${pkgPath}/src/hostConfig.ts`
				}
			}),
			generatePackageJson({
				inputFolder: pkgPath,
				outputFolder: pkgDistPath,
				baseContents: ({ name, description, version }) => ({
					name,
					description,
					version,
					peerDependencies: {
						react: version
					},
					main: 'index.js'
				})
			})
		]
	}
];
```

:::

å¹¶åœ¨ `dev.config.js` ä¸­åŠ å…¥ `reactNoopRendererConfig`ï¼Œç»Ÿä¸€æ‰“åŒ…ï¼š

```js
import reactConfig from './react.config';
import reactDomConfig from './react-dom.config';
import reactNoopRendererConfig from './react-noop-renderer.config';

export default () => {
	return [...reactConfig, ...reactDomConfig, ...reactNoopRendererConfig];
};
```

ç°åœ¨è¿è¡Œ `pnpm build-dev` å°±å¯ä»¥åœ¨ `dist` æ–‡ä»¶ä¸­çœ‹åˆ°æ‰“åŒ…å‡ºæ¥çš„ `react-noop-renderer`ã€‚

## 3. æµ‹è¯• useEffect

ä¸ºäº†å®Œå–„ Reconciler çš„æµ‹è¯•ç¯å¢ƒï¼Œæ”¯æŒå¼‚æ­¥æ“ä½œå’Œå¹¶å‘æƒ…å†µçš„æµ‹è¯•ï¼Œæˆ‘ä»¬å…ˆå®‰è£…ä¸€ä¸ªå¹¶å‘çš„æµ‹è¯•ä¸Šä¸‹æ–‡ç¯å¢ƒï¼š

```
pnpm i -D -w jest-react
```

å†å®‰è£… matchersï¼Œåœ¨ `scripts/jest/` æ–‡ä»¶å¤¹ä¸­æ–°å¢ä»¥ä¸‹ä¸‰ä¸ªæ–‡ä»¶ï¼š

- `reactTestMatchers.js` æ–‡ä»¶ï¼š

::: details

```js
'use strict';

const JestReact = require('jest-react');
const SchedulerMatchers = require('./schedulerTestMatchers');

function captureAssertion(fn) {
	// Trick to use a Jest matcher inside another Jest matcher. `fn` contains an
	// assertion; if it throws, we capture the error and return it, so the stack
	// trace presented to the user points to the original assertion in the
	// test file.
	try {
		fn();
	} catch (error) {
		return {
			pass: false,
			message: () => error.message
		};
	}
	return { pass: true };
}

function assertYieldsWereCleared(Scheduler) {
	const actualYields = Scheduler.unstable_clearYields();
	if (actualYields.length !== 0) {
		throw new Error(
			'Log of yielded values is not empty. ' +
				'Call expect(Scheduler).toHaveYielded(...) first.'
		);
	}
}

function toMatchRenderedOutput(ReactNoop, expectedJSX) {
	if (typeof ReactNoop.getChildrenAsJSX === 'function') {
		const Scheduler = ReactNoop._Scheduler;
		assertYieldsWereCleared(Scheduler);
		return captureAssertion(() => {
			expect(ReactNoop.getChildrenAsJSX()).toEqual(expectedJSX);
		});
	}
	return JestReact.unstable_toMatchRenderedOutput(ReactNoop, expectedJSX);
}

module.exports = {
	...SchedulerMatchers,
	toMatchRenderedOutput
};
```

:::

- `schedulerTestMatchers.js` æ–‡ä»¶ï¼š

::: details

```js
'use strict';

function captureAssertion(fn) {
	// Trick to use a Jest matcher inside another Jest matcher. `fn` contains an
	// assertion; if it throws, we capture the error and return it, so the stack
	// trace presented to the user points to the original assertion in the
	// test file.
	try {
		fn();
	} catch (error) {
		return {
			pass: false,
			message: () => error.message
		};
	}
	return { pass: true };
}

function assertYieldsWereCleared(Scheduler) {
	const actualYields = Scheduler.unstable_clearYields();
	if (actualYields.length !== 0) {
		throw new Error(
			'Log of yielded values is not empty. ' +
				'Call expect(Scheduler).toHaveYielded(...) first.'
		);
	}
}

function toFlushAndYield(Scheduler, expectedYields) {
	assertYieldsWereCleared(Scheduler);
	Scheduler.unstable_flushAllWithoutAsserting();
	const actualYields = Scheduler.unstable_clearYields();
	return captureAssertion(() => {
		expect(actualYields).toEqual(expectedYields);
	});
}

function toFlushAndYieldThrough(Scheduler, expectedYields) {
	assertYieldsWereCleared(Scheduler);
	Scheduler.unstable_flushNumberOfYields(expectedYields.length);
	const actualYields = Scheduler.unstable_clearYields();
	return captureAssertion(() => {
		expect(actualYields).toEqual(expectedYields);
	});
}

function toFlushUntilNextPaint(Scheduler, expectedYields) {
	assertYieldsWereCleared(Scheduler);
	Scheduler.unstable_flushUntilNextPaint();
	const actualYields = Scheduler.unstable_clearYields();
	return captureAssertion(() => {
		expect(actualYields).toEqual(expectedYields);
	});
}

function toFlushWithoutYielding(Scheduler) {
	return toFlushAndYield(Scheduler, []);
}

function toFlushExpired(Scheduler, expectedYields) {
	assertYieldsWereCleared(Scheduler);
	Scheduler.unstable_flushExpired();
	const actualYields = Scheduler.unstable_clearYields();
	return captureAssertion(() => {
		expect(actualYields).toEqual(expectedYields);
	});
}

function toHaveYielded(Scheduler, expectedYields) {
	return captureAssertion(() => {
		const actualYields = Scheduler.unstable_clearYields();
		expect(actualYields).toEqual(expectedYields);
	});
}

function toFlushAndThrow(Scheduler, ...rest) {
	assertYieldsWereCleared(Scheduler);
	return captureAssertion(() => {
		expect(() => {
			Scheduler.unstable_flushAllWithoutAsserting();
		}).toThrow(...rest);
	});
}

module.exports = {
	toFlushAndYield,
	toFlushAndYieldThrough,
	toFlushUntilNextPaint,
	toFlushWithoutYielding,
	toFlushExpired,
	toHaveYielded,
	toFlushAndThrow
};
```

:::

- `setupJest.js` æ–‡ä»¶ï¼š

::: details

```js
expect.extend({
	...require('./reactTestMatchers')
});
```

:::

å†ä¿®æ”¹ä¸€ä¸‹ jest çš„é…ç½®æ–‡ä»¶ `jest.config.js`ï¼Œæ–°å¢ä»¥ä¸‹é…ç½®ï¼š

```js
const { defaults } = require('jest-config');

module.exports = {
	// ...
	moduleNameMapper: {
		'^scheduler$': '<rootDir>/node_modules/scheduler/unstable_mock.js'
	},
	fakeTimers: {
		enableGlobally: true,
		legacyFakeTimers: true
	},
	setupFilesAfterEnv: ['./scripts/jest/setupJest.js']
};
```

ç°åœ¨å°±å¯ä»¥è¿è¡Œæµ‹è¯•ç”¨ä¾‹äº†ï¼Œåœ¨ `react-reconciler` åŒ…ä¸­æ–°å¢ `__tests__` æ–‡ä»¶å¤¹ï¼Œç”¨æ¥æ”¾æµ‹è¯•ç”¨ä¾‹ï¼Œç„¶åæ–°å¢æµ‹è¯•ç”¨ä¾‹ `ReactEffectOrdering-test.js`ï¼š

::: details

```js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @emails react-core
 * @jest-environment node
 */

/* eslint-disable no-func-assign */

'use strict';

let React;
let ReactNoop;
let Scheduler;
let act;
let useEffect;

describe('ReactHooksWithNoopRenderer', () => {
	beforeEach(() => {
		jest.resetModules();
		jest.useFakeTimers();

		React = require('react');
		act = require('jest-react').act;
		Scheduler = require('scheduler');
		ReactNoop = require('react-noop-renderer');

		useEffect = React.useEffect;
	});

	test('passive unmounts on deletion are fired in parent -> child order', async () => {
		const root = ReactNoop.createRoot();

		function Parent() {
			useEffect(() => {
				return () => Scheduler.unstable_yieldValue('Unmount parent');
			});
			return <Child />;
		}

		function Child() {
			useEffect(() => {
				return () => Scheduler.unstable_yieldValue('Unmount child');
			});
			return 'Child';
		}

		await act(async () => {
			root.render(<Parent />);
		});

		expect(root).toMatchRenderedOutput('Child');
		await act(async () => {
			root.render(null);
		});
		expect(Scheduler).toHaveYielded(['Unmount parent', 'Unmount child']);
	});
});
```

:::

ç°åœ¨æ‰§è¡Œ `pnpm test` å°±å¯ä»¥å¯¹ `useEffect` è¿›è¡Œæµ‹è¯•äº†ã€‚

ç›¸å…³ä»£ç å¯åœ¨ `git tag v1.16` æŸ¥çœ‹ï¼Œåœ°å€ï¼š[https://github.com/2xiao/my-react/tree/v1.16](https://github.com/2xiao/my-react/tree/v1.16)
