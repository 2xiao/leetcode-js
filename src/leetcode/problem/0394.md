# [394. Decode String](https://leetcode.com/problems/decode-string/)

ðŸŸ  <font color=#ffb800>Medium</font>&emsp; ðŸ”–&ensp; [`æ ˆ`](/leetcode/outline/tag/stack.md) [`é€’å½’`](/leetcode/outline/tag/recursion.md) [`å­—ç¬¦ä¸²`](/leetcode/outline/tag/string.md)&emsp; ðŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/decode-string/)

## é¢˜ç›®

Given an encoded string, return its decoded string.

The encoding rule is:` k[encoded_string]`, where the encoded_string inside the square brackets is being repeated exactly `k` times. Note that `k` is guaranteed to be a positive integer.

You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.

Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, `k`. For example, there won't be input like `3a` or `2[4]`.

**Example 1**:

```
Input: s = "3[a]2[bc]"
Output: "aaabcbc"
```

**Example 2**:

```
Input: s = "3[a2[c]]"
Output: "accaccacc"
```

**Example 3**:

```
Input: s = "2[abc]3[cd]ef"
Output: "abcabccdcdcdef"
```

## é¢˜ç›®å¤§æ„

ç»™å®šä¸€ä¸ªç»è¿‡ç¼–ç çš„å­—ç¬¦ä¸²ï¼Œè¿”å›žå®ƒè§£ç åŽçš„å­—ç¬¦ä¸²ã€‚

ç¼–ç è§„åˆ™ä¸º: `k[encoded_string]`ï¼Œè¡¨ç¤ºå…¶ä¸­æ–¹æ‹¬å·å†…éƒ¨çš„ `encoded_string` æ­£å¥½é‡å¤ `k` æ¬¡ã€‚æ³¨æ„ `k` ä¿è¯ä¸ºæ­£æ•´æ•°ã€‚

ä½ å¯ä»¥è®¤ä¸ºè¾“å…¥å­—ç¬¦ä¸²æ€»æ˜¯æœ‰æ•ˆçš„ï¼›è¾“å…¥å­—ç¬¦ä¸²ä¸­æ²¡æœ‰é¢å¤–çš„ç©ºæ ¼ï¼Œä¸”è¾“å…¥çš„æ–¹æ‹¬å·æ€»æ˜¯ç¬¦åˆæ ¼å¼è¦æ±‚çš„ã€‚

æ­¤å¤–ï¼Œä½ å¯ä»¥è®¤ä¸ºåŽŸå§‹æ•°æ®ä¸åŒ…å«æ•°å­—ï¼Œæ‰€æœ‰çš„æ•°å­—åªè¡¨ç¤ºé‡å¤çš„æ¬¡æ•° `k` ï¼Œä¾‹å¦‚ä¸ä¼šå‡ºçŽ°åƒ `3a` æˆ– `2[4]` çš„è¾“å…¥ã€‚

## è§£é¢˜æ€è·¯

æœ¬é¢˜å’Œ [ç¬¬ 880 é¢˜](./0880.md) ç±»ä¼¼ã€‚éœ€è¦æ³¨æ„ï¼Œæœ¬é¢˜ä¸­å¯èƒ½å‡ºçŽ°æ‹¬å·åµŒå¥—çš„æƒ…å†µï¼Œæ¯”å¦‚ `2[a2[bc]]`ï¼Œè¿™ç§æƒ…å†µä¸‹å¯ä»¥å…ˆè½¬åŒ–æˆ `2[abcbc]`ï¼Œå†è½¬åŒ–æˆ `abcbcabcbc`ï¼Œå¯ä»¥ä½¿ç”¨æ ˆå¤„ç†ã€‚

å…·ä½“åšæ³•æ˜¯ï¼š

- éåŽ†å­—ç¬¦ä¸²ï¼Œå¦‚æžœå½“å‰çš„å­—ç¬¦ä¸ºæ•°ä½ï¼Œè§£æžå‡ºä¸€ä¸ªæ•°å­—ï¼ˆè¿žç»­çš„å¤šä¸ªæ•°ä½ï¼‰å¹¶è¿›æ ˆï¼›
- å¦‚æžœå½“å‰çš„å­—ç¬¦ä¸ºå­—æ¯æˆ–è€…å·¦æ‹¬å·ï¼Œç›´æŽ¥è¿›æ ˆï¼›
- å¦‚æžœå½“å‰çš„å­—ç¬¦ä¸ºå³æ‹¬å·ï¼Œå¼€å§‹å‡ºæ ˆï¼Œä¸€ç›´åˆ°å·¦æ‹¬å·å‡ºæ ˆï¼Œå‡ºæ ˆåºåˆ—åè½¬åŽæ‹¼æŽ¥æˆä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ­¤æ—¶å–å‡ºæ ˆé¡¶çš„æ•°å­—ï¼Œå°±æ˜¯è¿™ä¸ªå­—ç¬¦ä¸²åº”è¯¥å‡ºçŽ°çš„æ¬¡æ•°ï¼Œæ ¹æ®è¿™ä¸ªæ¬¡æ•°å’Œå­—ç¬¦ä¸²æž„é€ å‡ºæ–°çš„å­—ç¬¦ä¸²å¹¶è¿›æ ˆï¼›
- é‡å¤å¦‚ä¸Šæ“ä½œï¼Œæœ€ç»ˆå°†æ ˆä¸­çš„å…ƒç´ æŒ‰ç…§ä»Žæ ˆåº•åˆ°æ ˆé¡¶çš„é¡ºåºæ‹¼æŽ¥èµ·æ¥ï¼Œå°±å¾—åˆ°äº†ç­”æ¡ˆã€‚

## ä»£ç 

```javascript
/**
 * @param {string} s
 * @return {string}
 */
var decodeString = function (s) {
  let stack = [];
  let res = "";
  let k = 0;

  const isDigit = (str) => str >= "0" && str <= "9";

  for (let item of s) {
    if (isDigit(item)) {
      k = k * 10 + Number(item);
    } else if (item === "[") {
      stack.push(k);
      stack.push(item);
      k = 0;
    } else if (item === "]") {
      let str = "";
      while (stack[stack.length - 1] !== "[") {
        str = stack.pop() + str;
      }
      stack.pop();
      let num = stack.pop();
      let repeat_str = "";
      while (num > 0) {
        repeat_str += str;
        num--;
      }
      stack.push(repeat_str);
    } else {
      stack.push(item);
    }
  }
  while (stack.length > 0) {
    res = stack.pop() + res;
  }
  return res;
};
```
