# [2196. Create Binary Tree From Descriptions](https://leetcode.com/problems/create-binary-tree-from-descriptions/)

ðŸŸ  <font color=#ffb800>Medium</font>&emsp; ðŸ”–&ensp; [`æ ‘`](/leetcode/outline/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/breadth-first-search.md) [`æ•°ç»„`](/leetcode/outline/tag/array.md) [`å“ˆå¸Œè¡¨`](/leetcode/outline/tag/hash-table.md) [`äºŒå‰æ ‘`](/leetcode/outline/tag/binary-tree.md)&emsp; ðŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/create-binary-tree-from-descriptions/)

## é¢˜ç›®

You are given a 2D integer array `descriptions` where `descriptions[i] = [parenti, childi, isLefti]` indicates that `parenti` is the **parent** of
`childi` in a **binary** tree of **unique** values. Furthermore,

- If `isLefti == 1`, then `childi` is the left child of `parenti`.
- If `isLefti == 0`, then `childi` is the right child of `parenti`.

Construct the binary tree described by `descriptions` and return _its **root**_.

The test cases will be generated such that the binary tree is **valid**.

**Example 1:**

![](https://assets.leetcode.com/uploads/2022/02/09/example1drawio.png)

> Input: descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]]
>
> Output: [50,20,80,15,17,19]
>
> Explanation: The root node is the node with value 50 since it has no parent.
>
> The resulting binary tree is shown in the diagram.

**Example 2:**

![](https://assets.leetcode.com/uploads/2022/02/09/example2drawio.png)

> Input: descriptions = [[1,2,1],[2,3,0],[3,4,1]]
>
> Output: [1,2,null,null,3,4]
>
> Explanation: The root node is the node with value 1 since it has no parent.
>
> The resulting binary tree is shown in the diagram.

**Constraints:**

- `1 <= descriptions.length <= 10^4`
- `descriptions[i].length == 3`
- `1 <= parenti, childi <= 10^5`
- `0 <= isLefti <= 1`
- The binary tree described by `descriptions` is valid.

## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ªäºŒç»´æ•´æ•°æ•°ç»„ `descriptions` ï¼Œå…¶ä¸­ `descriptions[i] = [parenti, childi, isLefti]` è¡¨ç¤º `parenti` æ˜¯ `childi` åœ¨ äºŒå‰æ ‘ ä¸­çš„ çˆ¶èŠ‚ç‚¹ï¼ŒäºŒå‰æ ‘ä¸­å„èŠ‚ç‚¹çš„å€¼ äº’ä¸ç›¸åŒ ã€‚æ­¤å¤–ï¼š

- å¦‚æžœ `isLefti == 1` ï¼Œé‚£ä¹ˆ `childi` å°±æ˜¯ `parenti` çš„å·¦å­èŠ‚ç‚¹ã€‚
- å¦‚æžœ `isLefti == 0` ï¼Œé‚£ä¹ˆ `childi` å°±æ˜¯ `parenti` çš„å³å­èŠ‚ç‚¹ã€‚
  è¯·ä½ æ ¹æ® `descriptions` çš„æè¿°æ¥æž„é€ äºŒå‰æ ‘å¹¶è¿”å›žå…¶ æ ¹èŠ‚ç‚¹ ã€‚

æµ‹è¯•ç”¨ä¾‹ä¼šä¿è¯å¯ä»¥æž„é€ å‡º æœ‰æ•ˆ çš„äºŒå‰æ ‘ã€‚

## è§£é¢˜æ€è·¯

è¿™é“é¢˜å¯ä»¥é€šè¿‡å­—å…¸æ¥å­˜å‚¨æ ‘èŠ‚ç‚¹ï¼Œç„¶åŽæ ¹æ®æè¿°æž„å»ºäºŒå‰æ ‘ã€‚

1. é¦–å…ˆï¼Œåˆ›å»ºä¸€ä¸ªç©ºå­—å…¸ `map`ï¼Œç”¨äºŽå­˜å‚¨æ ‘èŠ‚ç‚¹ï¼Œé”®ä¸ºèŠ‚ç‚¹çš„å€¼ï¼Œå€¼ä¸ºå¯¹åº”çš„èŠ‚ç‚¹å¯¹è±¡ `TreeNode`ã€‚

2. éåŽ†æè¿°æ•°ç»„ `descriptions`ï¼Œå¯¹äºŽæ¯ä¸ªæè¿° `[parent, child, isLeft]`ï¼š

   - å¦‚æžœ `parent` ä¸åœ¨ `map` ä¸­ï¼Œåˆ›å»ºä¸€ä¸ªå€¼ä¸º `parent` çš„æ ‘èŠ‚ç‚¹ï¼Œå¹¶å°†å…¶åŠ å…¥ `map`ã€‚
   - å¦‚æžœ `child` ä¸åœ¨ `map` ä¸­ï¼Œåˆ›å»ºä¸€ä¸ªå€¼ä¸º `child` çš„æ ‘èŠ‚ç‚¹ï¼Œå¹¶å°†å…¶åŠ å…¥ `map`ã€‚

3. å°†æ‰€æœ‰èŠ‚ç‚¹çš„å€¼å­˜å…¥ `set` ä¸­ï¼Œå› ä¸ºæ ¹èŠ‚ç‚¹æ²¡æœ‰çˆ¶èŠ‚ç‚¹ï¼Œæ‰€ä»¥å¯ä»¥é€šè¿‡æŽ’é™¤æ‰€æœ‰æœ‰çˆ¶èŠ‚ç‚¹çš„å…ƒç´ ï¼Œæ‰¾åˆ°æ ¹èŠ‚ç‚¹ã€‚

4. å†æ¬¡éåŽ†æè¿°æ•°ç»„ï¼Œå¯¹äºŽæ¯ä¸ªæè¿° `[parent, child, isLeft]`ï¼š

- é€šè¿‡ `map` å–å¾—å¯¹åº”çš„çˆ¶èŠ‚ç‚¹å’Œå­èŠ‚ç‚¹å¯¹è±¡ã€‚
- æ ¹æ® `isLeft` çš„å€¼åˆ¤æ–­ï¼Œå¦‚æžœä¸º 1ï¼Œåˆ™å°†å­èŠ‚ç‚¹ä½œä¸ºå·¦å­©å­åŠ åˆ°çˆ¶èŠ‚ç‚¹ä¸Šï¼›å¦‚æžœä¸º 0ï¼Œåˆ™å°†å­èŠ‚ç‚¹ä½œä¸ºå³å­©å­åŠ åˆ°çˆ¶èŠ‚ç‚¹ä¸Šã€‚
- åˆ é™¤ `set` ä¸­ `child` å¯¹åº”çš„å€¼ã€‚

5. æœ€åŽï¼Œ`set` ä¸­å‰©ä¸‹çš„å€¼å³ä¸ºæ ¹èŠ‚ç‚¹ï¼Œåœ¨ `map` ä¸­æ‰¾åˆ°å¯¹åº”çš„èŠ‚ç‚¹å¯¹è±¡è¿”å›žï¼Œå³ä¸ºæž„å»ºå¥½çš„äºŒå‰æ ‘çš„æ ¹ã€‚

## ä»£ç 

```javascript
/**
 * @param {number[][]} descriptions
 * @return {TreeNode}
 */
var createBinaryTree = function (descriptions) {
  let map = new Map();
  for (let [parent, child, isLeft] of descriptions) {
    if (!map.has[parent]) map.set(parent, new TreeNode(parent));
    if (!map.has[child]) map.set(child, new TreeNode(child));
  }
  let set = new Set([...map.keys()]);
  for (let [parent, child, isLeft] of descriptions) {
    let node = map.get(parent);
    if (isLeft) node.left = map.get(child);
    else node.right = map.get(child);
    map.set(parent, node);
    set.delete(child);
  }
  return map.get([...set][0]);
};
```

## ç›¸å…³é¢˜ç›®

:::: md-demo ç›¸å…³é¢˜ç›®

- [109. æœ‰åºé“¾è¡¨è½¬æ¢äºŒå‰æœç´¢æ ‘](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree)
- [1719. é‡æž„ä¸€æ£µæ ‘çš„æ–¹æ¡ˆæ•°](https://leetcode.com/problems/number-of-ways-to-reconstruct-a-tree)

::::
