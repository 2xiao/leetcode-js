# [154. å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼ II](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii)

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`æ•°ç»„`](/leetcode/outline/tag/array.md) [`äºŒåˆ†æŸ¥æ‰¾`](/leetcode/outline/tag/binary-search.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/)

## é¢˜ç›®

Suppose an array of length `n` sorted in ascending order is **rotated**
between `1` and `n` times. For example, the array `nums = [0,1,4,4,5,6,7]`
might become:

- `[4,5,6,7,0,1,4]` if it was rotated `4` times.
- `[0,1,4,4,5,6,7]` if it was rotated `7` times.

Notice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time
results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.

Given the sorted rotated array `nums` that may contain **duplicates** , return
_the minimum element of this array_.

You must decrease the overall operation steps as much as possible.

**Example 1:**

> Input: nums = [1,3,5]
>
> Output: 1

**Example 2:**

> Input: nums = [2,2,2,0,1]
>
> Output: 0

**Constraints:**

- `n == nums.length`
- `1 <= n <= 5000`
- `-5000 <= nums[i] <= 5000`
- `nums` is sorted and rotated between `1` and `n` times.

**Follow up:** This problem is similar to [Find Minimum in Rotated Sorted Array](https:/leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/), but `nums` may contain **duplicates**. Would this affect the runtime complexity? How and why?

## é¢˜ç›®å¤§æ„

å‡è®¾æŒ‰ç…§å‡åºæ’åºçš„æ•°ç»„åœ¨é¢„å…ˆæœªçŸ¥çš„æŸä¸ªç‚¹ä¸Šè¿›è¡Œäº†æ—‹è½¬ã€‚(ä¾‹å¦‚ï¼Œæ•°ç»„ `[0,1,2,4,5,6,7]` å¯èƒ½å˜ä¸º Â `[4,5,6,7,0,1,2]`Â )ã€‚è¯·æ‰¾å‡ºå…¶ä¸­æœ€å°çš„å…ƒç´ ã€‚

æ³¨æ„æ•°ç»„ä¸­å¯èƒ½å­˜åœ¨é‡å¤çš„å…ƒç´ ã€‚

## è§£é¢˜æ€è·¯

è¿™ä¸€é¢˜æ˜¯ç¬¬ 153 é¢˜çš„åŠ å¼ºç‰ˆï¼Œå¢åŠ äº†é‡å¤å…ƒç´ çš„æ¡ä»¶ï¼Œåšæ³•æ²¡æœ‰å˜ï¼Œè¿˜æ˜¯ç”¨äºŒåˆ†æœç´¢ï¼Œåªä¸è¿‡åœ¨ç›¸ç­‰å…ƒç´ ä¸Šå¤šå¢åŠ ä¸€ä¸ªåˆ¤æ–­å³å¯ã€‚

åˆ›å»ºä¸¤ä¸ªæŒ‡é’ˆ `left`ã€`right`ï¼Œåˆ†åˆ«æŒ‡å‘æ•°ç»„é¦–å°¾ï¼Œç„¶åè®¡ç®—å‡ºä¸¤ä¸ªæŒ‡é’ˆæ‰€æŒ‡ä¸‹æ ‡çš„ä¸­é—´å€¼ `mid`ï¼Œå°† `mid` ä¸ä¸¤ä¸ªæŒ‡é’ˆåšæ¯”è¾ƒã€‚

- å¦‚æœ `nums[mid] > nums[right]`ï¼Œåˆ™æœ€å°å€¼ä¸å¯èƒ½åœ¨ `mid` å·¦ä¾§ï¼Œä¸€å®šåœ¨ `mid` å³ä¾§ï¼Œåˆ™å°† `left` ç§»åŠ¨åˆ° `mid + 1` ä½ç½®ï¼Œç»§ç»­æŸ¥æ‰¾å³ä¾§åŒºé—´ã€‚
- å¦‚æœ `nums[mid] < nums[right]`ï¼Œåˆ™æœ€å°å€¼ä¸€å®šåœ¨ `mid` å·¦ä¾§ï¼Œæˆ–è€… `mid` ä½ç½®ï¼Œå°† `right` ç§»åŠ¨åˆ° `mid` ä½ç½®ä¸Šï¼Œç»§ç»­æŸ¥æ‰¾å·¦ä¾§åŒºé—´ã€‚
- å¦‚æœ `nums[mid] == nums[right]`ï¼Œæ— æ³•åˆ¤æ–­åœ¨ `mid` çš„å“ªä¸€ä¾§ï¼Œå¯ä»¥é‡‡ç”¨ `right = right - 1` é€æ­¥ç¼©å°åŒºåŸŸã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(log n)`
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(1)`

## ä»£ç 

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMin = function (nums) {
	let left = 0,
		right = nums.length - 1;
	while (left < right) {
		let mid = Math.floor((right + left) / 2);
		if (nums[mid] > nums[right]) {
			left = mid + 1;
		} else if (nums[mid] < nums[right]) {
			right = mid;
		} else {
			right--;
		}
	}
	return nums[left];
};
```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 153 | [å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array) | [[âœ“]](https://2xiao.github.io/leetcode-js/leetcode/problem/0153) |  [`æ•°ç»„`](/leetcode/outline/tag/array.md) [`äºŒåˆ†æŸ¥æ‰¾`](/leetcode/outline/tag/binary-search.md) | <font color=#ffb800>Medium</font> |

<style>
.blue {
    background-color: #096dd9;
    padding: 0.25rem 0.5rem;
    margin: 0;
    font-size: 0.85em;
    border-radius: 3px;
    color: white;
    font-weight: 500;
}
table th:first-of-type { width: 10%; }
table th:nth-of-type(2) { width: 35%; }
table th:nth-of-type(3) { width: 10%; }
table th:nth-of-type(4) { width: 35%; }
table th:nth-of-type(5) { width: 10%; }
</style>
