# [432. å…¨ O(1) çš„æ•°æ®ç»“æ„](https://leetcode.com/problems/all-oone-data-structure)

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`è®¾è®¡`](/leetcode/outline/tag/design.md) [`å“ˆå¸Œè¡¨`](/leetcode/outline/tag/hash-table.md) [`é“¾è¡¨`](/leetcode/outline/tag/linked-list.md) [`åŒå‘é“¾è¡¨`](/leetcode/outline/tag/doubly-linked-list.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/all-oone-data-structure)

## é¢˜ç›®

Design a data structure to store the strings' count with the ability to return
the strings with minimum and maximum counts.

Implement the `AllOne` class:

- `AllOne()` Initializes the object of the data structure.
- `inc(String key)` Increments the count of the string `key` by `1`. If `key` does not exist in the data structure, insert it with count `1`.
- `dec(String key)` Decrements the count of the string `key` by `1`. If the count of `key` is `0` after the decrement, remove it from the data structure. It is guaranteed that `key` exists in the data structure before the decrement.
- `getMaxKey()` Returns one of the keys with the maximal count. If no element exists, return an empty string `""`.
- `getMinKey()` Returns one of the keys with the minimum count. If no element exists, return an empty string `""`.

**Note** that each function must run in `O(1)` average time complexity.

**Example 1:**

> **Input**
>
> ["AllOne", "inc", "inc", "getMaxKey", "getMinKey", "inc", "getMaxKey", "getMinKey"]
>
> [[], ["hello"], ["hello"], [], [], ["leet"], [], []]
>
> **Output**
>
> [null, null, null, "hello", "hello", null, "hello", "leet"]
>
> **Explanation**
>
> AllOne allOne = new AllOne();
>
> allOne.inc("hello");
>
> allOne.inc("hello");
>
> allOne.getMaxKey(); // return "hello"
>
> allOne.getMinKey(); // return "hello"
>
> allOne.inc("leet");
>
> allOne.getMaxKey(); // return "hello"
>
> allOne.getMinKey(); // return "leet"

**Constraints:**

- `1 <= key.length <= 10`
- `key` consists of lowercase English letters.
- It is guaranteed that for each call to `dec`, `key` is existing in the data structure.
- At most `5 * 10^4` calls will be made to `inc`, `dec`, `getMaxKey`, and `getMinKey`.

## é¢˜ç›®å¤§æ„

è¯·ä½ è®¾è®¡ä¸€ä¸ªç”¨äºå­˜å‚¨å­—ç¬¦ä¸²è®¡æ•°çš„æ•°æ®ç»“æ„ï¼Œå¹¶èƒ½å¤Ÿè¿”å›è®¡æ•°æœ€å°å’Œæœ€å¤§çš„å­—ç¬¦ä¸²ã€‚

å®ç° `AllOne` ç±»ï¼š

- `AllOne()` åˆå§‹åŒ–æ•°æ®ç»“æ„çš„å¯¹è±¡ã€‚
- `inc(String key)` å­—ç¬¦ä¸² `key` çš„è®¡æ•°å¢åŠ  `1` ã€‚å¦‚æœæ•°æ®ç»“æ„ä¸­å°šä¸å­˜åœ¨ `key` ï¼Œé‚£ä¹ˆæ’å…¥è®¡æ•°ä¸º `1` çš„ `key` ã€‚
- `dec(String key)` å­—ç¬¦ä¸² `key` çš„è®¡æ•°å‡å°‘ `1` ã€‚å¦‚æœ `key` çš„è®¡æ•°åœ¨å‡å°‘åä¸º 0 ï¼Œé‚£ä¹ˆéœ€è¦å°†è¿™ä¸ª `key` ä»æ•°æ®ç»“æ„ä¸­åˆ é™¤ã€‚æµ‹è¯•ç”¨ä¾‹ä¿è¯ï¼šåœ¨å‡å°‘è®¡æ•°å‰ï¼Œ`key` å­˜åœ¨äºæ•°æ®ç»“æ„ä¸­ã€‚
- `getMaxKey()` è¿”å›ä»»æ„ä¸€ä¸ªè®¡æ•°æœ€å¤§çš„å­—ç¬¦ä¸²ã€‚å¦‚æœæ²¡æœ‰å…ƒç´ å­˜åœ¨ï¼Œè¿”å›ä¸€ä¸ªç©ºå­—ç¬¦ä¸² `""` ã€‚
- `getMinKey()` è¿”å›ä»»æ„ä¸€ä¸ªè®¡æ•°æœ€å°çš„å­—ç¬¦ä¸²ã€‚å¦‚æœæ²¡æœ‰å…ƒç´ å­˜åœ¨ï¼Œè¿”å›ä¸€ä¸ªç©ºå­—ç¬¦ä¸² `""` ã€‚

**æ³¨æ„**ï¼šæ¯ä¸ªå‡½æ•°éƒ½åº”å½“æ»¡è¶³ `O(1)` å¹³å‡æ—¶é—´å¤æ‚åº¦ã€‚

## è§£é¢˜æ€è·¯

è¿™é“é¢˜å¯ä»¥ç”¨ **å“ˆå¸Œè¡¨ + åŒå‘é“¾è¡¨** æ¥è§£å†³ã€‚

- é“¾è¡¨ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨ä¸€ä¸ªå­—ç¬¦ä¸²é›†åˆ `keys`ï¼Œå’Œä¸€ä¸ªæ­£æ•´æ•° `count`ï¼Œè¡¨ç¤º `keys` ä¸­çš„å­—ç¬¦ä¸²å‡å‡ºç° `count` æ¬¡ã€‚æ³¨æ„ï¼Œ `count` ç›¸åŒçš„å­—ç¬¦ä¸²å­˜å‚¨åœ¨åŒä¸€ä¸ªèŠ‚ç‚¹ä¸­ã€‚
- é“¾è¡¨ä»å¤´åˆ°å°¾çš„æ¯ä¸ªèŠ‚ç‚¹çš„ `count` å€¼å•è°ƒé€’å¢ï¼ˆä½†ä¸ä¸€å®šè¿ç»­ï¼‰ã€‚
- æ¯ä¸ªèŠ‚ç‚¹è¿˜éœ€å­˜å‚¨æŒ‡å‘ä¸Šä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ `prev` å’ŒæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ `next`ã€‚
- å¦å¤–è¿˜è¦ç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨ `map` ç»´æŠ¤æ¯ä¸ªå­—ç¬¦ä¸²å½“å‰æ‰€å¤„çš„é“¾è¡¨èŠ‚ç‚¹ã€‚

1. å¯¹äº `inc` æ“ä½œï¼š

- å½“è‹¥ `key` ä¸åœ¨é“¾è¡¨ä¸­ï¼Œåˆ¤æ–­å½“å‰é“¾è¡¨æœ‰æ²¡æœ‰ `count = 1` çš„èŠ‚ç‚¹ã€‚å› ä¸ºé“¾è¡¨æ˜¯æŒ‰ç…§ `count` å‡åºæ’åˆ—çš„ï¼Œæ‰€ä»¥åªéœ€è¦çœ‹å¤´èŠ‚ç‚¹çš„ `count` æ˜¯å¦ä¸º `1`ï¼›

  - è‹¥æœ‰åˆ™å…±ç”¨æ­¤èŠ‚ç‚¹ï¼›
  - å¦åˆ™æ–°å»ºä¸€ä¸ª `count = 1` çš„èŠ‚ç‚¹ï¼›

- è‹¥ `key` åœ¨é“¾è¡¨ä¸­ï¼Œè®¾ `key` æ‰€åœ¨èŠ‚ç‚¹ä¸º `cur`ï¼Œåˆ¤æ–­å½“å‰é“¾è¡¨æœ‰æ²¡æœ‰ `count = cur.count + 1` çš„èŠ‚ç‚¹ã€‚åŒç†ä¹Ÿåªéœ€è¦åˆ¤æ–­ `cur.next` çš„ `count` æ˜¯å¦ç­‰äº `cur.count + 1`ï¼›

  - è‹¥æœ‰åˆ™å…±ç”¨æ­¤ `cur.next` èŠ‚ç‚¹ï¼›
  - å¦åˆ™æ–°å»ºä¸€ä¸ª `count = cur.count + 1` çš„èŠ‚ç‚¹æ’å…¥åˆ° cur çš„åé¢ï¼›
  - æœ€åï¼Œå°† `key` ä» `cur.keys` ä¸­ç§»é™¤ï¼Œè‹¥ç§»é™¤å cur.keys ä¸ºç©ºï¼Œåˆ™å°† cur ä»é“¾è¡¨ä¸­ç§»é™¤ã€‚å¹¶æ›´æ–° `map` ä¸­ `key` æ‰€å¤„çš„èŠ‚ç‚¹ã€‚

2. å¯¹äº `dec` æ“ä½œï¼š

- è‹¥ `key` ä»…å‡ºç°ä¸€æ¬¡ï¼šå°†å…¶ä» `map` ä¸­ç§»é™¤ã€‚
- è‹¥ `key` å‡ºç°ä¸æ­¢ä¸€æ¬¡ï¼Œåˆ™éœ€è¦åˆ¤æ–­é“¾è¡¨ä¸­æ˜¯å¦æœ‰ `count = cur.count - 1` çš„èŠ‚ç‚¹.
  - è‹¥æœ‰ï¼Œåˆ™å…±ç”¨æ­¤ `cur.prev` èŠ‚ç‚¹;
  - å¦åˆ™æ–°å»ºä¸€ä¸ª `count = cur.count - 1` çš„èŠ‚ç‚¹ï¼›
- æœ€åï¼Œå°† `key` ä» `cur.keys` ä¸­ç§»é™¤ï¼Œè‹¥ç§»é™¤å `cur.keys` ä¸ºç©ºï¼Œåˆ™å°† `cur` ä»é“¾è¡¨ä¸­ç§»é™¤ã€‚

3. å¯¹äº `getMaxKey` æ“ä½œ:

- åœ¨é“¾è¡¨ä¸ä¸ºç©ºæ—¶ï¼Œè¿”å›é“¾è¡¨å°¾èŠ‚ç‚¹çš„ `keys` ä¸­çš„ä»»ä¸€å…ƒç´ ;
- å¦åˆ™è¿”å›ç©ºå­—ç¬¦ä¸²ã€‚

4. å¯¹äº getMinKey æ“ä½œ

- åœ¨é“¾è¡¨ä¸ä¸ºç©ºæ—¶ï¼Œè¿”å›é“¾è¡¨å¤´èŠ‚ç‚¹çš„ `keys` ä¸­çš„ä»»ä¸€å…ƒç´ ;
- å¦åˆ™è¿”å›ç©ºå­—ç¬¦ä¸²ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼šæ‰€æœ‰æ“ä½œå‡ä¸º `O(1)`ï¼Œè¿™é‡Œå°†å­—ç¬¦ä¸²é•¿åº¦è§†ä½œå¸¸æ•°ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œå…¶ä¸­ `n` æ˜¯è°ƒç”¨ `inc` çš„æ¬¡æ•°ã€‚æœ€åæƒ…å†µä¸‹æ¯æ¬¡è°ƒç”¨ `inc` ä¼ å…¥çš„å­—ç¬¦ä¸²å‡ä¸ç›¸åŒï¼Œæˆ‘ä»¬éœ€è¦ `O(n)` å¤§å°çš„å“ˆå¸Œè¡¨æ¥å­˜å‚¨æ‰€æœ‰å­—ç¬¦ä¸²ã€‚

## ä»£ç 

```javascript
class Node {
	constructor(key, count) {
		this.keys = new Set([key || '']);
		this.count = count || 0;
	}

	insert(node) {
		node.prev = this;
		node.next = this.next;
		node.prev.next = node;
		node.next.prev = node;

		return node;
	}
	remove() {
		this.next.prev = this.prev;
		this.prev.next = this.next;
	}
}
var AllOne = function () {
	this.map = new Map();
	this.root = new Node('', 0);
	this.root.next = this.root;
	this.root.prev = this.root;
};

/**
 * @param {string} key
 * @return {void}
 */
AllOne.prototype.inc = function (key) {
	// key åœ¨é“¾è¡¨ä¸­
	if (this.map.has(key)) {
		let cur = this.map.get(key),
			next = cur.next;

		if (next == this.root || next.count > cur.count + 1) {
			this.map.set(key, cur.insert(new Node(key, cur.count + 1)));
		} else {
			next.keys.add(key);
			this.map.set(key, next);
		}
		cur.keys.delete(key);
		if (cur.keys.size == 0) {
			cur.remove();
		}
	}
	// key ä¸åœ¨é“¾è¡¨ä¸­
	else {
		if (this.root.next === this.root || this.root.next.count > 1) {
			this.map.set(key, this.root.insert(new Node(key, 1)));
		} else {
			this.root.next.keys.add(key);
			this.map.set(key, this.root.next);
		}
	}
};

/**
 * @param {string} key
 * @return {void}
 */
AllOne.prototype.dec = function (key) {
	const cur = this.map.get(key);
	// count ä¸º 1 æ—¶ï¼Œç›´æ¥åˆ æ‰
	if (cur.count == 1) {
		this.map.delete(key);
	}
	// count å¤§äº 1 æ—¶ï¼Œå¯»æ‰¾ dec å key åœ¨é“¾è¡¨ä¸­çš„ä½ç½®
	else {
		const prev = cur.prev;
		if (prev == this.root || prev.count < cur.count - 1) {
			this.map.set(key, prev.insert(new Node(key, cur.count - 1)));
		} else {
			prev.keys.add(key);
			this.map.set(key, prev);
		}
	}
	cur.keys.delete(key);
	if (cur.keys.size == 0) {
		cur.remove();
	}
};

/**
 * @return {string}
 */
AllOne.prototype.getMaxKey = function () {
	if (!this.root.prev) return '';
	let maxKey = '';
	for (let key of this.root.prev.keys) {
		maxKey = key;
		break;
	}
	return maxKey;
};

/**
 * @return {string}
 */
AllOne.prototype.getMinKey = function () {
	if (!this.root.next) return '';
	let minKey = '';
	for (let key of this.root.next.keys) {
		minKey = key;
		break;
	}
	return minKey;
};

/**
 * Your AllOne object will be instantiated and called as such:
 * var obj = new AllOne()
 * obj.inc(key)
 * obj.dec(key)
 * var param_3 = obj.getMaxKey()
 * var param_4 = obj.getMinKey()
 */
```
