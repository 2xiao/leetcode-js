# [106. Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ ‘`](/leetcode/outline/tag/tree.md) [`æ•°ç»„`](/leetcode/outline/tag/array.md) [`å“ˆå¸Œè¡¨`](/leetcode/outline/tag/hash-table.md) [`åˆ†æ²»`](/leetcode/outline/tag/divide-and-conquer.md) [`äºŒå‰æ ‘`](/leetcode/outline/tag/binary-tree.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

## é¢˜ç›®

Given `postorder` and `inorder` traversal of a tree, construct the binary tree.

**Example 1**:

```
Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
Output: [3,9,20,null,null,15,7]

Return the following binary tree:

    	3
       / \
      9  20
        /  \
       15   7
```

**Example 2**:

```
Input: postorder = [-1], inorder = [-1]
Output: [-1]
```

Constraints:

- `1 <= postorder.length <= 3000`
- `inorder.length == postorder.length`
- `-3000 <= postorder[i]`, `inorder[i] <= 3000`
- `postorder` and `inorder` consist of unique values.
- Each value of `inorder` also appears in `postorder`.
- `postorder` is **guaranteed** to be the `postorder` traversal of the tree.
- `inorder` is **guaranteed** to be the `inorder` traversal of the tree.

## é¢˜ç›®å¤§æ„

æ ¹æ®ä¸€æ£µæ ‘çš„ä¸­åºéå†ä¸ååºéå†æ„é€ äºŒå‰æ ‘ã€‚

æ³¨æ„: ä½ å¯ä»¥å‡è®¾æ ‘ä¸­æ²¡æœ‰é‡å¤çš„å…ƒç´ ã€‚

## è§£é¢˜æ€è·¯

æ€è·¯ä¸ [ç¬¬ 105 é¢˜](./0105.md) ç±»ä¼¼ã€‚

æ„é€ äºŒå‰æ ‘ï¼Œç¬¬ä¸€ä»¶äº‹ä¸€å®šæ˜¯æ‰¾æ ¹èŠ‚ç‚¹ï¼Œç„¶åæƒ³åŠæ³•æ„é€ å·¦å³å­æ ‘ã€‚

ååºéå†ç»“æœæœ€åä¸€ä¸ªå€¼å°±æ˜¯æ ¹èŠ‚ç‚¹çš„å€¼ï¼Œç„¶åå†æ ¹æ®ä¸­åºéå†ç»“æœç¡®å®šå·¦å³å­æ ‘çš„èŠ‚ç‚¹ã€‚

ä¸æ–­çš„é€’å½’ç›´åˆ°æ‰€æœ‰çš„æ ‘éƒ½ç”Ÿæˆå®Œæˆã€‚

![](../../../assets/image/106.png)

é€’å½’æ—¶ç›´æ¥ä¼ å…¥éœ€è¦çš„ slice èŒƒå›´ä½œä¸ºè¾“å…¥, å¯ä»¥é¿å…ç”³è¯·å¯¹åº” inorder ç´¢å¼•çš„å†…å­˜ã€‚

## ä»£ç 

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} inorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */
var buildTree = function (inorder, postorder) {
  if (inorder.length == 0) return null;
  let root = new TreeNode(postorder[postorder.length - 1]);
  for (let i = 0; i < inorder.length; i++) {
    if (inorder[i] == root.val) {
      root.left = buildTree(inorder.slice(0, i), postorder.slice(0, i));
      root.right = buildTree(
        inorder.slice(i + 1),
        postorder.slice(i, postorder.length - 1)
      );
      break;
    }
  }
  return root;
};
```

## ç›¸å…³é¢˜ç›®

:::: md-demo ç›¸å…³é¢˜ç›®

- [105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](./0105.md)

::::
