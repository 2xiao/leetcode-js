# [958. Check Completeness of a Binary Tree](https://leetcode.com/problems/check-completeness-of-a-binary-tree/)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ ‘`](/leetcode/outline/tag/tree.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/breadth-first-search.md) [`äºŒå‰æ ‘`](/leetcode/outline/tag/binary-tree.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/check-completeness-of-a-binary-tree/)

## é¢˜ç›®

Given the `root` of a binary tree, determine if it is a _complete binary
tree_.

In a **[complete binary
tree](http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees)** ,
every level, except possibly the last, is completely filled, and all nodes in
the last level are as far left as possible. It can have between `1` and `2h`
nodes inclusive at the last level `h`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-1.png)

> Input: root = [1,2,3,4,5,6]
>
> Output: true
>
> Explanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.

**Example 2:**

![](https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-2.png)

> Input: root = [1,2,3,4,5,null,7]
>
> Output: false
>
> Explanation: The node with value 7 isn't as far left as possible.

**Constraints:**

- The number of nodes in the tree is in the range `[1, 100]`.
- `1 <= Node.val <= 1000`

## é¢˜ç›®å¤§æ„

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œç¡®å®šå®ƒæ˜¯å¦æ˜¯ä¸€ä¸ªå®Œå…¨äºŒå‰æ ‘ã€‚

å®Œå…¨äºŒå‰æ ‘çš„å®šä¹‰å¦‚ä¸‹ï¼š

è‹¥è®¾äºŒå‰æ ‘çš„æ·±åº¦ä¸º `h`ï¼Œé™¤ç¬¬ `h` å±‚å¤–ï¼Œå…¶å®ƒå„å±‚ (`1 ï½ h-1`) çš„ç»“ç‚¹æ•°éƒ½è¾¾åˆ°æœ€å¤§ä¸ªæ•°ï¼Œç¬¬ `h` å±‚æ‰€æœ‰çš„èŠ‚ç‚¹éƒ½è¿ç»­é›†ä¸­åœ¨æœ€å·¦è¾¹ï¼Œè¿™å°±æ˜¯å®Œå…¨äºŒå‰æ ‘ã€‚ï¼ˆæ³¨ï¼šç¬¬ `h` å±‚å¯èƒ½åŒ…å« `1~Â 2h`Â  ä¸ªèŠ‚ç‚¹ã€‚ï¼‰

## è§£é¢˜æ€è·¯

åˆ¤æ–­ä¸€æ£µäºŒå‰æ ‘æ˜¯å¦ä¸ºå®Œå…¨äºŒå‰æ ‘çš„å¸¸ç”¨æ–¹æ³•åŒ…æ‹¬å±‚åºéå†å’Œé€’å½’ä¸¤ç§ã€‚

### æ€è·¯ä¸€ï¼šå±‚åºéå†

å±‚åºéå†æ˜¯ä»ä¸Šåˆ°ä¸‹ã€ä»å·¦åˆ°å³ä¾æ¬¡éå†äºŒå‰æ ‘çš„æ¯ä¸€å±‚èŠ‚ç‚¹ã€‚åœ¨å±‚åºéå†çš„è¿‡ç¨‹ä¸­ï¼Œå¯¹äºæ¯ä¸€ä¸ªéç©ºèŠ‚ç‚¹ï¼Œéƒ½å°†å…¶å·¦å³å­èŠ‚ç‚¹ï¼ˆåŒ…æ‹¬ç©ºèŠ‚ç‚¹ï¼‰åŠ å…¥éå†é˜Ÿåˆ—ã€‚åœ¨éå†è¿‡ç¨‹ä¸­ï¼Œå¦‚æœé‡åˆ°ä¸€ä¸ªèŠ‚ç‚¹ä¸º nullï¼ˆç©ºèŠ‚ç‚¹ï¼‰ï¼Œåˆ™åç»­æ‰€æœ‰èŠ‚ç‚¹éƒ½åº”è¯¥æ˜¯ nullï¼Œå¦åˆ™ä¸æ˜¯å®Œå…¨äºŒå‰æ ‘ã€‚

---

### æ€è·¯äºŒï¼šé€’å½’

é€’å½’æ–¹æ³•ä¼šä½¿ç”¨èŠ‚ç‚¹ç¼–å·çš„æ€§è´¨ã€‚å¯¹äºä»»æ„èŠ‚ç‚¹ `i`ï¼Œå…¶å·¦å­èŠ‚ç‚¹ç¼–å·ä¸º `2 * i + 1`ï¼Œå³å­èŠ‚ç‚¹ç¼–å·ä¸º `2 * i + 2`ã€‚é€šè¿‡æ¯”è¾ƒèŠ‚ç‚¹çš„ç¼–å·å’Œæ ‘ä¸­å®é™…èŠ‚ç‚¹çš„æ•°é‡ï¼Œå¯ä»¥åˆ¤æ–­æ˜¯å¦ä¸ºå®Œå…¨äºŒå‰æ ‘ã€‚

## ä»£ç 

::: code-tabs
@tab å±‚åºéå†

```javascript
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isCompleteTree = function (root) {
	if (!root) return true;
	let queue = [root];
	let foundNull = false;
	while (queue.length) {
		let node = queue.shift();
		if (!node) {
			foundNull = true;
		} else {
			if (foundNull) return false;
			queue.push(node.left);
			queue.push(node.right);
		}
	}
	return true;
};
```

@tab é€’å½’

```javascript
var isCompleteTree = function (root) {
	const count = (root) => {
		if (!root) return 0;
		return 1 + count(root.left) + count(root.right);
	};
	// è®¡ç®—æ•´æ£µæ ‘çš„èŠ‚ç‚¹æ•°é‡
	const total = count(root);

	const isComplete = (root, index) => {
		// å¦‚æœå½“å‰èŠ‚ç‚¹ä¸ºç©ºï¼Œè®¤ä¸ºæ˜¯å®Œå…¨äºŒå‰æ ‘çš„ä¸€éƒ¨åˆ†
		if (!root) return true;
		// å¦‚æœå½“å‰èŠ‚ç‚¹çš„ç¼–å·è¶…è¿‡äº†æ€»èŠ‚ç‚¹æ•°é‡ï¼Œè¯´æ˜ä¸æ˜¯å®Œå…¨äºŒå‰æ ‘
		if (index >= total) return false;
		// é€’å½’æ£€æŸ¥å·¦å³å­æ ‘
		return (
			isComplete(root.left, index * 2 + 1) &&
			isComplete(root.right, index * 2 + 2)
		);
	};
	// ä»æ ¹èŠ‚ç‚¹å¼€å§‹é€’å½’æ£€æŸ¥
	return isComplete(root, 0);
};
```

:::
