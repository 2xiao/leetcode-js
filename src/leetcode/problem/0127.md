# [127. å•è¯æ¥é¾™](https://leetcode.com/problems/word-ladder)

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/breadth-first-search.md) [`å“ˆå¸Œè¡¨`](/leetcode/outline/tag/hash-table.md) [`å­—ç¬¦ä¸²`](/leetcode/outline/tag/string.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/word-ladder)

## é¢˜ç›®

A **transformation sequence** from word `beginWord` to word `endWord` using a
dictionary `wordList` is a sequence of words `beginWord -> s1 -> s2 -> ... ->
sk` such that:

- Every adjacent pair of words differs by a single letter.
- Every `si` for `1 <= i <= k` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.
- `sk == endWord`

Given two words, `beginWord` and `endWord`, and a dictionary `wordList`,
return _the **number of words** in the **shortest transformation sequence**
from_ `beginWord` _to_ `endWord` _, or_`0` _if no such sequence exists._

**Example 1:**

> Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
>
> Output: 5
>
> Explanation: One shortest transformation sequence is "hit" -> "hot" -> "dot" -> "dog" -> cog", which is 5 words long.

**Example 2:**

> Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
>
> Output: 0
>
> Explanation: The endWord "cog" is not in wordList, therefore there is no valid transformation sequence.

**Constraints:**

- `1 <= beginWord.length <= 10`
- `endWord.length == beginWord.length`
- `1 <= wordList.length <= 5000`
- `wordList[i].length == beginWord.length`
- `beginWord`, `endWord`, and `wordList[i]` consist of lowercase English letters.
- `beginWord != endWord`
- All the words in `wordList` are **unique**.

## é¢˜ç›®å¤§æ„

å­—å…¸ `wordList` ä¸­ä»å•è¯ `beginWord` åˆ° `endWord` çš„ **è½¬æ¢åºåˆ—** æ˜¯ä¸€ä¸ªæŒ‰ä¸‹è¿°è§„æ ¼å½¢æˆçš„åºåˆ— `beginWord -> s1 -> s2 -> ... -> sk`ï¼š

- æ¯ä¸€å¯¹ç›¸é‚»çš„å•è¯åªå·®ä¸€ä¸ªå­—æ¯ã€‚
- å¯¹äº `1 <= i <= k` æ—¶ï¼Œæ¯ä¸ª `si` éƒ½åœ¨ `wordList` ä¸­ã€‚æ³¨æ„ï¼Œ `beginWord` ä¸éœ€è¦åœ¨ `wordList` ä¸­ã€‚
- `sk == endWord`

ç»™ä½ ä¸¤ä¸ªå•è¯ `beginWord` å’Œ `endWord` å’Œä¸€ä¸ªå­—å…¸ `wordList` ï¼Œè¿”å› ä» `beginWord` åˆ° `endWord` çš„ **æœ€çŸ­è½¬æ¢åºåˆ—** ä¸­çš„ **å•è¯æ•°ç›®** ã€‚å¦‚æœä¸å­˜åœ¨è¿™æ ·çš„è½¬æ¢åºåˆ—ï¼Œè¿”å› `0` ã€‚

## è§£é¢˜æ€è·¯

è¿™é“é¢˜å’Œ [433 æœ€å°åŸºå› å˜åŒ–](./0433.md) å¾ˆåƒï¼Œå¯ä»¥è½¬æ¢ä¸º **å›¾çš„æœ€çŸ­è·¯å¾„é—®é¢˜**ï¼Œæ¯ä¸ªå•è¯æ˜¯å›¾ä¸­çš„èŠ‚ç‚¹ï¼Œä¸¤ä¸ªåªç›¸å·®ä¸€ä¸ªå­—æ¯çš„å•è¯ä¹‹é—´æœ‰ä¸€æ¡è¾¹ã€‚å› æ­¤å¯ä»¥ä½¿ç”¨ **å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰** æ¥æ±‚è§£ã€‚

åªä¸è¿‡ç¬¬ 433 é¢˜ç»™å®šäº†åŸºå› çš„å˜åŒ–èŒƒå›´æ˜¯ `A/T/G/C`ï¼Œè€Œè¿™é“é¢˜ä¸­ï¼Œç”¨äºæ›¿æ¢å•è¯ä¸­æ¯ä¸ªå­—ç¬¦çš„å­—ç¬¦èŒƒå›´éœ€è¦è‡ªå·±ä» `wordList` ä¸­æ±‚å¾—ã€‚

1. å°†èµ·å§‹å•è¯ `beginWord` æ”¾å…¥é˜Ÿåˆ— `queue`ï¼ŒåŒæ—¶è®¾å®šä¸€ä¸ªé›†åˆ `visited` ç”¨äºè®°å½•å·²ç»è®¿é—®è¿‡çš„å•è¯ï¼Œé¿å…é‡å¤è®¿é—®ã€‚
2. æ¯æ¬¡ä»é˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªå•è¯ï¼Œå°è¯•å°†å…¶æ¯ä¸ªå­—ç¬¦æ›¿æ¢ï¼Œçœ‹çœ‹æ˜¯å¦èƒ½å¾—åˆ°ä¸€ä¸ªæ–°çš„æœ‰æ•ˆå•è¯ï¼ˆè¿™ä¸ªæ–°å•è¯éœ€è¦åœ¨å­—å…¸ä¸­å­˜åœ¨ï¼Œä¸”æ²¡æœ‰è¢«è®¿é—®è¿‡ï¼‰ã€‚
3. å¦‚æœæŸæ¬¡å¾—åˆ°çš„å•è¯ç­‰äºç›®æ ‡å•è¯ `endWord`ï¼Œç›´æ¥è¿”å›å½“å‰çš„å˜åŒ–æ¬¡æ•° `step + 1`ã€‚
4. å¦‚æœè¯¥å•è¯æœ‰æ•ˆä¸”æœªè®¿é—®ï¼Œåˆ™å°†å…¶åŠ å…¥é˜Ÿåˆ—ï¼Œç»§ç»­ä¸‹ä¸€æ­¥çš„éå†ã€‚
5. å¦‚æœé˜Ÿåˆ—ä¸ºç©ºä½†è¿˜æœªæ‰¾åˆ°ç›®æ ‡å•è¯ï¼Œè¿”å› `0`ï¼Œè¡¨ç¤ºæ— æ³•åˆ°è¾¾ç›®æ ‡å•è¯ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(N \ M)`ï¼Œå…¶ä¸­ `N` æ˜¯å­—å…¸ä¸­çš„å•è¯æ•°é‡ï¼Œ`M` æ˜¯å•è¯çš„é•¿åº¦ã€‚åœ¨æ¯æ¬¡ BFS æ‰©å±•æ—¶ï¼Œæˆ‘ä»¬ä¼šå¯¹æ¯ä¸ªå•è¯çš„æ¯ä¸ªå­—æ¯è¿›è¡Œæ›¿æ¢ï¼Œç”Ÿæˆæ–°çš„å•è¯å¹¶æ£€æŸ¥æ˜¯å¦å­˜åœ¨äºå­—å…¸ä¸­ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(K * M + N)`ï¼Œå…¶ä¸­ `N` æ˜¯å­—å…¸ä¸­çš„å•è¯æ•°é‡ï¼Œ`M` æ˜¯å•è¯çš„é•¿åº¦ï¼Œ`K` æ˜¯ç”¨äºæ›¿æ¢å•è¯ä¸­æ¯ä¸ªå­—ç¬¦çš„å­—ç¬¦èŒƒå›´ï¼Œæœ€å¤§ä¸º `26`ã€‚

## ä»£ç 

```javascript
/**
 * @param {string} beginWord
 * @param {string} endWord
 * @param {string[]} wordList
 * @return {number}
 */
var ladderLength = function (beginWord, endWord, wordList) {
	// å°† wordList è½¬åŒ–ä¸º Set ä¾¿äºå¿«é€ŸæŸ¥æ‰¾
	const wordSet = new Set(wordList);

	// ç”¨äºè®¡ç®—æ›¿æ¢å•è¯ä¸­æ¯ä¸ªå­—ç¬¦çš„å­—ç¬¦èŒƒå›´
	const charSet = new Array(beginWord.length)
		.fill(0)
		.map((_, i) => new Set(wordList.map((item) => item[i])));

	if (!wordSet.has(endWord)) return 0;

	// åˆå§‹åŒ–é˜Ÿåˆ—
	let queue = [beginWord],
		visited = new Set([beginWord]),
		step = 0;

	// BFS æœç´¢
	while (queue.length) {
		const len = queue.length;

		for (let i = 0; i < len; i++) {
			var cur = queue.shift();

			// å¦‚æœæ‰¾åˆ°ç›®æ ‡å•è¯ï¼Œè¿”å›æ­¥æ•° + 1
			if (cur == endWord) {
				return step + 1;
			}

			// å°è¯•æ”¹å˜æ¯ä¸ªå­—ç¬¦
			for (let newWord of getAllDiff(cur, charSet)) {
				// å¦‚æœæ–°çš„å•è¯åœ¨ wordSet ä¸­ä¸”è¿˜æ²¡è®¿é—®è¿‡
				if (!visited.has(newWord) && wordSet.has(newWord)) {
					// åŠ å…¥é˜Ÿåˆ—ä¸­ï¼Œå¹¶æ ‡è®°å·²è®¿é—®
					queue.push(newWord);
					visited.add(newWord);
				}
			}
		}
		// æ­¥æ•° +1
		step++;
	}
	return 0;
};

// ç”¨äºè®¡ç®—æ›¿æ¢å•è¯ä¸­æ¯ä¸ªå­—ç¬¦çš„æ‰€æœ‰å¯èƒ½ç»“æœ
var getAllDiff = function (word, charSet) {
	let res = new Set();
	chars = word.split('');
	for (let i = 0; i < word.length; i++) {
		let char = word[i];
		for (let newChar of charSet[i]) {
			chars[i] = newChar;
			res.add(chars.join(''));
		}
		chars[i] = char;
	}
	return [...res];
};
```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 126 | [å•è¯æ¥é¾™ II](https://leetcode.com/problems/word-ladder-ii) |  |  [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/breadth-first-search.md) [`å“ˆå¸Œè¡¨`](/leetcode/outline/tag/hash-table.md) [`å­—ç¬¦ä¸²`](/leetcode/outline/tag/string.md) `1+` | <font color=#ff334b>Hard</font> |
| 433 | [æœ€å°åŸºå› å˜åŒ–](https://leetcode.com/problems/minimum-genetic-mutation) | [[âœ“]](https://2xiao.github.io/leetcode-js/leetcode/problem/0433) |  [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/breadth-first-search.md) [`å“ˆå¸Œè¡¨`](/leetcode/outline/tag/hash-table.md) [`å­—ç¬¦ä¸²`](/leetcode/outline/tag/string.md) | <font color=#ffb800>Medium</font> |
| 2452 | [è·ç¦»å­—å…¸ä¸¤æ¬¡ç¼–è¾‘ä»¥å†…çš„å•è¯](https://leetcode.com/problems/words-within-two-edits-of-dictionary) |  |  [`æ•°ç»„`](/leetcode/outline/tag/array.md) [`å­—ç¬¦ä¸²`](/leetcode/outline/tag/string.md) | <font color=#ffb800>Medium</font> |

<style>
.blue {
    background-color: #096dd9;
    padding: 0.25rem 0.5rem;
    margin: 0;
    font-size: 0.85em;
    border-radius: 3px;
    color: white;
    font-weight: 500;
}
table th:first-of-type { width: 10%; }
table th:nth-of-type(2) { width: 35%; }
table th:nth-of-type(3) { width: 10%; }
table th:nth-of-type(4) { width: 35%; }
table th:nth-of-type(5) { width: 10%; }
</style>
