# [366. å¯»æ‰¾äºŒå‰æ ‘çš„å¶å­èŠ‚ç‚¹](https://leetcode.com/problems/find-leaves-of-binary-tree)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ ‘`](/leetcode/outline/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/depth-first-search.md) [`äºŒå‰æ ‘`](/leetcode/outline/tag/binary-tree.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/find-leaves-of-binary-tree)

## é¢˜ç›®

Given a binary tree, collect a tree's nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty.

**Example 1:**

          1
         / \
        2   3
       / \
      4   5

> Input: [1,2,3,4,5]
>
> Output: [[4,5,3],[2],[1]]
>
> Explanation:
>
> [[3,5,4],[2],[1]] and [[3,4,5],[2],[1]] are also considered correct answers since per each level it does not matter the order on which elements are returned.

**Example 2:**

> Input: root = [1]
>
> Output: [[1]]

**Constraints:**

- The number of nodes in the tree is in the range `[1, 100]`.
- `-100 <= Node.val <= 100`

## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€æ£µå®Œå…¨äºŒå‰æ ‘ï¼Œè¯·æŒ‰ä»¥ä¸‹è¦æ±‚çš„é¡ºåºæ”¶é›†å®ƒçš„å…¨éƒ¨èŠ‚ç‚¹ï¼š

1. ä¾æ¬¡ä»å·¦åˆ°å³ï¼Œæ¯æ¬¡æ”¶é›†å¹¶åˆ é™¤æ‰€æœ‰çš„å¶å­èŠ‚ç‚¹
2. é‡å¤å¦‚ä¸Šè¿‡ç¨‹ç›´åˆ°æ•´æ£µæ ‘ä¸ºç©º

## è§£é¢˜æ€è·¯

äºŒå‰æ ‘èŠ‚ç‚¹çš„é«˜åº¦çš„å®šä¹‰æ˜¯ï¼šèŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ï¼ˆè¾¹æ•°ï¼‰ï¼Œå¯ä»¥å‘ç°è¿”å›æ•°ç»„å…¶å®æ˜¯æŒ‰ç…§äºŒå‰æ ‘çš„é«˜åº¦æ¥åˆ†ç»„çš„ï¼Œåªéœ€æ±‚å‡ºæ¯ä¸ªèŠ‚ç‚¹å·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦ - 1ï¼Œå³æ˜¯è¯¥èŠ‚ç‚¹çš„é«˜åº¦ã€‚

## ä»£ç 

```javascript
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var findLeaves = function(root) {
    if (!root) return []
    let res = []
    const maxDepth = (root) => {
        if (!root) return 0
        let depth = Math.max(maxDepth(root.left), maxDepth(root.right)) + 1
        res[depth - 1].push(root.val)
        return depth
    }
    maxDepth(root)
    return res
}
```
