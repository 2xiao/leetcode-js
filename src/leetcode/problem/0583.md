# [583. Delete Operation for Two Strings](https://leetcode.com/problems/delete-operation-for-two-strings/)

ðŸŸ  <font color=#ffb800>Medium</font>&emsp; ðŸ”–&ensp; [`å­—ç¬¦ä¸²`](/leetcode/outline/tag/string.md) [`åŠ¨æ€è§„åˆ’`](/leetcode/outline/tag/dynamic-programming.md)&emsp; ðŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/delete-operation-for-two-strings/)

## é¢˜ç›®

Given two strings `word1` and `word2`, return _the minimum number of **steps**
required to make_ `word1` _and_ `word2` _the same_.

In one **step** , you can delete exactly one character in either string.

**Example 1:**

> Input: word1 = "sea", word2 = "eat"
>
> Output: 2
>
> Explanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea".

**Example 2:**

> Input: word1 = "leetcode", word2 = "etco"
>
> Output: 4

**Constraints:**

- `1 <= word1.length, word2.length <= 500`
- `word1` and `word2` consist of only lowercase English letters.

## é¢˜ç›®å¤§æ„

ç»™å®šä¸¤ä¸ªå•è¯ `word1` å’Œ `word2` ï¼Œè¿”å›žä½¿å¾— `word1` å’Œ `word2` **ç›¸åŒ** æ‰€éœ€çš„ **æœ€å°æ­¥æ•°** ã€‚

**æ¯æ­¥** å¯ä»¥åˆ é™¤ä»»æ„ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­çš„ä¸€ä¸ªå­—ç¬¦ã€‚

`word1` å’Œ `word2` åªåŒ…å«å°å†™è‹±æ–‡å­—æ¯ã€‚

## è§£é¢˜æ€è·¯

é¢˜ç›®è¦æ±‚è®¡ç®—å°†ä¸¤ä¸ªå­—ç¬¦ä¸²å˜å¾—ç›¸åŒçš„æœ€å°‘åˆ é™¤æ¬¡æ•°ï¼Œè€Œè¿™ä¸¤ä¸ªå­—ç¬¦ä¸²æœ€åŽè¢«åˆ é™¤çš„ç»“æžœï¼Œå…¶å®žå°±æ˜¯å®ƒä»¬çš„æœ€é•¿å…¬å…±å­åºåˆ—ã€‚

åœ¨ [ç¬¬ 1143 é¢˜](./1143.md) ä¸­ï¼Œæˆ‘ä»¬è®¡ç®—äº†ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±å­åºåˆ—çš„é•¿åº¦ï¼ˆæœ‰é€’å½’å’Œ DP table ä¸¤ç§æ–¹æ³•ï¼‰ã€‚

é‚£ä¹ˆï¼Œè¦è®¡ç®—åˆ é™¤çš„æ¬¡æ•°ï¼Œå°±å¯ä»¥é€šè¿‡æœ€é•¿å…¬å…±å­åºåˆ—çš„é•¿åº¦æŽ¨å¯¼å‡ºæ¥ï¼š

```javascript
var minDistance = function (s1, s2) {
	const m = s1.length;
	const n = s2.length;
	// è®¡ç®—æœ€é•¿å…¬å…±å­åºåˆ—çš„é•¿åº¦
	const lcs = longestCommonSubsequence(s1, s2);
	return m - lcs + n - lcs;
};
```

## ä»£ç 

::: code-tabs

@tab åŠ¨æ€è§„åˆ’-é€’å½’

```javascript
/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = function (word1, word2) {
	const m = word1.length;
	const n = word2.length;
	let dp = new Array(m).fill(-1).map((i) => new Array(n).fill(-1));

	const helper = (i, j) => {
		if (i == -1 || j == -1) return 0;
		if (dp[i][j] != -1) return dp[i][j];
		if (word1.charAt(i) == word2.charAt(j)) {
			dp[i][j] = 1 + helper(i - 1, j - 1);
		} else {
			dp[i][j] = Math.max(helper(i, j - 1), helper(i - 1, j));
		}
		return dp[i][j];
	};

	// è®¡ç®—æœ€é•¿å…¬å…±å­åºåˆ—çš„é•¿åº¦
	const lcs = helper(m - 1, n - 1);

	return m - lcs + n - lcs;
};
```

@tab åŠ¨æ€è§„åˆ’-DP table

```javascript
/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = function (word1, word2) {
	const m = word1.length;
	const n = word2.length;
	const dp = new Array(m + 1).fill(0).map((i) => new Array(n + 1).fill(0));
	for (let i = 1; i <= m; i++) {
		for (let j = 1; j <= n; j++) {
			if (word1[i] == word2[j]) {
				dp[i][j] = 1 + dp[i - 1][j - 1];
			} else {
				dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
			}
		}
	}
	const lcs = dp[m][n];
	return m - lcs + n - lcs;
};
```

:::

## ç›¸å…³é¢˜ç›®

:::: md-demo ç›¸å…³é¢˜ç›®

- [72. ç¼–è¾‘è·ç¦»](https://leetcode.com/problems/edit-distance)
- [712. ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€å° ASCII åˆ é™¤å’Œ](https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings)
- [1143. æœ€é•¿å…¬å…±å­åºåˆ—](https://leetcode.com/problems/longest-common-subsequence)
- [2937. Make Three Strings Equal](https://leetcode.com/problems/make-three-strings-equal)

::::
