# [230. äºŒå‰æœç´¢æ ‘ä¸­ç¬¬ K å°çš„å…ƒç´ ](https://leetcode.com/problems/kth-smallest-element-in-a-bst)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ ‘`](/leetcode/outline/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/depth-first-search.md) [`äºŒå‰æœç´¢æ ‘`](/leetcode/outline/tag/binary-search-tree.md) [`äºŒå‰æ ‘`](/leetcode/outline/tag/binary-tree.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)

## é¢˜ç›®

Given the `root` of a binary search tree, and an integer `k`, return _the_
`kth` _smallest value ( **1-indexed** ) of all the values of the nodes in the
tree_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)

> Input: root = [3,1,4,null,2], k = 1
>
> Output: 1

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)

> Input: root = [5,3,6,2,4,null,null,1], k = 3
>
> Output: 3

**Constraints:**

- The number of nodes in the tree is `n`.
- `1 <= k <= n <= 10^4`
- `0 <= Node.val <= 10^4`

**Follow up:** If the BST is modified often (i.e., we can do insert and delete
operations) and you need to find the kth smallest frequently, how would you
optimize?

## é¢˜ç›®å¤§æ„

ç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œå’Œä¸€ä¸ªæ•´æ•° `k` ï¼Œè¯·ä½ è®¾è®¡ä¸€ä¸ªç®—æ³•æŸ¥æ‰¾å…¶ä¸­ç¬¬ `k` ä¸ªæœ€å°å…ƒç´ ï¼ˆä» `1` å¼€å§‹è®¡æ•°ï¼‰ã€‚

## è§£é¢˜æ€è·¯

BST çš„ä¸­åºéå†ç»“æœæ˜¯å‡åºçš„ï¼Œæ‰€ä»¥ç”¨ä¸€ä¸ªå¤–éƒ¨å˜é‡è®°å½•ä¸­åºéå†ç»“æœï¼Œç¬¬ `k` ä¸ªå…ƒç´ å³æ˜¯ç¬¬ `k` å°çš„å…ƒç´ ã€‚

éœ€è¦æ³¨æ„ `i++` è¦åœ¨ `return` ä¹‹å‰æ‰§è¡Œï¼Œå¦åˆ™ä¼šå¯¼è‡´è¿”å›æ­£ç¡®èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ã€‚

## ä»£ç 

```javascript
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthSmallest = function (root, k) {
  let i = 0;
  let res;
  const traverse = (root) => {
    if (!root) return null;
    traverse(root.left);
    i++;
    if (i == k) {
      res = root.val;
      return;
    }
    traverse(root.right);
  };
  traverse(root);
  return res;
};
```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 94 | [äºŒå‰æ ‘çš„ä¸­åºéå†](https://leetcode.com/problems/binary-tree-inorder-traversal) | [[âœ“]](https://2xiao.github.io/leetcode-js/leetcode/problem/0094) |  [`æ ˆ`](/leetcode/outline/tag/stack.md) [`æ ‘`](/leetcode/outline/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/depth-first-search.md) `1+` | <font color=#15bd66>Easy</font> |
| 671 | [äºŒå‰æ ‘ä¸­ç¬¬äºŒå°çš„èŠ‚ç‚¹](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree) |  |  [`æ ‘`](/leetcode/outline/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/depth-first-search.md) [`äºŒå‰æ ‘`](/leetcode/outline/tag/binary-tree.md) | <font color=#15bd66>Easy</font> |

<style>
.blue {
    background-color: #096dd9;
    padding: 0.25rem 0.5rem;
    margin: 0;
    font-size: 0.85em;
    border-radius: 3px;
    color: white;
    font-weight: 500;
}
table th:first-of-type { width: 10%; }
table th:nth-of-type(2) { width: 35%; }
table th:nth-of-type(3) { width: 10%; }
table th:nth-of-type(4) { width: 35%; }
table th:nth-of-type(5) { width: 10%; }
</style>
