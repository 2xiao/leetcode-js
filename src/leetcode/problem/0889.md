# [889. Construct Binary Tree from Preorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

ðŸŸ  <font color=#ffb800>Medium</font>&emsp; ðŸ”–&ensp; [`æ ‘`](/leetcode/outline/tag/tree.md) [`æ•°ç»„`](/leetcode/outline/tag/array.md) [`å“ˆå¸Œè¡¨`](/leetcode/outline/tag/hash-table.md) [`åˆ†æ²»`](/leetcode/outline/tag/divide-and-conquer.md) [`äºŒå‰æ ‘`](/leetcode/outline/tag/binary-tree.md)&emsp; ðŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

## é¢˜ç›®

Given two integer arrays, `preorder` and `postorder` where `preorder` is the
preorder traversal of a binary tree of **distinct** values and `postorder` is
the postorder traversal of the same tree, reconstruct and return _the binary
tree_.

If there exist multiple answers, you can **return any** of them.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/07/24/lc-prepost.jpg)

> Input: preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]
>
> Output: [1,2,3,4,5,6,7]

**Example 2:**

> Input: preorder = [1], postorder = [1]
>
> Output: [1]

**Constraints:**

- `1 <= preorder.length <= 30`
- `1 <= preorder[i] <= preorder.length`
- All the values of `preorder` are **unique**.
- `postorder.length == preorder.length`
- `1 <= postorder[i] <= postorder.length`
- All the values of `postorder` are **unique**.
- It is guaranteed that `preorder` and `postorder` are the preorder traversal and postorder traversal of the same binary tree.

## é¢˜ç›®å¤§æ„

ç»™å®šä¸€æ£µæ— é‡å¤å€¼äºŒå‰æ ‘çš„å‰åºéåŽ†ç»“æžœ `preorder` å’ŒåŽåºéåŽ†ç»“æžœ `postorder`ï¼Œæž„é€ å‡ºè¯¥äºŒå‰æ ‘å¹¶è¿”å›žå…¶æ ¹èŠ‚ç‚¹ã€‚å¦‚æžœå­˜åœ¨å¤šä¸ªç­”æ¡ˆï¼Œåˆ™å¯ä»¥è¿”å›žå…¶ä¸­ä»»æ„ä¸€ä¸ªã€‚

## è§£é¢˜æ€è·¯

åšè¿™é“é¢˜ä¹‹å‰ï¼Œå»ºè®®åšä¸€ä¸‹ [105. ä»Žå‰åºä¸Žä¸­åºéåŽ†åºåˆ—æž„é€ äºŒå‰æ ‘](./0105.md) å’Œ [106. ä»Žä¸­åºä¸ŽåŽåºéåŽ†åºåˆ—æž„é€ äºŒå‰æ ‘](./0105.md) è¿™ä¸¤é“é¢˜ã€‚

æž„å»ºäºŒå‰æ ‘çš„å¥—è·¯å¾ˆç®€å•ï¼Œå…ˆæ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œç„¶åŽæ‰¾åˆ°å¹¶é€’å½’æž„é€ å·¦å³å­æ ‘å³å¯ã€‚

è¿™é“é¢˜è®©ç”¨åŽåºéåŽ†å’Œå‰åºéåŽ†ç»“æžœè¿˜åŽŸäºŒå‰æ ‘ï¼Œå’Œå‰ä¸¤é“é¢˜æœ‰ä¸€ä¸ªæœ¬è´¨çš„åŒºåˆ«ï¼š

é€šè¿‡å‰åºä¸­åºï¼Œæˆ–è€…åŽåºä¸­åºéåŽ†ç»“æžœï¼Œå¯ä»¥ç¡®å®šä¸€æ£µåŽŸå§‹äºŒå‰æ ‘ï¼Œå¯ä»¥é€šè¿‡å‰åºæˆ–è€…åŽåºéåŽ†ç»“æžœæ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œç„¶åŽæ ¹æ®ä¸­åºéåŽ†ç»“æžœç¡®å®šå·¦å³å­æ ‘ã€‚

ä½†æ˜¯é€šè¿‡å‰åºåŽåºéåŽ†ç»“æžœï¼Œæ— æ³•ç¡®å®šåŽŸå§‹äºŒå‰æ ‘ã€‚å¯ä»¥ç¡®å®šæ ¹èŠ‚ç‚¹ï¼Œä½†æ˜¯æ— æ³•ç¡®åˆ‡çš„çŸ¥é“å·¦å³å­æ ‘æœ‰å“ªäº›èŠ‚ç‚¹ã€‚é¢˜ç›®ä¹Ÿè¯´äº†ï¼Œå¦‚æžœæœ‰å¤šç§ç»“æžœï¼Œå¯ä»¥è¿”å›žä»»æ„ä¸€ç§ã€‚

å…·ä½“ç®—æ³•æ˜¯ï¼š

1. é¦–å…ˆæŠŠå‰åºéåŽ†ç»“æžœçš„ç¬¬ä¸€ä¸ªå…ƒç´ æˆ–è€…åŽåºéåŽ†ç»“æžœçš„æœ€åŽä¸€ä¸ªå…ƒç´ ç¡®å®šä¸ºæ ¹èŠ‚ç‚¹çš„å€¼ã€‚
2. ç„¶åŽæŠŠå‰åºéåŽ†ç»“æžœçš„ç¬¬äºŒä¸ªå…ƒç´ ä½œä¸ºå·¦å­æ ‘çš„æ ¹èŠ‚ç‚¹çš„å€¼ã€‚
3. åœ¨åŽåºéåŽ†ç»“æžœä¸­å¯»æ‰¾å·¦å­æ ‘æ ¹èŠ‚ç‚¹çš„å€¼ï¼Œä»Žè€Œç¡®å®šäº†å·¦å­æ ‘çš„ç´¢å¼•è¾¹ç•Œï¼Œè¿›è€Œç¡®å®šå³å­æ ‘çš„ç´¢å¼•è¾¹ç•Œï¼Œé€’å½’æž„é€ å·¦å³å­æ ‘å³å¯ã€‚

## ä»£ç 

```javascript
/**
 * @param {number[]} preorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */
var constructFromPrePost = function (preorder, postorder) {
  if (preorder.length == 0) return null;
  let root = new TreeNode(preorder[0]);
  for (let i = 0; i < preorder.length; i++) {
    if (postorder[i] == preorder[1]) {
      root.left = constructFromPrePost(
        preorder.slice(1, i + 2),
        postorder.slice(0, i + 1)
      );
      root.right = constructFromPrePost(
        preorder.slice(i + 2),
        postorder.slice(i + 1, postorder.length - 1)
      );
      break;
    }
  }
  return root;
};
```
