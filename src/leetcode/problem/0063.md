# [63. Unique Paths II](https://leetcode.com/problems/unique-paths-ii/)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ•°ç»„`](/leetcode/outline/tag/array.md) [`åŠ¨æ€è§„åˆ’`](/leetcode/outline/tag/dynamic-programming.md) [`çŸ©é˜µ`](/leetcode/outline/tag/matrix.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/unique-paths-ii/)

## é¢˜ç›®

You are given an `m x n` integer array `grid`. There is a robot initially
located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to
move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot
can only move either down or right at any point in time.

An obstacle and space are marked as `1` or `0` respectively in `grid`. A path
that the robot takes cannot include **any** square that is an obstacle.

Return _the number of possible unique paths that the robot can take to reach the bottom-right corner_.

The testcases are generated so that the answer will be less than or equal to
`2 * 109`.



**Example 1:**

![](https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg)

> Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
> 
> Output: 2
> 
> Explanation: There is one obstacle in the middle of the 3x3 grid above.
> 
> There are two ways to reach the bottom-right corner:
> 
> 1. Right -> Right -> Down -> Down
> 
> 2. Down -> Down -> Right -> Right

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg)

> Input: obstacleGrid = [[0,1],[0,0]]
> 
> Output: 1

**Constraints:**

  * `m == obstacleGrid.length`
  * `n == obstacleGrid[i].length`
  * `1 <= m, n <= 100`
  * `obstacleGrid[i][j]` is `0` or `1`.


## é¢˜ç›®å¤§æ„

ä¸€ä¸ªæœºå™¨äººä½äºä¸€ä¸ª m x n ç½‘æ ¼çš„å·¦ä¸Šè§’ ï¼ˆèµ·å§‹ç‚¹åœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸ºâ€œStartâ€ ï¼‰ã€‚æœºå™¨äººæ¯æ¬¡åªèƒ½å‘ä¸‹æˆ–è€…å‘å³ç§»åŠ¨ä¸€æ­¥ã€‚æœºå™¨äººè¯•å›¾è¾¾åˆ°ç½‘æ ¼çš„å³ä¸‹è§’ï¼ˆåœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸ºâ€œFinishâ€ï¼‰ã€‚ç°åœ¨è€ƒè™‘ç½‘æ ¼ä¸­æœ‰éšœç¢ç‰©ã€‚é‚£ä¹ˆä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’å°†ä¼šæœ‰å¤šå°‘æ¡ä¸åŒçš„è·¯å¾„ï¼Ÿ

## è§£é¢˜æ€è·¯

- è¿™ä¸€é¢˜æ˜¯ [ç¬¬ 62 é¢˜](./0062.md) çš„åŠ å¼ºç‰ˆã€‚ä¹Ÿæ˜¯ä¸€é“è€ƒå¯Ÿ DP çš„ç®€å•é¢˜ã€‚
- è¿™ä¸€é¢˜æ¯”ç¬¬ 62 é¢˜å¢åŠ çš„æ¡ä»¶æ˜¯åœ°å›¾ä¸­ä¼šå‡ºç°éšœç¢ç‰©ï¼Œéšœç¢ç‰©çš„å¤„ç†æ–¹æ³•æ˜¯ `dp[i][j]=0`ã€‚
- éœ€è¦æ³¨æ„çš„ä¸€ç§æƒ…å†µæ˜¯ï¼Œèµ·ç‚¹å°±æ˜¯éšœç¢ç‰©ï¼Œé‚£ä¹ˆè¿™ç§æƒ…å†µç›´æ¥è¾“å‡º 0 ã€‚

| :heart: | 1        | 1   | 1   | 1        | 1   | 1   |
| ------- | -------- | --- | --- | -------- | --- | --- |
| 1       | :hankey: | 1   | 2   | :hankey: | 1   | 2   |
| 1       | 1        | 2   | 4   | 4        | 5   | 7   |

## ä»£ç 

```javascript
// æ—¶é—´å¤æ‚åº¦ O(nm)ï¼Œç©ºé—´å¤æ‚åº¦ O(m)
const path = (inputArr) => {
  // å¦‚æœèµ·ç‚¹å°±æ˜¯éšœç¢ç‰©
  if (inputArr[0][0] === 1) return 0;
  const m = inputArr.length;
  const n = inputArr[0].length;
  // ç”¨0å¡«å……ï¼Œå› ä¸ºç°åœ¨æœ‰éšœç¢ç‰©
  let arr = new Array(m).fill(0);
  // ç¬¬ä¸€åˆ—å…ˆå†™æˆ1
  arr[0] = 1;
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      if (inputArr[j][i] === 1) {
        // é‡åˆ°éšœç¢ç‰©arr[j]å°±å˜æˆ0ï¼Œè¿™é‡ŒåŒ…å«äº†ç¬¬ä¸€åˆ—çš„æƒ…å†µ
        arr[j] = 0;
      } else if (j > 0) {
        arr[j] = arr[j - 1] + arr[j];
      }
    }
  }
  return arr[m - 1];
};
```

## ç›¸å…³é¢˜ç›®

:::: md-demo ç›¸å…³é¢˜ç›®

- [62. ä¸åŒè·¯å¾„](./0062.md)
- [980. ä¸åŒè·¯å¾„ III](https://leetcode.com/problems/unique-paths-iii)
- [2304. ç½‘æ ¼ä¸­çš„æœ€å°è·¯å¾„ä»£ä»·](https://leetcode.com/problems/minimum-path-cost-in-a-grid)
- [2435. çŸ©é˜µä¸­å’Œèƒ½è¢« K æ•´é™¤çš„è·¯å¾„](https://leetcode.com/problems/paths-in-matrix-whose-sum-is-divisible-by-k)

::::
