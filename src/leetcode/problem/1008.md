# [1008. Construct Binary Search Tree from Preorder Traversal](https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/)

ðŸŸ  <font color=#ffb800>Medium</font>&emsp; ðŸ”–&ensp; [`æ ˆ`](/leetcode/outline/tag/stack.md) [`æ ‘`](/leetcode/outline/tag/tree.md) [`äºŒå‰æœç´¢æ ‘`](/leetcode/outline/tag/binary-search-tree.md) [`æ•°ç»„`](/leetcode/outline/tag/array.md) [`äºŒå‰æ ‘`](/leetcode/outline/tag/binary-tree.md) [`å•è°ƒæ ˆ`](/leetcode/outline/tag/monotonic-stack.md)&emsp; ðŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/)

## é¢˜ç›®

Given an array of integers preorder, which represents the **preorder traversal** of a BST (i.e., **binary search tree** ), construct the tree and
return _its root_.

It is **guaranteed** that there is always possible to find a binary search
tree with the given requirements for the given test cases.

A **binary search tree** is a binary tree where for every node, any descendant
of `Node.left` has a value **strictly less than** `Node.val`, and any
descendant of `Node.right` has a value **strictly greater than** `Node.val`.

A **preorder traversal** of a binary tree displays the value of the node
first, then traverses `Node.left`, then traverses `Node.right`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/03/06/1266.png)

> Input: preorder = [8,5,1,7,10,12]
>
> Output: [8,5,10,1,7,null,12]

**Example 2:**

> Input: preorder = [1,3]
>
> Output: [1,null,3]

**Constraints:**

- `1 <= preorder.length <= 100`
- `1 <= preorder[i] <= 1000`
- All the values of `preorder` are **unique**.

## é¢˜ç›®å¤§æ„

ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œå®ƒè¡¨ç¤º BST(å³ äºŒå‰æœç´¢æ ‘ )çš„ å…ˆåºéåŽ† ï¼Œæž„é€ æ ‘å¹¶è¿”å›žå…¶æ ¹ã€‚

ä¿è¯ å¯¹äºŽç»™å®šçš„æµ‹è¯•ç”¨ä¾‹ï¼Œæ€»æ˜¯æœ‰å¯èƒ½æ‰¾åˆ°å…·æœ‰ç»™å®šéœ€æ±‚çš„äºŒå‰æœç´¢æ ‘ã€‚

äºŒå‰æœç´¢æ ‘ æ˜¯ä¸€æ£µäºŒå‰æ ‘ï¼Œå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹ï¼Œ `Node.left` çš„ä»»ä½•åŽä»£çš„å€¼ ä¸¥æ ¼å°äºŽ `Node.val` , `Node.right` çš„ä»»ä½•åŽä»£çš„å€¼ ä¸¥æ ¼å¤§äºŽ `Node.val`ã€‚

äºŒå‰æ ‘çš„ å‰åºéåŽ† é¦–å…ˆæ˜¾ç¤ºèŠ‚ç‚¹çš„å€¼ï¼Œç„¶åŽéåŽ†`Node.left`ï¼Œæœ€åŽéåŽ†`Node.right`ã€‚

## è§£é¢˜æ€è·¯

æž„é€ äºŒå‰æ ‘ï¼Œå…ˆæ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œå†é€’å½’åœ°æž„é€ å·¦å³å­æ ‘ã€‚

æœ¬é¢˜ä¸­å·²çŸ¥äºŒå‰æœç´¢æ ‘çš„å…ˆåºéåŽ†ï¼Œæ ¹èŠ‚ç‚¹å°±æ˜¯æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚

åªéœ€è¦å†æ‰¾å‡ºå·¦å³å­æ ‘åˆ†å‰²çš„åœ°æ–¹ï¼Œå°±å¯ä»¥é€’å½’æž„é€ å·¦å³å­æ ‘äº†ã€‚æ ¹æ®äºŒå‰æœç´¢æ ‘çš„ç‰¹ç‚¹ï¼Œå·¦å­æ ‘çš„æ‰€æœ‰å€¼éƒ½å°äºŽæ ¹èŠ‚ç‚¹ï¼Œæ‰€ä»¥åªéœ€éåŽ†åŽç»­æ•°ç»„ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªæ¯”æ ¹èŠ‚ç‚¹å¤§çš„æ•°å€¼ï¼Œå³ä¸ºå³å­æ ‘å…ˆåºéåŽ†çš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚

## ä»£ç 

```javascript
/**
 * @param {number[]} preorder
 * @return {TreeNode}
 */
var bstFromPreorder = function (preorder) {
  if (!preorder.length) return null;
  let root = new TreeNode(preorder[0]);
  let mid = 1;
  while (preorder[mid] < preorder[0]) {
    mid++;
  }
  root.left = bstFromPreorder(preorder.slice(1, mid));
  root.right = bstFromPreorder(preorder.slice(mid));
  return root;
};
```
