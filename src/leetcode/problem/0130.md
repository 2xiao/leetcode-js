# [130. è¢«å›´ç»•çš„åŒºåŸŸ](https://leetcode.com/problems/surrounded-regions)

ðŸŸ  <font color=#ffb800>Medium</font>&emsp; ðŸ”–&ensp; [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/breadth-first-search.md) [`å¹¶æŸ¥é›†`](/leetcode/outline/tag/disjoint-set-union.md) [`æ•°ç»„`](/leetcode/outline/tag/array.md) [`çŸ©é˜µ`](/leetcode/outline/tag/matrix.md)&emsp; ðŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/surrounded-regions/)

## é¢˜ç›®

Given an `m x n` matrix `board` containing `'X'` and `'O'`, _capture all
regions that are 4-directionally surrounded by_ `'X'`.

A region is **captured** by flipping all `'O'`s into `'X'`s in that surrounded
region.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg)

> Input: board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
>
> Output: [["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
>
> Explanation: Notice that an 'O' should not be flipped if:
>
> - It is on the border, or
> - It is adjacent to an 'O' that should not be flipped.
>
> The bottom 'O' is on the border, so it is not flipped.
>
> The other three 'O' form a surrounded region, so they are flipped.

**Example 2:**

> Input: board = [["X"]]
>
> Output: [["X"]]

**Constraints:**

- `m == board.length`
- `n == board[i].length`
- `1 <= m, n <= 200`
- `board[i][j]` is `'X'` or `'O'`.

## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ª `m x n` çš„çŸ©é˜µ `board` ï¼Œç”±è‹¥å¹²å­—ç¬¦ `'X'` å’Œ `'O'` ç»„æˆï¼Œæ•èŽ· **æ‰€æœ‰** **è¢«å›´ç»•çš„åŒºåŸŸï¼š**

- **è¿žæŽ¥ï¼š** ä¸€ä¸ªå•å…ƒæ ¼ä¸Žæ°´å¹³æˆ–åž‚ç›´æ–¹å‘ä¸Šç›¸é‚»çš„å•å…ƒæ ¼è¿žæŽ¥ã€‚
- **åŒºåŸŸï¼šè¿žæŽ¥æ‰€æœ‰** `'O'` çš„å•å…ƒæ ¼æ¥å½¢æˆä¸€ä¸ªåŒºåŸŸã€‚
- **å›´ç»•ï¼š** å¦‚æžœæ‚¨å¯ä»¥ç”¨ `'X'` å•å…ƒæ ¼ **è¿žæŽ¥è¿™ä¸ªåŒºåŸŸ**ï¼Œå¹¶ä¸”åŒºåŸŸä¸­æ²¡æœ‰ä»»ä½•å•å…ƒæ ¼ä½äºŽ `board` è¾¹ç¼˜ï¼Œåˆ™è¯¥åŒºåŸŸè¢« `'X'` å•å…ƒæ ¼å›´ç»•ã€‚

é€šè¿‡å°†è¾“å…¥çŸ©é˜µ `board` ä¸­çš„æ‰€æœ‰ `'O'` æ›¿æ¢ä¸º `'X'` æ¥ **æ•èŽ·è¢«å›´ç»•çš„åŒºåŸŸã€‚**

## è§£é¢˜æ€è·¯

é¦–é€‰é€‰æ‹©å‡ºä¸Žå²¸è¾¹ç›¸è¿žçš„å²›å±¿å¹¶æ ‡è®°ä¸º `F`ï¼Œç„¶åŽæŠŠå†…éƒ¨å°é—­çš„å²›å±¿å…¨éƒ¨ç½®ä¸º Xï¼Œæœ€åŽæŠŠ `F` ç½®ä¸º `O`ã€‚

## ä»£ç 

```javascript
/**
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var solve = function (board) {
	const dfs = (board, i, j) => {
		const m = board.length,
			n = board[0].length;
		if (i < 0 || i >= m || j < 0 || j >= n) {
			return;
		}
		if (board[i][j] !== 'O') {
			return;
		}
		board[i][j] = 'F';
		dfs(board, i - 1, j);
		dfs(board, i + 1, j);
		dfs(board, i, j - 1);
		dfs(board, i, j + 1);
	};

	const m = board.length,
		n = board[0].length;

	// é€‰æ‹©å‡ºä¸Žå²¸è¾¹ç›¸è¿žçš„å²›å±¿å¹¶æ ‡è®°ä¸º F
	for (let i = 0; i < m; i++) {
		if (board[i][0] == 'O') dfs(board, i, 0);
		if (board[i][n - 1] == 'O') dfs(board, i, n - 1);
	}
	for (let j = 0; j < n; j++) {
		if (board[0][j] == 'O') dfs(board, 0, j);
		if (board[m - 1][j] == 'O') dfs(board, m - 1, j);
	}

	// æŠŠå†…éƒ¨å°é—­çš„å²›å±¿å…¨éƒ¨ç½®ä¸º Xï¼ŒæŠŠ F ç½®ä¸º O
	for (let i = 0; i < m; i++) {
		for (let j = 0; j < n; j++) {
			if (board[i][j] == 'F') {
				board[i][j] = 'O';
			} else {
				board[i][j] = 'X';
			}
		}
	}
};
```

## ç›¸å…³é¢˜ç›®

:::: md-demo ç›¸å…³é¢˜ç›®

- [200. å²›å±¿æ•°é‡](https://leetcode.com/problems/number-of-islands)
- [ðŸ”’ Walls and Gates](https://leetcode.com/problems/walls-and-gates)

::::
