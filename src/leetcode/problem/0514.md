# [514. Freedom Trail](https://leetcode.com/problems/freedom-trail/)

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/breadth-first-search.md) [`å­—ç¬¦ä¸²`](/leetcode/outline/tag/string.md) [`åŠ¨æ€è§„åˆ’`](/leetcode/outline/tag/dynamic-programming.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/freedom-trail/)

## é¢˜ç›®

In the video game Fallout 4, the quest **" Road to Freedom"** requires players
to reach a metal dial called the **" Freedom Trail Ring"** and use the dial to
spell a specific keyword to open the door.

Given a string `ring` that represents the code engraved on the outer ring and
another string `key` that represents the keyword that needs to be spelled,
return _the minimum number of steps to spell all the characters in the
keyword_.

Initially, the first character of the ring is aligned at the `"12:00"`
direction. You should spell all the characters in `key` one by one by rotating
`ring` clockwise or anticlockwise to make each character of the string key
aligned at the `"12:00"` direction and then by pressing the center button.

At the stage of rotating the ring to spell the key character `key[i]`:

1. You can rotate the ring clockwise or anticlockwise by one place, which counts as **one step**. The final purpose of the rotation is to align one of `ring`'s characters at the `"12:00"` direction, where this character must equal `key[i]`.
2. If the character `key[i]` has been aligned at the `"12:00"` direction, press the center button to spell, which also counts as **one step**. After the pressing, you could begin to spell the next character in the key (next stage). Otherwise, you have finished all the spelling.

**Example 1:**

![](https://assets.leetcode.com/uploads/2018/10/22/ring.jpg)

> Input: ring = "godding", key = "gd"
>
> Output: 4
>
> Explanation:
>
> For the first key character 'g', since it is already in place, we just need 1 step to spell this character.
>
> For the second key character 'd', we need to rotate the ring "godding" anticlockwise by two steps to make it become "ddinggo".
>
> Also, we need 1 more step for spelling.
>
> So the final output is 4.

**Example 2:**

> Input: ring = "godding", key = "godding"
>
> Output: 13

**Constraints:**

- `1 <= ring.length, key.length <= 100`
- `ring` and `key` consist of only lower case English letters.
- It is guaranteed that `key` could always be spelled by rotating `ring`.

## é¢˜ç›®å¤§æ„

ç”µå­æ¸¸æˆâ€œè¾å°„ 4â€ä¸­ï¼Œä»»åŠ¡ **â€œé€šå‘è‡ªç”±â€** è¦æ±‚ç©å®¶åˆ°è¾¾åä¸º **â€œFreedom Trail Ringâ€** çš„é‡‘å±è¡¨ç›˜ï¼Œå¹¶ä½¿ç”¨è¡¨ç›˜æ‹¼å†™ç‰¹å®šå…³é”®è¯æ‰èƒ½å¼€é—¨ã€‚

ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² `ring` ï¼Œè¡¨ç¤ºåˆ»åœ¨å¤–ç¯ä¸Šçš„ç¼–ç ï¼›ç»™å®šå¦ä¸€ä¸ªå­—ç¬¦ä¸² `key` ï¼Œè¡¨ç¤ºéœ€è¦æ‹¼å†™çš„å…³é”®è¯ã€‚æ‚¨éœ€è¦ç®—å‡ºèƒ½å¤Ÿæ‹¼å†™å…³é”®è¯ä¸­æ‰€æœ‰å­—ç¬¦çš„**æœ€å°‘**æ­¥æ•°ã€‚

æœ€åˆï¼Œ`ring` çš„ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸ `12:00` æ–¹å‘å¯¹é½ã€‚æ‚¨éœ€è¦é¡ºæ—¶é’ˆæˆ–é€†æ—¶é’ˆæ—‹è½¬ `ring` ä»¥ä½¿ `key` çš„ä¸€ä¸ªå­—ç¬¦åœ¨ `12:00` æ–¹å‘å¯¹é½ï¼Œç„¶åæŒ‰ä¸‹ä¸­å¿ƒæŒ‰é’®ï¼Œä»¥æ­¤é€ä¸ªæ‹¼å†™å®Œ `key` ä¸­çš„æ‰€æœ‰å­—ç¬¦ã€‚

æ—‹è½¬ `ring` æ‹¼å‡º `key` å­—ç¬¦ `key[i]` çš„é˜¶æ®µä¸­ï¼š

æ‚¨å¯ä»¥å°† `ring` é¡ºæ—¶é’ˆæˆ–é€†æ—¶é’ˆæ—‹è½¬ **ä¸€ä¸ªä½ç½®** ï¼Œè®¡ä¸º 1 æ­¥ã€‚æ—‹è½¬çš„æœ€ç»ˆç›®çš„æ˜¯å°†å­—ç¬¦ä¸² `ring` çš„ä¸€ä¸ªå­—ç¬¦ä¸ `12:00` æ–¹å‘å¯¹é½ï¼Œå¹¶ä¸”è¿™ä¸ªå­—ç¬¦å¿…é¡»ç­‰äºå­—ç¬¦ `key[i]` ã€‚

å¦‚æœå­—ç¬¦ `key[i]` å·²ç»å¯¹é½åˆ° `12:00` æ–¹å‘ï¼Œæ‚¨éœ€è¦æŒ‰ä¸‹ä¸­å¿ƒæŒ‰é’®è¿›è¡Œæ‹¼å†™ï¼Œè¿™ä¹Ÿå°†ç®—ä½œ **1 æ­¥**ã€‚æŒ‰å®Œä¹‹åï¼Œæ‚¨å¯ä»¥å¼€å§‹æ‹¼å†™ `key` çš„ä¸‹ä¸€ä¸ªå­—ç¬¦ï¼ˆä¸‹ä¸€é˜¶æ®µï¼‰, ç›´è‡³å®Œæˆæ‰€æœ‰æ‹¼å†™ã€‚

**ç¤ºä¾‹ 1ï¼š**

![](https://assets.leetcode.com/uploads/2018/10/22/ring.jpg)

> è¾“å…¥: ring = "godding", key = "gd"
>
> è¾“å‡º: 4
>
> è§£é‡Š:
>
> å¯¹äº key çš„ç¬¬ä¸€ä¸ªå­—ç¬¦ 'g'ï¼Œå·²ç»åœ¨æ­£ç¡®çš„ä½ç½®, æˆ‘ä»¬åªéœ€è¦ 1 æ­¥æ¥æ‹¼å†™è¿™ä¸ªå­—ç¬¦ã€‚
>
> å¯¹äº key çš„ç¬¬äºŒä¸ªå­—ç¬¦ 'd'ï¼Œæˆ‘ä»¬éœ€è¦é€†æ—¶é’ˆæ—‹è½¬ ring "godding" 2 æ­¥ä½¿å®ƒå˜æˆ "ddinggo"ã€‚
>
> å½“ç„¶, æˆ‘ä»¬è¿˜éœ€è¦ 1 æ­¥è¿›è¡Œæ‹¼å†™ã€‚
>
> å› æ­¤æœ€ç»ˆçš„è¾“å‡ºæ˜¯ 4ã€‚

**ç¤ºä¾‹ 2:**

> è¾“å…¥: ring = "godding", key = "godding"
>
> è¾“å‡º: 13

**æç¤ºï¼š**

- `1 <= ring.length, key.length <= 100`
- `ring` å’Œ `key` åªåŒ…å«å°å†™è‹±æ–‡å­—æ¯
- **ä¿è¯** å­—ç¬¦ä¸² `key` ä¸€å®šå¯ä»¥ç”±å­—ç¬¦ä¸² `ring` æ—‹è½¬æ‹¼å‡º

## è§£é¢˜æ€è·¯

1. **æ„å»ºæ˜ å°„**ï¼šé¦–å…ˆæ„å»ºä¸€ä¸ªæ˜ å°„ `map`ï¼Œå°†æ¯ä¸ªå­—ç¬¦åœ¨ `ring` ä¸­çš„å‡ºç°ä½ç½®è®°å½•ä¸‹æ¥ã€‚

2. **åŠ¨æ€è§„åˆ’é€’å½’**ï¼šä½¿ç”¨é€’å½’çš„æ–¹å¼è¿›è¡ŒåŠ¨æ€è§„åˆ’ã€‚å®šä¹‰ä¸€ä¸ªäºŒç»´æ•°ç»„ `dp`ï¼Œå…¶ä¸­ `dp[i][j]` è¡¨ç¤ºæŒ‡é’ˆåœ¨ `ring[i]` æ—¶ï¼Œåˆ° `key[j]` æœ€å°‘éœ€è¦å‡ æ­¥æ“ä½œã€‚

3. **é€’å½’å‡½æ•°**ï¼šå®šä¹‰é€’å½’å‡½æ•° `helper(i, j)`ï¼Œè¡¨ç¤ºå½“æŒ‡é’ˆåœ¨ `ring[i]` ä½ç½®ï¼Œéœ€è¦åŒ¹é… `key[j]` æ—¶çš„æœ€å°æ“ä½œæ­¥æ•°ã€‚

4. **é€’å½’ç»“æŸæ¡ä»¶**ï¼šå½“ `j` ç­‰äº `n` æ—¶ï¼Œè¡¨ç¤ºå·²ç»åŒ¹é…å®Œæ•´ä¸ª `key` å­—ç¬¦ä¸²ï¼Œè¿”å› 0ã€‚

5. **é€’å½’è¿‡ç¨‹**ï¼šéå† `key[j]` å¯¹åº”çš„æ‰€æœ‰å¯èƒ½ä½ç½® `k`ï¼Œè®¡ç®—æ—‹è½¬æ¬¡æ•° `rotate`ï¼Œç„¶åé€’å½’è°ƒç”¨ `helper(k, j + 1)`ï¼ŒåŠ ä¸Šå½“å‰çš„æ—‹è½¬æ¬¡æ•°å’Œ 1ï¼Œå–æœ€å°å€¼ä½œä¸ºç»“æœã€‚

6. **è®°å¿†åŒ–æœç´¢**ï¼šä¸ºäº†é¿å…é‡å¤è®¡ç®—ï¼Œä½¿ç”¨æ•°ç»„ `dp` è¿›è¡Œè®°å¿†åŒ–æœç´¢ï¼Œè®°å½•å·²ç»è®¡ç®—è¿‡çš„çŠ¶æ€ã€‚

- **æ—¶é—´å¤æ‚åº¦**: `O(m * n)` - å…¶ä¸­ `m` æ˜¯ `ring` çš„é•¿åº¦ï¼Œ`n` æ˜¯ `key` çš„é•¿åº¦ã€‚å¯¹äº `key` ä¸­çš„æ¯ä¸ªå­—ç¬¦ï¼Œéƒ½ä¼šè€ƒè™‘ `ring` ä¸­çš„æ‰€æœ‰å¯èƒ½ä½ç½®ã€‚
- **ç©ºé—´å¤æ‚åº¦**: `O(m * n)` - ä½¿ç”¨äº†ä¸€ä¸ªäºŒç»´æ•°ç»„æ¥å­˜å‚¨ä¸­é—´çŠ¶æ€ã€‚

## ä»£ç 

```javascript
/**
 * @param {string} ring
 * @param {string} key
 * @return {number}
 */
var findRotateSteps = function (ring, key) {
	const m = ring.length;
	const n = key.length;
	const map = new Map();

	// æ„å»ºæ˜ å°„
	for (let i = 0; i < m; i++) {
		let temp = map.get(ring[i]) || [];
		temp.push(i);
		map.set(ring[i], temp);
	}

	// åˆå§‹åŒ–åŠ¨æ€è§„åˆ’æ•°ç»„
	const dp = new Array(m).fill(0).map(() => new Array(n).fill(-1));

	// å®šä¹‰é€’å½’å‡½æ•°
	const helper = (i, j) => {
		// é€’å½’ç»“æŸæ¡ä»¶
		if (j == n) return 0;
		// è®°å¿†åŒ–æœç´¢
		if (dp[i][j] !== -1) return dp[i][j];

		let res = Infinity;
		// éå† key[j] å¯¹åº”çš„æ‰€æœ‰å¯èƒ½ä½ç½®
		for (let k of map.get(key[j])) {
			// è®¡ç®—æ—‹è½¬è¡¨ç›˜æ¬¡æ•°
			const rotate = Math.min(Math.abs(k - i), m - Math.abs(k - i));
			// é€’å½’è°ƒç”¨ï¼ŒåŠ ä¸Šå½“å‰çš„æ—‹è½¬æ¬¡æ•°å’Œ 1ï¼Œå–æœ€å°å€¼
			res = Math.min(res, 1 + rotate + helper(k, j + 1));
		}
		dp[i][j] = res;
		return res;
	};

	// è¿”å›ç»“æœ
	return helper(0, 0);
};
```
