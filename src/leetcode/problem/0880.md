# [880. ç´¢å¼•å¤„çš„è§£ç å­—ç¬¦ä¸²](https://leetcode.com/problems/decoded-string-at-index)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ ˆ`](/leetcode/outline/tag/stack.md) [`å­—ç¬¦ä¸²`](/leetcode/outline/tag/string.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/decoded-string-at-index)

## é¢˜ç›®

You are given an encoded string `s`. To decode the string to a tape, the
encoded string is read one character at a time and the following steps are
taken:

- If the character read is a letter, that letter is written onto the tape.
- If the character read is a digit `d`, the entire current tape is repeatedly written `d - 1` more times in total.

Given an integer `k`, return _the_`kth` _letter ( **1-indexed)** in the
decoded string_.

**Example 1:**

> Input: s = "leet2code3", k = 10
>
> Output: "o"
>
> Explanation: The decoded string is "leetleetcodeleetleetcodeleetleetcode".
>
> The 10th letter in the string is "o".

**Example 2:**

> Input: s = "ha22", k = 5
>
> Output: "h"
>
> Explanation: The decoded string is "hahahaha".
>
> The 5th letter is "h".

**Example 3:**

> Input: s = "a2345678999999999999999", k = 1
>
> Output: "a"
>
> Explanation: The decoded string is "a" repeated 8301530446056247680 times.
>
> The 1st letter is "a".

**Constraints:**

- `2 <= s.length <= 100`
- `s` consists of lowercase English letters and digits `2` through `9`.
- `s` starts with a letter.
- `1 <= k <= 10^9`
- It is guaranteed that `k` is less than or equal to the length of the decoded string.
- The decoded string is guaranteed to have less than `263` letters.

## é¢˜ç›®å¤§æ„

ç»™å®šä¸€ä¸ªç¼–ç å­—ç¬¦ä¸² `S`ã€‚ä¸ºäº†æ‰¾å‡ºè§£ç å­—ç¬¦ä¸²å¹¶å°†å…¶å†™å…¥ç£å¸¦ï¼Œä»ç¼–ç å­—ç¬¦ä¸²ä¸­æ¯æ¬¡è¯»å–ä¸€ä¸ªå­—ç¬¦ï¼Œå¹¶é‡‡å–ä»¥ä¸‹æ­¥éª¤ï¼š

- å¦‚æœæ‰€è¯»çš„å­—ç¬¦æ˜¯å­—æ¯ï¼Œåˆ™å°†è¯¥å­—æ¯å†™åœ¨ç£å¸¦ä¸Šã€‚
- å¦‚æœæ‰€è¯»çš„å­—ç¬¦æ˜¯æ•°å­—ï¼ˆä¾‹å¦‚ `d`ï¼‰ï¼Œåˆ™æ•´ä¸ªå½“å‰ç£å¸¦æ€»å…±ä¼šè¢«é‡å¤å†™ `d-1` æ¬¡ã€‚

ç°åœ¨ï¼Œå¯¹äºç»™å®šçš„ç¼–ç å­—ç¬¦ä¸² `S` å’Œç´¢å¼• `K`ï¼ŒæŸ¥æ‰¾å¹¶è¿”å›è§£ç å­—ç¬¦ä¸²ä¸­çš„ç¬¬ `K` ä¸ªå­—æ¯ã€‚

## è§£é¢˜æ€è·¯

ç”±äºè§£ç åçš„å­—ç¬¦ä¸²æœ‰å¯èƒ½è¶…å¤§ï¼Œä¸ä»…ä¼šè¶…æ—¶ï¼Œå†…å­˜ä¹Ÿä¼šæº¢å‡ºï¼Œæ‰€ä»¥ä¸èƒ½ç›´æ¥æš´åŠ›æ‰«æè§£ç ã€‚

ä»”ç»†è§‚å¯Ÿä¼šå‘ç°ï¼Œå¦‚æœæœ‰ä¸€ä¸ªåƒ `abcdeabcdeabcdeabcdeabcdeabcde` è¿™æ ·çš„è§£ç å­—ç¬¦ä¸²ï¼Œå’Œä¸€ä¸ªåƒ `K=23` è¿™æ ·çš„ç´¢å¼•ï¼Œé‚£ä¹ˆå¦‚æœ `K=3`ï¼Œç­”æ¡ˆæ˜¯ç›¸åŒçš„ã€‚

æ‰€ä»¥å¯ä»¥ä»åå‘å‰é€†å‘å¯»æ‰¾ï¼Œè·Ÿè¸ªè§£ç å­—ç¬¦ä¸²çš„å¤§å°æ¥æ‰¾å‡ºç­”æ¡ˆã€‚æ¯å½“è§£ç çš„å­—ç¬¦ä¸²ç­‰äºæŸäº›å•è¯ï¼ˆå¦‚ `abcde`ï¼‰é‡å¤ `n` æ¬¡æ—¶ï¼Œæˆ‘ä»¬å°±å¯ä»¥å°† `k` å‡å°‘åˆ° `K % (abcde.length)`ã€‚

å…·ä½“ç®—æ³•æ˜¯ï¼š

- é¦–å…ˆé¡ºåºéå†å­—ç¬¦ä¸²ï¼Œè®¡ç®—è§£ç å­—ç¬¦ä¸²çš„æ€»é•¿åº¦ `size`ï¼›
- å†ä»å½“å‰å­—ç¬¦ä¸²æœ€åä¸€ä½å¼€å§‹éå†ï¼Œç”¨ `K` å¯¹æ€»é•¿åº¦æ±‚ä½™ï¼š `K %= size`ï¼›
- å¦‚æœæ²¡æ•´é™¤ï¼Œåˆ™çœ‹å½“å‰æ˜¯å¦æ˜¯æ•°å­—ï¼š
  - æ˜¯æ•°å­—ï¼Œåˆ™å°†æ€»é•¿åº¦ç¼©å°ç­‰é‡å€ `size = size / S[i]` ï¼›
  - ä¸æ˜¯æ•°å­—ï¼Œåˆ™æ€»é•¿åº¦å‡ä¸€ `size = size - 1` ï¼›
- å¦‚æœæ•´é™¤äº†ï¼Œè§‚å¯Ÿæ˜¯å¦æ˜¯æ•°å­—ï¼š
  - æ˜¯æ•°å­—ï¼Œåˆ™å°†æ€»é•¿åº¦ç¼©å°ç­‰é‡å€ `size = size / S[i]` ï¼›
  - ä¸æ˜¯æ•°å­—ï¼Œåˆ™æ‰¾åˆ°ç­”æ¡ˆã€‚

## ä»£ç 

```javascript
/**
 * @param {string} s
 * @param {number} k
 * @return {string}
 */
var decodeAtIndex = function (s, k) {
  let size = 0;

  const isDigit = (str) => str >= "0" && str <= "9";

  for (let item of s) {
    if (isDigit(item)) size *= Number(item);
    else size++;
  }

  for (let i = s.length - 1; i >= 0; i--) {
    k %= size;
    if (k != 0) {
      if (isDigit(s[i])) {
        size = size / Number(s[i]);
      } else {
        size--;
      }
    } else {
      if (isDigit(s[i])) {
        size = size / Number(s[i]);
      } else {
        return s[i];
      }
    }
  }
};
```
