# [1049. æœ€åä¸€å—çŸ³å¤´çš„é‡é‡ II](https://leetcode.com/problems/last-stone-weight-ii)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ•°ç»„`](/leetcode/outline/tag/array.md) [`åŠ¨æ€è§„åˆ’`](/leetcode/outline/tag/dynamic-programming.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/last-stone-weight-ii/)

## é¢˜ç›®

You are given an array of integers `stones` where `stones[i]` is the weight of
the `ith` stone.

We are playing a game with the stones. On each turn, we choose any two stones
and smash them together. Suppose the stones have weights `x` and `y` with `x
<= y`. The result of this smash is:

- If `x == y`, both stones are destroyed, and
- If `x != y`, the stone of weight `x` is destroyed, and the stone of weight `y` has new weight `y - x`.

At the end of the game, there is **at most one** stone left.

Return _the smallest possible weight of the left stone_. If there are no
stones left, return `0`.

**Example 1:**

> Input: stones = [2,7,4,1,8,1]
>
> Output: 1
>
> Explanation:
>
> We can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1] then,
>
> we can combine 7 and 8 to get 1, so the array converts to [2,1,1,1] then,
>
> we can combine 2 and 1 to get 1, so the array converts to [1,1,1] then,
>
> we can combine 1 and 1 to get 0, so the array converts to [1], then that's the optimal value.

**Example 2:**

> Input: stones = [31,26,33,21,40]
>
> Output: 5

**Constraints:**

- `1 <= stones.length <= 30`
- `1 <= stones[i] <= 100`

## é¢˜ç›®å¤§æ„

æœ‰ä¸€å †çŸ³å¤´ï¼Œç”¨æ•´æ•°æ•°ç»„ `stones` è¡¨ç¤ºã€‚å…¶ä¸­ `stones[i]` è¡¨ç¤ºç¬¬ `i` å—çŸ³å¤´çš„é‡é‡ã€‚

æ¯ä¸€å›åˆï¼Œä»ä¸­é€‰å‡º **ä»»æ„ä¸¤å—çŸ³å¤´** ï¼Œç„¶åå°†å®ƒä»¬ä¸€èµ·ç²‰ç¢ã€‚å‡è®¾çŸ³å¤´çš„é‡é‡åˆ†åˆ«ä¸º `x` å’Œ `y`ï¼Œä¸” `x <= y`ã€‚é‚£ä¹ˆç²‰ç¢çš„å¯èƒ½ç»“æœå¦‚ä¸‹ï¼š

- å¦‚æœ `x == y`ï¼Œé‚£ä¹ˆä¸¤å—çŸ³å¤´éƒ½ä¼šè¢«å®Œå…¨ç²‰ç¢ï¼›
- å¦‚æœ `x != y`ï¼Œé‚£ä¹ˆé‡é‡ä¸º `x` çš„çŸ³å¤´å°†ä¼šå®Œå…¨ç²‰ç¢ï¼Œè€Œé‡é‡ä¸º `y` çš„çŸ³å¤´æ–°é‡é‡ä¸º `y-x`ã€‚

æœ€åï¼Œ**æœ€å¤šåªä¼šå‰©ä¸‹ä¸€å—** çŸ³å¤´ã€‚è¿”å›æ­¤çŸ³å¤´ **æœ€å°çš„å¯èƒ½é‡é‡** ã€‚å¦‚æœæ²¡æœ‰çŸ³å¤´å‰©ä¸‹ï¼Œå°±è¿”å› `0`ã€‚

**ç¤ºä¾‹ 1ï¼š**

> è¾“å…¥ï¼šstones = [2,7,4,1,8,1]
>
> è¾“å‡ºï¼š1
>
> è§£é‡Šï¼š
>
> ç»„åˆ 2 å’Œ 4ï¼Œå¾—åˆ° 2ï¼Œæ‰€ä»¥æ•°ç»„è½¬åŒ–ä¸º [2,7,1,8,1]ï¼Œ
>
> ç»„åˆ 7 å’Œ 8ï¼Œå¾—åˆ° 1ï¼Œæ‰€ä»¥æ•°ç»„è½¬åŒ–ä¸º [2,1,1,1]ï¼Œ
>
> ç»„åˆ 2 å’Œ 1ï¼Œå¾—åˆ° 1ï¼Œæ‰€ä»¥æ•°ç»„è½¬åŒ–ä¸º [1,1,1]ï¼Œ
>
> ç»„åˆ 1 å’Œ 1ï¼Œå¾—åˆ° 0ï¼Œæ‰€ä»¥æ•°ç»„è½¬åŒ–ä¸º [1]ï¼Œè¿™å°±æ˜¯æœ€ä¼˜å€¼ã€‚

**ç¤ºä¾‹ 2ï¼š**

> è¾“å…¥ï¼šstones = [31,26,33,21,40]
>
> è¾“å‡ºï¼š5

## è§£é¢˜æ€è·¯

### æ€è·¯ä¸€ï¼šåŠ¨æ€è§„åˆ’

è¿™é“é¢˜å¯ä»¥è½¬åŒ–ä¸ºèƒŒåŒ…é—®é¢˜ï¼Œæœ‰ä¸€å®šçš„éš¾åº¦ã€‚

é¢˜ç›®è¦ä»çŸ³å¤´å †ä¸­é€‰å‡ºä»»æ„ä¸¤å—çŸ³å¤´ï¼Œç„¶åå°†å®ƒä»¬ä¸€èµ·ç²‰ç¢ï¼Œæ±‚æœ€åä¸€å—çŸ³å¤´çš„é‡é‡ã€‚å¯ä»¥å°†é—®é¢˜è½¬åŒ–ä¸ºï¼šæŠŠä¸€å †çŸ³å¤´åˆ†æˆä¸¤å †ï¼Œæ±‚ä¸¤å †çŸ³å¤´é‡é‡å·®æœ€å°å€¼;

è¿›ä¸€æ­¥åˆ†æï¼Œè¦è®©å·®å€¼å°ï¼Œä¸¤å †çŸ³å¤´çš„é‡é‡éƒ½è¦æ¥è¿‘ `sum/2` ï¼Œæˆ‘ä»¬å‡è®¾ä¸¤å †åˆ†åˆ«ä¸º `A`ã€`B` ï¼Œ`A<sum/2`ï¼Œ`B>sum/2`ï¼Œè‹¥ `A` æ›´æ¥è¿‘ `sum/2` ï¼Œ`B` ä¹Ÿç›¸åº”æ›´æ¥è¿‘ `sum/2`;

è¿›ä¸€æ­¥è½¬åŒ–ï¼Œå°†ä¸€å † `stones` æ”¾è¿›æœ€å¤§å®¹é‡ä¸º `sum/2` çš„èƒŒåŒ…ï¼Œæ±‚æ”¾è¿›å»çš„çŸ³å¤´çš„æœ€å¤§é‡é‡ `MaxWeight`ï¼Œæœ€ç»ˆç­”æ¡ˆå³ä¸º `sum-2*MaxWeight`;

- å…ˆæ±‚å‡ºæ‰€æœ‰çŸ³å¤´çš„æ€»é‡é‡ `sum`ï¼Œåˆ™èƒŒåŒ…çš„é‡é‡ä¸º `target = sum / 2`ï¼›
- ä½¿ç”¨äºŒç»´æ•°ç»„ `dp`ï¼Œå…¶ä¸­ `dp[i][j]` è¡¨ç¤ºå°†å‰ `i` å—çŸ³å¤´æ”¾å…¥å®¹é‡ä¸º `j` çš„èƒŒåŒ…æ—¶ï¼ŒèƒŒåŒ…é‡ŒçŸ³å¤´çš„æœ€å¤§é‡é‡ã€‚
- åˆå§‹åŒ–ç¬¬ä¸€åˆ—ï¼Œè¡¨ç¤ºåªæœ‰ä¸€å—çŸ³å¤´ `stones[0]` æ—¶ï¼ŒèƒŒåŒ…é‡ŒçŸ³å¤´çš„æœ€å¤§é‡é‡ã€‚
- çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - stones[i]] + stones[i]`
  - å…¶ä¸­ï¼Œ`dp[i - 1][j]` è¡¨ç¤ºç¬¬ `i` ä¸ªçŸ³å¤´ä¸æ”¾å…¥èƒŒåŒ…ï¼›
  - `dp[i - 1][j - stones[i]] + stones[i]` è¡¨ç¤ºç¬¬ `i` ä¸ªçŸ³å¤´æ”¾å…¥èƒŒåŒ…ï¼Œåˆ™å¯¹äºå‰ `i - 1` å—çŸ³å¤´ï¼ŒèƒŒåŒ…çš„å®¹é‡åªå‰© `j - stones[i]`ï¼›
- éå†çŸ³å¤´é‡é‡å’ŒèƒŒåŒ…å®¹é‡ï¼Œæ ¹æ®çŠ¶æ€è½¬ç§»æ–¹ç¨‹æ›´æ–° `dp[i][j]` çš„å€¼ã€‚
- æœ€åè¿”å› `sum - 2 * dp[n - 1][target]`

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(n * target)`ï¼Œå…¶ä¸­ `n` æ˜¯çŸ³å¤´çš„æ•°é‡ï¼Œ`target` æ˜¯çŸ³å¤´æ€»é‡é‡çš„ 1/2ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(n * target)`ï¼Œä½¿ç”¨äº†ä¸€ä¸ªäºŒç»´åŠ¨æ€è§„åˆ’æ•°ç»„ã€‚

---

### æ€è·¯äºŒï¼šå‹ç¼©çŠ¶æ€çš„åŠ¨æ€è§„åˆ’

- ç”±äºäºŒç»´æ•°ç»„ä¸­ï¼Œç¬¬ `i` è¡Œ `dp[i][...]` åªå’Œç¬¬ `i - 1` è¡Œ `dp[i - 1][...]` æœ‰å…³ï¼Œæ‰€ä»¥å¯ä»¥å°† `dp` æ•°ç»„å‹ç¼©è‡³ä¸€ç»´ï¼›
- ä½¿ç”¨ä¸€ç»´æ•°ç»„ `dp`ï¼Œå…¶ä¸­ `dp[j]` è¡¨ç¤ºèƒŒåŒ…å®¹é‡ä¸º `j` æ—¶çš„ï¼ŒèƒŒåŒ…é‡ŒçŸ³å¤´çš„æœ€å¤§é‡é‡ï¼›
- åˆå§‹åŒ– `dp` æ•°ç»„ä¸º 0ï¼›
- çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š`dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]`ï¼›
  - å…¶ä¸­ï¼Œ`dp[j]` è¡¨ç¤ºç¬¬ `i` ä¸ªçŸ³å¤´ä¸æ”¾å…¥èƒŒåŒ…ï¼›
  - `dp[j - stones[i]] + stones[i]` è¡¨ç¤ºç¬¬ `i` ä¸ªçŸ³å¤´æ”¾å…¥èƒŒåŒ…ï¼Œåˆ™å¯¹äºå‰ `i - 1` å—çŸ³å¤´ï¼ŒèƒŒåŒ…çš„å®¹é‡åªå‰© `j - stones[i]`ï¼›
- éå†çŸ³å¤´é‡é‡å’ŒèƒŒåŒ…å®¹é‡ï¼Œæ ¹æ®çŠ¶æ€è½¬ç§»æ–¹ç¨‹æ›´æ–° `dp[i][j]` çš„å€¼ï¼Œæ³¨æ„ï¼Œæ­¤æ—¶éœ€è¦åå‘éå† `j`ï¼Œç¡®ä¿åœ¨æ›´æ–°å½“å‰çŠ¶æ€æ—¶ï¼Œæ‰€ä¾èµ–çš„çŠ¶æ€å·²ç»è¢«æ­£ç¡®è®¡ç®—ï¼›
- æœ€åè¿”å› `sum - 2 * dp[target]`ï¼›

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(n * target)`ï¼Œå…¶ä¸­ `n` æ˜¯çŸ³å¤´çš„æ•°é‡ï¼Œ`target` æ˜¯çŸ³å¤´æ€»é‡é‡çš„ 1/2ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(target)`ï¼Œä½¿ç”¨äº†ä¸€ä¸ªä¸€ç»´åŠ¨æ€è§„åˆ’æ•°ç»„ã€‚

## ä»£ç 

::: code-tabs

@tab åŠ¨æ€è§„åˆ’

```javascript
/**
 * @param {number[]} stones
 * @return {number}
 */
var lastStoneWeightII = function (stones) {
	const sum = stones.reduce((num, acc) => acc + num, 0);
	const target = Math.floor(sum / 2);
	const n = stones.length;
	const dp = new Array(n).fill(0).map(() => new Array(target + 1).fill(0));
	// base case
	for (let j = 0; j <= target; j++) {
		if (j < stones[0]) {
			dp[0][j] = 0;
		} else {
			dp[0][j] = stones[0];
		}
	}
	for (let i = 1; i < n; i++) {
		for (let j = 1; j <= target; j++) {
			if (j < stones[i]) {
				dp[i][j] = dp[i - 1][j];
			} else {
				dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - stones[i]] + stones[i]);
			}
		}
	}
	return sum - 2 * dp[n - 1][target];
};
```

@tab å‹ç¼©çŠ¶æ€çš„åŠ¨æ€è§„åˆ’

```javascript
/**
 * @param {number[]} stones
 * @return {number}
 */
var lastStoneWeightII = function (stones) {
	const sum = stones.reduce((num, acc) => acc + num, 0);
	const target = Math.floor(sum / 2);
	const n = stones.length;
	const dp = new Array(target + 1).fill(0);

	for (let i = 0; i < n; i++) {
		for (let j = target; j >= 0; j--) {
			if (j >= stones[i]) {
				dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);
			}
		}
	}
	return sum - 2 * dp[target];
};
```

:::

## ç›¸å…³é¢˜ç›®

:::: md-demo ç›¸å…³é¢˜ç›®
- [2035. å°†æ•°ç»„åˆ†æˆä¸¤ä¸ªæ•°ç»„å¹¶æœ€å°åŒ–æ•°ç»„å’Œçš„å·®](https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference)

::::
