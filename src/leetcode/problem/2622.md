# [2622. æœ‰æ—¶é—´é™åˆ¶çš„ç¼“å­˜](https://leetcode.com/problems/cache-with-time-limit)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/cache-with-time-limit)

## é¢˜ç›®

Write a class that allows getting and setting key-value pairs, however a
**time until expiration** is associated with each key.

The class has three public methods:

`set(key, value, duration)`: accepts an integer `key`, an integer `value`, and
a `duration` in milliseconds. Once the `duration` has elapsed, the key should
be inaccessible. The method should return `true` if the same un-expired key
already exists and `false` otherwise. Both the value and duration should be
overwritten if the key already exists.

`get(key)`: if an un-expired key exists, it should return the associated
value. Otherwise it should return `-1`.

`count()`: returns the count of un-expired keys.

**Example 1:**

> Input:
>
> actions = ["TimeLimitedCache", "set", "get", "count", "get"]
>
> values = [[], [1, 42, 100], [1], [], [1]]
>
> timeDelays = [0, 0, 50, 50, 150]
>
> Output: [null, false, 42, 1, -1]
>
> Explanation:
>
> At t=0, the cache is constructed.
>
> At t=0, a key-value pair (1: 42) is added with a time limit of 100ms. The value doesn't exist so false is returned.
>
> At t=50, key=1 is requested and the value of 42 is returned.
>
> At t=50, count() is called and there is one active key in the cache.
>
> At t=100, key=1 expires.
>
> At t=150, get(1) is called but -1 is returned because the cache is empty.

**Example 2:**

> Input:
>
> actions = ["TimeLimitedCache", "set", "set", "get", "get", "get", "count"]
>
> values = [[], [1, 42, 50], [1, 50, 100], [1], [1], [1], []]
>
> timeDelays = [0, 0, 40, 50, 120, 200, 250]
>
> Output: [null, false, true, 50, 50, -1, 0]
>
> Explanation:
>
> At t=0, the cache is constructed.
>
> At t=0, a key-value pair (1: 42) is added with a time limit of 50ms. The value doesn't exist so false is returned.
>
> At t=40, a key-value pair (1: 50) is added with a time limit of 100ms. A non-expired value already existed so true is returned and the old value was overwritten.
>
> At t=50, get(1) is called which returned 50.
>
> At t=120, get(1) is called which returned 50.
>
> At t=140, key=1 expires.
>
> At t=200, get(1) is called but the cache is empty so -1 is returned.
>
> At t=250, count() returns 0 because the cache is empty.

**Constraints:**

- `0 <= key, value <= 10^9`
- `0 <= duration <= 1000`
- `1 <= actions.length <= 100`
- `actions.length === values.length`
- `actions.length === timeDelays.length`
- `0 <= timeDelays[i] <= 1450`
- `actions[i]` is one of "TimeLimitedCache", "set", "get" and "count"
- First action is always "TimeLimitedCache" and must be executed immediately, with a 0-millisecond delay

## é¢˜ç›®å¤§æ„

ç¼–å†™ä¸€ä¸ªç±»ï¼Œå®ƒå…è®¸è·å–å’Œè®¾ç½®é”®-å€¼å¯¹ï¼Œå¹¶ä¸”æ¯ä¸ªé”®éƒ½æœ‰ä¸€ä¸ª **è¿‡æœŸæ—¶é—´** ã€‚

è¯¥ç±»æœ‰ä¸‰ä¸ªå…¬å…±æ–¹æ³•ï¼š

`set(key, value, duration)` ï¼šæ¥æ”¶å‚æ•°ä¸ºæ•´å‹é”® `key` ã€æ•´å‹å€¼ `value` å’Œä»¥æ¯«ç§’ä¸ºå•ä½çš„æŒç»­æ—¶é—´
`duration` ã€‚ä¸€æ—¦ `duration` åˆ°æœŸåï¼Œè¿™ä¸ªé”®å°±æ— æ³•è®¿é—®ã€‚å¦‚æœç›¸åŒçš„æœªè¿‡æœŸé”®å·²ç»å­˜åœ¨ï¼Œè¯¥æ–¹æ³•å°†è¿”å› `true` ï¼Œå¦åˆ™è¿”å› `false` ã€‚å¦‚æœè¯¥é”®å·²ç»å­˜åœ¨ï¼Œåˆ™å®ƒçš„å€¼å’ŒæŒç»­æ—¶é—´éƒ½åº”è¯¥è¢«è¦†ç›–ã€‚

`get(key)` ï¼šå¦‚æœå­˜åœ¨ä¸€ä¸ªæœªè¿‡æœŸçš„é”®ï¼Œå®ƒåº”è¯¥è¿”å›è¿™ä¸ªé”®ç›¸å…³çš„å€¼ã€‚å¦åˆ™è¿”å› `-1` ã€‚

`count()` ï¼šè¿”å›æœªè¿‡æœŸé”®çš„æ€»æ•°ã€‚

**æç¤ºï¼š**

- `0 <= key, value <= 10^9`
- `0 <= duration <= 1000`
- `1 <= actions.length <= 100`
- `actions.length === values.length`
- `actions.length === timeDelays.length`
- `0 <= timeDelays[i] <= 1450`
- `actions[i]` æ˜¯ "TimeLimitedCache"ã€"set"ã€"get" å’Œ "count" ä¸­çš„ä¸€ä¸ªã€‚
- ç¬¬ä¸€ä¸ªæ“ä½œå§‹ç»ˆæ˜¯ "TimeLimitedCache" è€Œä¸”ä¸€å®šä¼šä»¥ 0 æ¯«ç§’çš„å»¶è¿Ÿç«‹å³æ‰§è¡Œ

## è§£é¢˜æ€è·¯

1. **`constructor`**ï¼š

   - ä½¿ç”¨ `Map` æ•°æ®ç»“æ„æ¥å­˜å‚¨é”®å€¼å¯¹ï¼Œå…¶ä¸­æ¯ä¸ªé”®å¯¹åº”çš„å€¼ä¸ºä¸€ä¸ªæ•°ç»„ `[value, timer]`ï¼Œå…¶ä¸­ `value` æ˜¯å­˜å‚¨çš„å€¼ï¼Œ`timer` æ˜¯è¯¥é”®çš„å®šæ—¶å™¨ï¼Œç”¨äºåˆ é™¤è¿‡æœŸé”®ã€‚

2. **`set(key, value, duration)`**ï¼š

   - è¯¥æ–¹æ³•å°†ç»™å®šçš„é”® `key` å’Œå€¼ `value` å­˜å…¥ç¼“å­˜ï¼Œå¹¶è®¾ç½®è¯¥é”®å€¼å¯¹çš„æœ‰æ•ˆæœŸ `duration` æ¯«ç§’ã€‚
   - å¦‚æœç›¸åŒé”®å·²ç»å­˜åœ¨ä¸”æœªè¿‡æœŸï¼Œåˆ™è¿”å› `true`ï¼Œå¦åˆ™è¿”å› `false`ã€‚
   - ä½¿ç”¨ `setTimeout` å®šæ—¶å‡½æ•°ï¼Œåœ¨åˆ°æœŸæ—¶é—´åè‡ªåŠ¨åˆ é™¤è¯¥é”®å€¼å¯¹ã€‚
   - å¦‚æœé”®å·²ç»å­˜åœ¨ä¸”å®šæ—¶å™¨æ²¡æœ‰åˆ°æœŸï¼Œé¦–å…ˆæ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨ï¼Œä»¥ç¡®ä¿æ–°è®¾ç½®çš„ `duration` è¦†ç›–æ—§çš„æ—¶é—´ã€‚

3. **`get(key)`**ï¼š

   - æŸ¥è¯¢ç¼“å­˜ä¸­æ˜¯å¦å­˜åœ¨æœªè¿‡æœŸçš„é”® `key`ã€‚
   - å¦‚æœé”®å­˜åœ¨ä¸”æœªè¿‡æœŸï¼Œåˆ™è¿”å›å…¶å¯¹åº”çš„å€¼ï¼Œå¦åˆ™è¿”å› `-1`ã€‚

4. **`count()`**ï¼š
   - è¿”å›å½“å‰ç¼“å­˜ä¸­æœªè¿‡æœŸçš„é”®å€¼å¯¹æ•°é‡ï¼Œç›´æ¥é€šè¿‡ `Map` å¯¹è±¡çš„ `size` å±æ€§æ¥è·å–å½“å‰é”®çš„æ•°é‡ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š
  - **`set`**ï¼šæ¯æ¬¡è°ƒç”¨ `set`ï¼ŒæŸ¥æ‰¾å’Œæ’å…¥æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¸º `O(1)`ï¼Œåˆ é™¤æ—§çš„å®šæ—¶å™¨å’Œè®¾ç½®æ–°çš„å®šæ—¶å™¨ä¹Ÿä¸ºå¸¸æ•°æ—¶é—´æ“ä½œã€‚å› æ­¤ `set` çš„æ—¶é—´å¤æ‚åº¦ä¸º `O(1)`ã€‚
  - **`get`**ï¼šæŸ¥æ‰¾é”®çš„æ—¶é—´å¤æ‚åº¦ä¸º `O(1)`ã€‚
  - **`count`**ï¼š`Map.size` çš„è®¿é—®æ˜¯å¸¸æ•°æ—¶é—´æ“ä½œï¼Œæ—¶é—´å¤æ‚åº¦ä¸º `O(1)`ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(n)`ï¼Œå…¶ä¸­ `n` ä¸ºç¼“å­˜ä¸­å­˜å‚¨çš„é”®å€¼å¯¹æ•°é‡ï¼Œä½¿ç”¨äº† `Map` æ¥å­˜å‚¨é”®å€¼å¯¹ã€‚

## ä»£ç 

```javascript
var TimeLimitedCache = function () {
	this.cache = new Map();
};

/**
 * @param {number} key
 * @param {number} value
 * @param {number} duration time until expiration in ms
 * @return {boolean} if un-expired key already existed
 */
TimeLimitedCache.prototype.set = function (key, value, duration) {
	const timer = setTimeout(() => this.cache.delete(key), duration);
	const exist = this.cache.has(key);
	if (exist) {
		const oldTimer = this.cache.get(key)[1];
		clearTimeout(oldTimer);
	}
	this.cache.set(key, [value, timer]);
	return exist;
};

/**
 * @param {number} key
 * @return {number} value associated with key
 */
TimeLimitedCache.prototype.get = function (key) {
	if (this.cache.has(key)) return this.cache.get(key)[0];
	return -1;
};

/**
 * @return {number} count of non-expired keys
 */
TimeLimitedCache.prototype.count = function () {
	return this.cache.size;
};

/**
 * const timeLimitedCache = new TimeLimitedCache()
 * timeLimitedCache.set(1, 42, 1000); // false
 * timeLimitedCache.get(1) // 42
 * timeLimitedCache.count() // 1
 */
```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 2627 | [å‡½æ•°é˜²æŠ–](https://leetcode.com/problems/debounce) | [[âœ“]](https://2xiao.github.io/leetcode-js/leetcode/problem/2627) |  | <font color=#ffb800>Medium</font> |
| 2636 | [Promise å¯¹è±¡æ± ](https://leetcode.com/problems/promise-pool) | [[âœ“]](https://2xiao.github.io/leetcode-js/leetcode/problem/2636) |  | <font color=#ffb800>Medium</font> |
| 2637 | [æœ‰æ—¶é—´é™åˆ¶çš„ Promise å¯¹è±¡](https://leetcode.com/problems/promise-time-limit) | [[âœ“]](https://2xiao.github.io/leetcode-js/leetcode/problem/2637) |  | <font color=#ffb800>Medium</font> |

<style>
.blue {
    background-color: #096dd9;
    padding: 0.25rem 0.5rem;
    margin: 0;
    font-size: 0.85em;
    border-radius: 3px;
    color: white;
    font-weight: 500;
}
table th:first-of-type { width: 10%; }
table th:nth-of-type(2) { width: 35%; }
table th:nth-of-type(3) { width: 10%; }
table th:nth-of-type(4) { width: 35%; }
table th:nth-of-type(5) { width: 10%; }
</style>
