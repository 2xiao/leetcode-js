# [76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`å“ˆå¸Œè¡¨`](/leetcode/outline/tag/hash-table.md) [`å­—ç¬¦ä¸²`](/leetcode/outline/tag/string.md) [`æ»‘åŠ¨çª—å£`](/leetcode/outline/tag/sliding-window.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/minimum-window-substring/)

## é¢˜ç›®

Given two strings `s` and `t` of lengths m and n respectively, return the **minimum window substring** of `s` such that every character in `t` (including duplicates) is included in the window. If there is no such substring, return the empty string `""`.

The testcases will be generated such that the answer is **unique**.

Follow up: Could you find an algorithm that runs in `O(m + n)` time?

**Example 1**:

```
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
```

**Example 2**:

```
Input: s = "a", t = "a"
Output: "a"
```

**Example 3**:

```
Input: s = "a", t = "aa"
Output: ""
```

**Note**:

- `1 <= s.length <= 10^5`
- `1 <= t.length <= 10^5`
- `s` and `t` consist of uppercase and lowercase English letters.

## é¢˜ç›®å¤§æ„

ç»™å®šä¸€ä¸ªæºå­—ç¬¦ä¸² `s`ï¼Œå†ç»™ä¸€ä¸ªå­—ç¬¦ä¸² `t`ï¼Œè¦æ±‚åœ¨æºå­—ç¬¦ä¸²ä¸­æ‰¾åˆ°ä¸€ä¸ªçª—å£ï¼Œè¿™ä¸ªçª—å£åŒ…å«ç”±å­—ç¬¦ä¸²å„ç§æ’åˆ—ç»„åˆç»„æˆçš„ï¼Œçª—å£ä¸­å¯ä»¥åŒ…å« `t` ä¸­æ²¡æœ‰çš„å­—ç¬¦ï¼Œå¦‚æœå­˜åœ¨å¤šä¸ªï¼Œåœ¨ç»“æœä¸­è¾“å‡ºæœ€å°çš„çª—å£ï¼Œå¦‚æœæ‰¾ä¸åˆ°è¿™æ ·çš„çª—å£ï¼Œè¾“å‡ºç©ºå­—ç¬¦ä¸²ã€‚

è¿›é˜¶ï¼šä½ èƒ½è®¾è®¡ä¸€ä¸ªåœ¨ `O(m+n)` æ—¶é—´å†…è§£å†³æ­¤é—®é¢˜çš„ç®—æ³•å—ï¼Ÿ

## è§£é¢˜æ€è·¯

è¿™ä¸€é¢˜æ˜¯æ»‘åŠ¨çª—å£çš„é¢˜ç›®ï¼Œåœ¨çª—å£æ»‘åŠ¨çš„è¿‡ç¨‹ä¸­ä¸æ–­çš„æ‰©å¤§çª—å£å³è¾¹åŒ…å«å­—ç¬¦ä¸² `t`ï¼Œç›´åˆ°å®Œå…¨åŒ…å«å­—ç¬¦ä¸² `t` çš„å­—ç¬¦ä»¥åï¼Œå†ç¼©å°çª—å£å·¦è¾¹ï¼Œç›´åˆ°æ±‚å‡ºæœ€å°çª—å£ï¼Œå…·ä½“ç®—æ³•å¦‚ä¸‹ï¼š

1. åœ¨å­—ç¬¦ä¸² `s` ä¸­ä½¿ç”¨åŒæŒ‡é’ˆä¸­çš„å·¦å³æŒ‡é’ˆæŠ€å·§ï¼Œåˆå§‹åŒ– `left = right = 0`ï¼ŒæŠŠç´¢å¼•åŒºé—´ `[left, right]` ç§°ä¸ºä¸€ä¸ªã€Œçª—å£ã€ã€‚
2. å…ˆä¸æ–­åœ°å¢åŠ  `right` æŒ‡é’ˆæ‰©å¤§çª—å£ `[left, right]`ï¼Œç›´åˆ°çª—å£ä¸­çš„å­—ç¬¦ä¸²ç¬¦åˆè¦æ±‚ï¼ˆåŒ…å«äº† `t` ä¸­çš„æ‰€æœ‰å­—ç¬¦ï¼‰ã€‚
3. æ­¤æ—¶åœæ­¢å¢åŠ  `right`ï¼Œè½¬è€Œä¸æ–­å¢åŠ  `left` æŒ‡é’ˆç¼©å°çª—å£ `[left, right]`ï¼Œç›´åˆ°çª—å£ä¸­çš„å­—ç¬¦ä¸²ä¸å†ç¬¦åˆè¦æ±‚ï¼ˆä¸åŒ…å« `t` ä¸­çš„æ‰€æœ‰å­—ç¬¦äº†ï¼‰ã€‚åŒæ—¶ï¼Œæ¯æ¬¡å¢åŠ  `left`ï¼Œéƒ½è¦æ›´æ–°ä¸€è½®ç»“æœã€‚
4. é‡å¤ç¬¬ 2 å’Œç¬¬ 3 æ­¥ï¼Œç›´åˆ° `right` åˆ°è¾¾å­—ç¬¦ä¸² `s` çš„å°½å¤´ã€‚

## ä»£ç 

```javascript
/**
 * @param {string} s
 * @param {string} t
 * @return {string}
 */
var minWindow = function (s, t) {
  let need = new Map();
  let window = new Map();
  for (let i of t) {
    need.set(i, need.has(i) ? need.get(i) + 1 : 1);
  }

  let left = 0,
    right = 0,
    vaild = 0,
    start = 0,
    len = Infinity;
  while (right < s.length) {
    let i = s[right];
    right++;
    if (need.has(i)) {
      window.set(i, window.has(i) ? window.get(i) + 1 : 1);
      if (window.get(i) === need.get(i)) {
        vaild++;
      }
    }

    while (vaild === need.size) {
      if (right - left < len) {
        start = left;
        len = right - left;
      }
      let d = s[left];
      left++;
      if (need.has(d)) {
        if (window.get(d) === need.get(d)) {
          vaild--;
        }
        window.set(d, window.get(d) - 1);
      }
    }
  }
  return len === Infinity ? "" : s.slice(start, start + len);
};
```

## ç›¸å…³é¢˜ç›®

:::: md-demo ç›¸å…³é¢˜ç›®

- [30. ä¸²è”æ‰€æœ‰å•è¯çš„å­ä¸²](https://leetcode.com/problems/substring-with-concatenation-of-all-words)
- [209. é•¿åº¦æœ€å°çš„å­æ•°ç»„](https://leetcode.com/problems/minimum-size-subarray-sum)
- [239. æ»‘åŠ¨çª—å£æœ€å¤§å€¼](https://leetcode.com/problems/sliding-window-maximum)
- [567. å­—ç¬¦ä¸²çš„æ’åˆ—](https://leetcode.com/problems/permutation-in-string)
- [632. æœ€å°åŒºé—´](https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists)
- [ğŸ”’ Minimum Window Subsequence](https://leetcode.com/problems/minimum-window-subsequence)

::::
