# [1545. æ‰¾å‡ºç¬¬ N ä¸ªäºŒè¿›åˆ¶å­—ç¬¦ä¸²ä¸­çš„ç¬¬ K ä½](https://leetcode.com/problems/find-kth-bit-in-nth-binary-string)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`é€’å½’`](/leetcode/outline/tag/recursion.md) [`å­—ç¬¦ä¸²`](/leetcode/outline/tag/string.md) [`æ¨¡æ‹Ÿ`](/leetcode/outline/tag/simulation.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/find-kth-bit-in-nth-binary-string)

## é¢˜ç›®

Given two positive integers `n` and `k`, the binary string `Sn` is formed as
follows:

- `S1 = "0"`
- `Si = Si - 1 + "1" + reverse(invert(Si - 1))` for `i > 1`

Where `+` denotes the concatenation operation, `reverse(x)` returns the
reversed string `x`, and `invert(x)` inverts all the bits in `x` (`0` changes
to `1` and `1` changes to `0`).

For example, the first four strings in the above sequence are:

- `S1 = "0"`
- `S2 = "011"`
- `S3 = "0111001"`
- `S4 = "011100110110001"`

Return _the_ `kth` _bit_ _in_ `Sn`. It is guaranteed that `k` is valid for the
given `n`.

**Example 1:**

> Input: n = 3, k = 1
>
> Output: "0"
>
> Explanation: S3 is "**_0_** 111001".
>
> The 1st bit is "0".

**Example 2:**

> Input: n = 4, k = 11
>
> Output: "1"
>
> Explanation: S4 is "0111001101** _1_** 0001".
>
> The 11th bit is "1".

**Constraints:**

- `1 <= n <= 20`
- `1 <= k <= 2^n - 1`

## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸¤ä¸ªæ­£æ•´æ•° `n` å’Œ `k`ï¼ŒäºŒè¿›åˆ¶å­—ç¬¦ä¸² `Sn` çš„å½¢æˆè§„åˆ™å¦‚ä¸‹ï¼š

- `S1 = "0"`
- å½“ `i > 1` æ—¶ï¼Œ`Si = Si-1 + "1" + reverse(invert(Si-1))`

å…¶ä¸­ `+` è¡¨ç¤ºä¸²è”æ“ä½œï¼Œ`reverse(x)` è¿”å›åè½¬ `x` åå¾—åˆ°çš„å­—ç¬¦ä¸²ï¼Œè€Œ `invert(x)` åˆ™ä¼šç¿»è½¬ x ä¸­çš„æ¯ä¸€ä½ï¼ˆ0 å˜ä¸º
1ï¼Œè€Œ 1 å˜ä¸º 0ï¼‰ã€‚

ä¾‹å¦‚ï¼Œç¬¦åˆä¸Šè¿°æè¿°çš„åºåˆ—çš„å‰ 4 ä¸ªå­—ç¬¦ä¸²ä¾æ¬¡æ˜¯ï¼š

- `S1 = "0"`
- `S2 = "011"`
- `S3 = "0111001"`
- `S4 = "011100110110001"`

è¯·ä½ è¿”å› `Sn` çš„ **ç¬¬`k` ä½å­—ç¬¦** ï¼Œé¢˜ç›®æ•°æ®ä¿è¯ `k` ä¸€å®šåœ¨ `Sn` é•¿åº¦èŒƒå›´ä»¥å†…ã€‚

**æç¤ºï¼š**

- `1 <= n <= 20`
- `1 <= k <= 2^n - 1`

## è§£é¢˜æ€è·¯

- å¯ä»¥ä½¿ç”¨é€’å½’æ–¹æ³•ç”Ÿæˆç¬¬ `n` ä¸ªäºŒè¿›åˆ¶å­—ç¬¦ä¸²ã€‚ç”Ÿæˆçš„è¿‡ç¨‹å¯ä»¥ç”¨ `S(n) = S(n-1) + '1' + reverse(invert(Si - 1))` æ¥è¡¨ç¤ºï¼Œå…¶ä¸­ `reverse` æ˜¯ç¿»è½¬æ“ä½œï¼Œ`invert` æ˜¯å–åæ“ä½œï¼Œé€šè¿‡ `split` å’Œ `map` æ–¹æ³•å®ç°å–åæ“ä½œã€‚

- ä¸€æ—¦ç”Ÿæˆäº†ç¬¬ `n` ä¸ªå­—ç¬¦ä¸²ï¼Œå°±å¯ä»¥æ ¹æ® 1-indexed è§„åˆ™è¿”å›ç¬¬ `k` ä½çš„å­—ç¬¦ã€‚

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O(2^n)`ï¼Œéšç€ `n` å¢åŠ ï¼Œå­—ç¬¦ä¸²é•¿åº¦å‘ˆæŒ‡æ•°å¢é•¿ã€‚
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O(2^n)`ï¼Œå­˜å‚¨ç”Ÿæˆçš„å­—ç¬¦ä¸²æ‰€éœ€çš„ç©ºé—´ã€‚

## ä»£ç 

```javascript
/**
 * @param {number} n
 * @param {number} k
 * @return {character}
 */
var findKthBit = function (n, k) {
	const genString = (n) => {
		if (n == 1) return '0';
		const prev = genString(n - 1);
		const reverse = prev
			.split('')
			.map((i) => (i == '0' ? '1' : '0'))
			.reverse()
			.join('');
		return prev + '1' + reverse;
	};

	const str = genString(n);

	return str[k - 1]; // k æ˜¯ 1-indexed
};
```
