# [224. Basic Calculator](https://leetcode.com/problems/basic-calculator/)

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`æ ˆ`](../solution/æ ˆ) [`é€’å½’`](../solution/é€’å½’) [`æ•°å­¦`](../solution/æ•°å­¦) [`å­—ç¬¦ä¸²`](../solution/å­—ç¬¦ä¸²)
### é¢˜ç›®

Implement a basic calculator to evaluate a simple expression string.

The expression string may contain openÂ `(`Â and closing parenthesesÂ `)`, the plusÂ `+`Â or minus signÂ `-`,Â **non-negative**Â integers and empty spacesÂ .

**Example 1**:
:::tip
Input: "1 + 1"

Output: 2
:::

**Example 2**:
:::tip
Input: " 2-1 + 2 "

Output: 3
:::

**Example 3**:
:::tip
Input: "(1+(4+5+2)-3)+(6+8)"

Output: 23
:::

**Note**:

- You may assume that the given expression is always valid.
- **Do not**Â use theÂ `eval`Â built-in library function.

### é¢˜ç›®å¤§æ„

å®ç°ä¸€ä¸ªåŸºæœ¬çš„è®¡ç®—å™¨æ¥è®¡ç®—ä¸€ä¸ªç®€å•çš„å­—ç¬¦ä¸²è¡¨è¾¾å¼çš„å€¼ã€‚å­—ç¬¦ä¸²è¡¨è¾¾å¼å¯ä»¥åŒ…å«å·¦æ‹¬å· ( ï¼Œå³æ‹¬å· )ï¼ŒåŠ å· + ï¼Œå‡å· -ï¼Œéè´Ÿæ•´æ•°å’Œç©ºæ ¼ ã€‚

### è§£é¢˜æ€è·¯

- æ³¨æ„ç‚¹ä¸€ï¼šç®—å¼ä¸­æœ‰ç©ºæ ¼ï¼Œéœ€è¦è·³è¿‡
- æ³¨æ„ç‚¹äºŒï¼šç®—å¼ä¸­ä¼šå‡ºç°è´Ÿæ•°ï¼Œè´Ÿè´Ÿå¾—æ­£çš„æƒ…å†µéœ€è¦ç‰¹æ®Šå¤„ç†ï¼Œæ‰€ä»¥éœ€è¦è®°å½•æ¯æ¬¡è®¡ç®—å‡ºæ¥çš„ç¬¦å·

### ä»£ç 

```go

package leetcode

import (
	"container/list"
	"fmt"
	"strconv"
)

// è§£æ³•ä¸€
func calculate(s string) int {
	i, stack, result, sign := 0, list.New(), 0, 1 // è®°å½•åŠ å‡çŠ¶æ€
	for i < len(s) {
		if s[i] == ' ' {
			i++
		} else if s[i] <= '9' && s[i] >= '0' { // è·å–ä¸€æ®µæ•°å­—
			base, v := 10, int(s[i]-'0')
			for i+1 < len(s) && s[i+1] <= '9' && s[i+1] >= '0' {
				v = v*base + int(s[i+1]-'0')
				i++
			}
			result += v * sign
			i++
		} else if s[i] == '+' {
			sign = 1
			i++
		} else if s[i] == '-' {
			sign = -1
			i++
		} else if s[i] == '(' { // æŠŠä¹‹å‰è®¡ç®—ç»“æœåŠåŠ å‡çŠ¶æ€å‹æ ˆï¼Œå¼€å§‹æ–°çš„è®¡ç®—
			stack.PushBack(result)
			stack.PushBack(sign)
			result = 0
			sign = 1
			i++
		} else if s[i] == ')' { // æ–°çš„è®¡ç®—ç»“æœ * å‰ä¸€ä¸ªåŠ å‡çŠ¶æ€ + ä¹‹å‰è®¡ç®—ç»“æœ
			result = result*stack.Remove(stack.Back()).(int) + stack.Remove(stack.Back()).(int)
			i++
		}
	}
	return result
}

// è§£æ³•äºŒ
func calculate1(s string) int {
	stack := []byte{}
	for i := 0; i < len(s); i++ {
		if s[i] == ' ' {
			continue
		} else if s[i] == ')' {
			tmp, index := "", len(stack)-1
			for ; index >= 0; index-- {
				if stack[index] == '(' {
					break
				}
			}
			tmp = string(stack[index+1:])
			stack = stack[:index]
			res := strconv.Itoa(calculateStr(tmp))
			for j := 0; j < len(res); j++ {
				stack = append(stack, res[j])
			}
		} else {
			stack = append(stack, s[i])
		}
	}
	fmt.Printf("stack = %v\n", string(stack))
	return calculateStr(string(stack))
}

func calculateStr(str string) int {
	s, nums, tmpStr, res := []byte{}, []int{}, "", 0
	// å¤„ç†ç¬¦å·çš„é—®é¢˜ï¼Œ++å¾—+ï¼Œ--å¾—+ï¼Œ+-ã€-+å¾—-
	for i := 0; i < len(str); i++ {
		if len(s) > 0 && s[len(s)-1] == '+' && str[i] == '+' {
			continue
		} else if len(s) > 0 && s[len(s)-1] == '+' && str[i] == '-' {
			s[len(s)-1] = '-'
		} else if len(s) > 0 && s[len(s)-1] == '-' && str[i] == '+' {
			continue
		} else if len(s) > 0 && s[len(s)-1] == '-' && str[i] == '-' {
			s[len(s)-1] = '+'
		} else {
			s = append(s, str[i])
		}
	}
	str = string(s)
	s = []byte{}
	for i := 0; i < len(str); i++ {
		if isDigital(str[i]) {
			tmpStr += string(str[i])
		} else {
			num, _ := strconv.Atoi(tmpStr)
			nums = append(nums, num)
			tmpStr = ""
			s = append(s, str[i])
		}
	}
	if tmpStr != "" {
		num, _ := strconv.Atoi(tmpStr)
		nums = append(nums, num)
	}
	res = nums[0]
	for i := 0; i < len(s); i++ {
		if s[i] == '+' {
			res += nums[i+1]
		} else {
			res -= nums[i+1]
		}
	}
	fmt.Printf("s = %v nums = %v res = %v\n", string(s), nums, res)
	return res
}

func isDigital(v byte) bool {
	if v >= '0' && v <= '9' {
		return true
	}
	return false
}

```
