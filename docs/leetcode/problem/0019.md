# [19. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`é“¾è¡¨`](../solution/é“¾è¡¨.md) [`åŒæŒ‡é’ˆ`](../solution/åŒæŒ‡é’ˆ.md)

### é¢˜ç›®

Given theÂ `head`Â of a linked list, remove theÂ `nth`Â node from the end of the list and return its head.

**Follow up:**Â Could you do this in one pass?

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)

::: tip

Input: head = [1,2,3,4,5], n = 2

Output: [1,2,3,5]

:::

**Example 2:**

::: tip

Input: head = [1], n = 1

Output: []

:::

**Example 3:**

::: tip

Input: head = [1,2], n = 1

Output: [1]

:::

**Constraints:**

- The number of nodes in the list isÂ `sz`.
- `1 <= sz <= 30`
- `0 <= Node.val <= 100`
- `1 <= n <= sz`

### é¢˜ç›®å¤§æ„

åˆ é™¤é“¾è¡¨ä¸­å€’æ•°ç¬¬ n ä¸ªç»“ç‚¹ã€‚

### è§£é¢˜æ€è·¯

è¿™é“é¢˜æ¯”è¾ƒç®€å•ï¼Œå…ˆå¾ªç¯ä¸€æ¬¡æ‹¿åˆ°é“¾è¡¨çš„æ€»é•¿åº¦ï¼Œç„¶åå¾ªç¯åˆ°è¦åˆ é™¤çš„ç»“ç‚¹çš„å‰ä¸€ä¸ªç»“ç‚¹å¼€å§‹åˆ é™¤æ“ä½œã€‚éœ€è¦æ³¨æ„çš„ä¸€ä¸ªç‰¹ä¾‹æ˜¯ï¼Œæœ‰å¯èƒ½è¦åˆ é™¤å¤´ç»“ç‚¹ï¼Œè¦å•ç‹¬å¤„ç†ã€‚

è¿™é“é¢˜æœ‰ä¸€ç§ç‰¹åˆ«ç®€å•çš„è§£æ³•ã€‚è®¾ç½® 2 ä¸ªæŒ‡é’ˆï¼Œä¸€ä¸ªæŒ‡é’ˆè·ç¦»å‰ä¸€ä¸ªæŒ‡é’ˆ n ä¸ªè·ç¦»ã€‚åŒæ—¶ç§»åŠ¨ 2 ä¸ªæŒ‡é’ˆï¼Œ2 ä¸ªæŒ‡é’ˆéƒ½ç§»åŠ¨ç›¸åŒçš„è·ç¦»ã€‚å½“ä¸€ä¸ªæŒ‡é’ˆç§»åŠ¨åˆ°äº†ç»ˆç‚¹ï¼Œé‚£ä¹ˆå‰ä¸€ä¸ªæŒ‡é’ˆå°±æ˜¯å€’æ•°ç¬¬ n ä¸ªèŠ‚ç‚¹äº†ã€‚

### ä»£ç 

```go
package leetcode

import (
	"github.com/halfrost/leetcode-go/structures"
)

// ListNode define
type ListNode = structures.ListNode

/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */

// è§£æ³•ä¸€
func removeNthFromEnd(head *ListNode, n int) *ListNode {
	dummyHead := &ListNode{Next: head}
	preSlow, slow, fast := dummyHead, head, head
	for fast != nil {
		if n <= 0 {
			preSlow = slow
			slow = slow.Next
		}
		n--
		fast = fast.Next
	}
	preSlow.Next = slow.Next
	return dummyHead.Next
}

// è§£æ³•äºŒ
func removeNthFromEnd1(head *ListNode, n int) *ListNode {
	if head == nil {
		return nil
	}
	if n <= 0 {
		return head
	}
	current := head
	len := 0
	for current != nil {
		len++
		current = current.Next
	}
	if n > len {
		return head
	}
	if n == len {
		current := head
		head = head.Next
		current.Next = nil
		return head
	}
	current = head
	i := 0
	for current != nil {
		if i == len-n-1 {
			deleteNode := current.Next
			current.Next = current.Next.Next
			deleteNode.Next = nil
			break
		}
		i++
		current = current.Next
	}
	return head
}
```
