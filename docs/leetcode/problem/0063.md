# [63. Unique Paths II](https://leetcode.com/problems/unique-paths-ii/)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ•°ç»„`](../solution/array.md) [`åŠ¨æ€è§„åˆ’`](../solution/dynamic-programming.md) [`çŸ©é˜µ`](../solution/matrix.md)

### é¢˜ç›®

A robot is located at the top-left corner of aÂ *m*Â xÂ *n*Â grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

Now consider if some obstacles are added to the grids. How many unique paths would there be?

![](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

An obstacle and empty space is marked asÂ `1`Â andÂ `0`Â respectively in the grid.

**Note**:Â *m*Â andÂ *n*Â will be at most 100.

**Example 1**:

::: tip

Input:
[
[0,0,0],
[0,1,0],
[0,0,0]
]

Output: 2

:::

Explanation:

There is one obstacle in the middle of the 3x3 grid above.

There are two ways to reach the bottom-right corner:

1. Right -> Right -> Down -> Down
2. Down -> Down -> Right -> Right

### é¢˜ç›®å¤§æ„

ä¸€ä¸ªæœºå™¨äººä½äºä¸€ä¸ª m x n ç½‘æ ¼çš„å·¦ä¸Šè§’ ï¼ˆèµ·å§‹ç‚¹åœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸ºâ€œStartâ€ ï¼‰ã€‚æœºå™¨äººæ¯æ¬¡åªèƒ½å‘ä¸‹æˆ–è€…å‘å³ç§»åŠ¨ä¸€æ­¥ã€‚æœºå™¨äººè¯•å›¾è¾¾åˆ°ç½‘æ ¼çš„å³ä¸‹è§’ï¼ˆåœ¨ä¸‹å›¾ä¸­æ ‡è®°ä¸ºâ€œFinishâ€ï¼‰ã€‚ç°åœ¨è€ƒè™‘ç½‘æ ¼ä¸­æœ‰éšœç¢ç‰©ã€‚é‚£ä¹ˆä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’å°†ä¼šæœ‰å¤šå°‘æ¡ä¸åŒçš„è·¯å¾„ï¼Ÿ

### è§£é¢˜æ€è·¯

- è¿™ä¸€é¢˜æ˜¯ [ç¬¬ 62 é¢˜](./0062.md) çš„åŠ å¼ºç‰ˆã€‚ä¹Ÿæ˜¯ä¸€é“è€ƒå¯Ÿ DP çš„ç®€å•é¢˜ã€‚
- è¿™ä¸€é¢˜æ¯”ç¬¬ 62 é¢˜å¢åŠ çš„æ¡ä»¶æ˜¯åœ°å›¾ä¸­ä¼šå‡ºç°éšœç¢ç‰©ï¼Œéšœç¢ç‰©çš„å¤„ç†æ–¹æ³•æ˜¯ `dp[i][j]=0`ã€‚
- éœ€è¦æ³¨æ„çš„ä¸€ç§æƒ…å†µæ˜¯ï¼Œèµ·ç‚¹å°±æ˜¯éšœç¢ç‰©ï¼Œé‚£ä¹ˆè¿™ç§æƒ…å†µç›´æ¥è¾“å‡º 0 ã€‚

| :heart: | 1        | 1   | 1   | 1        | 1   | 1   |
| ------- | -------- | --- | --- | -------- | --- | --- |
| 1       | :hankey: | 1   | 2   | :hankey: | 1   | 2   |
| 1       | 1        | 2   | 4   | 4        | 5   | 7   |

### ä»£ç 

```javascript
// æ—¶é—´å¤æ‚åº¦ O(nm)ï¼Œç©ºé—´å¤æ‚åº¦ O(m)
const path = (inputArr) => {
  // å¦‚æœèµ·ç‚¹å°±æ˜¯éšœç¢ç‰©
  if (inputArr[0][0] === 1) return 0;
  const m = inputArr.length;
  const n = inputArr[0].length;
  // ç”¨0å¡«å……ï¼Œå› ä¸ºç°åœ¨æœ‰éšœç¢ç‰©
  let arr = new Array(m).fill(0);
  // ç¬¬ä¸€åˆ—å…ˆå†™æˆ1
  arr[0] = 1;
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      if (inputArr[j][i] === 1) {
        // é‡åˆ°éšœç¢ç‰©arr[j]å°±å˜æˆ0ï¼Œè¿™é‡ŒåŒ…å«äº†ç¬¬ä¸€åˆ—çš„æƒ…å†µ
        arr[j] = 0;
      } else if (j > 0) {
        arr[j] = arr[j - 1] + arr[j];
      }
    }
  }
  return arr[m - 1];
};
```
