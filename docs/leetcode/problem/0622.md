# [622. Design Circular Queue](https://leetcode.com/problems/design-circular-queue/)

:tangerine: <font color=#ffb800>Medium</font>&emsp; ðŸ”–&ensp; [`è®¾è®¡`](../solution/design.md) [`é˜Ÿåˆ—`](../solution/queue.md) [`æ•°ç»„`](../solution/array.md) [`é“¾è¡¨`](../solution/linked-list.md)

## é¢˜ç›®

Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called "Ring Buffer".

One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values.

Implementation theÂ `MyCircularQueue`Â class:

- `MyCircularQueue(k)`Â Initializes the object with the size of the queue to beÂ `k`.
- `int Front()`Â Gets the front item from the queue. If the queue is empty, returnÂ `1`.
- `int Rear()`Â Gets the last item from the queue. If the queue is empty, returnÂ `1`.
- `boolean enQueue(int value)`Â Inserts an element into the circular queue. ReturnÂ `true`Â if the operation is successful.
- `boolean deQueue()`Â Deletes an element from the circular queue. ReturnÂ `true`Â if the operation is successful.
- `boolean isEmpty()`Â Checks whether the circular queue is empty or not.
- `boolean isFull()`Â Checks whether the circular queue is full or not.

**Example 1:**

```
Input
["MyCircularQueue", "enQueue", "enQueue", "enQueue", "enQueue", "Rear", "isFull", "deQueue", "enQueue", "Rear"]
[[3], [1], [2], [3], [4], [], [], [], [4], []]
Output
[null, true, true, true, false, 3, true, true, true, 4]

Explanation
MyCircularQueue myCircularQueue = new MyCircularQueue(3);
myCircularQueue.enQueue(1); // return True
myCircularQueue.enQueue(2); // return True
myCircularQueue.enQueue(3); // return True
myCircularQueue.enQueue(4); // return False
myCircularQueue.Rear();     // return 3
myCircularQueue.isFull();   // return True
myCircularQueue.deQueue();  // return True
myCircularQueue.enQueue(4); // return True
myCircularQueue.Rear();     // return 4

```

**Constraints:**

- `1 <= k <= 1000`
- `0 <= value <= 1000`
- At mostÂ `3000`Â calls will be made toÂ `enQueue`,Â `deQueue`,Â `Front`,Â `Rear`,Â `isEmpty`, andÂ `isFull`.

**Follow up:**

Could you solve the problem without using the built-in queue?

## é¢˜ç›®å¤§æ„

è®¾è®¡ä½ çš„å¾ªçŽ¯é˜Ÿåˆ—å®žçŽ°ã€‚ å¾ªçŽ¯é˜Ÿåˆ—æ˜¯ä¸€ç§çº¿æ€§æ•°æ®ç»“æž„ï¼Œå…¶æ“ä½œè¡¨çŽ°åŸºäºŽ FIFOï¼ˆå…ˆè¿›å…ˆå‡ºï¼‰åŽŸåˆ™å¹¶ä¸”é˜Ÿå°¾è¢«è¿žæŽ¥åœ¨é˜Ÿé¦–ä¹‹åŽä»¥å½¢æˆä¸€ä¸ªå¾ªçŽ¯ã€‚å®ƒä¹Ÿè¢«ç§°ä¸ºâ€œçŽ¯å½¢ç¼“å†²å™¨â€ã€‚

å¾ªçŽ¯é˜Ÿåˆ—çš„ä¸€ä¸ªå¥½å¤„æ˜¯æˆ‘ä»¬å¯ä»¥åˆ©ç”¨è¿™ä¸ªé˜Ÿåˆ—ä¹‹å‰ç”¨è¿‡çš„ç©ºé—´ã€‚åœ¨ä¸€ä¸ªæ™®é€šé˜Ÿåˆ—é‡Œï¼Œä¸€æ—¦ä¸€ä¸ªé˜Ÿåˆ—æ»¡äº†ï¼Œæˆ‘ä»¬å°±ä¸èƒ½æ’å…¥ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œå³ä½¿åœ¨é˜Ÿåˆ—å‰é¢ä»æœ‰ç©ºé—´ã€‚ä½†æ˜¯ä½¿ç”¨å¾ªçŽ¯é˜Ÿåˆ—ï¼Œæˆ‘ä»¬èƒ½ä½¿ç”¨è¿™äº›ç©ºé—´åŽ»å­˜å‚¨æ–°çš„å€¼ã€‚

ä½ çš„å®žçŽ°åº”è¯¥æ”¯æŒå¦‚ä¸‹æ“ä½œï¼š

- MyCircularQueue(k): æž„é€ å™¨ï¼Œè®¾ç½®é˜Ÿåˆ—é•¿åº¦ä¸º k ã€‚
- Front: ä»Žé˜Ÿé¦–èŽ·å–å…ƒç´ ã€‚å¦‚æžœé˜Ÿåˆ—ä¸ºç©ºï¼Œè¿”å›ž -1 ã€‚
- Rear: èŽ·å–é˜Ÿå°¾å…ƒç´ ã€‚å¦‚æžœé˜Ÿåˆ—ä¸ºç©ºï¼Œè¿”å›ž -1 ã€‚
- enQueue(value): å‘å¾ªçŽ¯é˜Ÿåˆ—æ’å…¥ä¸€ä¸ªå…ƒç´ ã€‚å¦‚æžœæˆåŠŸæ’å…¥åˆ™è¿”å›žçœŸã€‚
- deQueue(): ä»Žå¾ªçŽ¯é˜Ÿåˆ—ä¸­åˆ é™¤ä¸€ä¸ªå…ƒç´ ã€‚å¦‚æžœæˆåŠŸåˆ é™¤åˆ™è¿”å›žçœŸã€‚
- isEmpty(): æ£€æŸ¥å¾ªçŽ¯é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºã€‚
- isFull(): æ£€æŸ¥å¾ªçŽ¯é˜Ÿåˆ—æ˜¯å¦å·²æ»¡ã€‚

## è§£é¢˜æ€è·¯

- è®¾è®¡ä¸€ä¸ªçŽ¯å½¢é˜Ÿåˆ—ï¼Œåº•å±‚ç”¨æ•°ç»„å®žçŽ°;
- é¢å¤–ç»´æŠ¤ 4 ä¸ªå˜é‡ï¼Œé˜Ÿåˆ—çš„æ€» size ï¼Œé˜Ÿå¤´ä¸‹æ ‡ head ï¼Œé˜Ÿå°¾ä¸‹æ ‡ tail ;
- æ¯æ­¤å…¥é˜Ÿå’Œå‡ºé˜Ÿéƒ½æ›´æ–° head , tail ï¼Œä¸‹æ ‡éœ€è¦å¯¹ size å–ä½™ï¼Œå› ä¸ºè¶…è¿‡ size å¤§å°ä¹‹åŽï¼Œéœ€è¦å¾ªçŽ¯å­˜å‚¨ï¼›

## ä»£ç 

```javascript
/**
 * @param {number} k
 */
var MyCircularQueue = function (k) {
  this.queue = new Array(k);
  this.head = 0;
  this.tail = 0;
  this.size = k;
};

/**
 * @param {number} value
 * @return {boolean}
 */
MyCircularQueue.prototype.enQueue = function (value) {
  if (this.isFull()) return false;
  this.queue[this.tail] = value;
  // å°† tail æŒ‡å‘é˜Ÿå°¾çš„ä¸‹ä¸€ä¸ªç©ºé—´
  this.tail = (this.tail + 1) % this.size;
  return true;
};

/**
 * @return {boolean}
 */
MyCircularQueue.prototype.deQueue = function () {
  if (this.isEmpty()) return false;
  this.queue[this.head] = null;
  // å°† head æŒ‡å‘æ–°çš„é˜Ÿå¤´
  this.head = (this.head + 1) % this.size;
  return true;
};

/**
 * @return {number}
 */
MyCircularQueue.prototype.Front = function () {
  return this.isEmpty() ? -1 : this.queue[this.head];
};

/**
 * @return {number}
 */
MyCircularQueue.prototype.Rear = function () {
  // å› ä¸º tail æŒ‡å‘é˜Ÿå°¾çš„ä¸‹ä¸€ä¸ªç©ºé—´ï¼Œæ‰€ä»¥è¦åˆ†æƒ…å†µå¤„ç†
  // è‹¥ tail == 0ï¼Œé‚£é˜Ÿå°¾åº”è¯¥åœ¨ size - 1
  // å…¶ä»–æƒ…å†µï¼Œé˜Ÿå°¾åœ¨ tail - 1
  let index = this.tail === 0 ? this.size - 1 : this.tail - 1;
  return this.isEmpty() ? -1 : this.queue[index];
};

/**
 * @return {boolean}
 */
MyCircularQueue.prototype.isEmpty = function () {
  // head == tail æ—¶ï¼Œæœ‰ä¸¤ç§æƒ…å†µ
  // ä¸€ç§æ˜¯é˜Ÿåˆ—ä¸ºç©ºï¼Œæ­¤æ—¶ queue[head] ä¸ºnull
  // ä¸€ç§æ˜¯é˜Ÿåˆ—æ»¡äº†ï¼Œæ­¤æ—¶ queue[head] æœ‰å€¼
  return this.head === this.tail && !this.queue[this.head];
};

/**
 * @return {boolean}
 */
MyCircularQueue.prototype.isFull = function () {
  return this.head === this.tail && !!this.queue[this.head];
};
```
