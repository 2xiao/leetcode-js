# [496. Next Greater Element I](https://leetcode.com/problems/next-greater-element-i/)

ğŸŸ¢ <font color=#15bd66>Esay</font>&emsp; ğŸ”–&ensp; [`æ ˆ`](../solution/stack.md) [`æ•°ç»„`](../solution/array.md) [`å“ˆå¸Œè¡¨`](../solution/hash-table.md) [`å•è°ƒæ ˆ`](../solution/monotonic-stack.md)

### é¢˜ç›®

You are given two arrays (without duplicates) nums1 and nums2 where nums1â€™s elements are subset of nums2. Find all the next greater numbers for nums1's elements in the corresponding places of nums2.

The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.

**Example 1**:

::: tip

Input: nums1 = [4,1,2], nums2 = [1,3,4,2].

Output: [-1,3,-1]

:::

Explanation:

- For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.
- For number 1 in the first array, the next greater number for it in the second array is 3.
- For number 2 in the first array, there is no next greater number for it in the second array, so output -1.

**Example 2**:

::: tip

Input: nums1 = [2,4], nums2 = [1,2,3,4].

Output: [3,-1]

:::

Explanation:

- For number 2 in the first array, the next greater number for it in the second array is 3.
- For number 4 in the first array, there is no next greater number for it in the second array, so output -1.
- **Note**:

- All elements in nums1 and nums2 are unique.
- The length of both nums1 and nums2 would not exceed 1000.

### é¢˜ç›®å¤§æ„

é¢˜ç›®ç»™å‡º 2 ä¸ªæ•°ç»„ A å’Œ Bï¼Œé’ˆå¯¹ A ä¸­çš„æ¯ä¸ªæ•°ç»„ä¸­çš„å…ƒç´ ï¼Œè¦æ±‚åœ¨ B æ•°ç»„ä¸­æ‰¾å‡ºæ¯” A æ•°ç»„ä¸­å…ƒç´ å¤§çš„æ•°ï¼ŒB ä¸­å…ƒç´ ä¹‹é—´çš„é¡ºåºä¿æŒä¸å˜ã€‚å¦‚æœæ‰¾åˆ°äº†å°±è¾“å‡ºè¿™ä¸ªå€¼ï¼Œå¦‚æœæ‰¾ä¸åˆ°å°±è¾“å‡º -1ã€‚

### è§£é¢˜æ€è·¯


### ä»£ç 

```go

package leetcode

func nextGreaterElement(nums1 []int, nums2 []int) []int {
	if len(nums1) == 0 || len(nums2) == 0 {
		return []int{}
	}
	res, reocrd := []int{}, map[int]int{}
	for i, v := range nums2 {
		reocrd[v] = i
	}
	for i := 0; i < len(nums1); i++ {
		flag := false
		for j := reocrd[nums1[i]]; j < len(nums2); j++ {
			if nums2[j] > nums1[i] {
				res = append(res, nums2[j])
				flag = true
				break
			}
		}
		if flag == false {
			res = append(res, -1)
		}
	}
	return res
}

```
