# [146. LRU Cache](https://leetcode.com/problems/lru-cache/)

:tangerine: <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`è®¾è®¡`](../solution/design.md) [`å“ˆå¸Œè¡¨`](../solution/hash-table.md) [`é“¾è¡¨`](../solution/linked-list.md) [`åŒå‘é“¾è¡¨`](../solution/doubly-linked-list.md)

### é¢˜ç›®

Design a data structure that follows the constraints of aÂ **[Least Recently Used (LRU) cache](https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU)**.

Implement theÂ `LRUCache`Â class:

- `LRUCache(int capacity)`Â Initialize the LRU cache withÂ **positive**Â sizeÂ `capacity`.
- `int get(int key)`Â Return the value of theÂ `key`Â if the key exists, otherwise returnÂ `1`.
- `void put(int key, int value)`Â Update the value of theÂ `key`Â if theÂ `key`Â exists. Otherwise, add theÂ `key-value`Â pair to the cache. If the number of keys exceeds theÂ `capacity`Â from this operation,Â **evict**Â the least recently used key.

**Follow up**:Could you doÂ `get`Â andÂ `put`Â inÂ `O(1)`Â time complexity?

**Example 1**:

```
Input
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
Output
[null, null, null, 1, null, -1, null, -1, 3, 4]

Explanation
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // cache is {1=1}
lRUCache.put(2, 2); // cache is {1=1, 2=2}
lRUCache.get(1);    // return 1
lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}
lRUCache.get(2);    // returns -1 (not found)
lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}
lRUCache.get(1);    // return -1 (not found)
lRUCache.get(3);    // return 3
lRUCache.get(4);    // return 4

```

**Constraints**:

- `1 <= capacity <= 3000`
- `0 <= key <= 3000`
- `0 <= value <= 104`
- At mostÂ `3 * 104`Â calls will be made toÂ `get`Â andÂ `put`.

### é¢˜ç›®å¤§æ„

è¯·ä½ è®¾è®¡å¹¶å®ç°ä¸€ä¸ªæ»¡è¶³ LRU (æœ€è¿‘æœ€å°‘ä½¿ç”¨) ç¼“å­˜ çº¦æŸçš„æ•°æ®ç»“æ„ã€‚

å®ç° `LRUCache` ç±»ï¼š

- `LRUCache(int capacity)` ä»¥ **æ­£æ•´æ•°** ä½œä¸ºå®¹é‡ `capacity` åˆå§‹åŒ– LRU ç¼“å­˜
- `int get(int key)` å¦‚æœå…³é”®å­— key å­˜åœ¨äºç¼“å­˜ä¸­ï¼Œåˆ™è¿”å›å…³é”®å­—çš„å€¼ï¼Œå¦åˆ™è¿”å› `-1` ã€‚
- `void put(int key, int value)` å¦‚æœå…³é”®å­— `key` å·²ç»å­˜åœ¨ï¼Œåˆ™å˜æ›´å…¶æ•°æ®å€¼ `value` ï¼›å¦‚æœä¸å­˜åœ¨ï¼Œåˆ™å‘ç¼“å­˜ä¸­æ’å…¥è¯¥ç»„ `key-value` ã€‚å¦‚æœæ’å…¥æ“ä½œå¯¼è‡´å…³é”®å­—æ•°é‡è¶…è¿‡ `capacity` ï¼Œåˆ™åº”è¯¥ **é€å‡º** æœ€ä¹…æœªä½¿ç”¨çš„å…³é”®å­—ã€‚
- å‡½æ•° `get` å’Œ `put` å¿…é¡»ä»¥ `O(1)` çš„å¹³å‡æ—¶é—´å¤æ‚åº¦è¿è¡Œã€‚

### è§£é¢˜æ€è·¯

`LRU` æ˜¯ `Least Recently Used` çš„ç¼©å†™ï¼Œå³æœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼Œæ˜¯ä¸€ç§å¸¸ç”¨çš„ç¼“å­˜æ·˜æ±°ç®—æ³•ï¼Œé€‰æ‹©æœ€ä¹…æœªä½¿ç”¨çš„é¡µé¢äºˆä»¥æ·˜æ±°ã€‚

![](../../../assets/images/2-2-7.png)

å¯ä»¥ç»´æŠ¤ä¸€ä¸ªæœ‰åºå•é“¾è¡¨ï¼Œè¶Šé è¿‘é“¾è¡¨å°¾éƒ¨çš„èŠ‚ç‚¹æ˜¯è¶Šæ—©ä¹‹å‰è®¿é—®çš„ã€‚å¦‚ä¸Šå›¾æ‰€ç¤ºï¼š

- è¦æ’å…¥ B çš„æ—¶å€™ï¼Œå‘ç°ç¼“å­˜ä¸­æœ‰ B ï¼Œè¿™æ—¶éœ€è¦æŠŠ B æ”¾åˆ°é“¾é¦–ï¼Œå› ä¸ºå®ƒè¢«ä½¿ç”¨äº†ï¼›
- è¦æ’å…¥ E çš„æ—¶å€™ï¼Œç¼“å­˜ä¸­æ²¡æœ‰ Eï¼Œç›´æ¥æŠŠ E æ’å…¥é“¾é¦–ï¼›
- è¦æ’å…¥ F çš„æ—¶å€™ï¼Œç¼“å­˜ä¸­æ²¡æœ‰ Fï¼Œå®¹é‡å·²æ»¡ï¼Œéœ€è¦æ·˜æ±°æ‰ A ï¼Œå› ä¸º A æœ€ä¹…æœªè¢«ä½¿ç”¨ï¼›
- è¦æ’å…¥ C çš„æ—¶å€™ï¼Œå‘ç°ç¼“å­˜ä¸­æœ‰ C ï¼Œè¿™æ—¶éœ€è¦æŠŠ C æ”¾åˆ°é“¾é¦–ï¼›
- è¦æ’å…¥ H çš„æ—¶å€™ï¼Œç¼“å­˜ä¸­æ²¡æœ‰ Hï¼Œå®¹é‡å·²æ»¡ï¼Œéœ€è¦æ·˜æ±°æ‰ D ï¼Œå› ä¸º D æœ€ä¹…æœªè¢«ä½¿ç”¨ï¼›

å¯ä»¥å‘ç°ï¼ŒLRU æ›´æ–°å’Œæ’å…¥æ–°èŠ‚ç‚¹éƒ½å‘ç”Ÿåœ¨é“¾é¦–ï¼Œåˆ é™¤æ•°æ®éƒ½å‘ç”Ÿåœ¨é“¾å°¾ã€‚

`LRUCache` ç±»æœ‰ä¸¤ä¸ªæ–¹æ³•ï¼š

- `get` å½“æœ‰ä¸€ä¸ªæ–°çš„æ•°æ®è¢«è®¿é—®æ—¶ï¼š
  - å¦‚æœæ­¤æ•°æ®ä¹‹å‰å·²ç»è¢«ç¼“å­˜åœ¨é“¾è¡¨ä¸­äº†ï¼Œéå†å¾—åˆ°è¿™ä¸ªæ•°æ®å¯¹åº”çš„èŠ‚ç‚¹ï¼Œå¹¶å°†å…¶ä»åŸæ¥çš„ä½ç½®åˆ é™¤ï¼Œç„¶åå†æ’å…¥åˆ°é“¾è¡¨çš„å¤´éƒ¨ï¼Œè¿”å›æ•°æ®çš„å€¼ï¼›
  - å¦‚æœæ­¤æ•°æ®æ²¡æœ‰åœ¨ç¼“å­˜é“¾è¡¨ä¸­ï¼Œåˆ™è¿”å› `-1`ï¼›
- `put` å¾€é“¾è¡¨é‡Œæ–°å¢æ•°æ®æ—¶ï¼š
  - å¦‚æœæ­¤æ•°æ®ä¹‹å‰å·²ç»è¢«ç¼“å­˜åœ¨é“¾è¡¨ä¸­äº†ï¼Œæ›´æ–°æ­¤æ•°æ®çš„å€¼ï¼Œå¹¶å°†å…¶ä»åŸæ¥çš„ä½ç½®åˆ é™¤ï¼Œå†æ’å…¥åˆ°é“¾è¡¨çš„å¤´éƒ¨ï¼›
  - å¦‚æœæ­¤æ•°æ®æ²¡æœ‰åœ¨ç¼“å­˜é“¾è¡¨ä¸­ï¼Œåˆåˆ†ä¸ºä¸¤ç§æƒ…å†µï¼š
    - å¦‚æœæ­¤æ—¶ç¼“å­˜æœªæ»¡ï¼Œåˆ™å°†æ­¤èŠ‚ç‚¹ç›´æ¥æ’å…¥åˆ°é“¾è¡¨çš„å¤´éƒ¨ï¼›
    - å¦‚æœæ­¤æ—¶ç¼“å­˜å·²æ»¡ï¼Œåˆ™é“¾è¡¨å°¾èŠ‚ç‚¹åˆ é™¤ï¼Œå°†æ–°çš„æ•°æ®èŠ‚ç‚¹æ’å…¥é“¾è¡¨çš„å¤´éƒ¨ã€‚

è¿™æ ·å°±ç”¨é“¾è¡¨å®ç°äº†ä¸€ä¸ª LRU ç¼“å­˜ï¼Œå¦‚æœä½¿ç”¨å•å‘é“¾è¡¨å®ç°ï¼Œåˆ™ç¼“å­˜è®¿é—®çš„æ—¶é—´å¤æ‚åº¦ä¸º O(n)ï¼Œå› ä¸ºä¸ç®¡ç¼“å­˜æœ‰æ²¡æœ‰æ»¡ï¼Œéƒ½éœ€è¦éå†ä¸€éé“¾è¡¨ã€‚

å¯ä»¥ç»§ç»­ä¼˜åŒ–è¿™ä¸ªå®ç°æ€è·¯ï¼Œæ¯”å¦‚ä½¿ç”¨åŒå‘é“¾è¡¨ï¼Œå¹¶å¼•å…¥ **å“ˆå¸Œè¡¨ï¼ˆHash tableï¼‰** æ¥è®°å½•æ¯ä¸ªæ•°æ®çš„ä½ç½®ï¼Œå°†ç¼“å­˜è®¿é—®çš„æ—¶é—´å¤æ‚åº¦é™åˆ° `O(1)`ã€‚

### ä»£ç 

```javascript
class Node {
  // @param {number} key
  // @param {number} value
  constructor(key, value) {
    this.key = key;
    this.value = value;
    this.next = null;
    this.prev = null;
  }
}

class LRUCache {
  // @param {number} capacity
  constructor(capacity) {
    this.cap = capacity;
    this.cache = new Map();
    this.head = new Node(0, 0);
    this.tail = new Node(0, 0);
    this.head.next = this.tail;
    this.tail.prev = this.head;
  }

  // @param {number} key
  // @return {number}
  get(key) {
    if (this.cache.has(key)) {
      this.remove(this.cache.get(key));
      this.insert(this.cache.get(key));
      return this.cache.get(key).value;
    }
    return -1;
  }

  // @param {Node} node
  remove(node) {
    const prev = node.prev;
    const next = node.next;
    prev.next = next;
    next.prev = prev;
  }

  // @param {Node} node
  insert(node) {
    const next = this.head.next;
    this.head.next = node;
    next.prev = node;
    node.prev = this.head;
    node.next = next;
  }

  // @param {number} key
  // @param {number} value
  // @return {void}
  put(key, value) {
    if (this.cache.has(key)) {
      this.remove(this.cache.get(key));
    }
    this.cache.set(key, new Node(key, value));
    this.insert(this.cache.get(key));
    if (this.cache.size > this.cap) {
      const old = this.tail.prev;
      this.remove(old);
      this.cache.delete(old.key);
    }
  }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
```
