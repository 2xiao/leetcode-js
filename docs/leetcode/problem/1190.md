# [1190. Reverse Substrings Between Each Pair of Parentheses](https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/)

:tangerine: <font color=#ffb800>Medium</font>&emsp; ðŸ”–&ensp; [`æ ˆ`](../solution/stack.md) [`å­—ç¬¦ä¸²`](../solution/string.md)

### é¢˜ç›®

You are given a stringÂ `s`Â that consists of lower case English letters and brackets.

Reverse the stringsÂ in eachÂ pair of matching parentheses, startingÂ from the innermost one.

Your result shouldÂ **not**Â contain any brackets.

**Example 1:**

::: tip
Input: s = "(abcd)"
Output: "dcba"
:::

**Example 2:**

::: tip
Input: s = "(u(love)i)"
Output: "iloveu"
:::

Explanation:Â The substring "love" is reversed first, then the whole string is reversed.

**Example 3:**

::: tip
Input: s = "(ed(et(oc))el)"
Output: "leetcode"
:::

Explanation:Â First, we reverse the substring "oc", then "etco", and finally, the whole string.

**Example 4:**

::: tip
Input: s = "a(bcdefghijkl(mno)p)q"
Output: "apmnolkjihgfedcbq"
:::

**Constraints:**

- `0 <= s.length <= 2000`
- `s`Â only contains lower case English characters and parentheses.
- It's guaranteed that all parentheses are balanced.

### é¢˜ç›®å¤§æ„

ç»™å‡ºä¸€ä¸ªå­—ç¬¦ä¸² Â `s`ï¼ˆä»…å«æœ‰å°å†™è‹±æ–‡å­—æ¯å’Œæ‹¬å·ï¼‰ã€‚è¯·ä½ æŒ‰ç…§ä»Žæ‹¬å·å†…åˆ°å¤–çš„é¡ºåºï¼Œé€å±‚åè½¬æ¯å¯¹åŒ¹é…æ‹¬å·ä¸­çš„å­—ç¬¦ä¸²ï¼Œå¹¶è¿”å›žæœ€ç»ˆçš„ç»“æžœã€‚æ³¨æ„ï¼Œæ‚¨çš„ç»“æžœä¸­ **ä¸åº”** åŒ…å«ä»»ä½•æ‹¬å·ã€‚

### è§£é¢˜æ€è·¯

- æœ¬é¢˜æœ€å®¹æ˜“æƒ³åˆ°çš„æ€è·¯æ˜¯åˆ©ç”¨æ ˆå°†æ¯å¯¹æ‹¬å·é‡Œé¢çš„å­—ç¬¦ä¸²å…¥æ ˆï¼Œå½“é‡åˆ° `")"` æ‹¬å·æ—¶å‡ºæ ˆå¹¶é€†åºã€‚ç”±äºŽç”¨åˆ°äº†æ ˆçš„æ•°æ®ç»“æž„ï¼Œå¤šå±‚æ‹¬å·åµŒå¥—çš„é—®é¢˜ä¹Ÿä¸ç”¨æ‹…å¿ƒã€‚è¿™ç§è¾¹å…¥æ ˆå‡ºæ ˆï¼Œé€†åºå­—ç¬¦ä¸²çš„æ–¹æ³•ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ `O(n^2)`ï¼Œæœ‰æ²¡æœ‰å¯èƒ½è¿›ä¸€æ­¥é™ä½Žæ—¶é—´å¤æ‚åº¦å‘¢ï¼Ÿ
- ä¸Šè¿°è§£æ³•ä¸­ï¼Œå­˜åœ¨é‡å¤éåŽ†çš„æƒ…å†µã€‚æ‰«æåŽŸå­—ç¬¦ä¸²çš„æ—¶å€™ï¼Œå…¥æ ˆå‡ºæ ˆå·²ç»æ‰«æäº†ä¸€æ¬¡ï¼Œåœ¨ `")"` æ‹¬å·å‡ºæ ˆæ—¶ï¼Œé€†åºåˆä¼šæ‰«ä¸€éå·²ç»å…¥æ ˆçš„å­—ç¬¦ä¸²ã€‚è¿™éƒ¨åˆ†é‡å¤éåŽ†çš„è¿‡ç¨‹å¯ä»¥ä¼˜åŒ–æŽ‰ã€‚ç¬¬ä¸€æ¬¡å¾ªçŽ¯å…ˆæ ‡è®°å‡ºé€†åºåŒºé—´ã€‚ä¾‹å¦‚é‡åˆ° `"("` çš„æ—¶å€™ï¼Œå…¥æ ˆå¹¶è®°å½•ä¸‹å®ƒçš„ä¸‹æ ‡ï¼Œå½“é‡åˆ° `")"` çš„æ—¶å€™ï¼Œæ„å‘³ç€è¿™ä¸€å¯¹æ‹¬å·åŒ¹é…ä¸Šäº†ï¼Œæ‰€ä»¥å°† `")"` çš„ä¸‹æ ‡å’Œä¹‹å‰å…¥æ ˆ `"("` çš„ä¸‹æ ‡äº¤æ¢ã€‚æ­¤æ¬¡éåŽ†å°†é€†åºåŒºé—´æ ‡è®°å‡ºæ¥äº†ã€‚å†éåŽ†ä¸€æ¬¡ï¼Œæ ¹æ®é€†åºåŒºé—´é€†åºå­—ç¬¦ä¸²ã€‚ä¸åœ¨é€†åºåŒºé—´çš„å­—ç¬¦ä¸²æ­£å¸¸ appendã€‚å¦‚æžœåœ¨é€†åºåŒºé—´å†…çš„ï¼Œé€†åºéåŽ†ï¼Œæ·»åŠ åˆ°æœ€ç»ˆç»“æžœå­—ç¬¦ä¸²ä¸­ã€‚è¿™æ ·åšï¼Œæ—¶é—´å¤æ‚åº¦ä»…ä¸º `O(n)`ã€‚å…·ä½“å®žçŽ°è§ä¸‹é¢ä»£ç ã€‚

### ä»£ç 

```go
package leetcode

func reverseParentheses(s string) string {
	pair, stack := make([]int, len(s)), []int{}
	for i, b := range s {
		if b == '(' {
			stack = append(stack, i)
		} else if b == ')' {
			j := stack[len(stack)-1]
			stack = stack[:len(stack)-1]
			pair[i], pair[j] = j, i
		}
	}
	res := []byte{}
	for i, step := 0, 1; i < len(s); i += step {
		if s[i] == '(' || s[i] == ')' {
			i = pair[i]
			step = -step
		} else {
			res = append(res, s[i])
		}
	}
	return string(res)
}
```
