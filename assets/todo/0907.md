# [907. Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ ˆ`](../solution/stack.md) [`æ•°ç»„`](../solution/array.md) [`åŠ¨æ€è§„åˆ’`](../solution/dynamic-programming.md) [`å•è°ƒæ ˆ`](../solution/monotonic-stack.md)

## é¢˜ç›®

Given an array of integers A, find the sum of min(B), where B ranges over every (contiguous) subarray of A.

Since the answer may be large, return the answer modulo 10^9 + 7.

**Example 1**:

```

Input: [3,1,2,4]
Output: 17
Explanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4].
Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.  Sum is 17.

```

**Note**:

1. 1 <= A.length <= 30000
2. 1 <= A[i] <= 30000

## é¢˜ç›®å¤§æ„

ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ Aï¼Œæ‰¾åˆ° min(B) çš„æ€»å’Œï¼Œå…¶ä¸­ B çš„èŒƒå›´ä¸º A çš„æ¯ä¸ªï¼ˆè¿ç»­ï¼‰å­æ•°ç»„ã€‚

ç”±äºç­”æ¡ˆå¯èƒ½å¾ˆå¤§ï¼Œå› æ­¤è¿”å›ç­”æ¡ˆæ¨¡ 10^9 + 7ã€‚

## è§£é¢˜æ€è·¯

- é¦–å…ˆæƒ³åˆ°çš„æ˜¯æš´åŠ›è§£æ³•ï¼Œç”¨ä¸¤å±‚å¾ªç¯ï¼Œåˆ†åˆ«æšä¸¾æ¯ä¸ªè¿ç»­çš„å­åŒºé—´ï¼ŒåŒºé—´å†…ç”¨ä¸€ä¸ªå…ƒç´ è®°å½•åŒºé—´å†…æœ€å°å€¼ã€‚æ¯å½“åŒºé—´èµ·ç‚¹å‘ç”Ÿå˜åŒ–çš„æ—¶å€™ï¼Œæœ€ç»ˆç»“æœéƒ½åŠ ä¸Šä¸Šæ¬¡éå†åŒºé—´æ‰¾å‡ºçš„æœ€å°å€¼ã€‚å½“æ•´ä¸ªæ•°ç»„éƒ½æ‰«å®Œä¸€éä»¥åï¼Œæœ€ç»ˆç»“æœæ¨¡ä¸Š 10^9+7ã€‚
- ä¸Šé¢æš´åŠ›è§£æ³•æ—¶é—´å¤æ‚åº¦ç‰¹åˆ«å¤§ï¼Œå› ä¸ºæŸä¸ªåŒºé—´çš„æœ€å°å€¼å¯èƒ½æ˜¯å¾ˆå¤šåŒºé—´çš„æœ€å°å€¼ï¼Œä½†æ˜¯æˆ‘ä»¬æš´åŠ›æšä¸¾æ‰€æœ‰åŒºé—´ï¼Œå¯¼è‡´è¦éå†çš„åŒºé—´ç‰¹åˆ«å¤šã€‚ä¼˜åŒ–ç‚¹å°±åœ¨å¦‚ä½•å‡å°‘éå†çš„åŒºé—´ã€‚ç¬¬äºŒç§æ€è·¯æ˜¯ç”¨ 2 ä¸ªå•è°ƒæ ˆã€‚æƒ³å¾—åˆ°æ€è·¯æ˜¯ `res = sum(A[i] * f(i))`ï¼Œå…¶ä¸­ f(i) æ˜¯å­åŒºé—´çš„æ•°ï¼ŒA[i] æ˜¯è¿™ä¸ªå­åŒºé—´å†…çš„æœ€å°å€¼ã€‚ä¸ºäº†å¾—åˆ° f(i) æˆ‘ä»¬éœ€è¦æ‰¾åˆ° left[i] å’Œ right[i]ï¼Œleft[i] æ˜¯ A[i] å·¦è¾¹ä¸¥æ ¼å¤§äº A[i](> å…³ç³»)çš„åŒºé—´é•¿åº¦ã€‚right[i] æ˜¯ A[i] å³è¾¹éä¸¥æ ¼å¤§äº(>= å…³ç³»)çš„åŒºé—´é•¿åº¦ã€‚left[i] + 1 ç­‰äºä»¥ A[i] ç»“å°¾çš„å­æ•°ç»„æ•°ç›®ï¼ŒA[i] æ˜¯å”¯ä¸€çš„æœ€å°å€¼ï¼›right[i] + 1 ç­‰äºä»¥ A[i] å¼€å§‹çš„å­æ•°ç»„æ•°ç›®ï¼ŒA[i] æ˜¯ç¬¬ä¸€ä¸ªæœ€å°å€¼ã€‚äºæ˜¯æœ‰ `f(i) = (left[i] + 1) * (right[i] + 1)`ã€‚ä¾‹å¦‚å¯¹äº [3,1,4,2,5,3,3,1] ä¸­çš„â€œ2â€ï¼Œæˆ‘ä»¬æ‰¾åˆ°çš„ä¸²å°±ä¸º[4,2,5,3,3]ï¼Œ2 å·¦è¾¹æœ‰ 1 ä¸ªæ•°æ¯” 2 å¤§ä¸”ç›¸é‚»ï¼Œ2 å³è¾¹æœ‰ 3 ä¸ªæ•°æ¯” 2 å¤§ä¸”ç›¸é‚»ï¼Œæ‰€ä»¥ 2 ä½œä¸ºæœ€å°å€¼çš„ä¸²æœ‰ 2 _ 4 = 8 ç§ã€‚ç”¨æ’åˆ—ç»„åˆçš„æ€ç»´ä¹Ÿèƒ½åˆ†æå‡ºæ¥ï¼Œ2 çš„å·¦è¾¹å¯ä»¥æ‹¿ 0ï¼Œ1ï¼Œâ€¦â€¦ m ä¸ªï¼Œæ€»å…± (m + 1) ç§ï¼ŒåŒç†å³è¾¹å¯ä»¥æ‹¿ 0ï¼Œ1ï¼Œâ€¦â€¦ n ä¸ªï¼Œæ€»å…± (n + 1) ç§ï¼Œæ‰€ä»¥æ€»å…± (m + 1)(n + 1)ç§ã€‚åªè¦è®¡ç®—å‡ºäº† f(i)ï¼Œè¿™ä¸ªé¢˜ç›®å°±å¥½åŠäº†ã€‚ä»¥ [3,1,2,4] ä¸ºä¾‹ï¼Œleft[i] + 1 = [1,2,1,1]ï¼Œright[i] + 1 = [1,3,2,1]ï¼Œå¯¹åº” i ä½çš„ä¹˜ç§¯æ˜¯ f[i] = [1 _ 1ï¼Œ2 _ 3ï¼Œ1 _ 2ï¼Œ1 _ 1] = [1ï¼Œ6ï¼Œ2ï¼Œ1]ï¼Œæœ€ç»ˆè¦æ±‚çš„æœ€å°å€¼çš„æ€»å’Œ res = 3 _ 1 + 1 _ 6 + 2 _ 2 + 4 \* 1 = 17ã€‚
- **çœ‹åˆ°è¿™ç§ mod1e9+7 çš„é¢˜ç›®ï¼Œé¦–å…ˆè¦æƒ³åˆ°çš„å°±æ˜¯ dp**ã€‚æœ€ç»ˆçš„ä¼˜åŒ–è§£å³æ˜¯åˆ©ç”¨ DP + å•è°ƒæ ˆã€‚å•è°ƒæ ˆç»´æŠ¤æ•°ç»„ä¸­çš„å€¼é€æ¸é€’å¢çš„å¯¹åº”ä¸‹æ ‡åºåˆ—ã€‚å®šä¹‰ `dp[i + 1]` ä»£è¡¨ä»¥ A[i] ç»“å°¾çš„å­åŒºé—´å†…æœ€å°å€¼çš„æ€»å’Œã€‚çŠ¶æ€è½¬ç§»æ–¹ç¨‹æ˜¯ `dp[i + 1] = dp[prev + 1] + (i - prev) * A[i]`ï¼Œå…¶ä¸­ prev æ˜¯æ¯” A[i] å°çš„å‰ä¸€ä¸ªæ•°ï¼Œç”±äºæˆ‘ä»¬ç»´æŠ¤äº†ä¸€ä¸ªå•è°ƒæ ˆï¼Œæ‰€ä»¥ prev å°±æ˜¯æ ˆé¡¶å…ƒç´ ã€‚(i - prev) _ A[i] ä»£è¡¨åœ¨è¿˜æ²¡æœ‰å‡ºç° prev ä¹‹å‰ï¼Œè¿™äº›åŒºé—´å†…éƒ½æ˜¯ A[i] æœ€å°ï¼Œé‚£ä¹ˆè¿™äº›åŒºé—´æœ‰ i - prev ä¸ªï¼Œæ‰€ä»¥æœ€å°å€¼æ€»å’Œåº”è¯¥æ˜¯ (i - prev) _ A[i]ã€‚å†åŠ ä¸Š dp[prev + 1] å°±æ˜¯ dp[i + 1] çš„æœ€å°å€¼æ€»å’Œäº†ã€‚ä»¥ [3, 1, 2, 4, 3] ä¸ºä¾‹ï¼Œå½“ i = 4, æ‰€æœ‰ä»¥ A[4] ä¸ºç»“å°¾çš„å­åŒºé—´æœ‰:

      [3]
      [4, 3]
      [2, 4, 3]
      [1, 2, 4, 3]
      [3, 1, 2, 4, 3]

  åœ¨è¿™ç§æƒ…å†µä¸‹, stack.peek() = 2, A[2] = 2ã€‚å‰ä¸¤ä¸ªå­åŒºé—´ [3] and [4, 3], æœ€å°å€¼çš„æ€»å’Œ = (i - stack.peek()) _ A[i] = 6ã€‚å 3 ä¸ªå­åŒºé—´æ˜¯ [2, 4, 3], [1, 2, 4, 3] å’Œ [3, 1, 2, 4, 3], å®ƒä»¬éƒ½åŒ…å« 2ï¼Œ2 æ˜¯æ¯” 3 å°çš„å‰ä¸€ä¸ªæ•°ï¼Œæ‰€ä»¥ dp[i + 1] = dp[stack.peek() + 1] = dp[2 + 1] = dp[3] = dp[2 + 1]ã€‚å³éœ€è¦æ±‚ i = 2 çš„æ—¶å€™ dp[i + 1] çš„å€¼ã€‚ç»§ç»­é€’æ¨ï¼Œæ¯” 2 å°çš„å‰ä¸€ä¸ªå€¼æ˜¯ 1ï¼ŒA[1] = 1ã€‚dp[3] = dp[1 + 1] + (2 - 1) _ A[2]= dp[2] + 2ã€‚dp[2] = dp[1 + 1]ï¼Œå½“ i = 1 çš„æ—¶å€™ï¼Œprev = -1ï¼Œå³æ²¡æœ‰äººæ¯” A[1] æ›´å°äº†ï¼Œæ‰€ä»¥ dp[2] = dp[1 + 1] = dp[-1 + 1] + (1 - (-1)) _ A[1] = 0 + 2 _ 1 = 2ã€‚è¿­ä»£å›å»ï¼Œdp[3] = dp[2] + 2 = 2 + 2 = 4ã€‚dp[stack.peek() + 1] = dp[2 + 1] = dp[3] = 4ã€‚æ‰€ä»¥ dp[i + 1] = 4 + 6 = 10ã€‚

- ä¸è¿™ä¸€é¢˜ç›¸ä¼¼çš„è§£é¢˜æ€è·¯çš„é¢˜ç›®æœ‰ç¬¬ 828 é¢˜ï¼Œç¬¬ 891 é¢˜ã€‚

## ä»£ç 

```javascript

package leetcode

// è§£æ³•ä¸€ æœ€å¿«çš„è§£æ˜¯ DP + å•è°ƒæ ˆ
func sumSubarrayMins(A []int) int {
	stack, dp, res, mod := []int{}, make([]int, len(A)+1), 0, 1000000007
	stack = append(stack, -1)

	for i := 0; i < len(A); i++ {
		for stack[len(stack)-1] != -1 && A[i] <= A[stack[len(stack)-1]] {
			stack = stack[:len(stack)-1]
		}
		dp[i+1] = (dp[stack[len(stack)-1]+1] + (i-stack[len(stack)-1])*A[i]) % mod
		stack = append(stack, i)
		res += dp[i+1]
		res %= mod
	}
	return res
}

type pair struct {
	val   int
	count int
}

// è§£æ³•äºŒ ç”¨ä¸¤ä¸ªå•è°ƒæ ˆ
func sumSubarrayMins1(A []int) int {
	res, n, mod := 0, len(A), 1000000007
	lefts, rights, leftStack, rightStack := make([]int, n), make([]int, n), []*pair{}, []*pair{}
	for i := 0; i < n; i++ {
		count := 1
		for len(leftStack) != 0 && leftStack[len(leftStack)-1].val > A[i] {
			count += leftStack[len(leftStack)-1].count
			leftStack = leftStack[:len(leftStack)-1]
		}
		leftStack = append(leftStack, &pair{val: A[i], count: count})
		lefts[i] = count
	}

	for i := n - 1; i >= 0; i-- {
		count := 1
		for len(rightStack) != 0 && rightStack[len(rightStack)-1].val >= A[i] {
			count += rightStack[len(rightStack)-1].count
			rightStack = rightStack[:len(rightStack)-1]
		}
		rightStack = append(rightStack, &pair{val: A[i], count: count})
		rights[i] = count
	}

	for i := 0; i < n; i++ {
		res = (res + A[i]*lefts[i]*rights[i]) % mod
	}
	return res
}

// è§£æ³•ä¸‰ æš´åŠ›è§£æ³•ï¼Œä¸­é—´å¾ˆå¤šé‡å¤åˆ¤æ–­å­æ•°ç»„çš„æƒ…å†µ
func sumSubarrayMins2(A []int) int {
	res, mod := 0, 1000000007
	for i := 0; i < len(A); i++ {
		stack := []int{}
		stack = append(stack, A[i])
		for j := i; j < len(A); j++ {
			if stack[len(stack)-1] >= A[j] {
				stack = stack[:len(stack)-1]
				stack = append(stack, A[j])
			}
			res += stack[len(stack)-1]
		}
	}
	return res % mod
}

```
