# [5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/)

:tangerine: <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`å­—ç¬¦ä¸²`](../solution/string.md) [`åŠ¨æ€è§„åˆ’`](../solution/dynamic-programming.md)

### é¢˜ç›®

Given a stringÂ `s`, returnÂ *the longest palindromic substring*Â inÂ `s`.

**Example 1:**

::: tip

Input: `s = "babad"`

Output: `"bab"`

Note: "aba" is also a valid answer.

:::

**Example 2:**

::: tip

Input: `s = "cbbd"`

Output: `"bb"`

:::

**Example 3:**

::: tip

Input: `s = "a"`

Output: `"a"`

:::

**Example 4:**

::: tip

Input: `s = "ac"`

Output: `"a"`

:::

**Constraints:**

- `1 <= s.length <= 1000`
- `s`Â consist of only digits and English letters (lower-case and/or upper-case),

### é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² `s`ï¼Œæ‰¾åˆ° `s` ä¸­æœ€é•¿çš„å›æ–‡å­ä¸²ã€‚

### è§£é¢˜æ€è·¯

- æ­¤é¢˜éå¸¸ç»å…¸ï¼Œå¹¶ä¸”æœ‰å¤šç§è§£æ³•ã€‚
- è§£æ³•ä¸€ï¼ŒåŠ¨æ€è§„åˆ’ã€‚å®šä¹‰ `dp[i][j]` è¡¨ç¤ºä»å­—ç¬¦ä¸²ç¬¬ `i` ä¸ªå­—ç¬¦åˆ°ç¬¬ `j` ä¸ªå­—ç¬¦è¿™ä¸€æ®µå­ä¸²æ˜¯å¦æ˜¯å›æ–‡ä¸²ã€‚ç”±å›æ–‡ä¸²çš„æ€§è´¨å¯ä»¥å¾—çŸ¥ï¼Œå›æ–‡ä¸²å»æ‰ä¸€å¤´ä¸€å°¾ç›¸åŒçš„å­—ç¬¦ä»¥åï¼Œå‰©ä¸‹çš„è¿˜æ˜¯å›æ–‡ä¸²ã€‚æ‰€ä»¥çŠ¶æ€è½¬ç§»æ–¹ç¨‹æ˜¯ `dp[i][j] = (s[i] == s[j]) && ((j-i < 3) || dp[i+1][j-1])`ï¼Œæ³¨æ„ç‰¹æ®Šçš„æƒ…å†µï¼Œ`j - i == 1` çš„æ—¶å€™ï¼Œå³åªæœ‰ 2 ä¸ªå­—ç¬¦çš„æƒ…å†µï¼Œåªéœ€è¦åˆ¤æ–­è¿™ 2 ä¸ªå­—ç¬¦æ˜¯å¦ç›¸åŒå³å¯ã€‚`j - i == 2` çš„æ—¶å€™ï¼Œå³åªæœ‰ 3 ä¸ªå­—ç¬¦çš„æƒ…å†µï¼Œåªéœ€è¦åˆ¤æ–­é™¤å»ä¸­å¿ƒä»¥å¤–å¯¹ç§°çš„ 2 ä¸ªå­—ç¬¦æ˜¯å¦ç›¸ç­‰ã€‚æ¯æ¬¡å¾ªç¯åŠ¨æ€ç»´æŠ¤ä¿å­˜æœ€é•¿å›æ–‡ä¸²å³å¯ã€‚æ—¶é—´å¤æ‚åº¦ O(n^2)ï¼Œç©ºé—´å¤æ‚åº¦ O(n^2)ã€‚
- è§£æ³•äºŒï¼Œä¸­å¿ƒæ‰©æ•£æ³•ã€‚åŠ¨æ€è§„åˆ’çš„æ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬å°†ä»»æ„èµ·å§‹ï¼Œç»ˆæ­¢èŒƒå›´å†…çš„å­—ç¬¦ä¸²éƒ½åˆ¤æ–­äº†ä¸€éã€‚å…¶å®æ²¡æœ‰è¿™ä¸ªå¿…è¦ï¼Œå¦‚æœä¸æ˜¯æœ€é•¿å›æ–‡ä¸²ï¼Œæ— éœ€åˆ¤æ–­å¹¶ä¿å­˜ç»“æœã€‚æ‰€ä»¥åŠ¨æ€è§„åˆ’çš„æ–¹æ³•åœ¨ç©ºé—´å¤æ‚åº¦ä¸Šè¿˜æœ‰ä¼˜åŒ–ç©ºé—´ã€‚åˆ¤æ–­å›æ–‡æœ‰ä¸€ä¸ªæ ¸å¿ƒé—®é¢˜æ˜¯æ‰¾åˆ°â€œè½´å¿ƒâ€ã€‚å¦‚æœé•¿åº¦æ˜¯å¶æ•°ï¼Œé‚£ä¹ˆè½´å¿ƒæ˜¯ä¸­å¿ƒè™šæ‹Ÿçš„ï¼Œå¦‚æœé•¿åº¦æ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆè½´å¿ƒæ­£å¥½æ˜¯æ­£ä¸­å¿ƒçš„é‚£ä¸ªå­—æ¯ã€‚ä¸­å¿ƒæ‰©æ•£æ³•çš„æ€æƒ³æ˜¯æšä¸¾æ¯ä¸ªè½´å¿ƒçš„ä½ç½®ã€‚ç„¶ååšä¸¤æ¬¡å‡è®¾ï¼Œå‡è®¾æœ€é•¿å›æ–‡ä¸²æ˜¯å¶æ•°ï¼Œé‚£ä¹ˆä»¥è™šæ‹Ÿä¸­å¿ƒå¾€ 2 è¾¹æ‰©æ•£ï¼›å‡è®¾æœ€é•¿å›æ–‡ä¸²æ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆä»¥æ­£ä¸­å¿ƒçš„å­—ç¬¦å¾€ 2 è¾¹æ‰©æ•£ã€‚æ‰©æ•£çš„è¿‡ç¨‹å°±æ˜¯å¯¹ç§°åˆ¤æ–­ä¸¤è¾¹å­—ç¬¦æ˜¯å¦ç›¸ç­‰çš„è¿‡ç¨‹ã€‚è¿™ä¸ªæ–¹æ³•æ—¶é—´å¤æ‚åº¦å’ŒåŠ¨æ€è§„åˆ’æ˜¯ä¸€æ ·çš„ï¼Œä½†æ˜¯ç©ºé—´å¤æ‚åº¦é™ä½äº†ã€‚æ—¶é—´å¤æ‚åº¦ O(n^2)ï¼Œç©ºé—´å¤æ‚åº¦ O(1)ã€‚
- è§£æ³•ä¸‰ï¼Œæ»‘åŠ¨çª—å£ã€‚è¿™ä¸ªå†™æ³•å…¶å®å°±æ˜¯ä¸­å¿ƒæ‰©æ•£æ³•å˜äº†ä¸€ä¸ªå†™æ³•ã€‚ä¸­å¿ƒæ‰©æ•£æ˜¯ä¾æ¬¡æšä¸¾æ¯ä¸€ä¸ªè½´å¿ƒã€‚æ»‘åŠ¨çª—å£çš„æ–¹æ³•ç¨å¾®ä¼˜åŒ–äº†ä¸€ç‚¹ï¼Œæœ‰äº›è½´å¿ƒä¸¤è¾¹å­—ç¬¦ä¸ç›¸ç­‰ï¼Œä¸‹æ¬¡å°±ä¸ä¼šæšä¸¾è¿™äº›ä¸å¯èƒ½å½¢æˆå›æ–‡å­ä¸²çš„è½´å¿ƒäº†ã€‚ä¸è¿‡è¿™ç‚¹ä¼˜åŒ–å¹¶æ²¡æœ‰ä¼˜åŒ–æ—¶é—´å¤æ‚åº¦ï¼Œæ—¶é—´å¤æ‚åº¦ O(n^2)ï¼Œç©ºé—´å¤æ‚åº¦ O(1)ã€‚
- è§£æ³•å››ï¼Œé©¬æ‹‰è½¦ç®—æ³•ã€‚è¿™ä¸ªç®—æ³•æ˜¯æœ¬é¢˜çš„æœ€ä¼˜è§£ï¼Œä¹Ÿæ˜¯æœ€å¤æ‚çš„è§£æ³•ã€‚æ—¶é—´å¤æ‚åº¦ O(n)ï¼Œç©ºé—´å¤æ‚åº¦ O(n)ã€‚ä¸­å¿ƒæ‰©æ•£æ³•æœ‰ 2 å¤„æœ‰é‡å¤åˆ¤æ–­ï¼Œç¬¬ä¸€å¤„æ˜¯æ¯æ¬¡éƒ½å¾€ä¸¤è¾¹æ‰©æ•£ï¼Œä¸åŒä¸­å¿ƒæ‰©æ•£å¤šæ¬¡ï¼Œå®é™…ä¸Šæœ‰å¾ˆå¤šé‡å¤åˆ¤æ–­çš„å­—ç¬¦ï¼Œèƒ½å¦ä¸é‡å¤åˆ¤æ–­ï¼Ÿç¬¬äºŒå¤„ï¼Œä¸­å¿ƒèƒ½å¦è·³è·ƒé€‰æ‹©ï¼Œä¸æ˜¯æ¯æ¬¡éƒ½æšä¸¾ï¼Œæ˜¯å¦å¯ä»¥åˆ©ç”¨å‰ä¸€æ¬¡çš„ä¿¡æ¯ï¼Œè·³è·ƒé€‰æ‹©ä¸‹ä¸€æ¬¡çš„ä¸­å¿ƒï¼Ÿé©¬æ‹‰è½¦ç®—æ³•é’ˆå¯¹é‡å¤åˆ¤æ–­çš„é—®é¢˜åšäº†ä¼˜åŒ–ï¼Œå¢åŠ äº†ä¸€ä¸ªè¾…åŠ©æ•°ç»„ï¼Œå°†æ—¶é—´å¤æ‚åº¦ä» O(n^2) ä¼˜åŒ–åˆ°äº† O(n)ï¼Œç©ºé—´æ¢äº†æ—¶é—´ï¼Œç©ºé—´å¤æ‚åº¦å¢åŠ åˆ° O(n)ã€‚

  ![https://img.halfrost.com/Leetcode/leetcode_5_1.png](https://img.halfrost.com/Leetcode/leetcode_5_1.png)

- é¦–å…ˆæ˜¯é¢„å¤„ç†ï¼Œå‘å­—ç¬¦ä¸²çš„å¤´å°¾ä»¥åŠæ¯ä¸¤ä¸ªå­—ç¬¦ä¸­é—´æ·»åŠ ä¸€ä¸ªç‰¹æ®Šå­—ç¬¦ `#`ï¼Œæ¯”å¦‚å­—ç¬¦ä¸² `aaba` å¤„ç†åä¼šå˜æˆ `#a#a#b#a#`ã€‚é‚£ä¹ˆåŸå…ˆé•¿åº¦ä¸ºå¶æ•°çš„å›æ–‡å­—ç¬¦ä¸² `aa` ä¼šå˜æˆé•¿åº¦ä¸ºå¥‡æ•°çš„å›æ–‡å­—ç¬¦ä¸² `#a#a#`ï¼Œè€Œé•¿åº¦ä¸ºå¥‡æ•°çš„å›æ–‡å­—ç¬¦ä¸² `aba` ä¼šå˜æˆé•¿åº¦ä»ç„¶ä¸ºå¥‡æ•°çš„å›æ–‡å­—ç¬¦ä¸² `#a#b#a#`ï¼Œç»è¿‡é¢„å¤„ç†ä»¥åï¼Œéƒ½ä¼šå˜æˆé•¿åº¦ä¸ºå¥‡æ•°çš„å­—ç¬¦ä¸²ã€‚**æ³¨æ„è¿™é‡Œçš„ç‰¹æ®Šå­—ç¬¦ä¸éœ€è¦æ˜¯æ²¡æœ‰å‡ºç°è¿‡çš„å­—æ¯ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ä»»ä½•ä¸€ä¸ªå­—ç¬¦æ¥ä½œä¸ºè¿™ä¸ªç‰¹æ®Šå­—ç¬¦ã€‚**è¿™æ˜¯å› ä¸ºï¼Œå½“æˆ‘ä»¬åªè€ƒè™‘é•¿åº¦ä¸ºå¥‡æ•°çš„å›æ–‡å­—ç¬¦ä¸²æ—¶ï¼Œæ¯æ¬¡æˆ‘ä»¬æ¯”è¾ƒçš„ä¸¤ä¸ªå­—ç¬¦å¥‡å¶æ€§ä¸€å®šæ˜¯ç›¸åŒçš„ï¼Œæ‰€ä»¥åŸæ¥å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦ä¸ä¼šä¸æ’å…¥çš„ç‰¹æ®Šå­—ç¬¦äº’ç›¸æ¯”è¾ƒï¼Œä¸ä¼šå› æ­¤äº§ç”Ÿé—®é¢˜ã€‚**é¢„å¤„ç†ä»¥åï¼Œä»¥æŸä¸ªä¸­å¿ƒæ‰©æ•£çš„æ­¥æ•°å’Œå®é™…å­—ç¬¦ä¸²é•¿åº¦æ˜¯ç›¸ç­‰çš„ã€‚**å› ä¸ºåŠå¾„é‡Œé¢åŒ…å«äº†æ’å…¥çš„ç‰¹æ®Šå­—ç¬¦ï¼Œåˆç”±äºå·¦å³å¯¹ç§°çš„æ€§è´¨ï¼Œæ‰€ä»¥æ‰©æ•£åŠå¾„å°±ç­‰äºåŸæ¥å›æ–‡å­ä¸²çš„é•¿åº¦ã€‚

  ![https://img.halfrost.com/Leetcode/leetcode_5_2.png](https://img.halfrost.com/Leetcode/leetcode_5_2.png)

- æ ¸å¿ƒéƒ¨åˆ†æ˜¯å¦‚ä½•é€šè¿‡å·¦è¾¹å·²ç»æ‰«æè¿‡çš„æ•°æ®æ¨å‡ºå³è¾¹ä¸‹ä¸€æ¬¡è¦æ‰©æ•£çš„ä¸­å¿ƒã€‚è¿™é‡Œå®šä¹‰ä¸‹ä¸€æ¬¡è¦æ‰©æ•£çš„ä¸­å¿ƒä¸‹æ ‡æ˜¯ `i`ã€‚å¦‚æœ `i` æ¯” `maxRight` è¦å°ï¼Œåªèƒ½ç»§ç»­ä¸­å¿ƒæ‰©æ•£ã€‚å¦‚æœ `i` æ¯” `maxRight` å¤§ï¼Œè¿™æ˜¯åˆåˆ†ä¸º 3 ç§æƒ…å†µã€‚ä¸‰ç§æƒ…å†µè§ä¸Šå›¾ã€‚å°†ä¸Šè¿° 3 ç§æƒ…å†µæ€»ç»“èµ·æ¥ï¼Œå°±æ˜¯ ï¼š`dp[i] = min(maxRight-i, dp[2*center-i])`ï¼Œå…¶ä¸­ï¼Œ`mirror` ç›¸å¯¹äº `center` æ˜¯å’Œ `i` ä¸­å¿ƒå¯¹ç§°çš„ï¼Œæ‰€ä»¥å®ƒçš„ä¸‹æ ‡å¯ä»¥è®¡ç®—å‡ºæ¥æ˜¯ `2*center-i`ã€‚æ›´æ–°å®Œ `dp[i]` ä»¥åï¼Œå°±è¦è¿›è¡Œä¸­å¿ƒæ‰©æ•£äº†ã€‚ä¸­å¿ƒæ‰©æ•£ä»¥ååŠ¨æ€ç»´æŠ¤æœ€é•¿å›æ–‡ä¸²å¹¶ç›¸åº”çš„æ›´æ–° `center`ï¼Œ`maxRight`ï¼Œå¹¶ä¸”è®°å½•ä¸‹åŸå§‹å­—ç¬¦ä¸²çš„èµ·å§‹ä½ç½® `begin` å’Œ `maxLen`ã€‚

### ä»£ç 

```javascript
// TODO: add code
package leetcode

// è§£æ³•ä¸€ Manacher's algorithmï¼Œæ—¶é—´å¤æ‚åº¦ O(n)ï¼Œç©ºé—´å¤æ‚åº¦ O(n)
func longestPalindrome(s string) string {
	if len(s) < 2 {
		return s
	}
	newS := make([]rune, 0)
	newS = append(newS, '#')
	for _, c := range s {
		newS = append(newS, c)
		newS = append(newS, '#')
	}
	// dp[i]:    ä»¥é¢„å¤„ç†å­—ç¬¦ä¸²ä¸‹æ ‡ i ä¸ºä¸­å¿ƒçš„å›æ–‡åŠå¾„(å¥‡æ•°é•¿åº¦æ—¶ä¸åŒ…æ‹¬ä¸­å¿ƒ)
	// maxRight: é€šè¿‡ä¸­å¿ƒæ‰©æ•£çš„æ–¹å¼èƒ½å¤Ÿæ‰©æ•£çš„æœ€å³è¾¹çš„ä¸‹æ ‡
	// center:   ä¸ maxRight å¯¹åº”çš„ä¸­å¿ƒå­—ç¬¦çš„ä¸‹æ ‡
	// maxLen:   è®°å½•æœ€é•¿å›æ–‡ä¸²çš„åŠå¾„
	// begin:    è®°å½•æœ€é•¿å›æ–‡ä¸²åœ¨èµ·å§‹ä¸² s ä¸­çš„èµ·å§‹ä¸‹æ ‡
	dp, maxRight, center, maxLen, begin := make([]int, len(newS)), 0, 0, 1, 0
	for i := 0; i < len(newS); i++ {
		if i < maxRight {
			// è¿™ä¸€è¡Œä»£ç æ˜¯ Manacher ç®—æ³•çš„å…³é”®æ‰€åœ¨
			dp[i] = min(maxRight-i, dp[2*center-i])
		}
		// ä¸­å¿ƒæ‰©æ•£æ³•æ›´æ–° dp[i]
		left, right := i-(1+dp[i]), i+(1+dp[i])
		for left >= 0 && right < len(newS) && newS[left] == newS[right] {
			dp[i]++
			left--
			right++
		}
		// æ›´æ–° maxRightï¼Œå®ƒæ˜¯éå†è¿‡çš„ i çš„ i + dp[i] çš„æœ€å¤§è€…
		if i+dp[i] > maxRight {
			maxRight = i + dp[i]
			center = i
		}
		// è®°å½•æœ€é•¿å›æ–‡å­ä¸²çš„é•¿åº¦å’Œç›¸åº”å®ƒåœ¨åŸå§‹å­—ç¬¦ä¸²ä¸­çš„èµ·ç‚¹
		if dp[i] > maxLen {
			maxLen = dp[i]
			begin = (i - maxLen) / 2 // è¿™é‡Œè¦é™¤ä»¥ 2 å› ä¸ºæœ‰æˆ‘ä»¬æ’å…¥çš„è¾…åŠ©å­—ç¬¦ #
		}
	}
	return s[begin : begin+maxLen]
}

func min(x, y int) int {
	if x < y {
		return x
	}
	return y
}

// è§£æ³•äºŒ æ»‘åŠ¨çª—å£ï¼Œæ—¶é—´å¤æ‚åº¦ O(n^2)ï¼Œç©ºé—´å¤æ‚åº¦ O(1)
func longestPalindrome1(s string) string {
	if len(s) == 0 {
		return ""
	}
	left, right, pl, pr := 0, -1, 0, 0
	for left < len(s) {
		// ç§»åŠ¨åˆ°ç›¸åŒå­—æ¯çš„æœ€å³è¾¹ï¼ˆå¦‚æœæœ‰ç›¸åŒå­—æ¯ï¼‰
		for right+1 < len(s) && s[left] == s[right+1] {
			right++
		}
		// æ‰¾åˆ°å›æ–‡çš„è¾¹ç•Œ
		for left-1 >= 0 && right+1 < len(s) && s[left-1] == s[right+1] {
			left--
			right++
		}
		if right-left > pr-pl {
			pl, pr = left, right
		}
		// é‡ç½®åˆ°ä¸‹ä¸€æ¬¡å¯»æ‰¾å›æ–‡çš„ä¸­å¿ƒ
		left = (left+right)/2 + 1
		right = left
	}
	return s[pl : pr+1]
}

// è§£æ³•ä¸‰ ä¸­å¿ƒæ‰©æ•£æ³•ï¼Œæ—¶é—´å¤æ‚åº¦ O(n^2)ï¼Œç©ºé—´å¤æ‚åº¦ O(1)
func longestPalindrome2(s string) string {
	res := ""
	for i := 0; i < len(s); i++ {
		res = maxPalindrome(s, i, i, res)
		res = maxPalindrome(s, i, i+1, res)
	}
	return res
}

func maxPalindrome(s string, i, j int, res string) string {
	sub := ""
	for i >= 0 && j < len(s) && s[i] == s[j] {
		sub = s[i : j+1]
		i--
		j++
	}
	if len(res) < len(sub) {
		return sub
	}
	return res
}

// è§£æ³•å›› DPï¼Œæ—¶é—´å¤æ‚åº¦ O(n^2)ï¼Œç©ºé—´å¤æ‚åº¦ O(n^2)
func longestPalindrome3(s string) string {
	res, dp := "", make([][]bool, len(s))
	for i := 0; i < len(s); i++ {
		dp[i] = make([]bool, len(s))
	}
	for i := len(s) - 1; i >= 0; i-- {
		for j := i; j < len(s); j++ {
			dp[i][j] = (s[i] == s[j]) && ((j-i < 3) || dp[i+1][j-1])
			if dp[i][j] && (res == "" || j-i+1 > len(res)) {
				res = s[i : j+1]
			}
		}
	}
	return res
}
```
