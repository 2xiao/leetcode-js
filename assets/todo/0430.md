# [430. Flatten a Multilevel Doubly Linked List](https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ·±åº¦ä¼˜å…ˆæœç´¢`](../solution/depth-first-search.md) [`é“¾è¡¨`](../solution/linked-list.md) [`åŒå‘é“¾è¡¨`](../solution/doubly-linked-list.md)

## é¢˜ç›®

You are given a doubly linked list, which contains nodes that have a next pointer, a previous pointer, and an additional child pointer. This child pointer may or may not point to a separate doubly linked list, also containing these special nodes. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure as shown in the example below.

Given the `head` of the first level of the list, flatten the list so that all the nodes appear in a single-level, doubly linked list. Let `curr` be a node with a child list. The nodes in the child list should appear after `curr` and before `curr.next` in the flattened list.

Return the `head` of the flattened list. The nodes in the list must have all of their child pointers set to null.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/11/09/flatten11.jpg)

```

Input: head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]

Output: [1,2,3,7,8,11,12,9,10,4,5,6]

```

Explanation: The multilevel linked list in the input is shown.

After flattening the multilevel linked list it becomes:

![](https://assets.leetcode.com/uploads/2021/11/09/flatten12.jpg)

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/11/09/flatten2.1.jpg)

```

Input: head = [1,2,null,3]

Output: [1,3,2]

```

Explanation: The multilevel linked list in the input is shown.

After flattening the multilevel linked list it becomes:

![](https://assets.leetcode.com/uploads/2021/11/24/list.jpg)

**Example 3:**

```

Input: head = []

Output: []

```

Explanation: There could be empty list in the input.

## é¢˜ç›®å¤§æ„

ç»™å®šä¸€ä¸ªå¸¦å­é“¾è¡¨æŒ‡é’ˆ child çš„åŒå‘é“¾è¡¨ï¼Œå°† child çš„å­é“¾è¡¨è¿›è¡Œæ‰å¹³åŒ–å¤„ç†ï¼Œä½¿æ‰€æœ‰èŠ‚ç‚¹å‡ºç°åœ¨å•çº§åŒå‘é“¾è¡¨ä¸­ã€‚

æ‰å¹³åŒ–å¤„ç†å¦‚ä¸‹ï¼š

```
åŸé“¾è¡¨ï¼š
1---2---3---4---5---6--NULL
        |
        7---8---9---10--NULL
            |
            11--12--NULL
æ‰å¹³åŒ–ä¹‹åï¼š
1---2---3---7---8---11---12---9---10---4---5---6--NULL
```

## è§£é¢˜æ€è·¯

é€’å½’å¤„ç†å¤šå±‚é“¾è¡¨çš„æ‰å¹³åŒ–ã€‚éå†é“¾è¡¨ï¼Œæ‰¾åˆ° child éç©ºçš„èŠ‚ç‚¹ï¼Œ å°†å…¶å­é“¾è¡¨é“¾æ¥åˆ°å½“å‰èŠ‚ç‚¹çš„ next ä½ç½®ï¼ˆè‡ªèº«æ‰å¹³åŒ–å¤„ç†ï¼‰ã€‚ç„¶åç»§ç»­å‘åéå†ï¼Œä¸æ–­æ‰¾åˆ° child èŠ‚ç‚¹ï¼Œå¹¶è¿›è¡Œé“¾æ¥ã€‚ç›´åˆ°å¤„ç†åˆ°å°¾éƒ¨ä½ç½®ã€‚

## ä»£ç 

```javascript
// TODO: add code
class Solution:
    def dfs(self, node: 'Node'):
        # æ‰¾åˆ°é“¾è¡¨çš„å°¾èŠ‚ç‚¹æˆ– child é“¾è¡¨ä¸ä¸ºç©ºçš„èŠ‚ç‚¹
        while node.next and not node.child:
            node = node.next
        tail = None
        if node.child:
            # å¦‚æœ child é“¾è¡¨ä¸ä¸ºç©ºï¼Œå°† child é“¾è¡¨æ‰å¹³åŒ–
            tail = self.dfs(node.child)

            # å°†æ‰å¹³åŒ–çš„ child é“¾è¡¨é“¾æ¥åœ¨è¯¥èŠ‚ç‚¹ä¹‹å
            temp = node.next
            node.next = node.child
            node.next.prev = node
            node.child = None
            tail.next = temp
            if temp:
                temp.prev = tail
            # é“¾æ¥ä¹‹åï¼Œä» child é“¾è¡¨çš„å°¾èŠ‚ç‚¹ç»§ç»­å‘åå¤„ç†é“¾è¡¨
            return self.dfs(tail)
        # child é“¾è¡¨ä¸ºç©ºï¼Œåˆ™è¯¥èŠ‚ç‚¹æ˜¯å°¾èŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›
        return node
    def flatten(self, head: 'Node') -> 'Node':
        if not head:
            return head
        self.dfs(head)
        return head
```
