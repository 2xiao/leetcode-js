# [874. æ¨¡æ‹Ÿè¡Œèµ°æœºå™¨äºº](https://leetcode.com/problems/walking-robot-simulation)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ•°ç»„`](/tag/array.md) [`å“ˆå¸Œè¡¨`](/tag/hash-table.md) [`æ¨¡æ‹Ÿ`](/tag/simulation.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/walking-robot-simulation)

## é¢˜ç›®

A robot on an infinite XY-plane starts at point `(0, 0)` facing north. The
robot receives an array of integers `commands`, which represents a sequence of
moves that it needs to execute. There are only three possible types of
instructions the robot can receive:

  * `-2`: Turn left `90` degrees.
  * `-1`: Turn right `90` degrees.
  * `1 <= k <= 9`: Move forward `k` units, one unit at a time.

Some of the grid squares are `obstacles`. The `ith` obstacle is at grid point
`obstacles[i] = (xi, yi)`. If the robot runs into an obstacle, it will stay in
its current location (on the block adjacent to the obstacle) and move onto the
next command.

Return the **maximum squared Euclidean distance** that the robot reaches at
any point in its path (i.e. if the distance is `5`, return `25`).

**Note:**

  * There can be an obstacle at `(0, 0)`. If this happens, the robot will ignore the obstacle until it has moved off the origin. However, it will be unable to return to `(0, 0)` due to the obstacle.
  * North means +Y direction.
  * East means +X direction.
  * South means -Y direction.
  * West means -X direction.



**Example 1:**

**Input:** commands = [4,-1,3], obstacles = []

**Output:** 25

**Explanation:**

The robot starts at `(0, 0)`:

  1. Move north 4 units to `(0, 4)`.
  2. Turn right.
  3. Move east 3 units to `(3, 4)`.

The furthest point the robot ever gets from the origin is `(3, 4)`, which
squared is `32 + 42 = 25` units away.

**Example 2:**

**Input:** commands = [4,-1,4,-2,4], obstacles = [[2,4]]

**Output:** 65

**Explanation:**

The robot starts at `(0, 0)`:

  1. Move north 4 units to `(0, 4)`.
  2. Turn right.
  3. Move east 1 unit and get blocked by the obstacle at `(2, 4)`, robot is at `(1, 4)`.
  4. Turn left.
  5. Move north 4 units to `(1, 8)`.

The furthest point the robot ever gets from the origin is `(1, 8)`, which
squared is `12 + 82 = 65` units away.

**Example 3:**

**Input:** commands = [6,-1,-1,6], obstacles = [[0,0]]

**Output:** 36

**Explanation:**

The robot starts at `(0, 0)`:

  1. Move north 6 units to `(0, 6)`.
  2. Turn right.
  3. Turn right.
  4. Move south 5 units and get blocked by the obstacle at `(0,0)`, robot is at `(0, 1)`.

The furthest point the robot ever gets from the origin is `(0, 6)`, which
squared is `62 = 36` units away.



**Constraints:**

  * `1 <= commands.length <= 10^4`
  * `commands[i]` is either `-2`, `-1`, or an integer in the range `[1, 9]`.
  * `0 <= obstacles.length <= 10^4`
  * `-3 * 104 <= xi, yi <= 3 * 10^4`
  * The answer is guaranteed to be less than `231`.


## é¢˜ç›®å¤§æ„

æœºå™¨äººåœ¨ä¸€ä¸ªæ— é™å¤§å°çš„ XY ç½‘æ ¼å¹³é¢ä¸Šè¡Œèµ°ï¼Œä»ç‚¹ `(0, 0)` å¤„å¼€å§‹å‡ºå‘ï¼Œé¢å‘åŒ—æ–¹ã€‚è¯¥æœºå™¨äººå¯ä»¥æ¥æ”¶ä»¥ä¸‹ä¸‰ç§ç±»å‹çš„å‘½ä»¤ `commands` ï¼š

  * `-2` ï¼šå‘å·¦è½¬ `90` åº¦
  * `-1` ï¼šå‘å³è½¬ `90` åº¦
  * `1 <= x <= 9` ï¼šå‘å‰ç§»åŠ¨ `x` ä¸ªå•ä½é•¿åº¦

åœ¨ç½‘æ ¼ä¸Šæœ‰ä¸€äº›æ ¼å­è¢«è§†ä¸ºéšœç¢ç‰© `obstacles` ã€‚ç¬¬ `i` ä¸ªéšœç¢ç‰©ä½äºç½‘æ ¼ç‚¹  `obstacles[i] = (xi, yi)` ã€‚

æœºå™¨äººæ— æ³•èµ°åˆ°éšœç¢ç‰©ä¸Šï¼Œå®ƒå°†ä¼šåœç•™åœ¨éšœç¢ç‰©çš„å‰ä¸€ä¸ªç½‘æ ¼æ–¹å—ä¸Šï¼Œå¹¶ç»§ç»­æ‰§è¡Œä¸‹ä¸€ä¸ªå‘½ä»¤ã€‚

è¿”å›æœºå™¨äººè·ç¦»åŸç‚¹çš„ **æœ€å¤§æ¬§å¼è·ç¦»** çš„ **å¹³æ–¹** ã€‚ï¼ˆå³ï¼Œå¦‚æœè·ç¦»ä¸º `5` ï¼Œåˆ™è¿”å› `25` ï¼‰



**æ³¨æ„ï¼š**

  * åŒ—æ–¹è¡¨ç¤º +Y æ–¹å‘ã€‚
  * ä¸œæ–¹è¡¨ç¤º +X æ–¹å‘ã€‚
  * å—æ–¹è¡¨ç¤º -Y æ–¹å‘ã€‚
  * è¥¿æ–¹è¡¨ç¤º -X æ–¹å‘ã€‚
  * åŸç‚¹ [0,0] å¯èƒ½ä¼šæœ‰éšœç¢ç‰©ã€‚



**ç¤ºä¾‹ 1ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** commands = [4,-1,3], obstacles = []
> 
> **è¾“å‡ºï¼š** 25
> 
> **è§£é‡Šï¼š** æœºå™¨äººå¼€å§‹ä½äº (0, 0)ï¼š
> 
> 1. å‘åŒ—ç§»åŠ¨ 4 ä¸ªå•ä½ï¼Œåˆ°è¾¾ (0, 4)
> 
> 2. å³è½¬
> 
> 3. å‘ä¸œç§»åŠ¨ 3 ä¸ªå•ä½ï¼Œåˆ°è¾¾ (3, 4)
> 
> è·ç¦»åŸç‚¹æœ€è¿œçš„æ˜¯ (3, 4) ï¼Œè·ç¦»ä¸º 32 + 42 = 25

**ç¤ºä¾‹  2ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** commands = [4,-1,4,-2,4], obstacles = [[2,4]]
> 
> **è¾“å‡ºï¼š** 65
> 
> **è§£é‡Š** ï¼šæœºå™¨äººå¼€å§‹ä½äº (0, 0)ï¼š
> 
> 1. å‘åŒ—ç§»åŠ¨ 4 ä¸ªå•ä½ï¼Œåˆ°è¾¾ (0, 4)
> 
> 2. å³è½¬
> 
> 3. å‘ä¸œç§»åŠ¨ 1 ä¸ªå•ä½ï¼Œç„¶åè¢«ä½äº (2, 4) çš„éšœç¢ç‰©é˜»æŒ¡ï¼Œæœºå™¨äººåœåœ¨ (1, 4)
> 
> 4. å·¦è½¬
> 
> 5. å‘åŒ—èµ° 4 ä¸ªå•ä½ï¼Œåˆ°è¾¾ (1, 8)
> 
> è·ç¦»åŸç‚¹æœ€è¿œçš„æ˜¯ (1, 8) ï¼Œè·ç¦»ä¸º 12 + 82 = 65

**ç¤ºä¾‹ 3ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** commands = [6,-1,-1,6], obstacles = []
> 
> **è¾“å‡ºï¼š** 36
> 
> **è§£é‡Šï¼š** æœºå™¨äººå¼€å§‹ä½äº (0, 0):
> 
> 1. å‘åŒ—ç§»åŠ¨ 6 ä¸ªå•ä½ï¼Œåˆ°è¾¾ (0, 6).
> 
> 2. å³è½¬
> 
> 3. å³è½¬
> 
> 4. å‘å—ç§»åŠ¨ 6 ä¸ªå•ä½ï¼Œåˆ°è¾¾ (0, 0).
> 
> æœºå™¨äººè·ç¦»åŸç‚¹æœ€è¿œçš„ç‚¹æ˜¯ (0, 6)ï¼Œå…¶è·ç¦»çš„å¹³æ–¹æ˜¯ 62 = 36 ä¸ªå•ä½ã€‚

**æç¤ºï¼š**

  * `1 <= commands.length <= 10^4`
  * `commands[i]` çš„å€¼å¯ä»¥å– `-2`ã€`-1` æˆ–è€…æ˜¯èŒƒå›´ `[1, 9]` å†…çš„ä¸€ä¸ªæ•´æ•°ã€‚
  * `0 <= obstacles.length <= 10^4`
  * `-3 * 104 <= xi, yi <= 3 * 10^4`
  * ç­”æ¡ˆä¿è¯å°äº `231`


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 2069 | [æ¨¡æ‹Ÿè¡Œèµ°æœºå™¨äºº II](https://leetcode.com/problems/walking-robot-simulation-ii) |  |  [`è®¾è®¡`](/tag/design.md) [`æ¨¡æ‹Ÿ`](/tag/simulation.md) | <font color=#ffb800>Medium</font> |