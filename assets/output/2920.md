---
title: 2920. æ”¶é›†æ‰€æœ‰é‡‘å¸å¯è·å¾—çš„æœ€å¤§ç§¯åˆ†
description: LeetCode,2920. æ”¶é›†æ‰€æœ‰é‡‘å¸å¯è·å¾—çš„æœ€å¤§ç§¯åˆ†,æ”¶é›†æ‰€æœ‰é‡‘å¸å¯è·å¾—çš„æœ€å¤§ç§¯åˆ†,Maximum Points After Collecting Coins From All Nodes,è§£é¢˜æ€è·¯,ä½è¿ç®—,æ ‘,æ·±åº¦ä¼˜å…ˆæœç´¢,æ•°ç»„,åŠ¨æ€è§„åˆ’
keywords:
  - LeetCode
  - 2920. æ”¶é›†æ‰€æœ‰é‡‘å¸å¯è·å¾—çš„æœ€å¤§ç§¯åˆ†
  - æ”¶é›†æ‰€æœ‰é‡‘å¸å¯è·å¾—çš„æœ€å¤§ç§¯åˆ†
  - Maximum Points After Collecting Coins From All Nodes
  - è§£é¢˜æ€è·¯
  - ä½è¿ç®—
  - æ ‘
  - æ·±åº¦ä¼˜å…ˆæœç´¢
  - æ•°ç»„
  - åŠ¨æ€è§„åˆ’
---

# 2920. æ”¶é›†æ‰€æœ‰é‡‘å¸å¯è·å¾—çš„æœ€å¤§ç§¯åˆ†

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`ä½è¿ç®—`](/tag/bit-manipulation.md) [`æ ‘`](/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`æ•°ç»„`](/tag/array.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/maximum-points-after-collecting-coins-from-all-nodes) [`LeetCode`](https://leetcode.com/problems/maximum-points-after-collecting-coins-from-all-nodes)

## é¢˜ç›®

There exists an undirected tree rooted at node `0` with `n` nodes labeled from
`0` to `n - 1`. You are given a 2D **integer** array `edges` of length `n -
1`, where `edges[i] = [ai, bi]` indicates that there is an edge between nodes
`ai` and `bi` in the tree. You are also given a **0-indexed** array `coins` of
size `n` where `coins[i]` indicates the number of coins in the vertex `i`, and
an integer `k`.

Starting from the root, you have to collect all the coins such that the coins
at a node can only be collected if the coins of its ancestors have been
already collected.

Coins at `nodei` can be collected in one of the following ways:

  * Collect all the coins, but you will get `coins[i] - k` points. If `coins[i] - k` is negative then you will lose `abs(coins[i] - k)` points.
  * Collect all the coins, but you will get `floor(coins[i] / 2)` points. If this way is used, then for all the `nodej` present in the subtree of `nodei`, `coins[j]` will get reduced to `floor(coins[j] / 2)`.

Return _the**maximum points** you can get after collecting the coins from
**all** the tree nodes._



**Example 1:**

![](https://assets.leetcode.com/uploads/2023/09/18/ex1-copy.png)

> Input: edges = [[0,1],[1,2],[2,3]], coins = [10,10,3,3], k = 5
> 
> Output: 11> 
> > 
> > 
> > 
> > 
> > 
> 
> 
> Explanation: 
> 
> Collect all the coins from node 0 using the first way. Total points = 10 - 5 = 5.
> 
> Collect all the coins from node 1 using the first way. Total points = 5 + (10 - 5) = 10.
> 
> Collect all the coins from node 2 using the second way so coins left at node 3 will be floor(3 / 2) = 1. Total points = 10 + floor(3 / 2) = 11.
> 
> Collect all the coins from node 3 using the second way. Total points = 11 + floor(1 / 2) = 11.
> 
> It can be shown that the maximum points we can get after collecting coins from all the nodes is 11. 

**Example 2:**

**![](https://assets.leetcode.com/uploads/2023/09/18/ex2.png)**

> Input: edges = [[0,1],[0,2]], coins = [8,4,4], k = 0
> 
> Output: 16
> 
> Explanation: 
> 
> Coins will be collected from all the nodes using the first way. Therefore, total points = (8 - 0) + (4 - 0) + (4 - 0) = 16.

**Constraints:**

  * `n == coins.length`
  * `2 <= n <= 10^5`
  * `0 <= coins[i] <= 10^4`
  * `edges.length == n - 1`
  * `0 <= edges[i][0], edges[i][1] < n`
  * `0 <= k <= 10^4`


## é¢˜ç›®å¤§æ„

æœ‰ä¸€æ£µç”± `n` ä¸ªèŠ‚ç‚¹ç»„æˆçš„æ— å‘æ ‘ï¼Œä»¥ `0`  ä¸ºæ ¹èŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹ç¼–å·ä» `0` åˆ° `n - 1` ã€‚ç»™ä½ ä¸€ä¸ªé•¿åº¦ä¸º `n - 1` çš„äºŒç»´ **æ•´æ•°**
æ•°ç»„ `edges` ï¼Œå…¶ä¸­ `edges[i] = [ai, bi]` è¡¨ç¤ºåœ¨æ ‘ä¸Šçš„èŠ‚ç‚¹ `ai` å’Œ `bi` ä¹‹é—´å­˜åœ¨ä¸€æ¡è¾¹ã€‚å¦ç»™ä½ ä¸€ä¸ªä¸‹æ ‡ä»
**0** å¼€å§‹ã€é•¿åº¦ä¸º `n` çš„æ•°ç»„ `coins` å’Œä¸€ä¸ªæ•´æ•° `k` ï¼Œå…¶ä¸­ `coins[i]` è¡¨ç¤ºèŠ‚ç‚¹ `i` å¤„çš„é‡‘å¸æ•°é‡ã€‚

ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œä½ å¿…é¡»æ”¶é›†æ‰€æœ‰é‡‘å¸ã€‚è¦æƒ³æ”¶é›†èŠ‚ç‚¹ä¸Šçš„é‡‘å¸ï¼Œå¿…é¡»å…ˆæ”¶é›†è¯¥èŠ‚ç‚¹çš„ç¥–å…ˆèŠ‚ç‚¹ä¸Šçš„é‡‘å¸ã€‚

èŠ‚ç‚¹ `i` ä¸Šçš„é‡‘å¸å¯ä»¥ç”¨ä¸‹è¿°æ–¹æ³•ä¹‹ä¸€è¿›è¡Œæ”¶é›†ï¼š

  * æ”¶é›†æ‰€æœ‰é‡‘å¸ï¼Œå¾—åˆ°å…±è®¡ `coins[i] - k` ç‚¹ç§¯åˆ†ã€‚å¦‚æœ `coins[i] - k` æ˜¯è´Ÿæ•°ï¼Œä½ å°†ä¼šå¤±å» `abs(coins[i] - k)` ç‚¹ç§¯åˆ†ã€‚
  * æ”¶é›†æ‰€æœ‰é‡‘å¸ï¼Œå¾—åˆ°å…±è®¡ `floor(coins[i] / 2)` ç‚¹ç§¯åˆ†ã€‚å¦‚æœé‡‡ç”¨è¿™ç§æ–¹æ³•ï¼ŒèŠ‚ç‚¹ `i` å­æ ‘ä¸­æ‰€æœ‰èŠ‚ç‚¹ `j` çš„é‡‘å¸æ•° `coins[j]` å°†ä¼šå‡å°‘è‡³ `floor(coins[j] / 2)` ã€‚

è¿”å›æ”¶é›† **æ‰€æœ‰** æ ‘èŠ‚ç‚¹çš„é‡‘å¸ä¹‹åå¯ä»¥è·å¾—çš„æœ€å¤§ç§¯åˆ†ã€‚



**ç¤ºä¾‹ 1ï¼š**

![](https://assets.leetcode.com/uploads/2023/09/18/ex1-copy.png)

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** edges = [[0,1],[1,2],[2,3]], coins = [10,10,3,3], k = 5
> 
> **è¾“å‡ºï¼š** 11> 
> > 
> > 
> > 
> > 
> > 
> 
> 
> **è§£é‡Šï¼š**
> 
> ä½¿ç”¨ç¬¬ä¸€ç§æ–¹æ³•æ”¶é›†èŠ‚ç‚¹ 0 ä¸Šçš„æ‰€æœ‰é‡‘å¸ã€‚æ€»ç§¯åˆ† = 10 - 5 = 5 ã€‚
> 
> ä½¿ç”¨ç¬¬ä¸€ç§æ–¹æ³•æ”¶é›†èŠ‚ç‚¹ 1 ä¸Šçš„æ‰€æœ‰é‡‘å¸ã€‚æ€»ç§¯åˆ† = 5 + (10 - 5) = 10 ã€‚
> 
> ä½¿ç”¨ç¬¬äºŒç§æ–¹æ³•æ”¶é›†èŠ‚ç‚¹ 2 ä¸Šçš„æ‰€æœ‰é‡‘å¸ã€‚æ‰€ä»¥èŠ‚ç‚¹ 3 ä¸Šçš„é‡‘å¸å°†ä¼šå˜ä¸º floor(3 / 2) = 1 ï¼Œæ€»ç§¯åˆ† = 10 + floor(3 / 2) = 11 ã€‚
> 
> ä½¿ç”¨ç¬¬äºŒç§æ–¹æ³•æ”¶é›†èŠ‚ç‚¹ 3 ä¸Šçš„æ‰€æœ‰é‡‘å¸ã€‚æ€»ç§¯åˆ† =  11 + floor(1 / 2) = 11.
> 
> å¯ä»¥è¯æ˜æ”¶é›†æ‰€æœ‰èŠ‚ç‚¹ä¸Šçš„é‡‘å¸èƒ½è·å¾—çš„æœ€å¤§ç§¯åˆ†æ˜¯ 11 ã€‚ 
> 
> 

**ç¤ºä¾‹ 2ï¼š**

**![](https://assets.leetcode.com/uploads/2023/09/18/ex2.png)**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** edges = [[0,1],[0,2]], coins = [8,4,4], k = 0
> 
> **è¾“å‡ºï¼š** 16
> 
> **è§£é‡Šï¼š**
> 
> ä½¿ç”¨ç¬¬ä¸€ç§æ–¹æ³•æ”¶é›†æ‰€æœ‰èŠ‚ç‚¹ä¸Šçš„é‡‘å¸ï¼Œå› æ­¤ï¼Œæ€»ç§¯åˆ† = (8 - 0) + (4 - 0) + (4 - 0) = 16 ã€‚
> 
> 



**æç¤ºï¼š**

  * `n == coins.length`
  * `2 <= n <= 10^5`
  * `0 <= coins[i] <= 10^4`
  * `edges.length == n - 1`
  * `0 <= edges[i][0], edges[i][1] < n`
  * `0 <= k <= 10^4`


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```