# [2322. ä»æ ‘ä¸­åˆ é™¤è¾¹çš„æœ€å°åˆ†æ•°](https://2xiao.github.io/leetcode-js/problem/2322.html)

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`ä½è¿ç®—`](/tag/bit-manipulation.md) [`æ ‘`](/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`æ•°ç»„`](/tag/array.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/minimum-score-after-removals-on-a-tree) [`LeetCode`](https://leetcode.com/problems/minimum-score-after-removals-on-a-tree)

## é¢˜ç›®

There is an undirected connected tree with `n` nodes labeled from `0` to `n -
1` and `n - 1` edges.

You are given a **0-indexed** integer array `nums` of length `n` where
`nums[i]` represents the value of the `ith` node. You are also given a 2D
integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates
that there is an edge between nodes `ai` and `bi` in the tree.

Remove two **distinct** edges of the tree to form three connected components.
For a pair of removed edges, the following steps are defined:

  1. Get the XOR of all the values of the nodes for **each** of the three components respectively.
  2. The **difference** between the **largest** XOR value and the **smallest** XOR value is the **score** of the pair.

  * For example, say the three components have the node values: `[4,5,7]`, `[1,9]`, and `[3,3,3]`. The three XOR values are `4 ^ 5 ^ 7 = _**6**_`, `1 ^ 9 = _**8**_`, and `3 ^ 3 ^ 3 = _**3**_`. The largest XOR value is `8` and the smallest XOR value is `3`. The score is then `8 - 3 = 5`.

Return _the**minimum** score of any possible pair of edge removals on the
given tree_.



**Example 1:**

![](https://assets.leetcode.com/uploads/2022/05/03/ex1drawio.png)

> Input: nums = [1,5,5,4,11], edges = [[0,1],[1,2],[1,3],[3,4]]
> 
> Output: 9
> 
> Explanation: The diagram above shows a way to make a pair of removals.
> - The 1st component has nodes [1,3,4] with values [5,4,11]. Its XOR value is 5 ^ 4 ^ 11 = 10.
> - The 2nd component has node [0] with value [1]. Its XOR value is 1 = 1.
> - The 3rd component has node [2] with value [5]. Its XOR value is 5 = 5.
> 
> The score is the difference between the largest and smallest XOR value which is 10 - 1 = 9.
> 
> It can be shown that no other pair of removals will obtain a smaller score than 9.

**Example 2:**

![](https://assets.leetcode.com/uploads/2022/05/03/ex2drawio.png)

> Input: nums = [5,5,2,4,4,2], edges = [[0,1],[1,2],[5,2],[4,3],[1,3]]
> 
> Output: 0
> 
> Explanation: The diagram above shows a way to make a pair of removals.
> - The 1st component has nodes [3,4] with values [4,4]. Its XOR value is 4 ^ 4 = 0.
> - The 2nd component has nodes [1,0] with values [5,5]. Its XOR value is 5 ^ 5 = 0.
> - The 3rd component has nodes [2,5] with values [2,2]. Its XOR value is 2 ^ 2 = 0.
> 
> The score is the difference between the largest and smallest XOR value which is 0 - 0 = 0.
> 
> We cannot obtain a smaller score than 0.

**Constraints:**

  * `n == nums.length`
  * `3 <= n <= 1000`
  * `1 <= nums[i] <= 10^8`
  * `edges.length == n - 1`
  * `edges[i].length == 2`
  * `0 <= ai, bi < n`
  * `ai != bi`
  * `edges` represents a valid tree.


## é¢˜ç›®å¤§æ„

å­˜åœ¨ä¸€æ£µæ— å‘è¿é€šæ ‘ï¼Œæ ‘ä¸­æœ‰ç¼–å·ä» `0` åˆ° `n - 1` çš„ `n` ä¸ªèŠ‚ç‚¹ï¼Œ ä»¥åŠ `n - 1` æ¡è¾¹ã€‚

ç»™ä½ ä¸€ä¸ªä¸‹æ ‡ä» **0** å¼€å§‹çš„æ•´æ•°æ•°ç»„ `nums` ï¼Œé•¿åº¦ä¸º `n` ï¼Œå…¶ä¸­ `nums[i]` è¡¨ç¤ºç¬¬ `i` ä¸ªèŠ‚ç‚¹çš„å€¼ã€‚å¦ç»™ä½ ä¸€ä¸ªäºŒç»´æ•´æ•°æ•°ç»„
`edges` ï¼Œé•¿åº¦ä¸º `n - 1` ï¼Œå…¶ä¸­ `edges[i] = [ai, bi]` è¡¨ç¤ºæ ‘ä¸­å­˜åœ¨ä¸€æ¡ä½äºèŠ‚ç‚¹ `ai` å’Œ `bi` ä¹‹é—´çš„è¾¹ã€‚

åˆ é™¤æ ‘ä¸­ä¸¤æ¡ **ä¸åŒ** çš„è¾¹ä»¥å½¢æˆä¸‰ä¸ªè¿é€šç»„ä»¶ã€‚å¯¹äºä¸€ç§åˆ é™¤è¾¹æ–¹æ¡ˆï¼Œå®šä¹‰å¦‚ä¸‹æ­¥éª¤ä»¥è®¡ç®—å…¶åˆ†æ•°ï¼š

  1. åˆ†åˆ«è·å–ä¸‰ä¸ªç»„ä»¶ **æ¯ä¸ª** ç»„ä»¶ä¸­æ‰€æœ‰èŠ‚ç‚¹å€¼çš„å¼‚æˆ–å€¼ã€‚
  2. **æœ€å¤§** å¼‚æˆ–å€¼å’Œ **æœ€å°** å¼‚æˆ–å€¼çš„ **å·®å€¼** å°±æ˜¯è¿™ä¸€ç§åˆ é™¤è¾¹æ–¹æ¡ˆçš„åˆ†æ•°ã€‚

  * ä¾‹å¦‚ï¼Œä¸‰ä¸ªç»„ä»¶çš„èŠ‚ç‚¹å€¼åˆ†åˆ«æ˜¯ï¼š`[4,5,7]`ã€`[1,9]` å’Œ `[3,3,3]` ã€‚ä¸‰ä¸ªå¼‚æˆ–å€¼åˆ†åˆ«æ˜¯ `4 ^ 5 ^ 7 = _**6**_`ã€`1 ^ 9 = _**8**_` å’Œ `3 ^ 3 ^ 3 = _**3**_` ã€‚æœ€å¤§å¼‚æˆ–å€¼æ˜¯ `8` ï¼Œæœ€å°å¼‚æˆ–å€¼æ˜¯ `3` ï¼Œåˆ†æ•°æ˜¯ `8 - 3 = 5` ã€‚

è¿”å›åœ¨ç»™å®šæ ‘ä¸Šæ‰§è¡Œä»»æ„åˆ é™¤è¾¹æ–¹æ¡ˆå¯èƒ½çš„ **æœ€å°** åˆ†æ•°ã€‚



**ç¤ºä¾‹ 1ï¼š**

![](https://assets.leetcode.com/uploads/2022/05/03/ex1drawio.png)

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** nums = [1,5,5,4,11], edges = [[0,1],[1,2],[1,3],[3,4]]
> 
> **è¾“å‡ºï¼š** 9
> 
> **è§£é‡Šï¼š** ä¸Šå›¾å±•ç¤ºäº†ä¸€ç§åˆ é™¤è¾¹æ–¹æ¡ˆã€‚
> - ç¬¬ 1 ä¸ªç»„ä»¶çš„èŠ‚ç‚¹æ˜¯ [1,3,4] ï¼Œå€¼æ˜¯ [5,4,11] ã€‚å¼‚æˆ–å€¼æ˜¯ 5 ^ 4 ^ 11 = 10 ã€‚
> - ç¬¬ 2 ä¸ªç»„ä»¶çš„èŠ‚ç‚¹æ˜¯ [0] ï¼Œå€¼æ˜¯ [1] ã€‚å¼‚æˆ–å€¼æ˜¯ 1 = 1 ã€‚
> - ç¬¬ 3 ä¸ªç»„ä»¶çš„èŠ‚ç‚¹æ˜¯ [2] ï¼Œå€¼æ˜¯ [5] ã€‚å¼‚æˆ–å€¼æ˜¯ 5 = 5 ã€‚
> 
> åˆ†æ•°æ˜¯æœ€å¤§å¼‚æˆ–å€¼å’Œæœ€å°å¼‚æˆ–å€¼çš„å·®å€¼ï¼Œ10 - 1 = 9 ã€‚
> 
> å¯ä»¥è¯æ˜ä¸å­˜åœ¨åˆ†æ•°æ¯” 9 å°çš„åˆ é™¤è¾¹æ–¹æ¡ˆã€‚
> 
> 

**ç¤ºä¾‹ 2ï¼š**

![](https://assets.leetcode.com/uploads/2022/05/03/ex2drawio.png)

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** nums = [5,5,2,4,4,2], edges = [[0,1],[1,2],[5,2],[4,3],[1,3]]
> 
> **è¾“å‡ºï¼š** 0
> 
> **è§£é‡Šï¼š** ä¸Šå›¾å±•ç¤ºäº†ä¸€ç§åˆ é™¤è¾¹æ–¹æ¡ˆã€‚
> - ç¬¬ 1 ä¸ªç»„ä»¶çš„èŠ‚ç‚¹æ˜¯ [3,4] ï¼Œå€¼æ˜¯ [4,4] ã€‚å¼‚æˆ–å€¼æ˜¯ 4 ^ 4 = 0 ã€‚
> - ç¬¬ 2 ä¸ªç»„ä»¶çš„èŠ‚ç‚¹æ˜¯ [1,0] ï¼Œå€¼æ˜¯ [5,5] ã€‚å¼‚æˆ–å€¼æ˜¯ 5 ^ 5 = 0 ã€‚
> - ç¬¬ 3 ä¸ªç»„ä»¶çš„èŠ‚ç‚¹æ˜¯ [2,5] ï¼Œå€¼æ˜¯ [2,2] ã€‚å¼‚æˆ–å€¼æ˜¯ 2 ^ 2 = 0 ã€‚
> 
> åˆ†æ•°æ˜¯æœ€å¤§å¼‚æˆ–å€¼å’Œæœ€å°å¼‚æˆ–å€¼çš„å·®å€¼ï¼Œ0 - 0 = 0 ã€‚
> 
> æ— æ³•è·å¾—æ¯” 0 æ›´å°çš„åˆ†æ•° 0 ã€‚
> 
> 



**æç¤ºï¼š**

  * `n == nums.length`
  * `3 <= n <= 1000`
  * `1 <= nums[i] <= 10^8`
  * `edges.length == n - 1`
  * `edges[i].length == 2`
  * `0 <= ai, bi < n`
  * `ai != bi`
  * `edges` è¡¨ç¤ºä¸€æ£µæœ‰æ•ˆçš„æ ‘


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```