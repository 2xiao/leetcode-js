---
title: 2489. 固定比率的子字符串数 🔒
description: LeetCode 2489. 固定比率的子字符串数 🔒题解，Number of Substrings With Fixed Ratio，包含解题思路、复杂度分析以及完整的 JavaScript 代码实现。
keywords:
  - LeetCode
  - 2489. 固定比率的子字符串数 🔒
  - 固定比率的子字符串数
  - Number of Substrings With Fixed Ratio
  - 解题思路
  - 哈希表
  - 数学
  - 字符串
  - 前缀和
---

# 2489. 固定比率的子字符串数 🔒

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`哈希表`](/tag/hash-table.md) [`数学`](/tag/math.md) [`字符串`](/tag/string.md) [`前缀和`](/tag/prefix-sum.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/number-of-substrings-with-fixed-ratio) [`LeetCode`](https://leetcode.com/problems/number-of-substrings-with-fixed-ratio)

## 题目

You are given a binary string `s`, and two integers `num1` and `num2`. `num1`
and `num2` are coprime numbers.

A **ratio substring** is a substring of s where the ratio between the number
of `0`'s and the number of `1`'s in the substring is exactly `num1 : num2`.

  * For example, if `num1 = 2` and `num2 = 3`, then `"01011"` and `"1110000111"` are ratio substrings, while `"11000"` is not.

Return _the number of**non-empty** ratio substrings of _`s`.

**Note** that:

  * A **substring** is a contiguous sequence of characters within a string.
  * Two values `x` and `y` are **coprime** if `gcd(x, y) == 1` where `gcd(x, y)` is the greatest common divisor of `x` and `y`.



**Example 1:**

> Input: s = "0110011", num1 = 1, num2 = 2
> 
> Output: 4
> 
> Explanation: There exist 4 non-empty ratio substrings.
> - The substring s[0..2]: "_011_ 0011". It contains one 0 and two 1's. The ratio is 1 : 2.
> - The substring s[1..4]: "0 _110_ 011". It contains one 0 and two 1's. The ratio is 1 : 2.
> - The substring s[4..6]: "0110 _011_ ". It contains one 0 and two 1's. The ratio is 1 : 2.
> - The substring s[1..6]: "0 _110011_ ". It contains two 0's and four 1's. The ratio is 2 : 4 == 1 : 2.
> 
> It can be shown that there are no more ratio substrings.

**Example 2:**

> Input: s = "10101", num1 = 3, num2 = 1
> 
> Output: 0
> 
> Explanation: There is no ratio substrings of s. We return 0.

**Constraints:**

  * `1 <= s.length <= 10^5`
  * `1 <= num1, num2 <= s.length`
  * `num1` and `num2` are coprime integers.


## 题目大意

给定一个二进制字符串 `s` 和两个整数 `num1` 和 `num2`。`num1` 和 `num2` 为互质。

**比率子串  **是 s 的子串，其中子串中 `0` 的数量与 `1` 的数量之比正好是 `num1 : num2`。

  * 例如，如果 `num1 = 2` 和 `num2 = 3`，那么 `"01011"` 和 `"1110000111"` 是比率子串，而 `"11000"` 不是。

返回 _`s` 的 **非空  **比率子串的个数。_

**注意** :

  * **子串  **是字符串中连续的字符序列。
  * 如果 `gcd(x, y) == 1`，则 `x` 和 `y` 为 **互质** ，其中 `gcd(x, y)` 为 `x` 和 `y` 的最大公约数。



**示例 1:**

> 
> 
> 
> 
> 
> **输入:** s = "0110011", num1 = 1, num2 = 2
> 
> **输出:** 4
> 
> **解释:** 有 4 个非空的比率子串。
> - 子字符串 s[0..2]: "_011_ 0011"。它包含一个 0 和两个 1。比例是 1:2。
> - 子字符串 s[1..4]: "0 _110_ 011"。它包含一个 0 和两个 1。比例是 1:2。
> - 子字符串 s[4..6]: "0110 _011_ "。它包含一个 0 和两个 1。比例是 1:2。
> - 子字符串 s[1..6]: "0 _110011_ "。它包含两个 0 和四个 1。比例是 2:4 == 1:2。
> 
> 它可以显示没有更多的比率子串。
> 
> 

**示例 2:**

> 
> 
> 
> 
> 
> **输入:** s = "10101", num1 = 3, num2 = 1
> 
> **输出:** 0
> 
> **解释:** s 没有比率子串，返回 0。
> 
> 



**提示:**

  * `1 <= s.length <= 10^5`
  * `1 <= num1, num2 <= s.length`
  * `num1` 和 `num2` 互质。


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 696 | 计数二进制子串 | [[✓]](/problem/0696.md) |  [`双指针`](/tag/two-pointers.md) [`字符串`](/tag/string.md) | 🟢 | [🀄️](https://leetcode.cn/problems/count-binary-substrings) [🔗](https://leetcode.com/problems/count-binary-substrings) |