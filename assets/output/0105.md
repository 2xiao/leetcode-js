# [105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ ‘`](/leetcode/outline/tag/tree.md) [`æ•°ç»„`](/leetcode/outline/tag/array.md) [`å“ˆå¸Œè¡¨`](/leetcode/outline/tag/hash-table.md) [`åˆ†æ²»`](/leetcode/outline/tag/divide-and-conquer.md) [`äºŒå‰æ ‘`](/leetcode/outline/tag/binary-tree.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal)


## é¢˜ç›®

Given two integer arrays `preorder` and `inorder` where `preorder` is the
preorder traversal of a binary tree and `inorder` is the inorder traversal of
the same tree, construct and return _the binary tree_.



**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

> Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
> 
> Output: [3,9,20,null,null,15,7]

**Example 2:**

> Input: preorder = [-1], inorder = [-1]
> 
> Output: [-1]

**Constraints:**

  * `1 <= preorder.length <= 3000`
  * `inorder.length == preorder.length`
  * `-3000 <= preorder[i], inorder[i] <= 3000`
  * `preorder` and `inorder` consist of **unique** values.
  * Each value of `inorder` also appears in `preorder`.
  * `preorder` is **guaranteed** to be the preorder traversal of the tree.
  * `inorder` is **guaranteed** to be the inorder traversal of the tree.


## é¢˜ç›®å¤§æ„

ç»™å®šä¸¤ä¸ªæ•´æ•°æ•°ç»„ `preorder` å’Œ `inorder` ï¼Œå…¶ä¸­ `preorder` æ˜¯äºŒå‰æ ‘çš„**å…ˆåºéå†** ï¼Œ `inorder`
æ˜¯åŒä¸€æ£µæ ‘çš„**ä¸­åºéå†** ï¼Œè¯·æ„é€ äºŒå‰æ ‘å¹¶è¿”å›å…¶æ ¹èŠ‚ç‚¹ã€‚



**ç¤ºä¾‹ 1:**

![](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

> 
> 
> 
> 
> 
> **è¾“å…¥****:** preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
> 
> **è¾“å‡º:** [3,9,20,null,null,15,7]
> 
> 

**ç¤ºä¾‹ 2:**

> 
> 
> 
> 
> 
> **è¾“å…¥:** preorder = [-1], inorder = [-1]
> 
> **è¾“å‡º:** [-1]
> 
> 



**æç¤º:**

  * `1 <= preorder.length <= 3000`
  * `inorder.length == preorder.length`
  * `-3000 <= preorder[i], inorder[i] <= 3000`
  * `preorder` å’Œ `inorder` å‡ **æ— é‡å¤** å…ƒç´ 
  * `inorder` å‡å‡ºç°åœ¨ `preorder`
  * `preorder` **ä¿è¯** ä¸ºäºŒå‰æ ‘çš„å‰åºéå†åºåˆ—
  * `inorder` **ä¿è¯** ä¸ºäºŒå‰æ ‘çš„ä¸­åºéå†åºåˆ—


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

:::: md-demo ç›¸å…³é¢˜ç›®
- [ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal)

::::
