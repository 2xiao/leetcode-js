# [1966. æœªæ’åºæ•°ç»„ä¸­çš„å¯è¢«äºŒåˆ†æœç´¢çš„æ•°](https://leetcode.com/problems/binary-searchable-numbers-in-an-unsorted-array)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ•°ç»„`](/tag/array.md) [`äºŒåˆ†æŸ¥æ‰¾`](/tag/binary-search.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/binary-searchable-numbers-in-an-unsorted-array)

## é¢˜ç›®

Consider a function that implements an algorithm **similar** to [Binary
Search](https://leetcode.com/explore/learn/card/binary-search/). The function
has two input parameters: `sequence` is a sequence of integers, and `target`
is an integer value. The purpose of the function is to find if the `target`
exists in the `sequence`.

The pseudocode of the function is as follows:

> 
> 
> 
> 
> 
> func(sequence, target)
> 
>   while sequence is not empty
> 
> > 
> **randomly** choose an element from sequence as the pivot
> 
> > 
> if pivot = target, return **true**
> 
> > 
> else if pivot < target, remove pivot and all elements to its left from the sequence
> 
> > 
> else, remove pivot and all elements to its right from the sequence
> 
>   end while
> 
>   return **false**
> 
> 

When the `sequence` is sorted, the function works correctly for **all**
values. When the `sequence` is not sorted, the function does not work for all
values, but may still work for **some** values.

Given an integer array `nums`, representing the `sequence`, that contains
**unique** numbers and **may or may not be sorted** , return _the number of
values that are**guaranteed** to be found using the function, for **every
possible** pivot selection_.



**Example 1:**

> Input: nums = [7]
> 
> Output: 1
> 
> **Explanation** : 
> 
> Searching for value 7 is guaranteed to be found.
> 
> Since the sequence has only one element, 7 will be chosen as the pivot. Because the pivot equals the target, the function will return true.

**Example 2:**

> Input: nums = [-1,5,2]
> 
> Output: 1
> 
> **Explanation** : 
> 
> Searching for value -1 is guaranteed to be found.
> 
> If -1 was chosen as the pivot, the function would return true.
> 
> If 5 was chosen as the pivot, 5 and 2 would be removed. In the next loop, the sequence would have only -1 and the function would return true.
> 
> If 2 was chosen as the pivot, 2 would be removed. In the next loop, the sequence would have -1 and 5. No matter which number was chosen as the next pivot, the function would find -1 and return true.
> 
> 
> 
> Searching for value 5 is NOT guaranteed to be found.
> 
> If 2 was chosen as the pivot, -1, 5 and 2 would be removed. The sequence would be empty and the function would return false.
> 
> 
> 
> Searching for value 2 is NOT guaranteed to be found.
> 
> If 5 was chosen as the pivot, 5 and 2 would be removed. In the next loop, the sequence would have only -1 and the function would return false.
> 
> 
> 
> Because only -1 is guaranteed to be found, you should return 1.

**Constraints:**

  * `1 <= nums.length <= 10^5`
  * `-10^5 <= nums[i] <= 10^5`
  * All the values of `nums` are **unique**.



**Follow-up:** If `nums` has **duplicates** , would you modify your algorithm?
If so, how?


## é¢˜ç›®å¤§æ„

æœ‰ä¸€ä¸ª **ç±»ä¼¼** [äºŒåˆ†æœç´¢](https://leetcode.com/explore/learn/card/binary-search/)çš„æ–¹æ³•ã€‚
è¿™ä¸ªæ–¹æ³•æœ‰ä¸¤ä¸ªå…¥å‚: `sequence` æ˜¯ä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œ `target` æ˜¯ä¸€ä¸ªæ•´æ•°ã€‚ è¿™ä¸ªæ–¹æ³•å¯ä»¥åˆ¤æ–­ `target` æ˜¯å¦å­˜åœ¨
`sequence`ä¸­ã€‚

è¯¥æ–¹æ³•çš„ä¼ªä»£ç å¦‚ä¸‹ï¼š

> 
> 
> 
> 
> 
> func(sequence, target)
> 
>   while sequence is not empty
> 
> > 
> **randomly** choose an element from sequence as the pivot
> 
> > 
> if pivot = target, return **true**
> 
> > 
> else if pivot < target, remove pivot and all elements to its left from the sequence
> 
> > 
> else, remove pivot and all elements to its right from the sequence
> 
>   end while
> 
>   return **false**

å½“ `sequence` æ˜¯æ’å¥½åºæ—¶, è¿™ä¸ªæ–¹æ³•å¯¹ **æ‰€æœ‰** å€¼éƒ½å¯æ­£å¸¸åˆ¤æ–­ã€‚å¦‚æœ `sequence` ä¸æ˜¯æ’å¥½åºçš„,
è¯¥æ–¹æ³•å¹¶ä¸æ˜¯å¯¹æ‰€æœ‰å€¼éƒ½å¯æ­£å¸¸åˆ¤æ–­, ä½†å¯¹**ä¸€äº›** å€¼ä»å¯æ­£å¸¸åˆ¤æ–­ã€‚

ç»™å®šä¸€ä¸ªä»…åŒ…å«**ä¸åŒ** æ•°å­—çš„æ•°ç»„ `nums`è¡¨ç¤º `sequence`ï¼Œ nums**æ˜¯å¦æ’åºæœªçŸ¥** ï¼Œå¯¹äº **æ‰€æœ‰å¯èƒ½** çš„é€‰æ‹©,
è¿”å›é€šè¿‡è¿™ä¸ªæ–¹æ³•**ä¿è¯** èƒ½æ‰¾åˆ°çš„å€¼çš„æ•°é‡ã€‚



**ç¤ºä¾‹  1:**

> 
> 
> 
> 
> 
> **è¾“å…¥:** nums = [7]
> 
> **è¾“å‡º:** 1
> 
> **è§£é‡Š** : 
> 
> 7 ä¿è¯èƒ½è¢«æ‰¾åˆ°.
> 
> å› ä¸ºæ•°ç»„ä¸­åªæœ‰ä¸€ä¸ªæ•°å­—, 7 ä¸€å®šä¼šè¢«é€‰ä¸­. å› ä¸ºé€‰ä¸­çš„å€¼ç­‰äºtarget, è¿™ä¸ªæ–¹æ³•ä¼šè¿”å› true.
> 
> 

**ç¤ºä¾‹  2:**

> 
> 
> 
> 
> 
> **è¾“å…¥:** nums = [-1,5,2]
> 
> **è¾“å‡º:** 1
> 
> **è§£é‡Š** : 
> 
> åªæœ‰ -1 ä¿è¯èƒ½è¢«æ‰¾åˆ°.
> 
> å¦‚æœ -1 è¢«é€‰ä¸­, è¿™ä¸ªæ–¹æ³•å°±ä¼šè¿”å› true.
> 
> å¦‚æœ 5 è¢«é€‰ä¸­, 5 å’Œ 2 ä¼šè¢«ç§»é™¤ã€‚ åœ¨ä¸‹ä¸€æ¬¡å¾ªç¯æ—¶, è¿™ä¸ªåºåˆ—åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼š -1 ï¼Œè¿™ä¸ªæ–¹æ³•å°±ä¼šè¿”å› true.
> 
> å¦‚æœ 2 è¢«é€‰ä¸­, 2 å°†ä¼šè¢«ç§»é™¤ã€‚ åœ¨ä¸‹æ¬¡å¾ªç¯æ—¶, è¿™ä¸ªåºåˆ—é‡Œå°†ä¼šæœ‰ -1 å’Œ 5. æ— è®ºå“ªä¸ªæ•°å­—è¢«é€‰ä¸­, è¿™ä¸ªæ–¹æ³•éƒ½ä¼šæ‰¾åˆ° -1 ä¸”è¿”å› true.
> 
> 
> 
> 5 ä¸èƒ½ä¿è¯è¢«æ‰¾åˆ°ã€‚
> 
> å¦‚æœ 2 è¢«é€‰ä¸­, -1, 5 å’Œ 2 å°†ä¼šè¢«ç§»é™¤ã€‚ è¿™ä¸ªåºåˆ—å°†ä¼šè¢«æ¸…ç©ºä¸”è¿™ä¸ªæ–¹æ³•ä¼šè¿”å› falseã€‚
> 
> 
> 
> 2 ä¸èƒ½ä¿è¯è¢«æ‰¾åˆ°.
> 
> å¦‚æœ 5 è¢«é€‰ä¸­, 5 å’Œ 2 å°†ä¼šè¢«ç§»é™¤ã€‚åœ¨ä¸‹æ¬¡å¾ªç¯æ—¶, è¿™ä¸ªåºåˆ—åªä¼šæœ‰ä¸€ä¸ªå…ƒç´ ï¼š -1 ä¸”è¿™ä¸ªæ–¹æ³•ä¼šè¿”å› falseã€‚
> 
> 
> 
> å› ä¸ºåªæœ‰-1 æ˜¯ä¿è¯èƒ½è¢«æ‰¾åˆ°çš„, ä½ åº”è¯¥è¿”å› 1.
> 
> 



**æç¤º:**

  * `1 <= nums.length <= 10^5`
  * `-10^5 <= nums[i] <= 10^5`
  * `nums` ä¸­æ‰€æœ‰å€¼éƒ½ **ä¸åŒ**.



**æå‡:**  å¦‚æœ `nums` å­˜åœ¨ **é‡å¤çš„å€¼** , ä½ ä¼šå¦‚ä½•ä¿®æ”¹ä½ çš„ç®—æ³•å—?


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```