---
title: 2411. æŒ‰ä½æˆ–æœ€å¤§çš„æœ€å°å­æ•°ç»„é•¿åº¦
description: LeetCode,2411. æŒ‰ä½æˆ–æœ€å¤§çš„æœ€å°å­æ•°ç»„é•¿åº¦,æŒ‰ä½æˆ–æœ€å¤§çš„æœ€å°å­æ•°ç»„é•¿åº¦,Smallest Subarrays With Maximum Bitwise OR,è§£é¢˜æ€è·¯,ä½è¿ç®—,æ•°ç»„,äºŒåˆ†æŸ¥æ‰¾,æ»‘åŠ¨çª—å£
keywords:
  - LeetCode
  - 2411. æŒ‰ä½æˆ–æœ€å¤§çš„æœ€å°å­æ•°ç»„é•¿åº¦
  - æŒ‰ä½æˆ–æœ€å¤§çš„æœ€å°å­æ•°ç»„é•¿åº¦
  - Smallest Subarrays With Maximum Bitwise OR
  - è§£é¢˜æ€è·¯
  - ä½è¿ç®—
  - æ•°ç»„
  - äºŒåˆ†æŸ¥æ‰¾
  - æ»‘åŠ¨çª—å£
---

# 2411. æŒ‰ä½æˆ–æœ€å¤§çš„æœ€å°å­æ•°ç»„é•¿åº¦

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`ä½è¿ç®—`](/tag/bit-manipulation.md) [`æ•°ç»„`](/tag/array.md) [`äºŒåˆ†æŸ¥æ‰¾`](/tag/binary-search.md) [`æ»‘åŠ¨çª—å£`](/tag/sliding-window.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or) [`LeetCode`](https://leetcode.com/problems/smallest-subarrays-with-maximum-bitwise-or)

## é¢˜ç›®

You are given a **0-indexed** array `nums` of length `n`, consisting of non-
negative integers. For each index `i` from `0` to `n - 1`, you must determine
the size of the **minimum sized** non-empty subarray of `nums` starting at `i`
(**inclusive**) that has the **maximum** possible **bitwise OR**.

  * In other words, let `Bij` be the bitwise OR of the subarray `nums[i...j]`. You need to find the smallest subarray starting at `i`, such that bitwise OR of this subarray is equal to `max(Bik)` where `i <= k <= n - 1`.

The bitwise OR of an array is the bitwise OR of all the numbers in it.

Return _an integer array_`answer` _of size_`n` _where_`answer[i]`_is the
length of the**minimum** sized subarray starting at _`i` _with**maximum**
bitwise OR._

A **subarray** is a contiguous non-empty sequence of elements within an array.



**Example 1:**

> Input: nums = [1,0,2,1,3]
> 
> Output: [3,3,2,2,1]
> 
> Explanation:
> 
> The maximum possible bitwise OR starting at any index is 3. 
> - Starting at index 0, the shortest subarray that yields it is [1,0,2].
> - Starting at index 1, the shortest subarray that yields the maximum bitwise OR is [0,2,1].
> - Starting at index 2, the shortest subarray that yields the maximum bitwise OR is [2,1].
> - Starting at index 3, the shortest subarray that yields the maximum bitwise OR is [1,3].
> - Starting at index 4, the shortest subarray that yields the maximum bitwise OR is [3].
> 
> Therefore, we return [3,3,2,2,1]. 

**Example 2:**

> Input: nums = [1,2]
> 
> Output: [2,1]
> 
> Explanation: Starting at index 0, the shortest subarray that yields the maximum bitwise OR is of length 2.
> 
> Starting at index 1, the shortest subarray that yields the maximum bitwise OR is of length 1.
> 
> Therefore, we return [2,1].

**Constraints:**

  * `n == nums.length`
  * `1 <= n <= 10^5`
  * `0 <= nums[i] <= 10^9`


## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ªé•¿åº¦ä¸º `n` ä¸‹æ ‡ä» **0**  å¼€å§‹çš„æ•°ç»„ `nums` ï¼Œæ•°ç»„ä¸­æ‰€æœ‰æ•°å­—å‡ä¸ºéè´Ÿæ•´æ•°ã€‚å¯¹äº `0` åˆ° `n - 1` ä¹‹é—´çš„æ¯ä¸€ä¸ªä¸‹æ ‡
`i` ï¼Œä½ éœ€è¦æ‰¾å‡º `nums` ä¸­ä¸€ä¸ª **æœ€å°** éç©ºå­æ•°ç»„ï¼Œå®ƒçš„èµ·å§‹ä½ç½®ä¸º `i` ï¼ˆåŒ…å«è¿™ä¸ªä½ç½®ï¼‰ï¼ŒåŒæ—¶æœ‰ **æœ€å¤§**  çš„
**æŒ‰ä½æˆ–****è¿ç®—å€¼**  ã€‚

  * æ¢è¨€ä¹‹ï¼Œä»¤ `Bij` è¡¨ç¤ºå­æ•°ç»„ `nums[i...j]` çš„æŒ‰ä½æˆ–è¿ç®—çš„ç»“æœï¼Œä½ éœ€è¦æ‰¾åˆ°ä¸€ä¸ªèµ·å§‹ä½ç½®ä¸º `i` çš„æœ€å°å­æ•°ç»„ï¼Œè¿™ä¸ªå­æ•°ç»„çš„æŒ‰ä½æˆ–è¿ç®—çš„ç»“æœç­‰äº `max(Bik)` ï¼Œå…¶ä¸­ `i <= k <= n - 1` ã€‚

ä¸€ä¸ªæ•°ç»„çš„æŒ‰ä½æˆ–è¿ç®—å€¼æ˜¯è¿™ä¸ªæ•°ç»„é‡Œæ‰€æœ‰æ•°å­—æŒ‰ä½æˆ–è¿ç®—çš„ç»“æœã€‚

è¯·ä½ è¿”å›ä¸€ä¸ªå¤§å°ä¸º `n` çš„æ•´æ•°æ•°ç»„ _ _`answer`ï¼Œå…¶ä¸­ _ _`answer[i]`æ˜¯å¼€å§‹ä½ç½®ä¸º `i` ï¼ŒæŒ‰ä½æˆ–è¿ç®—ç»“æœæœ€å¤§ï¼Œä¸”
**æœ€çŸ­**  å­æ•°ç»„çš„é•¿åº¦ã€‚

**å­æ•°ç»„**  æ˜¯æ•°ç»„é‡Œä¸€æ®µè¿ç»­éç©ºå…ƒç´ ç»„æˆçš„åºåˆ—ã€‚



**ç¤ºä¾‹ 1ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** nums = [1,0,2,1,3]
> 
> **è¾“å‡ºï¼š**[3,3,2,2,1]
> 
> **è§£é‡Šï¼š**
> 
> ä»»ä½•ä½ç½®å¼€å§‹ï¼Œæœ€å¤§æŒ‰ä½æˆ–è¿ç®—çš„ç»“æœéƒ½æ˜¯ 3 ã€‚
> - ä¸‹æ ‡ 0 å¤„ï¼Œèƒ½å¾—åˆ°ç»“æœ 3 çš„æœ€çŸ­å­æ•°ç»„æ˜¯ [1,0,2] ã€‚
> - ä¸‹æ ‡ 1 å¤„ï¼Œèƒ½å¾—åˆ°ç»“æœ 3 çš„æœ€çŸ­å­æ•°ç»„æ˜¯ [0,2,1] ã€‚
> - ä¸‹æ ‡ 2 å¤„ï¼Œèƒ½å¾—åˆ°ç»“æœ 3 çš„æœ€çŸ­å­æ•°ç»„æ˜¯ [2,1] ã€‚
> - ä¸‹æ ‡ 3 å¤„ï¼Œèƒ½å¾—åˆ°ç»“æœ 3 çš„æœ€çŸ­å­æ•°ç»„æ˜¯ [1,3] ã€‚
> - ä¸‹æ ‡ 4 å¤„ï¼Œèƒ½å¾—åˆ°ç»“æœ 3 çš„æœ€çŸ­å­æ•°ç»„æ˜¯ [3] ã€‚
> 
> æ‰€ä»¥æˆ‘ä»¬è¿”å› [3,3,2,2,1] ã€‚
> 
> 

**ç¤ºä¾‹ 2ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** nums = [1,2]
> 
> **è¾“å‡ºï¼š**[2,1]
> 
> **è§£é‡Šï¼š** ä¸‹æ ‡ 0 å¤„ï¼Œèƒ½å¾—åˆ°æœ€å¤§æŒ‰ä½æˆ–è¿ç®—å€¼çš„æœ€çŸ­å­æ•°ç»„é•¿åº¦ä¸º 2 ã€‚
> 
> ä¸‹æ ‡ 1 å¤„ï¼Œèƒ½å¾—åˆ°æœ€å¤§æŒ‰ä½æˆ–è¿ç®—å€¼çš„æœ€çŸ­å­æ•°ç»„é•¿åº¦ä¸º 1 ã€‚
> 
> æ‰€ä»¥æˆ‘ä»¬è¿”å› [2,1] ã€‚
> 
> 



**æç¤ºï¼š**

  * `n == nums.length`
  * `1 <= n <= 10^5`
  * `0 <= nums[i] <= 10^9`


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ | åŠ›æ‰£ |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 23 | åˆå¹¶ K ä¸ªå‡åºé“¾è¡¨ | [[âœ“]](/problem/0023.md) |  [`é“¾è¡¨`](/tag/linked-list.md) [`åˆ†æ²»`](/tag/divide-and-conquer.md) [`å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰`](/tag/heap-priority-queue.md) `1+` | ğŸ”´ | [ğŸ€„ï¸](https://leetcode.cn/problems/merge-k-sorted-lists) [ğŸ”—](https://leetcode.com/problems/merge-k-sorted-lists) |
| 898 | å­æ•°ç»„æŒ‰ä½æˆ–æ“ä½œ |  |  [`ä½è¿ç®—`](/tag/bit-manipulation.md) [`æ•°ç»„`](/tag/array.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md) | ğŸŸ  | [ğŸ€„ï¸](https://leetcode.cn/problems/bitwise-ors-of-subarrays) [ğŸ”—](https://leetcode.com/problems/bitwise-ors-of-subarrays) |
| 2419 | æŒ‰ä½ä¸æœ€å¤§çš„æœ€é•¿å­æ•°ç»„ |  |  [`ä½è¿ç®—`](/tag/bit-manipulation.md) [`è„‘ç­‹æ€¥è½¬å¼¯`](/tag/brainteaser.md) [`æ•°ç»„`](/tag/array.md) | ğŸŸ  | [ğŸ€„ï¸](https://leetcode.cn/problems/longest-subarray-with-maximum-bitwise-and) [ğŸ”—](https://leetcode.com/problems/longest-subarray-with-maximum-bitwise-and) |