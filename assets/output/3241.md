# [3241. æ ‡è®°æ‰€æœ‰èŠ‚ç‚¹éœ€è¦çš„æ—¶é—´](https://leetcode.com/problems/time-taken-to-mark-all-nodes)

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`æ ‘`](/leetcode/outline/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/depth-first-search.md) [`å›¾`](/leetcode/outline/tag/graph.md) [`åŠ¨æ€è§„åˆ’`](/leetcode/outline/tag/dynamic-programming.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/time-taken-to-mark-all-nodes)


## é¢˜ç›®

There exists an **undirected** tree with `n` nodes numbered `0` to `n - 1`.
You are given a 2D integer array `edges` of length `n - 1`, where `edges[i] =
[ui, vi]` indicates that there is an edge between nodes `ui` and `vi` in the
tree.

Initially, **all** nodes are **unmarked**. For each node `i`:

  * If `i` is odd, the node will get marked at time `x` if there is **at least** one node _adjacent_ to it which was marked at time `x - 1`.
  * If `i` is even, the node will get marked at time `x` if there is **at least** one node _adjacent_ to it which was marked at time `x - 2`.

Return an array `times` where `times[i]` is the time when all nodes get marked
in the tree, if you mark node `i` at time `t = 0`.

**Note** that the answer for each `times[i]` is **independent** , i.e. when
you mark node `i` all other nodes are _unmarked_.



**Example 1:**

**Input:** edges = [[0,1],[0,2]]

**Output:** [2,4,3]

**Explanation:**

![](https://assets.leetcode.com/uploads/2024/06/01/screenshot-2024-06-02-122236.png)

  * For `i = 0`: 
> 
> * Node 1 is marked at `t = 1`, and Node 2 at `t = 2`.
  * For `i = 1`: 
> 
> * Node 0 is marked at `t = 2`, and Node 2 at `t = 4`.
  * For `i = 2`: 
> 
> * Node 0 is marked at `t = 2`, and Node 1 at `t = 3`.

**Example 2:**

**Input:** edges = [[0,1]]

**Output:** [1,2]

**Explanation:**

![](https://assets.leetcode.com/uploads/2024/06/01/screenshot-2024-06-02-122249.png)

  * For `i = 0`: 
> 
> * Node 1 is marked at `t = 1`.
  * For `i = 1`: 
> 
> * Node 0 is marked at `t = 2`.

**Example 3:**

**Input:** edges = [[2,4],[0,1],[2,3],[0,2]]

**Output:** [4,6,3,5,5]

**Explanation:**

![](https://assets.leetcode.com/uploads/2024/06/03/screenshot-2024-06-03-210550.png)



**Constraints:**

  * `2 <= n <= 10^5`
  * `edges.length == n - 1`
  * `edges[i].length == 2`
  * `0 <= edges[i][0], edges[i][1] <= n - 1`
  * The input is generated such that `edges` represents a valid tree.


## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€æ£µ **æ— å‘**  æ ‘ï¼Œæ ‘ä¸­èŠ‚ç‚¹ä» `0` åˆ° `n - 1` ç¼–å·ã€‚åŒæ—¶ç»™ä½ ä¸€ä¸ªé•¿åº¦ä¸º `n - 1` çš„äºŒç»´æ•´æ•°æ•°ç»„ `edges` ï¼Œå…¶ä¸­
`edges[i] = [ui, vi]` è¡¨ç¤ºèŠ‚ç‚¹ `ui` å’Œ `vi` åœ¨æ ‘ä¸­æœ‰ä¸€æ¡è¾¹ã€‚

ä¸€å¼€å§‹ï¼Œ**æ‰€æœ‰**  èŠ‚ç‚¹éƒ½ **æœªæ ‡è®°**  ã€‚å¯¹äºèŠ‚ç‚¹ `i` ï¼š

  * å½“ `i` æ˜¯å¥‡æ•°æ—¶ï¼Œå¦‚æœæ—¶åˆ» `x - 1` è¯¥èŠ‚ç‚¹æœ‰ **è‡³å°‘**  ä¸€ä¸ªç›¸é‚»èŠ‚ç‚¹å·²ç»è¢«æ ‡è®°äº†ï¼Œé‚£ä¹ˆèŠ‚ç‚¹ `i` ä¼šåœ¨æ—¶åˆ» `x` è¢«æ ‡è®°ã€‚
  * å½“ `i` æ˜¯å¶æ•°æ—¶ï¼Œå¦‚æœæ—¶åˆ» `x - 2` è¯¥èŠ‚ç‚¹æœ‰ **è‡³å°‘**  ä¸€ä¸ªç›¸é‚»èŠ‚ç‚¹å·²ç»è¢«æ ‡è®°äº†ï¼Œé‚£ä¹ˆèŠ‚ç‚¹ `i` ä¼šåœ¨æ—¶åˆ» `x` è¢«æ ‡è®°ã€‚

è¯·ä½ è¿”å›ä¸€ä¸ªæ•°ç»„ `times` ï¼Œè¡¨ç¤ºå¦‚æœä½ åœ¨æ—¶åˆ» `t = 0` æ ‡è®°èŠ‚ç‚¹ `i` ï¼Œé‚£ä¹ˆæ—¶åˆ» `times[i]` æ—¶ï¼Œæ ‘ä¸­æ‰€æœ‰èŠ‚ç‚¹éƒ½ä¼šè¢«æ ‡è®°ã€‚

è¯·æ³¨æ„ï¼Œæ¯ä¸ª `times[i]` çš„ç­”æ¡ˆéƒ½æ˜¯ç‹¬ç«‹çš„ï¼Œå³å½“ä½ æ ‡è®°èŠ‚ç‚¹ `i` æ—¶ï¼Œæ‰€æœ‰å…¶ä»–èŠ‚ç‚¹éƒ½æœªæ ‡è®°ã€‚



**ç¤ºä¾‹ 1ï¼š**

**è¾“å…¥ï¼š** edges = [[0,1],[0,2]]

**è¾“å‡ºï¼š**[2,4,3]

**è§£é‡Šï¼š**

![](https://assets.leetcode.com/uploads/2024/06/01/screenshot-2024-06-02-122236.png)

  * å¯¹äº `i = 0` ï¼š 
> 
> * èŠ‚ç‚¹ 1 åœ¨æ—¶åˆ» `t = 1` è¢«æ ‡è®°ï¼ŒèŠ‚ç‚¹ 2 åœ¨æ—¶åˆ» `t = 2` è¢«æ ‡è®°ã€‚
  * å¯¹äº `i = 1` ï¼š 
> 
> * èŠ‚ç‚¹ 0 åœ¨æ—¶åˆ» `t = 2` è¢«æ ‡è®°ï¼ŒèŠ‚ç‚¹ 2 åœ¨æ—¶åˆ» `t = 4` è¢«æ ‡è®°ã€‚
  * å¯¹äº `i = 2` ï¼š 
> 
> * èŠ‚ç‚¹ 0 åœ¨æ—¶åˆ» `t = 2` è¢«æ ‡è®°ï¼ŒèŠ‚ç‚¹ 1 åœ¨æ—¶åˆ» `t = 3` è¢«æ ‡è®°ã€‚

**ç¤ºä¾‹ 2ï¼š**

**è¾“å…¥ï¼š** edges = [[0,1]]

**è¾“å‡ºï¼š**[1,2]

**è§£é‡Šï¼š**

![](https://assets.leetcode.com/uploads/2024/06/01/screenshot-2024-06-02-122249.png)

  * å¯¹äº `i = 0` ï¼š 
> 
> * èŠ‚ç‚¹ 1 åœ¨æ—¶åˆ» `t = 1` è¢«æ ‡è®°ã€‚
  * å¯¹äº `i = 1` ï¼š 
> 
> * èŠ‚ç‚¹ 0 åœ¨æ—¶åˆ» `t = 2` è¢«æ ‡è®°ã€‚

**ç¤ºä¾‹ 3ï¼š**

**è¾“å…¥ï¼š** edges = [[2,4],[0,1],[2,3],[0,2]]

**è¾“å‡ºï¼š**[4,6,3,5,5]

**è§£é‡Šï¼š**

![](https://assets.leetcode.com/uploads/2024/06/03/screenshot-2024-06-03-210550.png)



**æç¤ºï¼š**

  * `2 <= n <= 10^5`
  * `edges.length == n - 1`
  * `edges[i].length == 2`
  * `0 <= edges[i][0], edges[i][1] <= n - 1`
  * è¾“å…¥ä¿è¯ `edges` è¡¨ç¤ºä¸€æ£µåˆæ³•çš„æ ‘ã€‚


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 834 | [æ ‘ä¸­è·ç¦»ä¹‹å’Œ](https://leetcode.com/problems/sum-of-distances-in-tree) |  |  [`æ ‘`](/leetcode/outline/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/depth-first-search.md) [`å›¾`](/leetcode/outline/tag/graph.md) `1+` | <font color=#ff334b>Hard</font> |
| 2467 | [æ ‘ä¸Šæœ€å¤§å¾—åˆ†å’Œè·¯å¾„](https://leetcode.com/problems/most-profitable-path-in-a-tree) |  |  [`æ ‘`](/leetcode/outline/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/breadth-first-search.md) `2+` | <font color=#ffb800>Medium</font> |
| 3313 | [Find the Last Marked Nodes in Tree](https://leetcode.com/problems/find-the-last-marked-nodes-in-tree) |  |  [`æ ‘`](/leetcode/outline/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/depth-first-search.md) | <font color=#ff334b>Hard</font> |

<style>
.blue {
    background-color: #096dd9;
    padding: 0.25rem 0.5rem;
    margin: 0;
    font-size: 0.85em;
    border-radius: 3px;
    color: white;
    font-weight: 500;
}
table th:first-of-type { width: 10%; }
table th:nth-of-type(2) { width: 35%; }
table th:nth-of-type(3) { width: 10%; }
table th:nth-of-type(4) { width: 35%; }
table th:nth-of-type(5) { width: 10%; }
</style>
