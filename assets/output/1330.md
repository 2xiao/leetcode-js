# [1330. ç¿»è½¬å­æ•°ç»„å¾—åˆ°æœ€å¤§çš„æ•°ç»„å€¼](https://2xiao.github.io/leetcode-js/problem/1330.html)

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`è´ªå¿ƒ`](/tag/greedy.md) [`æ•°ç»„`](/tag/array.md) [`æ•°å­¦`](/tag/math.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/reverse-subarray-to-maximize-array-value) [`LeetCode`](https://leetcode.com/problems/reverse-subarray-to-maximize-array-value)

## é¢˜ç›®

You are given an integer array `nums`. The _value_ of this array is defined as
the sum of `|nums[i] - nums[i + 1]|` for all `0 <= i < nums.length - 1`.

You are allowed to select any subarray of the given array and reverse it. You
can perform this operation **only once**.

Find maximum possible value of the final array.



**Example 1:**

> Input: nums = [2,3,1,5,4]
> 
> Output: 10
> 
> Explanation: By reversing the subarray [3,1,5] the array becomes [2,5,1,3,4] whose value is 10.

**Example 2:**

> Input: nums = [2,4,9,24,2,1,10]
> 
> Output: 68

**Constraints:**

  * `2 <= nums.length <= 3 * 10^4`
  * `-10^5 <= nums[i] <= 10^5`
  * The answer is guaranteed to fit in a 32-bit integer.


## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` ã€‚ã€Œæ•°ç»„å€¼ã€å®šä¹‰ä¸ºæ‰€æœ‰æ»¡è¶³ `0 <= i < nums.length-1` çš„ `|nums[i]-nums[i+1]|`
çš„å’Œã€‚

ä½ å¯ä»¥é€‰æ‹©ç»™å®šæ•°ç»„çš„ä»»æ„å­æ•°ç»„ï¼Œå¹¶å°†è¯¥å­æ•°ç»„ç¿»è½¬ã€‚ä½†ä½ åªèƒ½æ‰§è¡Œè¿™ä¸ªæ“ä½œ **ä¸€æ¬¡** ã€‚

è¯·ä½ æ‰¾åˆ°å¯è¡Œçš„æœ€å¤§ **æ•°ç»„å€¼  **ã€‚



**ç¤ºä¾‹ 1ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** nums = [2,3,1,5,4]
> 
> **è¾“å‡ºï¼š** 10
> 
> **è§£é‡Šï¼š** é€šè¿‡ç¿»è½¬å­æ•°ç»„ [3,1,5] ï¼Œæ•°ç»„å˜æˆ [2,5,1,3,4] ï¼Œæ•°ç»„å€¼ä¸º 10 ã€‚
> 
> 

**ç¤ºä¾‹ 2ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** nums = [2,4,9,24,2,1,10]
> 
> **è¾“å‡ºï¼š** 68
> 
> 



**æç¤ºï¼š**

  * `2 <= nums.length <= 3*10^4`
  * `-10^5 <= nums[i] <= 10^5`
  * ç­”æ¡ˆä¿è¯åœ¨ 32 ä½æ•´æ•°èŒƒå›´å†…ã€‚


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```