# [2421. å¥½è·¯å¾„çš„æ•°ç›®](https://leetcode.com/problems/number-of-good-paths)

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`æ ‘`](/leetcode/outline/tag/tree.md) [`å¹¶æŸ¥é›†`](/leetcode/outline/tag/union-find.md) [`å›¾`](/leetcode/outline/tag/graph.md) [`æ•°ç»„`](/leetcode/outline/tag/array.md) [`å“ˆå¸Œè¡¨`](/leetcode/outline/tag/hash-table.md) [`æ’åº`](/leetcode/outline/tag/sorting.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/number-of-good-paths)


## é¢˜ç›®

There is a tree (i.e. a connected, undirected graph with no cycles) consisting
of `n` nodes numbered from `0` to `n - 1` and exactly `n - 1` edges.

You are given a **0-indexed** integer array `vals` of length `n` where
`vals[i]` denotes the value of the `ith` node. You are also given a 2D integer
array `edges` where `edges[i] = [ai, bi]` denotes that there exists an
**undirected** edge connecting nodes `ai` and `bi`.

A **good path** is a simple path that satisfies the following conditions:

  1. The starting node and the ending node have the **same** value.
  2. All nodes between the starting node and the ending node have values **less than or equal to** the starting node (i.e. the starting node's value should be the maximum value along the path).

Return _the number of distinct good paths_.

Note that a path and its reverse are counted as the **same** path. For
example, `0 -> 1` is considered to be the same as `1 -> 0`. A single node is
also considered as a valid path.



**Example 1:**

![](https://assets.leetcode.com/uploads/2022/08/04/f9caaac15b383af9115c5586779dec5.png)

> Input: vals = [1,3,2,1,3], edges = [[0,1],[0,2],[2,3],[2,4]]
> 
> Output: 6
> 
> Explanation: There are 5 good paths consisting of a single node.
> 
> There is 1 additional good path: 1 -> 0 -> 2 -> 4.
> 
> (The reverse path 4 -> 2 -> 0 -> 1 is treated as the same as 1 -> 0 -> 2 -> 4.)
> 
> Note that 0 -> 2 -> 3 is not a good path because vals[2] > vals[0].

**Example 2:**

![](https://assets.leetcode.com/uploads/2022/08/04/149d3065ec165a71a1b9aec890776ff.png)

> Input: vals = [1,1,2,2,3], edges = [[0,1],[1,2],[2,3],[2,4]]
> 
> Output: 7
> 
> Explanation: There are 5 good paths consisting of a single node.
> 
> There are 2 additional good paths: 0 -> 1 and 2 -> 3.

**Example 3:**

![](https://assets.leetcode.com/uploads/2022/08/04/31705e22af3d9c0a557459bc7d1b62d.png)

> Input: vals = [1], edges = []
> 
> Output: 1
> 
> Explanation: The tree consists of only one node, so there is one good path.

**Constraints:**

  * `n == vals.length`
  * `1 <= n <= 3 * 10^4`
  * `0 <= vals[i] <= 10^5`
  * `edges.length == n - 1`
  * `edges[i].length == 2`
  * `0 <= ai, bi < n`
  * `ai != bi`
  * `edges` represents a valid tree.


## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€æ£µ `n` ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼ˆè¿é€šæ— å‘æ— ç¯çš„å›¾ï¼‰ï¼ŒèŠ‚ç‚¹ç¼–å·ä» `0` åˆ° `n - 1` ä¸”æ°å¥½æœ‰ `n - 1` æ¡è¾¹ã€‚

ç»™ä½ ä¸€ä¸ªé•¿åº¦ä¸º `n` ä¸‹æ ‡ä» **0**  å¼€å§‹çš„æ•´æ•°æ•°ç»„ `vals` ï¼Œåˆ†åˆ«è¡¨ç¤ºæ¯ä¸ªèŠ‚ç‚¹çš„å€¼ã€‚åŒæ—¶ç»™ä½ ä¸€ä¸ªäºŒç»´æ•´æ•°æ•°ç»„ `edges` ï¼Œå…¶ä¸­
`edges[i] = [ai, bi]` è¡¨ç¤ºèŠ‚ç‚¹ `ai` å’Œ `bi` ä¹‹é—´æœ‰ä¸€æ¡ **æ— å‘**  è¾¹ã€‚

ä¸€æ¡ **å¥½è·¯å¾„**  éœ€è¦æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š

  1. å¼€å§‹èŠ‚ç‚¹å’Œç»“æŸèŠ‚ç‚¹çš„å€¼ **ç›¸åŒ**  ã€‚
  2. å¼€å§‹èŠ‚ç‚¹å’Œç»“æŸèŠ‚ç‚¹ä¸­é—´çš„æ‰€æœ‰èŠ‚ç‚¹å€¼éƒ½ **å°äºç­‰äº**  å¼€å§‹èŠ‚ç‚¹çš„å€¼ï¼ˆä¹Ÿå°±æ˜¯è¯´å¼€å§‹èŠ‚ç‚¹çš„å€¼åº”è¯¥æ˜¯è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„æœ€å¤§å€¼ï¼‰ã€‚

è¯·ä½ è¿”å›ä¸åŒå¥½è·¯å¾„çš„æ•°ç›®ã€‚

æ³¨æ„ï¼Œä¸€æ¡è·¯å¾„å’Œå®ƒåå‘çš„è·¯å¾„ç®—ä½œ **åŒä¸€**  è·¯å¾„ã€‚æ¯”æ–¹è¯´ï¼Œ `0 -> 1` ä¸ `1 -> 0` è§†ä¸ºåŒä¸€æ¡è·¯å¾„ã€‚å•ä¸ªèŠ‚ç‚¹ä¹Ÿè§†ä¸ºä¸€æ¡åˆæ³•è·¯å¾„ã€‚



**ç¤ºä¾‹  1ï¼š**

![](https://assets.leetcode.com/uploads/2022/08/04/f9caaac15b383af9115c5586779dec5.png)

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** vals = [1,3,2,1,3], edges = [[0,1],[0,2],[2,3],[2,4]]
> 
> **è¾“å‡ºï¼š** 6
> 
> **è§£é‡Šï¼š** æ€»å…±æœ‰ 5 æ¡å•ä¸ªèŠ‚ç‚¹çš„å¥½è·¯å¾„ã€‚
> 
> è¿˜æœ‰ 1 æ¡å¥½è·¯å¾„ï¼š1 -> 0 -> 2 -> 4 ã€‚
> 
> ï¼ˆåæ–¹å‘çš„è·¯å¾„ 4 -> 2 -> 0 -> 1 è§†ä¸ºè·Ÿ 1 -> 0 -> 2 -> 4 ä¸€æ ·çš„è·¯å¾„ï¼‰
> 
> æ³¨æ„ 0 -> 2 -> 3 ä¸æ˜¯ä¸€æ¡å¥½è·¯å¾„ï¼Œå› ä¸º vals[2] > vals[0] ã€‚
> 
> 

**ç¤ºä¾‹ 2ï¼š**

![](https://assets.leetcode.com/uploads/2022/08/04/149d3065ec165a71a1b9aec890776ff.png)

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** vals = [1,1,2,2,3], edges = [[0,1],[1,2],[2,3],[2,4]]
> 
> **è¾“å‡ºï¼š** 7
> 
> **è§£é‡Šï¼š** æ€»å…±æœ‰ 5 æ¡å•ä¸ªèŠ‚ç‚¹çš„å¥½è·¯å¾„ã€‚
> 
> è¿˜æœ‰ 2 æ¡å¥½è·¯å¾„ï¼š0 -> 1 å’Œ 2 -> 3 ã€‚
> 
> 

**ç¤ºä¾‹ 3ï¼š**

![](https://assets.leetcode.com/uploads/2022/08/04/31705e22af3d9c0a557459bc7d1b62d.png)

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** vals = [1], edges = []
> 
> **è¾“å‡ºï¼š** 1
> 
> **è§£é‡Šï¼š** è¿™æ£µæ ‘åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæ‰€ä»¥åªæœ‰ä¸€æ¡å¥½è·¯å¾„ã€‚
> 
> 



**æç¤ºï¼š**

  * `n == vals.length`
  * `1 <= n <= 3 * 10^4`
  * `0 <= vals[i] <= 10^5`
  * `edges.length == n - 1`
  * `edges[i].length == 2`
  * `0 <= ai, bi < n`
  * `ai != bi`
  * `edges` è¡¨ç¤ºä¸€æ£µåˆæ³•çš„æ ‘ã€‚


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

:::: md-demo ç›¸å…³é¢˜ç›®
- [æ£€æŸ¥è¾¹é•¿åº¦é™åˆ¶çš„è·¯å¾„æ˜¯å¦å­˜åœ¨](https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths)
- [æ£€æŸ¥è¾¹é•¿åº¦é™åˆ¶çš„è·¯å¾„æ˜¯å¦å­˜åœ¨ II](https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths-ii)
- [æœ€é•¿çš„ç¾å¥½å­å­—ç¬¦ä¸²](https://leetcode.com/problems/longest-nice-substring)
- [ç»Ÿè®¡æ•°ç»„ä¸­å¥½ä¸‰å…ƒç»„æ•°ç›®](https://leetcode.com/problems/count-good-triplets-in-an-array)
- [ç»Ÿè®¡ç›¸ä¼¼å­—ç¬¦ä¸²å¯¹çš„æ•°ç›®](https://leetcode.com/problems/count-pairs-of-similar-strings)

::::
