---
title: 3412. 计算字符串的镜像分数
description: LeetCode 3412. 计算字符串的镜像分数题解，Find Mirror Score of a String，包含解题思路、复杂度分析以及完整的 JavaScript 代码实现。
keywords:
  - LeetCode
  - 3412. 计算字符串的镜像分数
  - 计算字符串的镜像分数
  - Find Mirror Score of a String
  - 解题思路
  - 栈
  - 哈希表
  - 字符串
  - 模拟
---

# 3412. 计算字符串的镜像分数

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`栈`](/tag/stack.md) [`哈希表`](/tag/hash-table.md) [`字符串`](/tag/string.md) [`模拟`](/tag/simulation.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/find-mirror-score-of-a-string) [`LeetCode`](https://leetcode.com/problems/find-mirror-score-of-a-string)

## 题目

You are given a string `s`.

We define the **mirror** of a letter in the English alphabet as its
corresponding letter when the alphabet is reversed. For example, the mirror of
`'a'` is `'z'`, and the mirror of `'y'` is `'b'`.

Initially, all characters in the string `s` are **unmarked**.

You start with a score of 0, and you perform the following process on the
string `s`:

  * Iterate through the string from left to right.
  * At each index `i`, find the closest **unmarked** index `j` such that `j < i` and `s[j]` is the mirror of `s[i]`. Then, **mark** both indices `i` and `j`, and add the value `i - j` to the total score.
  * If no such index `j` exists for the index `i`, move on to the next index without making any changes.

Return the total score at the end of the process.



**Example 1:**

**Input:** s = "aczzx"

**Output:** 5

**Explanation:**

  * `i = 0`. There is no index `j` that satisfies the conditions, so we skip.
  * `i = 1`. There is no index `j` that satisfies the conditions, so we skip.
  * `i = 2`. The closest index `j` that satisfies the conditions is `j = 0`, so we mark both indices 0 and 2, and then add `2 - 0 = 2` to the score.
  * `i = 3`. There is no index `j` that satisfies the conditions, so we skip.
  * `i = 4`. The closest index `j` that satisfies the conditions is `j = 1`, so we mark both indices 1 and 4, and then add `4 - 1 = 3` to the score.

**Example 2:**

**Input:** s = "abcdef"

**Output:** 0

**Explanation:**

For each index `i`, there is no index `j` that satisfies the conditions.



**Constraints:**

  * `1 <= s.length <= 10^5`
  * `s` consists only of lowercase English letters.


## 题目大意

给你一个字符串 `s`。

英文字母中每个字母的 **镜像  **定义为反转字母表之后对应位置上的字母。例如，`'a'` 的镜像是 `'z'`，`'y'` 的镜像是 `'b'`。

最初，字符串 `s` 中的所有字符都 **未标记  **。

字符串 `s` 的初始分数为 0 ，你需要对其执行以下过程：

  * 从左到右遍历字符串。
  * 对于每个下标 `i `，找到距离最近的 **未标记** 下标 `j`，下标 `j` 需要满足 `j < i` 且 `s[j]` 是 `s[i]` 的镜像。然后 **标记** 下标 `i` 和 `j`，总分加上 `i - j` 的值。
  * 如果对于下标 `i`，不存在满足条件的下标 `j`，则跳过该下标，继续处理下一个下标，不需要进行标记。

返回最终的总分。



**示例 1：**

**输入：** s = "aczzx"

**输出：** 5

**解释：**

  * `i = 0`。没有符合条件的下标 `j`，跳过。
  * `i = 1`。没有符合条件的下标 `j`，跳过。
  * `i = 2`。距离最近的符合条件的下标是 `j = 0`，因此标记下标 0 和 2，然后将总分加上 `2 - 0 = 2` 。
  * `i = 3`。没有符合条件的下标 `j`，跳过。
  * `i = 4`。距离最近的符合条件的下标是 `j = 1`，因此标记下标 1 和 4，然后将总分加上 `4 - 1 = 3` 。

**示例 2：**

**输入：** s = "abcdef"

**输出：** 0

**解释：**

对于每个下标 `i`，都不存在满足条件的下标 `j`。



**提示：**

  * `1 <= s.length <= 10^5`
  * `s` 仅由小写英文字母组成。


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```