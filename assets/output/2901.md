# [2901. æœ€é•¿ç›¸é‚»ä¸ç›¸ç­‰å­åºåˆ— II](https://2xiao.github.io/leetcode-js/problem/2901.html)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ•°ç»„`](/tag/array.md) [`å­—ç¬¦ä¸²`](/tag/string.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/longest-unequal-adjacent-groups-subsequence-ii) [`LeetCode`](https://leetcode.com/problems/longest-unequal-adjacent-groups-subsequence-ii)

## é¢˜ç›®

You are given a string array `words`, and an array `groups`, both arrays
having length `n`.

The **hamming distance** between two strings of equal length is the number of
positions at which the corresponding characters are **different**.

You need to select the **longest** subsequence from an array of indices `[0,
1, ..., n - 1]`, such that for the subsequence denoted as `[i0, i1, ...,
ik-1]` having length `k`, the following holds:

  * For **adjacent** indices in the subsequence, their corresponding groups are **unequal** , i.e., `groups[ij] != groups[ij+1]`, for each `j` where `0 < j + 1 < k`.
  * `words[ij]` and `words[ij+1]` are **equal** in length, and the **hamming distance** between them is `1`, where `0 < j + 1 < k`, for all indices in the subsequence.

Return _a string array containing the words corresponding to the indices**(in
order)** in the selected subsequence_. If there are multiple answers, return
_any of them_.

**Note:** strings in `words` may be **unequal** in length.



**Example 1:**

**Input:** words = ["bab","dab","cab"], groups = [1,2,2]

**Output:**["bab","cab"]

**Explanation:** A subsequence that can be selected is `[0,2]`.

  * `groups[0] != groups[2]`
  * `words[0].length == words[2].length`, and the hamming distance between them is 1.

So, a valid answer is `[words[0],words[2]] = ["bab","cab"]`.

Another subsequence that can be selected is `[0,1]`.

  * `groups[0] != groups[1]`
  * `words[0].length == words[1].length`, and the hamming distance between them is `1`.

So, another valid answer is `[words[0],words[1]] = ["bab","dab"]`.

It can be shown that the length of the longest subsequence of indices that
satisfies the conditions is `2`.

**Example 2:**

**Input:** words = ["a","b","c","d"], groups = [1,2,3,4]

**Output:**["a","b","c","d"]

**Explanation:** We can select the subsequence `[0,1,2,3]`.

It satisfies both conditions.

Hence, the answer is `[words[0],words[1],words[2],words[3]] =
["a","b","c","d"]`.

It has the longest length among all subsequences of indices that satisfy the
conditions.

Hence, it is the only answer.



**Constraints:**

  * `1 <= n == words.length == groups.length <= 1000`
  * `1 <= words[i].length <= 10`
  * `1 <= groups[i] <= n`
  * `words` consists of **distinct** strings.
  * `words[i]` consists of lowercase English letters.


## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ªæ•´æ•° `n` å’Œä¸€ä¸ªä¸‹æ ‡ä» **0**  å¼€å§‹çš„å­—ç¬¦ä¸²æ•°ç»„ `words` ï¼Œå’Œä¸€ä¸ªä¸‹æ ‡ä» **0**  å¼€å§‹çš„æ•°ç»„ `groups`
ï¼Œä¸¤ä¸ªæ•°ç»„é•¿åº¦éƒ½æ˜¯ `n` ã€‚

ä¸¤ä¸ªé•¿åº¦ç›¸ç­‰å­—ç¬¦ä¸²çš„ **æ±‰æ˜è·ç¦»**  å®šä¹‰ä¸ºå¯¹åº”ä½ç½®å­—ç¬¦ **ä¸åŒ**  çš„æ•°ç›®ã€‚

ä½ éœ€è¦ä»ä¸‹æ ‡ `[0, 1, ..., n - 1]` ä¸­é€‰å‡ºä¸€ä¸ª **æœ€é•¿ å­åºåˆ—** ï¼Œå°†è¿™ä¸ªå­åºåˆ—è®°ä½œé•¿åº¦ä¸º `k` çš„ `[i0, i1, ...,
ik - 1]` ï¼Œå®ƒéœ€è¦æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š

  * **ç›¸é‚»** ä¸‹æ ‡å¯¹åº”çš„ `groups` å€¼ **ä¸åŒ** ã€‚å³ï¼Œå¯¹äºæ‰€æœ‰æ»¡è¶³ `0 < j + 1 < k` çš„ `j` éƒ½æœ‰ `groups[ij] != groups[ij + 1]` ã€‚
  * å¯¹äºæ‰€æœ‰ `0 < j + 1 < k` çš„ä¸‹æ ‡ `j` ï¼Œéƒ½æ»¡è¶³ `words[ij]` å’Œ `words[ij + 1]` çš„é•¿åº¦ **ç›¸ç­‰**  ï¼Œä¸”ä¸¤ä¸ªå­—ç¬¦ä¸²ä¹‹é—´çš„ **æ±‰æ˜è·ç¦»**  ä¸º `1` ã€‚

è¯·ä½ è¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ï¼Œå®ƒæ˜¯ä¸‹æ ‡å­åºåˆ— **ä¾æ¬¡**  å¯¹åº” `words` æ•°ç»„ä¸­çš„å­—ç¬¦ä¸²è¿æ¥å½¢æˆçš„å­—ç¬¦ä¸²æ•°ç»„ã€‚å¦‚æœæœ‰å¤šä¸ªç­”æ¡ˆï¼Œè¿”å›ä»»æ„ä¸€ä¸ªã€‚

**å­åºåˆ—**  æŒ‡çš„æ˜¯ä»åŸæ•°ç»„ä¸­åˆ æ‰ä¸€äº›ï¼ˆä¹Ÿå¯èƒ½ä¸€ä¸ªä¹Ÿä¸åˆ æ‰ï¼‰å…ƒç´ ï¼Œå‰©ä½™å…ƒç´ ä¸æ”¹å˜ç›¸å¯¹ä½ç½®å¾—åˆ°çš„æ–°çš„æ•°ç»„ã€‚

**æ³¨æ„ï¼š**`words` ä¸­çš„å­—ç¬¦ä¸²é•¿åº¦å¯èƒ½ **ä¸ç›¸ç­‰**  ã€‚



**ç¤ºä¾‹ 1ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** n = 3, words = ["bab","dab","cab"], groups = [1,2,2]
> 
> **è¾“å‡ºï¼š**["bab","cab"]
> 
> **è§£é‡Šï¼š** ä¸€ä¸ªå¯è¡Œçš„å­åºåˆ—æ˜¯ [0,2] ã€‚
> - groups[0] != groups[2]
> - words[0].length == words[2].length ä¸”å®ƒä»¬ä¹‹é—´çš„æ±‰æ˜è·ç¦»ä¸º 1 ã€‚
> 
> æ‰€ä»¥ä¸€ä¸ªå¯è¡Œçš„ç­”æ¡ˆæ˜¯ [words[0],words[2]] = ["bab","cab"] ã€‚
> 
> å¦ä¸€ä¸ªå¯è¡Œçš„å­åºåˆ—æ˜¯ [0,1] ã€‚
> - groups[0] != groups[1]
> - words[0].length = words[1].length ä¸”å®ƒä»¬ä¹‹é—´çš„æ±‰æ˜è·ç¦»ä¸º 1 ã€‚
> 
> æ‰€ä»¥å¦ä¸€ä¸ªå¯è¡Œçš„ç­”æ¡ˆæ˜¯ [words[0],words[1]] = ["bab","dab"] ã€‚
> 
> ç¬¦åˆé¢˜æ„çš„æœ€é•¿å­åºåˆ—çš„é•¿åº¦ä¸º 2 ã€‚

**ç¤ºä¾‹ 2ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** n = 4, words = ["a","b","c","d"], groups = [1,2,3,4]
> 
> **è¾“å‡ºï¼š**["a","b","c","d"]
> 
> **è§£é‡Šï¼š** æˆ‘ä»¬é€‰æ‹©å­åºåˆ— [0,1,2,3] ã€‚
> 
> å®ƒåŒæ—¶æ»¡è¶³ä¸¤ä¸ªæ¡ä»¶ã€‚
> 
> æ‰€ä»¥ç­”æ¡ˆä¸º [words[0],words[1],words[2],words[3]] = ["a","b","c","d"] ã€‚
> 
> å®ƒæ˜¯æ‰€æœ‰ä¸‹æ ‡å­åºåˆ—é‡Œæœ€é•¿ä¸”æ»¡è¶³æ‰€æœ‰æ¡ä»¶çš„ã€‚
> 
> æ‰€ä»¥å®ƒæ˜¯å”¯ä¸€çš„ç­”æ¡ˆã€‚
> 
> 



**æç¤ºï¼š**

  * `1 <= n == words.length == groups.length <= 1000`
  * `1 <= words[i].length <= 10`
  * `1 <= groups[i] <= n`
  * `words` ä¸­çš„å­—ç¬¦ä¸² **äº’ä¸ç›¸åŒ**  ã€‚
  * `words[i]` åªåŒ…å«å°å†™è‹±æ–‡å­—æ¯ã€‚


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```