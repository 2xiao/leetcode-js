---
title: 3406. 从盒子中找出字典序最大的字符串 II 🔒
description: LeetCode 3406. 从盒子中找出字典序最大的字符串 II 🔒题解，Find the Lexicographically Largest String From the Box II，包含解题思路、复杂度分析以及完整的 JavaScript 代码实现。
keywords:
  - LeetCode
  - 3406. 从盒子中找出字典序最大的字符串 II 🔒
  - 从盒子中找出字典序最大的字符串 II
  - Find the Lexicographically Largest String From the Box II
  - 解题思路
  - 双指针
  - 字符串
---

# 3406. 从盒子中找出字典序最大的字符串 II 🔒

🔴 <font color=#ff334b>Hard</font>&emsp; 🔖&ensp; [`双指针`](/tag/two-pointers.md) [`字符串`](/tag/string.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/find-the-lexicographically-largest-string-from-the-box-ii) [`LeetCode`](https://leetcode.com/problems/find-the-lexicographically-largest-string-from-the-box-ii)

## 题目

You are given a string `word`, and an integer `numFriends`.

Alice is organizing a game for her `numFriends` friends. There are multiple
rounds in the game, where in each round:

  * `word` is split into `numFriends` **non-empty** strings, such that no previous round has had the **exact** same split.
  * All the split words are put into a box.

Find the **lexicographically largest** string from the box after all the
rounds are finished.

A string `a` is **lexicographically smaller** than a string `b` if in the
first position where `a` and `b` differ, string `a` has a letter that appears
earlier in the alphabet than the corresponding letter in `b`.  
If the first `min(a.length, b.length)` characters do not differ, then the
shorter string is the lexicographically smaller one.



**Example 1:**

**Input:** word = "dbca", numFriends = 2

**Output:** "dbc"

**Explanation:**

All possible splits are:

  * `"d"` and `"bca"`.
  * `"db"` and `"ca"`.
  * `"dbc"` and `"a"`.

**Example 2:**

**Input:** word = "gggg", numFriends = 4

**Output:** "g"

**Explanation:**

The only possible split is: `"g"`, `"g"`, `"g"`, and `"g"`.



**Constraints:**

  * `1 <= word.length <= 2 * 10^5`
  * `word` consists only of lowercase English letters.
  * `1 <= numFriends <= word.length`


## 题目大意

给你一个字符串 `word` 和一个整数 `numFriends`。

Alice 正在为她的 `numFriends` 位朋友组织一个游戏。游戏分为多个回合，在每一回合中：

  * `word` 被分割成 `numFriends` 个 **非空  **字符串，且该分割方式与之前的任意回合所采用的都 **不完全相同  **。
  * 所有分割出的字符串都会被放入一个盒子中。

在所有回合结束后，找出盒子中 **字典序最大的  **字符串。

字符串 `a` 的字典序 **小于  **字符串 `b` 的前提是：在两个字符串上第一处不同的位置上，`a` 的字母在字母表中的顺序早于 `b`
中对应的字母。  
如果前 `min(a.length, b.length)` 个字符都相同，那么较短的字符串字典序更小。



**示例 1：**

**输入:** word = "dbca", numFriends = 2

**输出:** "dbc"

**解释:**  

所有可能的分割方式为：

  * `"d"` 和 `"bca"`。
  * `"db"` 和 `"ca"`。
  * `"dbc"` 和 `"a"`。

**示例 2：**

**输入:** word = "gggg", numFriends = 4

**输出:** "g"

**解释:**  

唯一可能的分割方式为：`"g"`, `"g"`, `"g"`, 和 `"g"`。



**提示:**

  * `1 <= word.length <= 2 * 10^5`
  * `word` 仅由小写英文字母组成。
  * `1 <= numFriends <= word.length`




## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```