---
title: 2313. 二叉树中得到结果所需的最少翻转次数 🔒
description: LeetCode 2313. 二叉树中得到结果所需的最少翻转次数 🔒题解，Minimum Flips in Binary Tree to Get Result，包含解题思路、复杂度分析以及完整的 JavaScript 代码实现。
keywords:
  - LeetCode
  - 2313. 二叉树中得到结果所需的最少翻转次数 🔒
  - 二叉树中得到结果所需的最少翻转次数
  - Minimum Flips in Binary Tree to Get Result
  - 解题思路
  - 树
  - 深度优先搜索
  - 动态规划
  - 二叉树
---

# 2313. 二叉树中得到结果所需的最少翻转次数 🔒

🔴 <font color=#ff334b>Hard</font>&emsp; 🔖&ensp; [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`动态规划`](/tag/dynamic-programming.md) [`二叉树`](/tag/binary-tree.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/minimum-flips-in-binary-tree-to-get-result) [`LeetCode`](https://leetcode.com/problems/minimum-flips-in-binary-tree-to-get-result)

## 题目

You are given the `root` of a **binary tree** with the following properties:

  * **Leaf nodes** have either the value `0` or `1`, representing `false` and `true` respectively.
  * **Non-leaf nodes** have either the value `2`, `3`, `4`, or `5`, representing the boolean operations `OR`, `AND`, `XOR`, and `NOT`, respectively.

You are also given a boolean `result`, which is the desired result of the
**evaluation** of the `root` node.

The evaluation of a node is as follows:

  * If the node is a leaf node, the evaluation is the **value** of the node, i.e. `true` or `false`.
  * Otherwise, **evaluate** the node's children and **apply** the boolean operation of its value with the children's evaluations.

In one operation, you can **flip** a leaf node, which causes a `false` node to
become `true`, and a `true` node to become `false`.

Return _the minimum number of operations that need to be performed such that
the evaluation of_`root` _yields_`result`. It can be shown that there is
always a way to achieve `result`.

A **leaf node** is a node that has zero children.

Note: `NOT` nodes have either a left child or a right child, but other non-
leaf nodes have both a left child and a right child.



**Example 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2300-2399/2313.Minimum%20Flips%20in%20Binary%20Tree%20to%20Get%20Result/images/operationstree.png)

> Input: root = [3,5,4,2,null,1,1,1,0], result = true
> 
> Output: 2
> 
> Explanation:
> 
> It can be shown that a minimum of 2 nodes have to be flipped to make the root of the tree
> 
> evaluate to true. One way to achieve this is shown in the diagram above.

**Example 2:**

> Input: root = [0], result = false
> 
> Output: 0
> 
> Explanation:
> 
> The root of the tree already evaluates to false, so 0 nodes have to be flipped.

**Constraints:**

  * The number of nodes in the tree is in the range `[1, 105]`.
  * `0 <= Node.val <= 5`
  * `OR`, `AND`, and `XOR` nodes have `2` children.
  * `NOT` nodes have `1` child.
  * Leaf nodes have a value of `0` or `1`.
  * Non-leaf nodes have a value of `2`, `3`, `4`, or `5`.


## 题目大意

给定**二叉树** 的根 `root`，具有以下属性:

  * **叶节点  **的值为 `0` 或 `1`，分别表示 `false` 和 `true`。
  * **非叶节点** 的值为 `2`、`3`、`4`、`5`，分别表示布尔运算 `OR`, `AND`, `XOR`, `NOT`。

您还将得到一个布尔型 `result`，这是 `root` 节点的期望 **评价**** ** 结果。

对节点的评价计算如下:

  * 如果节点是叶节点，则评价是节点的 **值** ，即 `true` 或 `false`.
  * 否则, 将其值的布尔运算应用于子节点的 **评价** ，该节点的 **评价  **即为布尔运算后的结果。

在一个操作中，您可以 **翻转  **一个叶节点，这将导致一个 `false` 节点变为 `true` 节点，一个 `true` 节点变为 `false`
节点。

返回 _需要执行的最小操作数，以使_`root` _  的_ _评价得到  _`result`。可以证明，总有办法达到 `result`。

**叶节点  **是没有子节点的节点。

注意: `NOT` 节点只有左孩子或只有右孩子，但其他非叶节点同时拥有左孩子和右孩子。



**示例 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2300-2399/2313.Minimum%20Flips%20in%20Binary%20Tree%20to%20Get%20Result/images/operationstree.png)

> 
> 
> 
> 
> 
> **输入:** root = [3,5,4,2,null,1,1,1,0], result = true
> 
> **输出:** 2
> 
> **解释:**
> 
> 可以证明，至少需要翻转 2 个节点才能使树的 root 评价为 true。上面的图显示了实现这一目标的一种方法。
> 
> 

**示例 2:**

> 
> 
> 
> 
> 
> **输入:** root = [0], result = false
> 
> **输出:** 0
> 
> **解释:**
> 
> 树的 root 的评价已经为 false，所以 0 个节点必须翻转。
> 
> 



**提示:**

  * 树中的节点数在 `[1, 105]` 范围内。
  * `0 <= Node.val <= 5`
  * `OR`, `AND`, `XOR` 节点有 `2` 个子节点。
  * `NOT` 只有一个 `1` 子节点。
  * 叶节点的值为 `0` 或 `1`.
  * 非叶节点的值为`2`, `3`, `4`, `5`.


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 1612 | 检查两棵二叉表达式树是否等价 🔒 |  |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`哈希表`](/tag/hash-table.md) `2+` | 🟠 | [🀄️](https://leetcode.cn/problems/check-if-two-expression-trees-are-equivalent) [🔗](https://leetcode.com/problems/check-if-two-expression-trees-are-equivalent) |
| 1628 | 设计带解析函数的表达式树 🔒 |  |  [`栈`](/tag/stack.md) [`树`](/tag/tree.md) [`设计`](/tag/design.md) `3+` | 🟠 | [🀄️](https://leetcode.cn/problems/design-an-expression-tree-with-evaluate-function) [🔗](https://leetcode.com/problems/design-an-expression-tree-with-evaluate-function) |
| 2331 | 计算布尔二叉树的值 | [[✓]](/problem/2331.md) |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`二叉树`](/tag/binary-tree.md) | 🟢 | [🀄️](https://leetcode.cn/problems/evaluate-boolean-binary-tree) [🔗](https://leetcode.com/problems/evaluate-boolean-binary-tree) |