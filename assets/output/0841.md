# [841. é’¥åŒ™å’Œæˆ¿é—´](https://leetcode.com/problems/keys-and-rooms)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/breadth-first-search.md) [`å›¾`](/leetcode/outline/tag/graph.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/keys-and-rooms)


## é¢˜ç›®

There are `n` rooms labeled from `0` to `n - 1` and all the rooms are locked
except for room `0`. Your goal is to visit all the rooms. However, you cannot
enter a locked room without having its key.

When you visit a room, you may find a set of **distinct keys** in it. Each key
has a number on it, denoting which room it unlocks, and you can take all of
them with you to unlock the other rooms.

Given an array `rooms` where `rooms[i]` is the set of keys that you can obtain
if you visited room `i`, return `true` _if you can visit**all** the rooms, or_
`false` _otherwise_.



**Example 1:**

> Input: rooms = [[1],[2],[3],[]]
> 
> Output: true
> 
> Explanation: 
> 
> We visit room 0 and pick up key 1.
> 
> We then visit room 1 and pick up key 2.
> 
> We then visit room 2 and pick up key 3.
> 
> We then visit room 3.
> 
> Since we were able to visit every room, we return true.

**Example 2:**

> Input: rooms = [[1,3],[3,0,1],[2],[0]]
> 
> Output: false
> 
> Explanation: We can not enter room number 2 since the only key that unlocks it is in that room.

**Constraints:**

  * `n == rooms.length`
  * `2 <= n <= 1000`
  * `0 <= rooms[i].length <= 1000`
  * `1 <= sum(rooms[i].length) <= 3000`
  * `0 <= rooms[i][j] < n`
  * All the values of `rooms[i]` are **unique**.


## é¢˜ç›®å¤§æ„

æœ‰ `n` ä¸ªæˆ¿é—´ï¼Œæˆ¿é—´æŒ‰ä» `0` åˆ° `n - 1` ç¼–å·ã€‚æœ€åˆï¼Œé™¤ `0`
å·æˆ¿é—´å¤–çš„å…¶ä½™æ‰€æœ‰æˆ¿é—´éƒ½è¢«é”ä½ã€‚ä½ çš„ç›®æ ‡æ˜¯è¿›å…¥æ‰€æœ‰çš„æˆ¿é—´ã€‚ç„¶è€Œï¼Œä½ ä¸èƒ½åœ¨æ²¡æœ‰è·å¾—é’¥åŒ™çš„æ—¶å€™è¿›å…¥é”ä½çš„æˆ¿é—´ã€‚

å½“ä½ è¿›å…¥ä¸€ä¸ªæˆ¿é—´ï¼Œä½ å¯èƒ½ä¼šåœ¨é‡Œé¢æ‰¾åˆ°ä¸€å¥— **ä¸åŒçš„é’¥åŒ™** ï¼Œæ¯æŠŠé’¥åŒ™ä¸Šéƒ½æœ‰å¯¹åº”çš„æˆ¿é—´å·ï¼Œå³è¡¨ç¤ºé’¥åŒ™å¯ä»¥æ‰“å¼€çš„æˆ¿é—´ã€‚ä½ å¯ä»¥æ‹¿ä¸Šæ‰€æœ‰é’¥åŒ™å»è§£é”å…¶ä»–æˆ¿é—´ã€‚

ç»™ä½ ä¸€ä¸ªæ•°ç»„ `rooms` å…¶ä¸­ `rooms[i]` æ˜¯ä½ è¿›å…¥ `i` å·æˆ¿é—´å¯ä»¥è·å¾—çš„é’¥åŒ™é›†åˆã€‚å¦‚æœèƒ½è¿›å…¥ **æ‰€æœ‰** æˆ¿é—´è¿”å›
`true`ï¼Œå¦åˆ™è¿”å› `false`ã€‚



**ç¤ºä¾‹ 1ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** rooms = [[1],[2],[3],[]]
> 
> **è¾“å‡ºï¼š** true
> 
> **è§£é‡Šï¼š**
> 
> æˆ‘ä»¬ä» 0 å·æˆ¿é—´å¼€å§‹ï¼Œæ‹¿åˆ°é’¥åŒ™ 1ã€‚
> 
> ä¹‹åæˆ‘ä»¬å» 1 å·æˆ¿é—´ï¼Œæ‹¿åˆ°é’¥åŒ™ 2ã€‚
> 
> ç„¶åæˆ‘ä»¬å» 2 å·æˆ¿é—´ï¼Œæ‹¿åˆ°é’¥åŒ™ 3ã€‚
> 
> æœ€åæˆ‘ä»¬å»äº† 3 å·æˆ¿é—´ã€‚
> 
> ç”±äºæˆ‘ä»¬èƒ½å¤Ÿè¿›å…¥æ¯ä¸ªæˆ¿é—´ï¼Œæˆ‘ä»¬è¿”å› trueã€‚
> 
> 

**ç¤ºä¾‹ 2ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** rooms = [[1,3],[3,0,1],[2],[0]]
> 
> **è¾“å‡ºï¼š** false
> 
> **è§£é‡Šï¼š** æˆ‘ä»¬ä¸èƒ½è¿›å…¥ 2 å·æˆ¿é—´ã€‚
> 
> 



**æç¤ºï¼š**

  * `n == rooms.length`
  * `2 <= n <= 1000`
  * `0 <= rooms[i].length <= 1000`
  * `1 <= sum(rooms[i].length) <= 3000`
  * `0 <= rooms[i][j] < n`
  * æ‰€æœ‰ `rooms[i]` çš„å€¼ **äº’ä¸ç›¸åŒ**


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

:::: md-demo ç›¸å…³é¢˜ç›®
- [261. ä»¥å›¾åˆ¤æ ‘](https://leetcode.com/problems/graph-valid-tree)

::::
