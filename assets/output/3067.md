# [3067. åœ¨å¸¦æƒæ ‘ç½‘ç»œä¸­ç»Ÿè®¡å¯è¿æ¥æœåŠ¡å™¨å¯¹æ•°ç›®](https://leetcode.com/problems/count-pairs-of-connectable-servers-in-a-weighted-tree-network)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ ‘`](/outline/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/outline/tag/depth-first-search.md) [`æ•°ç»„`](/outline/tag/array.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/count-pairs-of-connectable-servers-in-a-weighted-tree-network)

## é¢˜ç›®

You are given an unrooted weighted tree with `n` vertices representing servers
numbered from `0` to `n - 1`, an array `edges` where `edges[i] = [ai, bi,
weighti]` represents a bidirectional edge between vertices `ai` and `bi` of
weight `weighti`. You are also given an integer `signalSpeed`.

Two servers `a` and `b` are **connectable** through a server `c` if:

  * `a < b`, `a != c` and `b != c`.
  * The distance from `c` to `a` is divisible by `signalSpeed`.
  * The distance from `c` to `b` is divisible by `signalSpeed`.
  * The path from `c` to `b` and the path from `c` to `a` do not share any edges.

Return _an integer array_ `count` _of length_ `n` _where_ `count[i]` _is
the**number** of server pairs that are **connectable** through_ _the server_
`i`.



**Example 1:**

![](https://assets.leetcode.com/uploads/2024/01/21/example22.png)

> Input: edges = [[0,1,1],[1,2,5],[2,3,13],[3,4,9],[4,5,2]], signalSpeed = 1
> 
> Output: [0,4,6,6,4,0]
> 
> Explanation: Since signalSpeed is 1, count[c] is equal to the number of pairs of paths that start at c and do not share any edges.
> 
> In the case of the given path graph, count[c] is equal to the number of servers to the left of c multiplied by the servers to the right of c.

**Example 2:**

![](https://assets.leetcode.com/uploads/2024/01/21/example11.png)

> Input: edges = [[0,6,3],[6,5,3],[0,3,1],[3,2,7],[3,1,6],[3,4,2]], signalSpeed = 3
> 
> Output: [2,0,0,0,0,0,2]
> 
> Explanation: Through server 0, there are 2 pairs of connectable servers: (4, 5) and (4, 6).
> 
> Through server 6, there are 2 pairs of connectable servers: (4, 5) and (0, 5).
> 
> It can be shown that no two servers are connectable through servers other than 0 and 6.

**Constraints:**

  * `2 <= n <= 1000`
  * `edges.length == n - 1`
  * `edges[i].length == 3`
  * `0 <= ai, bi < n`
  * `edges[i] = [ai, bi, weighti]`
  * `1 <= weighti <= 10^6`
  * `1 <= signalSpeed <= 10^6`
  * The input is generated such that `edges` represents a valid tree.


## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€æ£µæ— æ ¹å¸¦æƒæ ‘ï¼Œæ ‘ä¸­æ€»å…±æœ‰ `n` ä¸ªèŠ‚ç‚¹ï¼Œåˆ†åˆ«è¡¨ç¤º `n` ä¸ªæœåŠ¡å™¨ï¼ŒæœåŠ¡å™¨ä» `0` åˆ° `n - 1` ç¼–å·ã€‚åŒæ—¶ç»™ä½ ä¸€ä¸ªæ•°ç»„ `edges`
ï¼Œå…¶ä¸­ `edges[i] = [ai, bi, weighti]` è¡¨ç¤ºèŠ‚ç‚¹ `ai` å’Œ `bi` ä¹‹é—´æœ‰ä¸€æ¡åŒå‘è¾¹ï¼Œè¾¹çš„æƒå€¼ä¸º `weighti`
ã€‚å†ç»™ä½ ä¸€ä¸ªæ•´æ•° `signalSpeed` ã€‚

å¦‚æœä¸¤å°æœåŠ¡å™¨ `a` å’Œ `b` æ˜¯é€šè¿‡æœåŠ¡å™¨ `c` **å¯è¿æ¥çš„** ï¼Œåˆ™ï¼š

  * `a < b` ï¼Œ`a != c` ä¸” `b != c` ã€‚
  * ä» `c` åˆ° `a` çš„è·ç¦»æ˜¯å¯ä»¥è¢« `signalSpeed` æ•´é™¤çš„ã€‚
  * ä» `c` åˆ° `b` çš„è·ç¦»æ˜¯å¯ä»¥è¢« `signalSpeed` æ•´é™¤çš„ã€‚
  * ä» `c` åˆ° `b` çš„è·¯å¾„ä¸ä» `c` åˆ° `a` çš„è·¯å¾„æ²¡æœ‰ä»»ä½•å…¬å…±è¾¹ã€‚

è¯·ä½ è¿”å›ä¸€ä¸ªé•¿åº¦ä¸º `n` çš„æ•´æ•°æ•°ç»„ `count` ï¼Œå…¶ä¸­ `count[i]` è¡¨ç¤ºé€šè¿‡æœåŠ¡å™¨ `i` **å¯è¿æ¥**  çš„æœåŠ¡å™¨å¯¹çš„ **æ•°ç›®**
ã€‚



**ç¤ºä¾‹ 1ï¼š**

![](https://assets.leetcode.com/uploads/2024/01/21/example22.png)

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** edges = [[0,1,1],[1,2,5],[2,3,13],[3,4,9],[4,5,2]], signalSpeed = 1
> 
> **è¾“å‡ºï¼š**[0,4,6,6,4,0]
> 
> **è§£é‡Šï¼š** ç”±äº signalSpeed ç­‰äº 1 ï¼Œcount[c] ç­‰äºæ‰€æœ‰ä» c å¼€å§‹ä¸”æ²¡æœ‰å…¬å…±è¾¹çš„è·¯å¾„å¯¹æ•°ç›®ã€‚
> 
> åœ¨è¾“å…¥å›¾ä¸­ï¼Œcount[c] ç­‰äºæœåŠ¡å™¨ c å·¦è¾¹æœåŠ¡å™¨æ•°ç›®ä¹˜ä»¥å³è¾¹æœåŠ¡å™¨æ•°ç›®ã€‚
> 
> 

**ç¤ºä¾‹ 2ï¼š**

![](https://assets.leetcode.com/uploads/2024/01/21/example11.png)

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** edges = [[0,6,3],[6,5,3],[0,3,1],[3,2,7],[3,1,6],[3,4,2]], signalSpeed = 3
> 
> **è¾“å‡ºï¼š**[2,0,0,0,0,0,2]
> 
> **è§£é‡Šï¼š** é€šè¿‡æœåŠ¡å™¨ 0 ï¼Œæœ‰ 2 ä¸ªå¯è¿æ¥æœåŠ¡å™¨å¯¹(4, 5) å’Œ (4, 6) ã€‚
> 
> é€šè¿‡æœåŠ¡å™¨ 6 ï¼Œæœ‰ 2 ä¸ªå¯è¿æ¥æœåŠ¡å™¨å¯¹ (4, 5) å’Œ (0, 5) ã€‚
> 
> æ‰€æœ‰æœåŠ¡å™¨å¯¹éƒ½å¿…é¡»é€šè¿‡æœåŠ¡å™¨ 0 æˆ– 6 æ‰å¯è¿æ¥ï¼Œæ‰€ä»¥å…¶ä»–æœåŠ¡å™¨å¯¹åº”çš„å¯è¿æ¥æœåŠ¡å™¨å¯¹æ•°ç›®éƒ½ä¸º 0 ã€‚
> 
> 



**æç¤ºï¼š**

  * `2 <= n <= 1000`
  * `edges.length == n - 1`
  * `edges[i].length == 3`
  * `0 <= ai, bi < n`
  * `edges[i] = [ai, bi, weighti]`
  * `1 <= weighti <= 10^6`
  * `1 <= signalSpeed <= 10^6`
  * è¾“å…¥ä¿è¯ `edges` æ„æˆä¸€æ£µåˆæ³•çš„æ ‘ã€‚


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 310 | [æœ€å°é«˜åº¦æ ‘](https://leetcode.com/problems/minimum-height-trees) |  |  [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/outline/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/outline/tag/breadth-first-search.md) [`å›¾`](/outline/tag/graph.md) `1+` | <font color=#ffb800>Medium</font> |
| 834 | [æ ‘ä¸­è·ç¦»ä¹‹å’Œ](https://leetcode.com/problems/sum-of-distances-in-tree) |  |  [`æ ‘`](/outline/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/outline/tag/depth-first-search.md) [`å›¾`](/outline/tag/graph.md) `1+` | <font color=#ff334b>Hard</font> |

<style>
.blue {
    background-color: #096dd9;
    padding: 0.25rem 0.5rem;
    margin: 0;
    font-size: 0.85em;
    border-radius: 3px;
    color: white;
    font-weight: 500;
}
table th:first-of-type { width: 10%; }
table th:nth-of-type(2) { width: 35%; }
table th:nth-of-type(3) { width: 10%; }
table th:nth-of-type(4) { width: 35%; }
table th:nth-of-type(5) { width: 10%; }
</style>
