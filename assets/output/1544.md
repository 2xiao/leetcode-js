# [1544. æ•´ç†å­—ç¬¦ä¸²](https://leetcode.com/problems/make-the-string-great)

ğŸŸ¢ <font color=#15bd66>Easy</font>&emsp; ğŸ”–&ensp; [`æ ˆ`](/leetcode/outline/tag/stack.md) [`å­—ç¬¦ä¸²`](/leetcode/outline/tag/string.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/make-the-string-great)

## é¢˜ç›®

Given a string `s` of lower and upper case English letters.

A good string is a string which doesn't have **two adjacent characters**
`s[i]` and `s[i + 1]` where:

  * `0 <= i <= s.length - 2`
  * `s[i]` is a lower-case letter and `s[i + 1]` is the same letter but in upper-case or **vice-versa**.

To make the string good, you can choose **two adjacent** characters that make
the string bad and remove them. You can keep doing this until the string
becomes good.

Return _the string_ after making it good. The answer is guaranteed to be
unique under the given constraints.

**Notice** that an empty string is also good.



**Example 1:**

> Input: s = "leEeetcode"
> 
> Output: "leetcode"
> 
> Explanation: In the first step, either you choose i = 1 or i = 2, both will result "leEeetcode" to be reduced to "leetcode".

**Example 2:**

> Input: s = "abBAcC"
> 
> Output: ""
> 
> Explanation: We have many possible scenarios, and all lead to the same answer. For example:
> 
> "abBAcC" --> "aAcC" --> "cC" --> ""
> 
> "abBAcC" --> "abBA" --> "aA" --> ""

**Example 3:**

> Input: s = "s"
> 
> Output: "s"

**Constraints:**

  * `1 <= s.length <= 100`
  * `s` contains only lower and upper case English letters.


## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ªç”±å¤§å°å†™è‹±æ–‡å­—æ¯ç»„æˆçš„å­—ç¬¦ä¸² `s` ã€‚

ä¸€ä¸ªæ•´ç†å¥½çš„å­—ç¬¦ä¸²ä¸­ï¼Œä¸¤ä¸ªç›¸é‚»å­—ç¬¦ `s[i]` å’Œ `s[i+1]`ï¼Œå…¶ä¸­ `0<= i <= s.length-2` ï¼Œè¦æ»¡è¶³å¦‚ä¸‹æ¡ä»¶:

  * è‹¥ `s[i]` æ˜¯å°å†™å­—ç¬¦ï¼Œåˆ™ `s[i+1]` ä¸å¯ä»¥æ˜¯ç›¸åŒçš„å¤§å†™å­—ç¬¦ã€‚
  * è‹¥ `s[i]` æ˜¯å¤§å†™å­—ç¬¦ï¼Œåˆ™ `s[i+1]` ä¸å¯ä»¥æ˜¯ç›¸åŒçš„å°å†™å­—ç¬¦ã€‚

è¯·ä½ å°†å­—ç¬¦ä¸²æ•´ç†å¥½ï¼Œæ¯æ¬¡ä½ éƒ½å¯ä»¥ä»å­—ç¬¦ä¸²ä¸­é€‰å‡ºæ»¡è¶³ä¸Šè¿°æ¡ä»¶çš„ **ä¸¤ä¸ªç›¸é‚»** å­—ç¬¦å¹¶åˆ é™¤ï¼Œç›´åˆ°å­—ç¬¦ä¸²æ•´ç†å¥½ä¸ºæ­¢ã€‚

è¯·è¿”å›æ•´ç†å¥½çš„ **å­—ç¬¦ä¸²** ã€‚é¢˜ç›®ä¿è¯åœ¨ç»™å‡ºçš„çº¦æŸæ¡ä»¶ä¸‹ï¼Œæµ‹è¯•æ ·ä¾‹å¯¹åº”çš„ç­”æ¡ˆæ˜¯å”¯ä¸€çš„ã€‚

**æ³¨æ„ï¼š** ç©ºå­—ç¬¦ä¸²ä¹Ÿå±äºæ•´ç†å¥½çš„å­—ç¬¦ä¸²ï¼Œå°½ç®¡å…¶ä¸­æ²¡æœ‰ä»»ä½•å­—ç¬¦ã€‚

**ç¤ºä¾‹ 1ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** s = "leEeetcode"
> 
> **è¾“å‡ºï¼š** "leetcode"
> 
> **è§£é‡Šï¼š** æ— è®ºä½ ç¬¬ä¸€æ¬¡é€‰çš„æ˜¯ i = 1 è¿˜æ˜¯ i = 2ï¼Œéƒ½ä¼šä½¿ "leEeetcode" ç¼©å‡ä¸º "leetcode" ã€‚
> 
> 

**ç¤ºä¾‹ 2ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** s = "abBAcC"
> 
> **è¾“å‡ºï¼š** ""
> 
> **è§£é‡Šï¼š** å­˜åœ¨å¤šç§ä¸åŒæƒ…å†µï¼Œä½†æ‰€æœ‰çš„æƒ…å†µéƒ½ä¼šå¯¼è‡´ç›¸åŒçš„ç»“æœã€‚ä¾‹å¦‚ï¼š
> 
> "abBAcC" --> "aAcC" --> "cC" --> ""
> 
> "abBAcC" --> "abBA" --> "aA" --> ""
> 
> 

**ç¤ºä¾‹ 3ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** s = "s"
> 
> **è¾“å‡ºï¼š** "s"
> 
> 

**æç¤ºï¼š**

  * `1 <= s.length <= 100`
  * `s` åªåŒ…å«å°å†™å’Œå¤§å†™è‹±æ–‡å­—æ¯


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```