---
title: 1245. 树的直径 🔒
description: LeetCode 1245. 树的直径 🔒题解，Tree Diameter，包含解题思路、复杂度分析以及完整的 JavaScript 代码实现。
keywords:
  - LeetCode
  - 1245. 树的直径 🔒
  - 树的直径
  - Tree Diameter
  - 解题思路
  - 树
  - 深度优先搜索
  - 广度优先搜索
  - 图
  - 拓扑排序
---

# 1245. 树的直径 🔒

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) [`图`](/tag/graph.md) [`拓扑排序`](/tag/topological-sort.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/tree-diameter) [`LeetCode`](https://leetcode.com/problems/tree-diameter)

## 题目

The **diameter** of a tree is **the number of edges** in the longest path in
that tree.

There is an undirected tree of `n` nodes labeled from `0` to `n - 1`. You are
given a 2D array `edges` where `edges.length == n - 1` and `edges[i] = [ai,
bi]` indicates that there is an undirected edge between nodes `ai` and `bi` in
the tree.

Return _the**diameter** of the tree_.



**Example 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1200-1299/1245.Tree%20Diameter/images/tree1.jpg)

> Input: edges = [[0,1],[0,2]]
> 
> Output: 2
> 
> Explanation: The longest path of the tree is the path 1 - 0 - 2.

**Example 2:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1200-1299/1245.Tree%20Diameter/images/tree2.jpg)

> Input: edges = [[0,1],[1,2],[2,3],[1,4],[4,5]]
> 
> Output: 4
> 
> Explanation: The longest path of the tree is the path 3 - 2 - 1 - 4 - 5.

**Constraints:**

  * `n == edges.length + 1`
  * `1 <= n <= 10^4`
  * `0 <= ai, bi < n`
  * `ai != bi`


## 题目大意

给你这棵「无向树」，请你测算并返回它的「直径」：这棵树上最长简单路径的 **边数** 。

我们用一个由所有「边」组成的数组 `edges` 来表示一棵无向树，其中 `edges[i] = [u, v]` 表示节点 `u` 和 `v`
之间的双向边。

树上的节点都已经用 `{0, 1, ..., edges.length}` 中的数做了标记，每个节点上的标记都是独一无二的。



**示例 1：**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1200-1299/1245.Tree%20Diameter/images/1397_example_1.png)

> 
> 
> 
> 
> 
> **输入：** edges = [[0,1],[0,2]]
> 
> **输出：** 2
> 
> **解释：**
> 
> 这棵树上最长的路径是 1 - 0 - 2，边数为 2。
> 
> 

**示例 2：**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1200-1299/1245.Tree%20Diameter/images/1397_example_2.png)

> 
> 
> 
> 
> 
> **输入：** edges = [[0,1],[1,2],[2,3],[1,4],[4,5]]
> 
> **输出：** 4
> 
> **解释：**
> 
> 这棵树上最长的路径是 3 - 2 - 1 - 4 - 5，边数为 4。
> 
> 



**提示：**

  * `0 <= edges.length < 10^4`
  * `edges[i][0] != edges[i][1]`
  * `0 <= edges[i][j] <= edges.length`
  * `edges` 会形成一棵无向树


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 1617 | 统计子树中城市之间最大距离 |  |  [`位运算`](/tag/bit-manipulation.md) [`树`](/tag/tree.md) [`动态规划`](/tag/dynamic-programming.md) `2+` | 🔴 | [🀄️](https://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities) [🔗](https://leetcode.com/problems/count-subtrees-with-max-distance-between-cities) |
| 3203 | 合并两棵树后的最小直径 | [[✓]](/problem/3203.md) |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) `1+` | 🔴 | [🀄️](https://leetcode.cn/problems/find-minimum-diameter-after-merging-two-trees) [🔗](https://leetcode.com/problems/find-minimum-diameter-after-merging-two-trees) |