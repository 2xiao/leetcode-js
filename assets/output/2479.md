# [2479. ä¸¤ä¸ªä¸é‡å å­æ ‘çš„æœ€å¤§å¼‚æˆ–å€¼](https://leetcode.com/problems/maximum-xor-of-two-non-overlapping-subtrees)

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`æ ‘`](/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`å›¾`](/tag/graph.md) [`å­—å…¸æ ‘`](/tag/trie.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/maximum-xor-of-two-non-overlapping-subtrees)

## é¢˜ç›®

There is an undirected tree with `n` nodes labeled from `0` to `n - 1`. You
are given the integer `n` and a 2D integer array `edges` of length `n - 1`,
where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai`
and `bi` in the tree. The root of the tree is the node labeled `0`.

Each node has an associated **value**. You are given an array `values` of
length `n`, where `values[i]` is the **value** of the `ith` node.

Select any two **non-overlapping** subtrees. Your **score** is the bitwise XOR
of the sum of the values within those subtrees.

Return _the_ _**maximum**_ _possible**score** you can achieve_. _If it is
impossible to find two nonoverlapping subtrees_ , return `0`.

**Note** that:

  * The **subtree** of a node is the tree consisting of that node and all of its descendants.
  * Two subtrees are **non-overlapping** if they do not share **any common** node.



**Example 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2400-2499/2479.Maximum%20XOR%20of%20Two%20Non-
Overlapping%20Subtrees/images/treemaxxor.png)

> Input: n = 6, edges = [[0,1],[0,2],[1,3],[1,4],[2,5]], values = [2,8,3,6,2,5]
> 
> Output: 24
> 
> Explanation: Node 1's subtree has sum of values 16, while node 2's subtree has sum of values 8, so choosing these nodes will yield a score of 16 XOR 8 = 24. It can be proved that is the maximum possible score we can obtain.

**Example 2:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2400-2499/2479.Maximum%20XOR%20of%20Two%20Non-
Overlapping%20Subtrees/images/tree3drawio.png)

> Input: n = 3, edges = [[0,1],[1,2]], values = [4,6,1]
> 
> Output: 0
> 
> Explanation: There is no possible way to select two non-overlapping subtrees, so we just return 0.

**Constraints:**

  * `2 <= n <= 5 * 10^4`
  * `edges.length == n - 1`
  * `0 <= ai, bi < n`
  * `values.length == n`
  * `1 <= values[i] <= 10^9`
  * It is guaranteed that `edges` represents a valid tree.


## é¢˜ç›®å¤§æ„

æœ‰ä¸€ä¸ªæ— å‘æ ‘ï¼Œæœ‰ `n` ä¸ªèŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹æ ‡è®°ä¸ºä» `0` åˆ° `n - 1`ã€‚ç»™å®šæ•´æ•° `n` å’Œä¸€ä¸ªé•¿åº¦ä¸º `n - 1` çš„ 2 ç»´æ•´æ•°æ•°ç»„
`edges`ï¼Œå…¶ä¸­ `edges[i] = [ai, bi]` è¡¨ç¤ºåœ¨æ ‘ä¸­çš„èŠ‚ç‚¹ `ai` å’Œ `bi` ä¹‹é—´æœ‰ä¸€æ¡è¾¹ã€‚æ ‘çš„æ ¹èŠ‚ç‚¹æ˜¯æ ‡è®°ä¸º `0`
çš„èŠ‚ç‚¹ã€‚

æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªç›¸å…³è”çš„ **å€¼** ã€‚ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º n çš„æ•°ç»„ `values`ï¼Œå…¶ä¸­ `values[i]` æ˜¯ç¬¬ `i` ä¸ªèŠ‚ç‚¹çš„ **å€¼** ã€‚

é€‰æ‹©ä»»æ„ä¸¤ä¸ª **ä¸é‡å   **çš„å­æ ‘ã€‚ä½ çš„ **åˆ†æ•°  **æ˜¯è¿™äº›å­æ ‘ä¸­å€¼çš„å’Œçš„é€ä½å¼‚æˆ–ã€‚

è¿”å› _ä½ èƒ½è¾¾åˆ°çš„æœ€å¤§åˆ†æ•°_ ã€‚ _å¦‚æœä¸å¯èƒ½æ‰¾åˆ°ä¸¤ä¸ªä¸é‡å çš„å­æ ‘_ ï¼Œåˆ™è¿”å› `0`ã€‚

**æ³¨æ„** ï¼š

  * èŠ‚ç‚¹çš„ **å­æ ‘  **æ˜¯ç”±è¯¥èŠ‚ç‚¹åŠå…¶æ‰€æœ‰å­èŠ‚ç‚¹ç»„æˆçš„æ ‘ã€‚
  * å¦‚æœä¸¤ä¸ªå­æ ‘ä¸å…±äº« **ä»»ä½•å…¬å…±  **èŠ‚ç‚¹ï¼Œåˆ™å®ƒä»¬æ˜¯ **ä¸é‡å   **çš„ã€‚



**ç¤ºä¾‹ 1ï¼š**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2400-2499/2479.Maximum%20XOR%20of%20Two%20Non-
Overlapping%20Subtrees/images/treemaxxor.png)

> 
> 
> 
> 
> 
> **è¾“å…¥:** n = 6, edges = [[0,1],[0,2],[1,3],[1,4],[2,5]], values = [2,8,3,6,2,5]
> 
> **è¾“å‡º:** 24
> 
> **è§£é‡Š:** èŠ‚ç‚¹ 1 çš„å­æ ‘çš„å’Œå€¼ä¸º 16ï¼Œè€ŒèŠ‚ç‚¹ 2 çš„å­æ ‘çš„å’Œå€¼ä¸º 8ï¼Œå› æ­¤é€‰æ‹©è¿™äº›èŠ‚ç‚¹å°†å¾—åˆ° 16 XOR 8 = 24 çš„åˆ†æ•°ã€‚å¯ä»¥è¯æ˜ï¼Œè¿™æ˜¯æˆ‘ä»¬èƒ½å¾—åˆ°çš„æœ€å¤§å¯èƒ½åˆ†æ•°ã€‚
> 
> 

**ç¤ºä¾‹ 2ï¼š**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2400-2499/2479.Maximum%20XOR%20of%20Two%20Non-
Overlapping%20Subtrees/images/tree3drawio.png)

> 
> 
> 
> 
> 
> **è¾“å…¥:** n = 3, edges = [[0,1],[1,2]], values = [4,6,1]
> 
> **è¾“å‡º:** 0
> 
> **è§£é‡Š:** ä¸å¯èƒ½é€‰æ‹©ä¸¤ä¸ªä¸é‡å çš„å­æ ‘ï¼Œæ‰€ä»¥æˆ‘ä»¬åªè¿”å› 0ã€‚
> 
> 



**æç¤ºï¼š**

  * `2 <= n <= 5 * 10^4`
  * `edges.length == n - 1`
  * `0 <= ai, bi < n`
  * `values.length == n`
  * `1 <= values[i] <= 10^9`
  * ä¿è¯ `edges` ä»£è¡¨ä¸€ä¸ªæœ‰æ•ˆçš„æ ‘ã€‚


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```