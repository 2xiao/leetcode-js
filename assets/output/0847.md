# [847. è®¿é—®æ‰€æœ‰èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„](https://leetcode.com/problems/shortest-path-visiting-all-nodes)

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`ä½è¿ç®—`](/tag/bit-manipulation.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/tag/breadth-first-search.md) [`å›¾`](/tag/graph.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md) [`çŠ¶æ€å‹ç¼©`](/tag/bitmask.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/shortest-path-visiting-all-nodes)

## é¢˜ç›®

You have an undirected, connected graph of `n` nodes labeled from `0` to `n -
1`. You are given an array `graph` where `graph[i]` is a list of all the nodes
connected with node `i` by an edge.

Return _the length of the shortest path that visits every node_. You may start
and stop at any node, you may revisit nodes multiple times, and you may reuse
edges.



**Example 1:**

![](https://assets.leetcode.com/uploads/2021/05/12/shortest1-graph.jpg)

> Input: graph = [[1,2,3],[0],[0],[0]]
> 
> Output: 4
> 
> Explanation: One possible path is [1,0,2,0,3]

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/05/12/shortest2-graph.jpg)

> Input: graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]
> 
> Output: 4
> 
> Explanation: One possible path is [0,1,4,2,3]

**Constraints:**

  * `n == graph.length`
  * `1 <= n <= 12`
  * `0 <= graph[i].length < n`
  * `graph[i]` does not contain `i`.
  * If `graph[a]` contains `b`, then `graph[b]` contains `a`.
  * The input graph is always connected.


## é¢˜ç›®å¤§æ„

å­˜åœ¨ä¸€ä¸ªç”± `n` ä¸ªèŠ‚ç‚¹ç»„æˆçš„æ— å‘è¿é€šå›¾ï¼Œå›¾ä¸­çš„èŠ‚ç‚¹æŒ‰ä» `0` åˆ° `n - 1` ç¼–å·ã€‚

ç»™ä½ ä¸€ä¸ªæ•°ç»„ `graph` è¡¨ç¤ºè¿™ä¸ªå›¾ã€‚å…¶ä¸­ï¼Œ`graph[i]` æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼Œç”±æ‰€æœ‰ä¸èŠ‚ç‚¹ `i` ç›´æ¥ç›¸è¿çš„èŠ‚ç‚¹ç»„æˆã€‚

è¿”å›èƒ½å¤Ÿè®¿é—®æ‰€æœ‰èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„çš„é•¿åº¦ã€‚ä½ å¯ä»¥åœ¨ä»»ä¸€èŠ‚ç‚¹å¼€å§‹å’Œåœæ­¢ï¼Œä¹Ÿå¯ä»¥å¤šæ¬¡é‡è®¿èŠ‚ç‚¹ï¼Œå¹¶ä¸”å¯ä»¥é‡ç”¨è¾¹ã€‚



**ç¤ºä¾‹ 1ï¼š**

![](https://assets.leetcode.com/uploads/2021/05/12/shortest1-graph.jpg)

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** graph = [[1,2,3],[0],[0],[0]]
> 
> **è¾“å‡ºï¼š** 4
> 
> **è§£é‡Šï¼š** ä¸€ç§å¯èƒ½çš„è·¯å¾„ä¸º [1,0,2,0,3]

**ç¤ºä¾‹ 2ï¼š**

![](https://assets.leetcode.com/uploads/2021/05/12/shortest2-graph.jpg)

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]
> 
> **è¾“å‡ºï¼š** 4
> 
> **è§£é‡Šï¼š** ä¸€ç§å¯èƒ½çš„è·¯å¾„ä¸º [0,1,4,2,3]
> 
> 



**æç¤ºï¼š**

  * `n == graph.length`
  * `1 <= n <= 12`
  * `0 <= graph[i].length < n`
  * `graph[i]` ä¸åŒ…å« `i`
  * å¦‚æœ `graph[a]` åŒ…å« `b` ï¼Œé‚£ä¹ˆ `graph[b]` ä¹ŸåŒ…å« `a`
  * è¾“å…¥çš„å›¾æ€»æ˜¯è¿é€šå›¾


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 3149 | [æ‰¾å‡ºåˆ†æ•°æœ€ä½çš„æ’åˆ—](https://leetcode.com/problems/find-the-minimum-cost-array-permutation) |  |  [`ä½è¿ç®—`](/tag/bit-manipulation.md) [`æ•°ç»„`](/tag/array.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md) `1+` | <font color=#ff334b>Hard</font> |