---
title: 1101. 彼此熟识的最早时间 🔒
description: LeetCode 1101. 彼此熟识的最早时间 🔒题解，The Earliest Moment When Everyone Become Friends，包含解题思路、复杂度分析以及完整的 JavaScript 代码实现。
keywords:
  - LeetCode
  - 1101. 彼此熟识的最早时间 🔒
  - 彼此熟识的最早时间
  - The Earliest Moment When Everyone Become Friends
  - 解题思路
  - 并查集
  - 数组
  - 排序
---

# 1101. 彼此熟识的最早时间 🔒

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`并查集`](/tag/union-find.md) [`数组`](/tag/array.md) [`排序`](/tag/sorting.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/the-earliest-moment-when-everyone-become-friends) [`LeetCode`](https://leetcode.com/problems/the-earliest-moment-when-everyone-become-friends)

## 题目

There are n people in a social group labeled from `0` to `n - 1`. You are
given an array `logs` where `logs[i] = [timestampi, xi, yi]` indicates that
`xi` and `yi` will be friends at the time `timestampi`.

Friendship is **symmetric**. That means if `a` is friends with `b`, then `b`
is friends with `a`. Also, person `a` is acquainted with a person `b` if `a`
is friends with `b`, or `a` is a friend of someone acquainted with `b`.

Return _the earliest time for which every person became acquainted with every
other person_. If there is no such earliest time, return `-1`.



**Example 1:**

> Input: logs = [[20190101,0,1],[20190104,3,4],[20190107,2,3],[20190211,1,5],[20190224,2,4],[20190301,0,3],[20190312,1,2],[20190322,4,5]], n = 6
> 
> Output: 20190301
> 
> Explanation: 
> 
> The first event occurs at timestamp = 20190101, and after 0 and 1 become friends, we have the following friendship groups [0,1], [2], [3], [4], [5].
> 
> The second event occurs at timestamp = 20190104, and after 3 and 4 become friends, we have the following friendship groups [0,1], [2], [3,4], [5].
> 
> The third event occurs at timestamp = 20190107, and after 2 and 3 become friends, we have the following friendship groups [0,1], [2,3,4], [5].
> 
> The fourth event occurs at timestamp = 20190211, and after 1 and 5 become friends, we have the following friendship groups [0,1,5], [2,3,4].
> 
> The fifth event occurs at timestamp = 20190224, and as 2 and 4 are already friends, nothing happens.
> 
> The sixth event occurs at timestamp = 20190301, and after 0 and 3 become friends, we all become friends.

**Example 2:**

> Input: logs = [[0,2,0],[1,0,1],[3,0,3],[4,1,2],[7,3,1]], n = 4
> 
> Output: 3
> 
> Explanation: At timestamp = 3, all the persons (i.e., 0, 1, 2, and 3) become friends.

**Constraints:**

  * `2 <= n <= 100`
  * `1 <= logs.length <= 10^4`
  * `logs[i].length == 3`
  * `0 <= timestampi <= 10^9`
  * `0 <= xi, yi <= n - 1`
  * `xi != yi`
  * All the values `timestampi` are **unique**.
  * All the pairs `(xi, yi)` occur at most one time in the input.


## 题目大意

在一个社交圈子当中，有 `n` 个人。每个人都有一个从 `0` 到 `n - 1` 的唯一编号。我们有一份日志列表 `logs`，其中 `logs[i] =
[timestampi, xi, yi]` 表示 `xi` 和 `yi` 将在同一时间 `timestampi` 成为朋友。

友谊是 **相互** 的。也就是说，如果 `a` 和 `b` 是朋友，那么 `b` 和 `a` 也是朋友。同样，如果 `a` 和 `b` 是朋友，或者
`a` 是 `b` 朋友的朋友 ，那么 `a` 和 `b` 是熟识友。

返回圈子里所有人之间都熟识的最早时间。如果找不到最早时间，就返回 `-1` 。



**示例 1：**

> 
> 
> 
> 
> 
> **输入：** logs = [[20190101,0,1],[20190104,3,4],[20190107,2,3],[20190211,1,5],[20190224,2,4],[20190301,0,3],[20190312,1,2],[20190322,4,5]], N = 6
> 
> **输出：** 20190301
> 
> **解释：**
> 
> 第一次结交发生在 timestamp = 20190101，0 和 1 成为好友，社交朋友圈如下 [0,1], [2], [3], [4], [5]。
> 
> 第二次结交发生在 timestamp = 20190104，3 和 4 成为好友，社交朋友圈如下 [0,1], [2], [3,4], [5].
> 
> 第三次结交发生在 timestamp = 20190107，2 和 3 成为好友，社交朋友圈如下 [0,1], [2,3,4], [5].
> 
> 第四次结交发生在 timestamp = 20190211，1 和 5 成为好友，社交朋友圈如下 [0,1,5], [2,3,4].
> 
> 第五次结交发生在 timestamp = 20190224，2 和 4 已经是好友了。
> 
> 第六次结交发生在 timestamp = 20190301，0 和 3 成为好友，大家都互相熟识了。
> 
> 

**示例 2:**

> 
> 
> 
> 
> 
> **输入:** logs = [[0,2,0],[1,0,1],[3,0,3],[4,1,2],[7,3,1]], n = 4
> 
> **输出:** 3
> 
> 



**提示：**

  * `2 <= n <= 100`
  * `1 <= logs.length <= 10^4`
  * `logs[i].length == 3`
  * `0 <= timestampi <= 10^9`
  * `0 <= xi, yi <= n - 1`
  * `xi != yi`
  * `timestampi` 中的所有时间戳 **均****不同**
  * 所有的对 `(xi, yi)` 在输入中最多出现一次


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 547 | 省份数量 | [[✓]](/problem/0547.md) |  [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) [`并查集`](/tag/union-find.md) `1+` | 🟠 | [🀄️](https://leetcode.cn/problems/number-of-provinces) [🔗](https://leetcode.com/problems/number-of-provinces) |