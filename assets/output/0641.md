# [641. è®¾è®¡å¾ªç¯åŒç«¯é˜Ÿåˆ—](https://leetcode.com/problems/design-circular-deque)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`è®¾è®¡`](/leetcode/outline/tag/design.md) [`é˜Ÿåˆ—`](/leetcode/outline/tag/queue.md) [`æ•°ç»„`](/leetcode/outline/tag/array.md) [`é“¾è¡¨`](/leetcode/outline/tag/linked-list.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/design-circular-deque)


## é¢˜ç›®

Design your implementation of the circular double-ended queue (deque).

Implement the `MyCircularDeque` class:

  * `MyCircularDeque(int k)` Initializes the deque with a maximum size of `k`.
  * `boolean insertFront()` Adds an item at the front of Deque. Returns `true` if the operation is successful, or `false` otherwise.
  * `boolean insertLast()` Adds an item at the rear of Deque. Returns `true` if the operation is successful, or `false` otherwise.
  * `boolean deleteFront()` Deletes an item from the front of Deque. Returns `true` if the operation is successful, or `false` otherwise.
  * `boolean deleteLast()` Deletes an item from the rear of Deque. Returns `true` if the operation is successful, or `false` otherwise.
  * `int getFront()` Returns the front item from the Deque. Returns `-1` if the deque is empty.
  * `int getRear()` Returns the last item from Deque. Returns `-1` if the deque is empty.
  * `boolean isEmpty()` Returns `true` if the deque is empty, or `false` otherwise.
  * `boolean isFull()` Returns `true` if the deque is full, or `false` otherwise.



**Example 1:**

> 
> 
> 
> 
> 
> **Input**
> 
> ["MyCircularDeque", "insertLast", "insertLast", "insertFront", "insertFront", "getRear", "isFull", "deleteLast", "insertFront", "getFront"]
> 
> [[3], [1], [2], [3], [4], [], [], [], [4], []]
> 
> **Output**
> 
> [null, true, true, true, false, 2, true, true, true, 4]
> 
> 
> 
> **Explanation**
> 
> MyCircularDeque myCircularDeque = new MyCircularDeque(3);
> 
> myCircularDeque.insertLast(1);  // return True
> 
> myCircularDeque.insertLast(2);  // return True
> 
> myCircularDeque.insertFront(3); // return True
> 
> myCircularDeque.insertFront(4); // return False, the queue is full.
> 
> myCircularDeque.getRear();> 
>   // return 2
> 
> myCircularDeque.isFull();> 
>    // return True
> 
> myCircularDeque.deleteLast();   // return True
> 
> myCircularDeque.insertFront(4); // return True
> 
> myCircularDeque.getFront();> 
>  // return 4

**Constraints:**

  * `1 <= k <= 1000`
  * `0 <= value <= 1000`
  * At most `2000` calls will be made to `insertFront`, `insertLast`, `deleteFront`, `deleteLast`, `getFront`, `getRear`, `isEmpty`, `isFull`.


## é¢˜ç›®å¤§æ„

è®¾è®¡å®ç°åŒç«¯é˜Ÿåˆ—ã€‚

å®ç° `MyCircularDeque` ç±»:

  * `MyCircularDeque(int k)` ï¼šæ„é€ å‡½æ•°,åŒç«¯é˜Ÿåˆ—æœ€å¤§ä¸º `k` ã€‚
  * `boolean insertFront()`ï¼šå°†ä¸€ä¸ªå…ƒç´ æ·»åŠ åˆ°åŒç«¯é˜Ÿåˆ—å¤´éƒ¨ã€‚ å¦‚æœæ“ä½œæˆåŠŸè¿”å› `true` ï¼Œå¦åˆ™è¿”å› `false` ã€‚
  * `boolean insertLast()` ï¼šå°†ä¸€ä¸ªå…ƒç´ æ·»åŠ åˆ°åŒç«¯é˜Ÿåˆ—å°¾éƒ¨ã€‚å¦‚æœæ“ä½œæˆåŠŸè¿”å› `true` ï¼Œå¦åˆ™è¿”å› `false` ã€‚
  * `boolean deleteFront()` ï¼šä»åŒç«¯é˜Ÿåˆ—å¤´éƒ¨åˆ é™¤ä¸€ä¸ªå…ƒç´ ã€‚ å¦‚æœæ“ä½œæˆåŠŸè¿”å› `true` ï¼Œå¦åˆ™è¿”å› `false` ã€‚
  * `boolean deleteLast()` ï¼šä»åŒç«¯é˜Ÿåˆ—å°¾éƒ¨åˆ é™¤ä¸€ä¸ªå…ƒç´ ã€‚å¦‚æœæ“ä½œæˆåŠŸè¿”å› `true` ï¼Œå¦åˆ™è¿”å› `false` ã€‚
  * `int getFront()` )ï¼šä»åŒç«¯é˜Ÿåˆ—å¤´éƒ¨è·å¾—ä¸€ä¸ªå…ƒç´ ã€‚å¦‚æœåŒç«¯é˜Ÿåˆ—ä¸ºç©ºï¼Œè¿”å› `-1` ã€‚
  * `int getRear()` ï¼šè·å¾—åŒç«¯é˜Ÿåˆ—çš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚ å¦‚æœåŒç«¯é˜Ÿåˆ—ä¸ºç©ºï¼Œè¿”å› `-1` ã€‚
  * `boolean isEmpty()` ï¼šè‹¥åŒç«¯é˜Ÿåˆ—ä¸ºç©ºï¼Œåˆ™è¿”å› `true` ï¼Œå¦åˆ™è¿”å› `false`  ã€‚
  * `boolean isFull()` ï¼šè‹¥åŒç«¯é˜Ÿåˆ—æ»¡äº†ï¼Œåˆ™è¿”å› `true` ï¼Œå¦åˆ™è¿”å› `false` ã€‚



**ç¤ºä¾‹ 1ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥**
> 
> ["MyCircularDeque", "insertLast", "insertLast", "insertFront", "insertFront", "getRear", "isFull", "deleteLast", "insertFront", "getFront"]
> 
> [[3], [1], [2], [3], [4], [], [], [], [4], []]
> 
> **è¾“å‡º**
> 
> [null, true, true, true, false, 2, true, true, true, 4]
> 
> 
> 
> **è§£é‡Š**
> 
> MyCircularDeque circularDeque = new MycircularDeque(3); // è®¾ç½®å®¹é‡å¤§å°ä¸º3
> 
> circularDeque.insertLast(1);			> 
> > 
> // è¿”å› true
> 
> circularDeque.insertLast(2);			> 
> > 
> // è¿”å› true
> 
> circularDeque.insertFront(3);			> 
> > 
> // è¿”å› true
> 
> circularDeque.insertFront(4);			> 
> > 
> // å·²ç»æ»¡äº†ï¼Œè¿”å› false
> 
> circularDeque.getRear();  				// è¿”å› 2
> 
> circularDeque.isFull();				> 
> > 
> // è¿”å› true
> 
> circularDeque.deleteLast();			> 
> > 
> // è¿”å› true
> 
> circularDeque.insertFront(4);			> 
> > 
> // è¿”å› true
> 
> circularDeque.getFront();				// è¿”å› 4
> 
>  



**æç¤ºï¼š**

  * `1 <= k <= 1000`
  * `0 <= value <= 1000`
  * `insertFront`, `insertLast`, `deleteFront`, `deleteLast`, `getFront`, `getRear`, `isEmpty`, `isFull`  è°ƒç”¨æ¬¡æ•°ä¸å¤§äº `2000` æ¬¡


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 622 | [è®¾è®¡å¾ªç¯é˜Ÿåˆ—](https://leetcode.com/problems/design-circular-queue) | [[âœ“]](https://2xiao.github.io/leetcode-js/leetcode/problem/0622) |  [`è®¾è®¡`](/leetcode/outline/tag/design.md) [`é˜Ÿåˆ—`](/leetcode/outline/tag/queue.md) [`æ•°ç»„`](/leetcode/outline/tag/array.md) `1+` | <font color=#ffb800>Medium</font> |
| 1670 | [è®¾è®¡å‰ä¸­åé˜Ÿåˆ—](https://leetcode.com/problems/design-front-middle-back-queue) |  |  [`è®¾è®¡`](/leetcode/outline/tag/design.md) [`é˜Ÿåˆ—`](/leetcode/outline/tag/queue.md) [`æ•°ç»„`](/leetcode/outline/tag/array.md) `2+` | <font color=#ffb800>Medium</font> |

<style>
.blue {
    background-color: #096dd9;
    padding: 0.25rem 0.5rem;
    margin: 0;
    font-size: 0.85em;
    border-radius: 3px;
    color: white;
    font-weight: 500;
}
table th:first-of-type { width: 10%; }
table th:nth-of-type(2) { width: 35%; }
table th:nth-of-type(3) { width: 10%; }
table th:nth-of-type(4) { width: 35%; }
table th:nth-of-type(5) { width: 10%; }
</style>
