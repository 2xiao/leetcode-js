# [284. çª¥è§†è¿­ä»£å™¨](https://leetcode.com/problems/peeking-iterator)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`è®¾è®¡`](/outline/tag/design.md) [`æ•°ç»„`](/outline/tag/array.md) [`è¿­ä»£å™¨`](/outline/tag/iterator.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/peeking-iterator)

## é¢˜ç›®

Design an iterator that supports the `peek` operation on an existing iterator
in addition to the `hasNext` and the `next` operations.

Implement the `PeekingIterator` class:

  * `PeekingIterator(Iterator<int> nums)` Initializes the object with the given integer iterator `iterator`.
  * `int next()` Returns the next element in the array and moves the pointer to the next element.
  * `boolean hasNext()` Returns `true` if there are still elements in the array.
  * `int peek()` Returns the next element in the array **without** moving the pointer.

**Note:** Each language may have a different implementation of the constructor
and `Iterator`, but they all support the `int next()` and `boolean hasNext()`
functions.



**Example 1:**

> 
> 
> 
> 
> 
> **Input**
> 
> ["PeekingIterator", "next", "peek", "next", "next", "hasNext"]
> 
> [[[1, 2, 3]], [], [], [], [], []]
> 
> **Output**
> 
> [null, 1, 2, 2, 3, false]
> 
> 
> 
> **Explanation**
> 
> PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [_**1**_ ,2,3]
> 
> peekingIterator.next();> 
> // return 1, the pointer moves to the next element [1,_**2**_ ,3].
> 
> peekingIterator.peek();> 
> // return 2, the pointer does not move [1,_**2**_ ,3].
> 
> peekingIterator.next();> 
> // return 2, the pointer moves to the next element [1,2,_**3**_]
> 
> peekingIterator.next();> 
> // return 3, the pointer moves to the next element [1,2,3]
> 
> peekingIterator.hasNext(); // return False

**Constraints:**

  * `1 <= nums.length <= 1000`
  * `1 <= nums[i] <= 1000`
  * All the calls to `next` and `peek` are valid.
  * At most `1000` calls will be made to `next`, `hasNext`, and `peek`.



**Follow up:** How would you extend your design to be generic and work with
all types, not just integer?


## é¢˜ç›®å¤§æ„

è¯·ä½ åœ¨è®¾è®¡ä¸€ä¸ªè¿­ä»£å™¨ï¼Œåœ¨é›†æˆç°æœ‰è¿­ä»£å™¨æ‹¥æœ‰çš„ `hasNext` å’Œ `next` æ“ä½œçš„åŸºç¡€ä¸Šï¼Œè¿˜é¢å¤–æ”¯æŒ `peek` æ“ä½œã€‚

å®ç° `PeekingIterator` ç±»ï¼š

  * `PeekingIterator(Iterator<int> nums)` ä½¿ç”¨æŒ‡å®šæ•´æ•°è¿­ä»£å™¨ `nums` åˆå§‹åŒ–è¿­ä»£å™¨ã€‚
  * `int next()` è¿”å›æ•°ç»„ä¸­çš„ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œå¹¶å°†æŒ‡é’ˆç§»åŠ¨åˆ°ä¸‹ä¸ªå…ƒç´ å¤„ã€‚
  * `bool hasNext()` å¦‚æœæ•°ç»„ä¸­å­˜åœ¨ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œè¿”å› `true` ï¼›å¦åˆ™ï¼Œè¿”å› `false` ã€‚
  * `int peek()` è¿”å›æ•°ç»„ä¸­çš„ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œä½† **ä¸** ç§»åŠ¨æŒ‡é’ˆã€‚

**æ³¨æ„ï¼š** æ¯ç§è¯­è¨€å¯èƒ½æœ‰ä¸åŒçš„æ„é€ å‡½æ•°å’Œè¿­ä»£å™¨ `Iterator`ï¼Œä½†å‡æ”¯æŒ `int next()` å’Œ `boolean hasNext()`
å‡½æ•°ã€‚



**ç¤ºä¾‹ 1ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š**
> 
> ["PeekingIterator", "next", "peek", "next", "next", "hasNext"]
> 
> [[[1, 2, 3]], [], [], [], [], []]
> 
> **è¾“å‡ºï¼š**
> 
> [null, 1, 2, 2, 3, false]
> 
> 
> 
> **è§£é‡Šï¼š**
> 
> PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [_**1**_ ,2,3]
> 
> peekingIterator.next();> 
> // è¿”å› 1 ï¼ŒæŒ‡é’ˆç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªå…ƒç´  [1,_**2**_ ,3]
> 
> peekingIterator.peek();> 
> // è¿”å› 2 ï¼ŒæŒ‡é’ˆæœªå‘ç”Ÿç§»åŠ¨ [1,_**2**_ ,3]
> 
> peekingIterator.next();> 
> // è¿”å› 2 ï¼ŒæŒ‡é’ˆç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªå…ƒç´  [1,2,_**3**_]
> 
> peekingIterator.next();> 
> // è¿”å› 3 ï¼ŒæŒ‡é’ˆç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªå…ƒç´  [1,2,3]
> 
> peekingIterator.hasNext(); // è¿”å› False
> 
> 



**æç¤ºï¼š**

  * `1 <= nums.length <= 1000`
  * `1 <= nums[i] <= 1000`
  * å¯¹ `next` å’Œ `peek` çš„è°ƒç”¨å‡æœ‰æ•ˆ
  * `next`ã€`hasNext` å’Œ `peek `æœ€å¤šè°ƒç”¨  `1000` æ¬¡



**è¿›é˜¶ï¼š** ä½ å°†å¦‚ä½•æ‹“å±•ä½ çš„è®¾è®¡ï¼Ÿä½¿ä¹‹å˜å¾—é€šç”¨åŒ–ï¼Œä»è€Œé€‚åº”æ‰€æœ‰çš„ç±»å‹ï¼Œè€Œä¸åªæ˜¯æ•´æ•°å‹ï¼Ÿ


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 173 | [äºŒå‰æœç´¢æ ‘è¿­ä»£å™¨](https://leetcode.com/problems/binary-search-tree-iterator) | [[âœ“]](/problem/0173) |  [`æ ˆ`](/outline/tag/stack.md) [`æ ‘`](/outline/tag/tree.md) [`è®¾è®¡`](/outline/tag/design.md) `3+` | <font color=#ffb800>Medium</font> |
| 251 | [å±•å¼€äºŒç»´å‘é‡](https://leetcode.com/problems/flatten-2d-vector) |  |  [`è®¾è®¡`](/outline/tag/design.md) [`æ•°ç»„`](/outline/tag/array.md) [`åŒæŒ‡é’ˆ`](/outline/tag/two-pointers.md) `1+` | <font color=#ffb800>Medium</font> |
| 281 | [é”¯é½¿è¿­ä»£å™¨](https://leetcode.com/problems/zigzag-iterator) |  |  [`è®¾è®¡`](/outline/tag/design.md) [`é˜Ÿåˆ—`](/outline/tag/queue.md) [`æ•°ç»„`](/outline/tag/array.md) `1+` | <font color=#ffb800>Medium</font> |

<style>
.blue {
    background-color: #096dd9;
    padding: 0.25rem 0.5rem;
    margin: 0;
    font-size: 0.85em;
    border-radius: 3px;
    color: white;
    font-weight: 500;
}
table th:first-of-type { width: 10%; }
table th:nth-of-type(2) { width: 35%; }
table th:nth-of-type(3) { width: 10%; }
table th:nth-of-type(4) { width: 35%; }
table th:nth-of-type(5) { width: 10%; }
</style>
