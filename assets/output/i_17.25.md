# [é¢è¯•é¢˜ 17.25. å•è¯çŸ©é˜µ](https://leetcode.cn/problems/word-rectangle-lcci)

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`å­—å…¸æ ‘`](/tag/trie.md) [`æ•°ç»„`](/tag/array.md) [`å­—ç¬¦ä¸²`](/tag/string.md) [`å›æº¯`](/tag/backtracking.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.cn/problems/word-rectangle-lcci)

## é¢˜ç›®

Given a list of millions of words, design an algorithm to create the largest
possible rectangle of letters such that every row forms a word (reading left
to right) and every column forms a word (reading top to bottom). The words
need not be chosen consecutively from the list but all rows must be the same
length and all columns must be the same height.

If there are more than one answer, return any one of them. A word can be used
more than once.

**Example 1:**

> 
> 
> 
> 
> 
> **Input:** ["this", "real", "hard", "trh", "hea", "iar", "sld"]
> 
> Output:[
> 
>    "this",
> 
>    "real",
> 
>    "hard"
> 
> ]

**Example 2:**

> 
> 
> 
> 
> 
> **Input:** ["aa"]
> 
> Output:["aa","aa"]

**Notes:**

  * `words.length <= 1000`
  * `words[i].length <= 100`
  * It's guaranteed that all the words are randomly generated.


## é¢˜ç›®å¤§æ„

ç»™å®šä¸€ä»½å•è¯çš„æ¸…å•ï¼Œè®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œåˆ›å»ºç”±å­—æ¯ç»„æˆçš„é¢ç§¯æœ€å¤§çš„çŸ©å½¢ï¼Œå…¶ä¸­æ¯ä¸€è¡Œç»„æˆä¸€ä¸ªå•è¯(è‡ªå·¦å‘å³)ï¼Œæ¯ä¸€åˆ—ä¹Ÿç»„æˆä¸€ä¸ªå•è¯(è‡ªä¸Šè€Œä¸‹)ã€‚ä¸è¦æ±‚è¿™äº›å•è¯åœ¨æ¸…å•é‡Œè¿ç»­å‡ºç°ï¼Œä½†è¦æ±‚æ‰€æœ‰è¡Œç­‰é•¿ï¼Œæ‰€æœ‰åˆ—ç­‰é«˜ã€‚

å¦‚æœæœ‰å¤šä¸ªé¢ç§¯æœ€å¤§çš„çŸ©å½¢ï¼Œè¾“å‡ºä»»æ„ä¸€ä¸ªå‡å¯ã€‚ä¸€ä¸ªå•è¯å¯ä»¥é‡å¤ä½¿ç”¨ã€‚

**ç¤ºä¾‹ 1:**

> 
> 
> 
> 
> 
> **è¾“å…¥:** ["this", "real", "hard", "trh", "hea", "iar", "sld"]
> 
> **è¾“å‡º:**[
> 
>    "this",
> 
>    "real",
> 
>    "hard"
> 
> ]

**ç¤ºä¾‹ 2:**

> 
> 
> 
> 
> 
> **è¾“å…¥:** ["aa"]
> 
> **è¾“å‡º:**["aa","aa"]

**è¯´æ˜ï¼š**

  * `words.length <= 1000`
  * `words[i].length <= 100`
  * æ•°æ®ä¿è¯å•è¯è¶³å¤Ÿéšæœº


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```