---
title: 439. 三元表达式解析器 🔒
description: LeetCode 439. 三元表达式解析器 🔒题解，Ternary Expression Parser，包含解题思路、复杂度分析以及完整的 JavaScript 代码实现。
keywords:
  - LeetCode
  - 439. 三元表达式解析器 🔒
  - 三元表达式解析器
  - Ternary Expression Parser
  - 解题思路
  - 栈
  - 递归
  - 字符串
---

# 439. 三元表达式解析器 🔒

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`栈`](/tag/stack.md) [`递归`](/tag/recursion.md) [`字符串`](/tag/string.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/ternary-expression-parser) [`LeetCode`](https://leetcode.com/problems/ternary-expression-parser)

## 题目

Given a string `expression` representing arbitrarily nested ternary
expressions, evaluate the expression, and return _the result of it_.

You can always assume that the given expression is valid and only contains
digits, `'?'`, `':'`, `'T'`, and `'F'` where `'T'` is true and `'F'` is false.
All the numbers in the expression are **one-digit** numbers (i.e., in the
range `[0, 9]`).

The conditional expressions group right-to-left (as usual in most languages),
and the result of the expression will always evaluate to either a digit, `'T'`
or `'F'`.



**Example 1:**

> Input: expression = "T?2:3"
> 
> Output: "2"
> 
> Explanation: If true, then result is 2; otherwise result is 3.

**Example 2:**

> Input: expression = "F?1:T?4:5"
> 
> Output: "4"
> 
> Explanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:
> 
> "(F ? 1 : (T ? 4 : 5))" --> "(F ? 1 : 4)" --> "4"
> 
> or "(F ? 1 : (T ? 4 : 5))" --> "(T ? 4 : 5)" --> "4"

**Example 3:**

> Input: expression = "T?T?F:5:3"
> 
> Output: "F"
> 
> Explanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:
> 
> "(T ? (T ? F : 5) : 3)" --> "(T ? F : 3)" --> "F"
> 
> "(T ? (T ? F : 5) : 3)" --> "(T ? F : 5)" --> "F"

**Constraints:**

  * `5 <= expression.length <= 10^4`
  * `expression` consists of digits, `'T'`, `'F'`, `'?'`, and `':'`.
  * It is **guaranteed** that `expression` is a valid ternary expression and that each number is a **one-digit number**.


## 题目大意

给定一个表示任意嵌套三元表达式的字符串 `expression` ，求值并返回其结果。

你可以总是假设给定的表达式是有效的，并且只包含数字， `'?'` ，  `':'` ，  `'T'` 和 `'F'` ，其中 `'T'` 为真， `'F'`
为假。表达式中的所有数字都是 **一位** 数(即在 **[0,9]** 范围内)。

条件表达式从右到左分组(大多数语言中都是这样)，表达式的结果总是为数字，`'T'` 或 `'F'` 。



**示例 1：**

> 
> 
> 
> 
> 
> **输入：** expression = "T?2:3"
> 
> **输出：** "2"
> 
> **解释：** 如果条件为真，结果为 2；否则，结果为 3。
> 
> 

**示例 2：**

> 
> 
> 
> 
> 
> **输入：** expression = "F?1:T?4:5"
> 
> **输出：** "4"
> 
> **解释：** 条件表达式自右向左结合。使用括号的话，相当于：
> 
>  "(F ? 1 : (T ? 4 : 5))" --> "(F ? 1 : 4)" --> "4"
> 
> or "(F ? 1 : (T ? 4 : 5))" --> "(T ? 4 : 5)" --> "4"
> 
> 

**示例 3：**

> 
> 
> 
> 
> 
> **输入：** expression = "T?T?F:5:3"
> 
> **输出：** "F"
> 
> **解释：** 条件表达式自右向左结合。使用括号的话，相当于：
> 
> "(T ? (T ? F : 5) : 3)" --> "(T ? F : 3)" --> "F"
> 
> "(T ? (T ? F : 5) : 3)" --> "(T ? F : 5)" --> "F"



**提示:**

  * `5 <= expression.length <= 10^4`
  * `expression` 由数字, `'T'`, `'F'`, `'?'` 和 `':'` 组成
  * **保证  **了表达式是一个有效的三元表达式，并且每个数字都是 **一位数**  


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 385 | 迷你语法分析器 | [[✓]](/problem/0385.md) |  [`栈`](/tag/stack.md) [`深度优先搜索`](/tag/depth-first-search.md) [`字符串`](/tag/string.md) | 🟠 | [🀄️](https://leetcode.cn/problems/mini-parser) [🔗](https://leetcode.com/problems/mini-parser) |
| 722 | 删除注释 |  |  [`数组`](/tag/array.md) [`字符串`](/tag/string.md) | 🟠 | [🀄️](https://leetcode.cn/problems/remove-comments) [🔗](https://leetcode.com/problems/remove-comments) |
| 736 | Lisp 语法解析 |  |  [`栈`](/tag/stack.md) [`递归`](/tag/recursion.md) [`哈希表`](/tag/hash-table.md) `1+` | 🔴 | [🀄️](https://leetcode.cn/problems/parse-lisp-expression) [🔗](https://leetcode.com/problems/parse-lisp-expression) |