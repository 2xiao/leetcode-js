# [16.14. æœ€ä½³ç›´çº¿](https://leetcode.cn/problems/best-line-lcci)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`å‡ ä½•`](/tag/geometry.md) [`æ•°ç»„`](/tag/array.md) [`å“ˆå¸Œè¡¨`](/tag/hash-table.md) [`æ•°å­¦`](/tag/math.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.cn/problems/best-line-lcci)

## é¢˜ç›®

Given a two-dimensional graph with points on it, find a line which passes the
most number of points.

Assume all the points that passed by the line are stored in list `S` sorted by
their number. You need to return `[S[0], S[1]]`, that is , two points that
have smallest number. If there are more than one line that passes the most
number of points, choose the one that has the smallest `S[0].` If there are
more that one line that has the same `S[0]`, choose the one that has smallest
`S[1]`.

**Example:**

> 
> 
> 
> 
> 
> **Input:** [[0,0],[1,1],[1,0],[2,0]]
> 
> Output: [0,2]
> 
> Explanation: The numbers of points passed by the line are [0,2,3].
> 
> 

**Note:**

  * `2 <= len(Points) <= 300`
  * `len(Points[i]) = 2`


## é¢˜ç›®å¤§æ„

ç»™å®šä¸€ä¸ªäºŒç»´å¹³é¢åŠå¹³é¢ä¸Šçš„ N
ä¸ªç‚¹åˆ—è¡¨`Points`ï¼Œå…¶ä¸­ç¬¬`i`ä¸ªç‚¹çš„åæ ‡ä¸º`Points[i]=[Xi,Yi]`ã€‚è¯·æ‰¾å‡ºä¸€æ¡ç›´çº¿ï¼Œå…¶é€šè¿‡çš„ç‚¹çš„æ•°ç›®æœ€å¤šã€‚

è®¾ç©¿è¿‡æœ€å¤šç‚¹çš„ç›´çº¿æ‰€ç©¿è¿‡çš„å…¨éƒ¨ç‚¹ç¼–å·ä»å°åˆ°å¤§æ’åºçš„åˆ—è¡¨ä¸º`S`ï¼Œä½ ä»…éœ€è¿”å›`[S[0],S[1]]`ä½œä¸ºç­”æ¡ˆï¼Œè‹¥æœ‰å¤šæ¡ç›´çº¿ç©¿è¿‡äº†ç›¸åŒæ•°é‡çš„ç‚¹ï¼Œåˆ™é€‰æ‹©`S[0]`å€¼è¾ƒå°çš„ç›´çº¿è¿”å›ï¼Œ`S[0]`ç›¸åŒåˆ™é€‰æ‹©`S[1]`å€¼è¾ƒå°çš„ç›´çº¿è¿”å›ã€‚

**ç¤ºä¾‹ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** [[0,0],[1,1],[1,0],[2,0]]
> 
> **è¾“å‡ºï¼š** [0,2]
> 
> **è§£é‡Šï¼š** æ‰€æ±‚ç›´çº¿ç©¿è¿‡çš„3ä¸ªç‚¹çš„ç¼–å·ä¸º[0,2,3]
> 
> 

**æç¤ºï¼š**

  * `2 <= len(Points) <= 300`
  * `len(Points[i]) = 2`


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```