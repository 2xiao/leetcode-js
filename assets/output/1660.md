---
title: 1660. 纠正二叉树 🔒
description: LeetCode 1660. 纠正二叉树 🔒题解，Correct a Binary Tree，包含解题思路、复杂度分析以及完整的 JavaScript 代码实现。
keywords:
  - LeetCode
  - 1660. 纠正二叉树 🔒
  - 纠正二叉树
  - Correct a Binary Tree
  - 解题思路
  - 树
  - 深度优先搜索
  - 广度优先搜索
  - 哈希表
  - 二叉树
---

# 1660. 纠正二叉树 🔒

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) [`哈希表`](/tag/hash-table.md) [`二叉树`](/tag/binary-tree.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/correct-a-binary-tree) [`LeetCode`](https://leetcode.com/problems/correct-a-binary-tree)

## 题目

You have a binary tree with a small defect. There is **exactly one** invalid
node where its right child incorrectly points to another node at the **same
depth** but to the **invalid node 's right**.

Given the root of the binary tree with this defect, `root`, return _the root
of the binary tree after**removing** this invalid node **and every node
underneath it** (minus the node it incorrectly points to)._

**Custom testing:**

The test input is read as 3 lines:

  * `TreeNode root`
  * `int fromNode` (**not available to**`correctBinaryTree`)
  * `int toNode` (**not available to**`correctBinaryTree`)

After the binary tree rooted at `root` is parsed, the `TreeNode` with value of
`fromNode` will have its right child pointer pointing to the `TreeNode` with a
value of `toNode`. Then, `root` is passed to `correctBinaryTree`.



**Example 1:**

**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1600-1699/1660.Correct%20a%20Binary%20Tree/images/ex1v2.png)**

> Input: root = [1,2,3], fromNode = 2, toNode = 3
> 
> Output: [1,null,3]
> 
> Explanation: The node with value 2 is invalid, so remove it.

**Example 2:**

**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1600-1699/1660.Correct%20a%20Binary%20Tree/images/ex2v3.png)**

> Input: root = [8,3,1,7,null,9,4,2,null,null,null,5,6], fromNode = 7, toNode = 4
> 
> Output: [8,3,1,null,null,9,4,null,null,5,6]
> 
> Explanation: The node with value 7 is invalid, so remove it and the node underneath it, node 2.

**Constraints:**

  * The number of nodes in the tree is in the range `[3, 104]`.
  * `-10^9 <= Node.val <= 10^9`
  * All `Node.val` are **unique**.
  * `fromNode != toNode`
  * `fromNode` and `toNode` will exist in the tree and will be on the same depth.
  * `toNode` is to the **right** of `fromNode`.
  * `fromNode.right` is `null` in the initial tree from the test data.


## 题目大意

你有一棵二叉树，这棵二叉树有个小问题，其中**有且只有一个** 无效节点，它的右子节点错误地指向了与其在**同一层** 且在其**右侧** 的一个其他节点。

给定一棵这样的问题二叉树的根节点 `root` ，将该无效节点**及其所有子节点移除** （除被错误指向的节点外），然后返回新二叉树的根结点。

**自定义测试用例：**

测试用例的输入由三行组成：

  * `TreeNode root`
  * `int fromNode` （在****`correctBinaryTree` 中**不可见** ）
  * `int toNode` （在****`correctBinaryTree` 中**不可见** ）

当以 `root` 为根的二叉树被解析后，值为 `fromNode` 的节点 `TreeNode` 将其右子节点指向值为 `toNode` 的节点
`TreeNode` 。然后， `root` 传入 `correctBinaryTree` 的参数中。

**示例 1:**

**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1600-1699/1660.Correct%20a%20Binary%20Tree/images/ex1v2.png)**

> 
> 
> 
> 
> 
> **输入:** root = [1,2,3], fromNode = 2, toNode = 3
> 
> **输出:** [1,null,3]
> 
> **解释:** 值为 2 的节点是无效的，所以移除之。
> 
> 

**示例 2:**

**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1600-1699/1660.Correct%20a%20Binary%20Tree/images/ex2v3.png)**

> 
> 
> 
> 
> 
> **输入:** root = [8,3,1,7,null,9,4,2,null,null,null,5,6], fromNode = 7, toNode = 4
> 
> **输出:** [8,3,1,null,null,9,4,null,null,5,6]
> 
> **解释:** 值为 7 的节点是无效的，所以移除这个节点及其子节点 2。
> 
> 

**提示:**

  * 树中节点个数的范围是 `[3, 104]` 。
  * `-10^9 <= Node.val <= 10^9`
  * 所有的 `Node.val` 都是**互不相同** 的。
  * `fromNode != toNode`
  * `fromNode` 和 `toNode` 将出现在树中的同一层。
  * `toNode` 在 `fromNode` 的右侧。
  * `fromNode.right` 在测试用例的树中建立后为 `null` 。


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 114 | 二叉树展开为链表 | [[✓]](/problem/0114.md) |  [`栈`](/tag/stack.md) [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) `2+` | 🟠 | [🀄️](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list) [🔗](https://leetcode.com/problems/flatten-binary-tree-to-linked-list) |
| 430 | 扁平化多级双向链表 | [[✓]](/problem/0430.md) |  [`深度优先搜索`](/tag/depth-first-search.md) [`链表`](/tag/linked-list.md) [`双向链表`](/tag/doubly-linked-list.md) | 🟠 | [🀄️](https://leetcode.cn/problems/flatten-a-multilevel-doubly-linked-list) [🔗](https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list) |