# [1660. çº æ­£äºŒå‰æ ‘](https://leetcode.com/problems/correct-a-binary-tree)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ ‘`](/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/tag/breadth-first-search.md) [`å“ˆå¸Œè¡¨`](/tag/hash-table.md) [`äºŒå‰æ ‘`](/tag/binary-tree.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/correct-a-binary-tree)

## é¢˜ç›®

You have a binary tree with a small defect. There is **exactly one** invalid
node where its right child incorrectly points to another node at the **same
depth** but to the **invalid node 's right**.

Given the root of the binary tree with this defect, `root`, return _the root
of the binary tree after**removing** this invalid node **and every node
underneath it** (minus the node it incorrectly points to)._

**Custom testing:**

The test input is read as 3 lines:

  * `TreeNode root`
  * `int fromNode` (**not available to**`correctBinaryTree`)
  * `int toNode` (**not available to**`correctBinaryTree`)

After the binary tree rooted at `root` is parsed, the `TreeNode` with value of
`fromNode` will have its right child pointer pointing to the `TreeNode` with a
value of `toNode`. Then, `root` is passed to `correctBinaryTree`.



**Example 1:**

**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1600-1699/1660.Correct%20a%20Binary%20Tree/images/ex1v2.png)**

> 
> 
> Input: root = [1,2,3], fromNode = 2, toNode = 3
> 
> 
> 
> Output: [1,null,3]
> 
> 
> 
> Explanation: The node with value 2 is invalid, so remove it.
> 
> 

**Example 2:**

**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1600-1699/1660.Correct%20a%20Binary%20Tree/images/ex2v3.png)**

> 
> 
> Input: root = [8,3,1,7,null,9,4,2,null,null,null,5,6], fromNode = 7, toNode = 4
> 
> 
> 
> Output: [8,3,1,null,null,9,4,null,null,5,6]
> 
> 
> 
> Explanation: The node with value 7 is invalid, so remove it and the node underneath it, node 2.
> 
> 

**Constraints:**

  * The number of nodes in the tree is in the range `[3, 104]`.
  * `-10^9 <= Node.val <= 10^9`
  * All `Node.val` are **unique**.
  * `fromNode != toNode`
  * `fromNode` and `toNode` will exist in the tree and will be on the same depth.
  * `toNode` is to the **right** of `fromNode`.
  * `fromNode.right` is `null` in the initial tree from the test data.


## é¢˜ç›®å¤§æ„

ä½ æœ‰ä¸€æ£µäºŒå‰æ ‘ï¼Œè¿™æ£µäºŒå‰æ ‘æœ‰ä¸ªå°é—®é¢˜ï¼Œå…¶ä¸­**æœ‰ä¸”åªæœ‰ä¸€ä¸ª** æ— æ•ˆèŠ‚ç‚¹ï¼Œå®ƒçš„å³å­èŠ‚ç‚¹é”™è¯¯åœ°æŒ‡å‘äº†ä¸å…¶åœ¨**åŒä¸€å±‚** ä¸”åœ¨å…¶**å³ä¾§** çš„ä¸€ä¸ªå…¶ä»–èŠ‚ç‚¹ã€‚

ç»™å®šä¸€æ£µè¿™æ ·çš„é—®é¢˜äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œå°†è¯¥æ— æ•ˆèŠ‚ç‚¹**åŠå…¶æ‰€æœ‰å­èŠ‚ç‚¹ç§»é™¤** ï¼ˆé™¤è¢«é”™è¯¯æŒ‡å‘çš„èŠ‚ç‚¹å¤–ï¼‰ï¼Œç„¶åè¿”å›æ–°äºŒå‰æ ‘çš„æ ¹ç»“ç‚¹ã€‚

**è‡ªå®šä¹‰æµ‹è¯•ç”¨ä¾‹ï¼š**

æµ‹è¯•ç”¨ä¾‹çš„è¾“å…¥ç”±ä¸‰è¡Œç»„æˆï¼š

  * `TreeNode root`
  * `int fromNode` ï¼ˆåœ¨****`correctBinaryTree` ä¸­**ä¸å¯è§** ï¼‰
  * `int toNode` ï¼ˆåœ¨****`correctBinaryTree` ä¸­**ä¸å¯è§** ï¼‰

å½“ä»¥ `root` ä¸ºæ ¹çš„äºŒå‰æ ‘è¢«è§£æåï¼Œå€¼ä¸º `fromNode` çš„èŠ‚ç‚¹ `TreeNode` å°†å…¶å³å­èŠ‚ç‚¹æŒ‡å‘å€¼ä¸º `toNode` çš„èŠ‚ç‚¹
`TreeNode` ã€‚ç„¶åï¼Œ `root` ä¼ å…¥ `correctBinaryTree` çš„å‚æ•°ä¸­ã€‚

**ç¤ºä¾‹ 1:**

**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1600-1699/1660.Correct%20a%20Binary%20Tree/images/ex1v2.png)**

> 
> 
> 
> 
> 
> **è¾“å…¥:** root = [1,2,3], fromNode = 2, toNode = 3
> 
> **è¾“å‡º:** [1,null,3]
> 
> **è§£é‡Š:** å€¼ä¸º 2 çš„èŠ‚ç‚¹æ˜¯æ— æ•ˆçš„ï¼Œæ‰€ä»¥ç§»é™¤ä¹‹ã€‚
> 
> 

**ç¤ºä¾‹ 2:**

**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1600-1699/1660.Correct%20a%20Binary%20Tree/images/ex2v3.png)**

> 
> 
> 
> 
> 
> **è¾“å…¥:** root = [8,3,1,7,null,9,4,2,null,null,null,5,6], fromNode = 7, toNode = 4
> 
> **è¾“å‡º:** [8,3,1,null,null,9,4,null,null,5,6]
> 
> **è§£é‡Š:** å€¼ä¸º 7 çš„èŠ‚ç‚¹æ˜¯æ— æ•ˆçš„ï¼Œæ‰€ä»¥ç§»é™¤è¿™ä¸ªèŠ‚ç‚¹åŠå…¶å­èŠ‚ç‚¹ 2ã€‚
> 
> 

**æç¤º:**

  * æ ‘ä¸­èŠ‚ç‚¹ä¸ªæ•°çš„èŒƒå›´æ˜¯ `[3, 104]` ã€‚
  * `-10^9 <= Node.val <= 10^9`
  * æ‰€æœ‰çš„ `Node.val` éƒ½æ˜¯**äº’ä¸ç›¸åŒ** çš„ã€‚
  * `fromNode != toNode`
  * `fromNode` å’Œ `toNode` å°†å‡ºç°åœ¨æ ‘ä¸­çš„åŒä¸€å±‚ã€‚
  * `toNode` åœ¨ `fromNode` çš„å³ä¾§ã€‚
  * `fromNode.right` åœ¨æµ‹è¯•ç”¨ä¾‹çš„æ ‘ä¸­å»ºç«‹åä¸º `null` ã€‚


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 114 | [äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨](https://leetcode.com/problems/flatten-binary-tree-to-linked-list) | [[âœ“]](/problem/0114.md) |  [`æ ˆ`](/tag/stack.md) [`æ ‘`](/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) `2+` | <font color=#ffb800>Medium</font> |
| 430 | [æ‰å¹³åŒ–å¤šçº§åŒå‘é“¾è¡¨](https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list) | [[âœ“]](/problem/0430.md) |  [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`é“¾è¡¨`](/tag/linked-list.md) [`åŒå‘é“¾è¡¨`](/tag/doubly-linked-list.md) | <font color=#ffb800>Medium</font> |