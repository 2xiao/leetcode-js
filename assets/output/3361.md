---
title: 3361. ä¸¤ä¸ªå­—ç¬¦ä¸²çš„åˆ‡æ¢è·ç¦»
description: LeetCode 3361. ä¸¤ä¸ªå­—ç¬¦ä¸²çš„åˆ‡æ¢è·ç¦»é¢˜è§£ï¼ŒShift Distance Between Two Stringsï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 3361. ä¸¤ä¸ªå­—ç¬¦ä¸²çš„åˆ‡æ¢è·ç¦»
  - ä¸¤ä¸ªå­—ç¬¦ä¸²çš„åˆ‡æ¢è·ç¦»
  - Shift Distance Between Two Strings
  - è§£é¢˜æ€è·¯
  - æ•°ç»„
  - å­—ç¬¦ä¸²
  - å‰ç¼€å’Œ
---

# 3361. ä¸¤ä¸ªå­—ç¬¦ä¸²çš„åˆ‡æ¢è·ç¦»

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ•°ç»„`](/tag/array.md) [`å­—ç¬¦ä¸²`](/tag/string.md) [`å‰ç¼€å’Œ`](/tag/prefix-sum.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/shift-distance-between-two-strings) [`LeetCode`](https://leetcode.com/problems/shift-distance-between-two-strings)

## é¢˜ç›®

You are given two strings `s` and `t` of the same length, and two integer
arrays `nextCost` and `previousCost`.

In one operation, you can pick any index `i` of `s`, and perform **either
one** of the following actions:

  * Shift `s[i]` to the next letter in the alphabet. If `s[i] == 'z'`, you should replace it with `'a'`. This operation costs `nextCost[j]` where `j` is the index of `s[i]` in the alphabet.
  * Shift `s[i]` to the previous letter in the alphabet. If `s[i] == 'a'`, you should replace it with `'z'`. This operation costs `previousCost[j]` where `j` is the index of `s[i]` in the alphabet.

The **shift distance** is the **minimum** total cost of operations required to
transform `s` into `t`.

Return the **shift distance** from `s` to `t`.



**Example 1:**

**Input:** s = "abab", t = "baba", nextCost =
[100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], previousCost =
[1,100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]

**Output:** 2

**Explanation:**

  * We choose index `i = 0` and shift `s[0]` 25 times to the previous character for a total cost of 1.
  * We choose index `i = 1` and shift `s[1]` 25 times to the next character for a total cost of 0.
  * We choose index `i = 2` and shift `s[2]` 25 times to the previous character for a total cost of 1.
  * We choose index `i = 3` and shift `s[3]` 25 times to the next character for a total cost of 0.

**Example 2:**

**Input:** s = "leet", t = "code", nextCost =
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1], previousCost =
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]

**Output:** 31

**Explanation:**

  * We choose index `i = 0` and shift `s[0]` 9 times to the previous character for a total cost of 9.
  * We choose index `i = 1` and shift `s[1]` 10 times to the next character for a total cost of 10.
  * We choose index `i = 2` and shift `s[2]` 1 time to the previous character for a total cost of 1.
  * We choose index `i = 3` and shift `s[3]` 11 times to the next character for a total cost of 11.



**Constraints:**

  * `1 <= s.length == t.length <= 10^5`
  * `s` and `t` consist only of lowercase English letters.
  * `nextCost.length == previousCost.length == 26`
  * `0 <= nextCost[i], previousCost[i] <= 10^9`


## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸¤ä¸ªé•¿åº¦ç›¸åŒçš„å­—ç¬¦ä¸² `s` å’Œ `t` ï¼Œä»¥åŠä¸¤ä¸ªæ•´æ•°æ•°ç»„ `nextCost` å’Œ `previousCost` ã€‚

ä¸€æ¬¡æ“ä½œä¸­ï¼Œä½ å¯ä»¥é€‰æ‹© `s` ä¸­çš„ä¸€ä¸ªä¸‹æ ‡ `i` ï¼Œæ‰§è¡Œä»¥ä¸‹æ“ä½œ **ä¹‹ä¸€**  ï¼š

  * å°† `s[i]` åˆ‡æ¢ä¸ºå­—æ¯è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªå­—æ¯ï¼Œå¦‚æœ `s[i] == 'z'` ï¼Œåˆ‡æ¢åå¾—åˆ° `'a'` ã€‚æ“ä½œçš„ä»£ä»·ä¸º `nextCost[j]` ï¼Œå…¶ä¸­ `j` è¡¨ç¤º `s[i]` åœ¨å­—æ¯è¡¨ä¸­çš„ä¸‹æ ‡ã€‚
  * å°† `s[i]` åˆ‡æ¢ä¸ºå­—æ¯è¡¨ä¸­çš„ä¸Šä¸€ä¸ªå­—æ¯ï¼Œå¦‚æœ `s[i] == 'a'` ï¼Œåˆ‡æ¢åå¾—åˆ° `'z'` ã€‚æ“ä½œçš„ä»£ä»·ä¸º `previousCost[j]` ï¼Œå…¶ä¸­ `j` æ˜¯ `s[i]` åœ¨å­—æ¯è¡¨ä¸­çš„ä¸‹æ ‡ã€‚

**åˆ‡æ¢è·ç¦»**  æŒ‡çš„æ˜¯å°†å­—ç¬¦ä¸² `s` å˜ä¸ºå­—ç¬¦ä¸² `t` çš„ **æœ€å°‘**  æ“ä½œä»£ä»·æ€»å’Œã€‚

è¯·ä½ è¿”å›ä» `s` åˆ° `t` çš„ **åˆ‡æ¢è·ç¦»**  ã€‚



**ç¤ºä¾‹ 1ï¼š**

**è¾“å…¥ï¼š** s = "abab", t = "baba", nextCost =
[100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], previousCost =
[1,100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]

**è¾“å‡ºï¼š** 2

**è§£é‡Šï¼š**

  * é€‰æ‹©ä¸‹æ ‡ `i = 0` å¹¶å°† `s[0]` å‘å‰åˆ‡æ¢ 25 æ¬¡ï¼Œæ€»ä»£ä»·ä¸º 1 ã€‚
  * é€‰æ‹©ä¸‹æ ‡ `i = 1` å¹¶å°† `s[1]` å‘ååˆ‡æ¢ 25 æ¬¡ï¼Œæ€»ä»£ä»·ä¸º 0 ã€‚
  * é€‰æ‹©ä¸‹æ ‡ `i = 2` å¹¶å°† `s[2]` å‘å‰åˆ‡æ¢ 25 æ¬¡ï¼Œæ€»ä»£ä»·ä¸º 1 ã€‚
  * é€‰æ‹©ä¸‹æ ‡ `i = 3` å¹¶å°† `s[3]` å‘ååˆ‡æ¢ 25 æ¬¡ï¼Œæ€»ä»£ä»·ä¸º 0 ã€‚

**ç¤ºä¾‹ 2ï¼š**

**è¾“å…¥ï¼š** s = "leet", t = "code", nextCost =
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1], previousCost =
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]

**è¾“å‡ºï¼š** 31

**è§£é‡Šï¼š**

  * é€‰æ‹©ä¸‹æ ‡ `i = 0` å¹¶å°† `s[0]` å‘å‰åˆ‡æ¢ 9 æ¬¡ï¼Œæ€»ä»£ä»·ä¸º 9 ã€‚
  * é€‰æ‹©ä¸‹æ ‡ `i = 1` å¹¶å°† `s[1]` å‘ååˆ‡æ¢ 10 æ¬¡ï¼Œæ€»ä»£ä»·ä¸º 10 ã€‚
  * é€‰æ‹©ä¸‹æ ‡ `i = 2` å¹¶å°† `s[2]` å‘å‰åˆ‡æ¢ 1 æ¬¡ï¼Œæ€»ä»£ä»·ä¸º 1 ã€‚
  * é€‰æ‹©ä¸‹æ ‡ `i = 3` å¹¶å°† `s[3]` å‘ååˆ‡æ¢ 11 æ¬¡ï¼Œæ€»ä»£ä»·ä¸º 11 ã€‚



**æç¤ºï¼š**

  * `1 <= s.length == t.length <= 10^5`
  * `s` å’Œ `t` éƒ½åªåŒ…å«å°å†™è‹±æ–‡å­—æ¯ã€‚
  * `nextCost.length == previousCost.length == 26`
  * `0 <= nextCost[i], previousCost[i] <= 10^9`


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ | åŠ›æ‰£ |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 848 | å­—æ¯ç§»ä½ |  |  [`æ•°ç»„`](/tag/array.md) [`å­—ç¬¦ä¸²`](/tag/string.md) [`å‰ç¼€å’Œ`](/tag/prefix-sum.md) | ğŸŸ  | [ğŸ€„ï¸](https://leetcode.cn/problems/shifting-letters) [ğŸ”—](https://leetcode.com/problems/shifting-letters) |
| 2381 | å­—æ¯ç§»ä½ II | [[âœ“]](/problem/2381.md) |  [`æ•°ç»„`](/tag/array.md) [`å­—ç¬¦ä¸²`](/tag/string.md) [`å‰ç¼€å’Œ`](/tag/prefix-sum.md) | ğŸŸ  | [ğŸ€„ï¸](https://leetcode.cn/problems/shifting-letters-ii) [ğŸ”—](https://leetcode.com/problems/shifting-letters-ii) |