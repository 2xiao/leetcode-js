---
title: 1778. æœªçŸ¥ç½‘æ ¼ä¸­çš„æœ€çŸ­è·¯å¾„ ğŸ”’
description: LeetCode,1778. æœªçŸ¥ç½‘æ ¼ä¸­çš„æœ€çŸ­è·¯å¾„ ğŸ”’,æœªçŸ¥ç½‘æ ¼ä¸­çš„æœ€çŸ­è·¯å¾„,Shortest Path in a Hidden Grid,è§£é¢˜æ€è·¯,æ·±åº¦ä¼˜å…ˆæœç´¢,å¹¿åº¦ä¼˜å…ˆæœç´¢,å›¾,äº¤äº’
keywords:
  - LeetCode
  - 1778. æœªçŸ¥ç½‘æ ¼ä¸­çš„æœ€çŸ­è·¯å¾„ ğŸ”’
  - æœªçŸ¥ç½‘æ ¼ä¸­çš„æœ€çŸ­è·¯å¾„
  - Shortest Path in a Hidden Grid
  - è§£é¢˜æ€è·¯
  - æ·±åº¦ä¼˜å…ˆæœç´¢
  - å¹¿åº¦ä¼˜å…ˆæœç´¢
  - å›¾
  - äº¤äº’
---

# 1778. æœªçŸ¥ç½‘æ ¼ä¸­çš„æœ€çŸ­è·¯å¾„ ğŸ”’

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/tag/breadth-first-search.md) [`å›¾`](/tag/graph.md) [`äº¤äº’`](/tag/interactive.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/shortest-path-in-a-hidden-grid) [`LeetCode`](https://leetcode.com/problems/shortest-path-in-a-hidden-grid)

## é¢˜ç›®

This is an **interactive problem**.

There is a robot in a hidden grid, and you are trying to get it from its
starting cell to the target cell in this grid. The grid is of size `m x n`,
and each cell in the grid is either empty or blocked. It is **guaranteed**
that the starting cell and the target cell are different, and neither of them
is blocked.

You want to find the minimum distance to the target cell. However, you **do
not know** the grid's dimensions, the starting cell, nor the target cell. You
are only allowed to ask queries to the `GridMaster` object.

Thr `GridMaster` class has the following functions:

  * `boolean canMove(char direction)` Returns `true` if the robot can move in that direction. Otherwise, it returns `false`.
  * `void move(char direction)` Moves the robot in that direction. If this move would move the robot to a blocked cell or off the grid, the move will be **ignored** , and the robot will remain in the same position.
  * `boolean isTarget()` Returns `true` if the robot is currently on the target cell. Otherwise, it returns `false`.

Note that `direction` in the above functions should be a character from
`{'U','D','L','R'}`, representing the directions up, down, left, and right,
respectively.

Return _the**minimum distance** between the robot's initial starting cell and
the target cell. If there is no valid path between the cells, return _`-1`.

**Custom testing:**

The test input is read as a 2D matrix `grid` of size `m x n` where:

  * `grid[i][j] == -1` indicates that the robot is in cell `(i, j)` (the starting cell).
  * `grid[i][j] == 0` indicates that the cell `(i, j)` is blocked.
  * `grid[i][j] == 1` indicates that the cell `(i, j)` is empty.
  * `grid[i][j] == 2` indicates that the cell `(i, j)` is the target cell.

There is exactly one `-1` and `2` in `grid`. Remember that you will **not**
have this information in your code.



**Example 1:**

> Input: grid = [[1,2],[-1,0]]
> 
> Output: 2
> 
> Explanation: One possible interaction is described below:
> 
> The robot is initially standing on cell (1, 0), denoted by the -1.
> - master.canMove('U') returns true.
> - master.canMove('D') returns false.
> - master.canMove('L') returns false.
> - master.canMove('R') returns false.
> - master.move('U') moves the robot to the cell (0, 0).
> - master.isTarget() returns false.
> - master.canMove('U') returns false.
> - master.canMove('D') returns true.
> - master.canMove('L') returns false.
> - master.canMove('R') returns true.
> - master.move('R') moves the robot to the cell (0, 1).
> - master.isTarget() returns true. 
> 
> We now know that the target is the cell (0, 1), and the shortest path to the target cell is 2.

**Example 2:**

> Input: grid = [[0,0,-1],[1,1,1],[2,0,0]]
> 
> Output: 4
> 
> Explanation:  The minimum distance between the robot and the target cell is 4.

**Example 3:**

> Input: grid = [[-1,0],[0,2]]
> 
> Output: -1
> 
> Explanation:  There is no path from the robot to the target cell.



**Constraints:**

  * `1 <= n, m <= 500`
  * `m == grid.length`
  * `n == grid[i].length`
  * `grid[i][j]` is either `-1`, `0`, `1`, or `2`.
  * There is **exactly one** `-1` in `grid`.
  * There is **exactly one** `2` in `grid`.


## é¢˜ç›®å¤§æ„

è¿™æ˜¯ä¸€ä¸ª**äº¤äº’å¼çš„é—®é¢˜ã€‚**

ä¸€ä¸ªæœªçŸ¥çš„ç½‘æ ¼é‡Œæœ‰ä¸€ä¸ªæœºå™¨äººï¼Œä½ éœ€è¦è®©æœºå™¨äººä»èµ·ç‚¹èµ°åˆ°ç»ˆç‚¹ã€‚è¿™ä¸ªç½‘æ ¼çš„å¤§å°æ˜¯ `m x
n`ï¼Œç½‘æ ¼ä¸­çš„æ¯ä¸ªä½ç½®åªä¼šæ˜¯å¯é€šè¡Œå’Œä¸å¯é€šè¡Œä¸¤ç§çŠ¶æ€ã€‚é¢˜ç›®**ä¿è¯** æœºå™¨äººçš„èµ·ç‚¹å’Œç»ˆç‚¹ä¸åŒï¼Œä¸”éƒ½æ˜¯å¯é€šè¡Œçš„ã€‚

ä½ éœ€è¦æ‰¾åˆ°èµ·ç‚¹åˆ°ç»ˆç‚¹çš„æœ€çŸ­è·¯å¾„ï¼Œç„¶è€Œä½ **ä¸çŸ¥é“** ç½‘æ ¼çš„å¤§å°ã€èµ·ç‚¹å’Œç»ˆç‚¹ã€‚ä½ åªèƒ½å‘ `GridMaster` å¯¹è±¡æŸ¥è¯¢ã€‚

`GridMaster`æœ‰è¿™äº›æ–¹æ³•ï¼š

  * `boolean canMove(char direction)` å½“æœºå™¨äººèƒ½å‘å¯¹åº”æ–¹å‘ç§»åŠ¨æ—¶ï¼Œè¿”å› `true`ï¼Œå¦åˆ™è¿”å› `false`ã€‚
  * `void move(char direction)` æŠŠæœºå™¨äººå‘è¿™ä¸ªæ–¹å‘ç§»åŠ¨ã€‚å¦‚æœç§»åŠ¨æ–¹å‘ä¸Šæ˜¯ä¸å¯é€šè¡Œçš„æˆ–æ˜¯ç½‘æ ¼çš„è¾¹ç•Œï¼Œåˆ™è¿™æ¬¡ç§»åŠ¨ä¼šè¢«**å¿½ç•¥** ï¼Œæœºå™¨äººä¼šå¾…åœ¨åŸåœ°ã€‚
  * `boolean isTarget()` å¦‚æœæœºå™¨äººå½“å‰ä½äºç»ˆç‚¹ï¼Œè¿”å› `true`ï¼Œå¦åˆ™è¿”å› `false`ã€‚

æ³¨æ„ä¸Šè¿°æ–¹æ³•ä¸­çš„directionåº”è¯¥æ˜¯ `{'U','D','L','R'}` ä¸­çš„ä¸€ä¸ªï¼Œåˆ†åˆ«ä»£è¡¨ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘ã€‚

è¿”å›æœºå™¨äººçš„åˆå§‹ä½ç½®åˆ°ç»ˆç‚¹çš„æœ€çŸ­è·ç¦»ã€‚å¦‚æœåœ¨èµ·ç‚¹å’Œç»ˆç‚¹é—´æ²¡æœ‰è·¯å¾„è”é€šï¼Œè¿”å› `-1`ã€‚

**è‡ªå®šä¹‰æµ‹è¯•ç”¨ä¾‹**

æµ‹è¯•ç”¨ä¾‹æ˜¯ä¸€ä¸ª `m x n` çš„äºŒç»´çŸ©é˜µ `grid`ï¼Œå…¶ä¸­ï¼š

  * `grid[i][j] == -1` è¡¨æ˜æœºå™¨äººä¸€å¼€å§‹ä½äºä½ç½® `(i, j)` ï¼ˆå³èµ·ç‚¹ï¼‰ã€‚
  * `grid[i][j] == 0` è¡¨æ˜ä½ç½® `(i, j)` ä¸å¯é€šè¡Œã€‚
  * `grid[i][j] == 1` è¡¨æ˜ä½ç½® `(i, j)` å¯ä»¥é€šè¡Œ.
  * `grid[i][j] == 2` è¡¨æ˜ä½ç½® `(i, j)` æ˜¯ç»ˆç‚¹.

`grid` é‡Œæ°æœ‰ä¸€ä¸ª`-1` å’Œä¸€ä¸ª `2`ã€‚è®°ä½åœ¨ä½ çš„ä»£ç ä¸­ï¼Œä½ å¯¹è¿™äº›ä¿¡æ¯å°†**ä¸€æ— æ‰€çŸ¥** ã€‚

**ç¤ºä¾‹1ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥:** grid = [[1,2],[-1,0]]
> 
> **è¾“å‡º:** 2
> 
> **è§£é‡Š:** ä¸€ç§å¯èƒ½çš„äº¤äº’è¿‡ç¨‹å¦‚ä¸‹ï¼š
> 
> The robot is initially standing on cell (1, 0), denoted by the -1.
> - master.canMove('U') è¿”å› true.
> - master.canMove('D') è¿”å›false.
> - master.canMove('L') è¿”å› false.
> - master.canMove('R') è¿”å› false.
> - master.move('U') æŠŠæœºå™¨äººç§»åŠ¨åˆ° (0, 0).
> - master.isTarget() è¿”å› false.
> - master.canMove('U') è¿”å› false.
> - master.canMove('D') è¿”å› true.
> - master.canMove('L') è¿”å› false.
> - master.canMove('R') è¿”å› true.
> - master.move('R') æŠŠæœºå™¨äººç§»åŠ¨åˆ° (0, 1).
> - master.isTarget() è¿”å› true. 
> 
> æˆ‘ä»¬ç°åœ¨çŸ¥é“ç»ˆç‚¹æ˜¯ç‚¹ (0, 1)ï¼Œè€Œä¸”æœ€çŸ­çš„è·¯å¾„æ˜¯2.
> 
> 

**ç¤ºä¾‹2:**

> 
> 
> 
> 
> 
> **è¾“å…¥:** grid = [[0,0,-1],[1,1,1],[2,0,0]]
> 
> **è¾“å‡º:** 4
> 
> **è§£é‡Š:**Â æœºå™¨äººå’Œç»ˆç‚¹çš„æœ€çŸ­è·¯å¾„é•¿æ˜¯4.

**ç¤ºä¾‹3:**

> 
> 
> 
> 
> 
> **è¾“å…¥:** grid = [[-1,0],[0,2]]
> 
> **è¾“å‡º:** -1
> 
> **è§£é‡Š:**Â æœºå™¨äººå’Œç»ˆç‚¹é—´æ²¡æœ‰å¯é€šè¡Œçš„è·¯å¾„.

**æç¤ºï¼š**

  * `1 <= n, m <= 500`
  * `m == grid.length`
  * `n == grid[i].length`
  * `grid[i][j]` åªå¯èƒ½æ˜¯ `-1`, `0`, `1` æˆ– `2`
  * `grid` ä¸­ **æœ‰ä¸”åªæœ‰ä¸€ä¸ª** `-1`
  * `grid` ä¸­**æœ‰ä¸”åªæœ‰ä¸€ä¸ª** `2`


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ | åŠ›æ‰£ |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 489 | æ‰«åœ°æœºå™¨äºº ğŸ”’ |  |  [`å›æº¯`](/tag/backtracking.md) [`äº¤äº’`](/tag/interactive.md) | ğŸ”´ | [ğŸ€„ï¸](https://leetcode.cn/problems/robot-room-cleaner) [ğŸ”—](https://leetcode.com/problems/robot-room-cleaner) |
| 1810 | éšè—ç½‘æ ¼ä¸‹çš„æœ€å°æ¶ˆè€—è·¯å¾„ ğŸ”’ |  |  [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/tag/breadth-first-search.md) [`å›¾`](/tag/graph.md) `2+` | ğŸŸ  | [ğŸ€„ï¸](https://leetcode.cn/problems/minimum-path-cost-in-a-hidden-grid) [ğŸ”—](https://leetcode.com/problems/minimum-path-cost-in-a-hidden-grid) |