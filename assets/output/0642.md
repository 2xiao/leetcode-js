# [642. è®¾è®¡æœç´¢è‡ªåŠ¨è¡¥å…¨ç³»ç»Ÿ ğŸ”’](https://2xiao.github.io/leetcode-js/problem/0642.html)

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`è®¾è®¡`](/tag/design.md) [`å­—å…¸æ ‘`](/tag/trie.md) [`å­—ç¬¦ä¸²`](/tag/string.md) [`æ•°æ®æµ`](/tag/data-stream.md) [`æ’åº`](/tag/sorting.md) [`å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰`](/tag/heap-priority-queue.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/design-search-autocomplete-system) [`LeetCode`](https://leetcode.com/problems/design-search-autocomplete-system)

## é¢˜ç›®

Design a search autocomplete system for a search engine. Users may input a
sentence (at least one word and end with a special character `'#'`).

You are given a string array `sentences` and an integer array `times` both of
length `n` where `sentences[i]` is a previously typed sentence and `times[i]`
is the corresponding number of times the sentence was typed. For each input
character except `'#'`, return the top `3` historical hot sentences that have
the same prefix as the part of the sentence already typed.

Here are the specific rules:

  * The hot degree for a sentence is defined as the number of times a user typed the exactly same sentence before.
  * The returned top `3` hot sentences should be sorted by hot degree (The first is the hottest one). If several sentences have the same hot degree, use ASCII-code order (smaller one appears first).
  * If less than `3` hot sentences exist, return as many as you can.
  * When the input is a special character, it means the sentence ends, and in this case, you need to return an empty list.

Implement the `AutocompleteSystem` class:

  * `AutocompleteSystem(String[] sentences, int[] times)` Initializes the object with the `sentences` and `times` arrays.
  * `List<String> input(char c)` This indicates that the user typed the character `c`. 
> 
> * Returns an empty array `[]` if `c == '#'` and stores the inputted sentence in the system.
> 
> * Returns the top `3` historical hot sentences that have the same prefix as the part of the sentence already typed. If there are fewer than `3` matches, return them all.



**Example 1:**

> 
> 
> 
> 
> 
> **Input**
> 
> ["AutocompleteSystem", "input", "input", "input", "input"]
> 
> [[["i love you", "island", "iroman", "i love leetcode"], [5, 3, 2, 2]], ["i"], [" "], ["a"], ["#"]]
> 
> **Output**
> 
> [null, ["i love you", "island", "i love leetcode"], ["i love you", "i love leetcode"], [], []]
> 
> 
> 
> **Explanation**
> 
> AutocompleteSystem obj = new AutocompleteSystem(["i love you", "island", "iroman", "i love leetcode"], [5, 3, 2, 2]);
> 
> obj.input("i"); // return ["i love you", "island", "i love leetcode"]. There are four sentences that have prefix "i". Among them, "ironman" and "i love leetcode" have same hot degree. Since ' ' has ASCII code 32 and 'r' has ASCII code 114, "i love leetcode" should be in front of "ironman". Also we only need to output top 3 hot sentences, so "ironman" will be ignored.
> 
> obj.input(" "); // return ["i love you", "i love leetcode"]. There are only two sentences that have prefix "i ".
> 
> obj.input("a"); // return []. There are no sentences that have prefix "i a".
> 
> obj.input("#"); // return []. The user finished the input, the sentence "i a" should be saved as a historical sentence in system. And the following input will be counted as a new search.

**Constraints:**

  * `n == sentences.length`
  * `n == times.length`
  * `1 <= n <= 100`
  * `1 <= sentences[i].length <= 100`
  * `1 <= times[i] <= 50`
  * `c` is a lowercase English letter, a hash `'#'`, or space `' '`.
  * Each tested sentence will be a sequence of characters `c` that end with the character `'#'`.
  * Each tested sentence will have a length in the range `[1, 200]`.
  * The words in each input sentence are separated by single spaces.
  * At most `5000` calls will be made to `input`.


## é¢˜ç›®å¤§æ„

ä¸ºæœç´¢å¼•æ“è®¾è®¡ä¸€ä¸ªæœç´¢è‡ªåŠ¨è¡¥å…¨ç³»ç»Ÿã€‚ç”¨æˆ·ä¼šè¾“å…¥ä¸€æ¡è¯­å¥ï¼ˆæœ€å°‘åŒ…å«ä¸€ä¸ªå­—æ¯ï¼Œä»¥ç‰¹æ®Šå­—ç¬¦ `'#'` ç»“å°¾ï¼‰ã€‚

ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ `sentences` å’Œä¸€ä¸ªæ•´æ•°æ•°ç»„ `times` ï¼Œé•¿åº¦éƒ½ä¸º `n` ï¼Œå…¶ä¸­ `sentences[i]` æ˜¯ä¹‹å‰è¾“å…¥çš„å¥å­ï¼Œ
`times[i]` æ˜¯è¯¥å¥å­è¾“å…¥çš„ç›¸åº”æ¬¡æ•°ã€‚å¯¹äºé™¤ `â€˜#â€™` ä»¥å¤–çš„æ¯ä¸ªè¾“å…¥å­—ç¬¦ï¼Œè¿”å›å‰ `3`
ä¸ªå†å²çƒ­é—¨å¥å­ï¼Œè¿™äº›å¥å­çš„å‰ç¼€ä¸å·²ç»è¾“å…¥çš„å¥å­çš„éƒ¨åˆ†ç›¸åŒã€‚

ä¸‹é¢æ˜¯è¯¦ç»†è§„åˆ™ï¼š

  * ä¸€æ¡å¥å­çš„çƒ­åº¦å®šä¹‰ä¸ºå†å²ä¸Šç”¨æˆ·è¾“å…¥è¿™ä¸ªå¥å­çš„æ€»æ¬¡æ•°ã€‚
  * è¿”å›å‰ `3` çš„å¥å­éœ€è¦æŒ‰ç…§çƒ­åº¦ä»é«˜åˆ°ä½æ’åºï¼ˆç¬¬ä¸€ä¸ªæ˜¯æœ€çƒ­é—¨çš„ï¼‰ã€‚å¦‚æœæœ‰å¤šæ¡çƒ­åº¦ç›¸åŒçš„å¥å­ï¼Œè¯·æŒ‰ç…§ ASCII ç çš„é¡ºåºè¾“å‡ºï¼ˆASCII ç è¶Šå°æ’åè¶Šå‰ï¼‰ã€‚
  * å¦‚æœæ»¡è¶³æ¡ä»¶çš„å¥å­ä¸ªæ•°å°‘äº `3` ï¼Œå°†å®ƒä»¬å…¨éƒ¨è¾“å‡ºã€‚
  * å¦‚æœè¾“å…¥äº†ç‰¹æ®Šå­—ç¬¦ï¼Œæ„å‘³ç€å¥å­ç»“æŸäº†ï¼Œè¯·è¿”å›ä¸€ä¸ªç©ºé›†åˆã€‚

å®ç° `AutocompleteSystem` ç±»ï¼š

  * `AutocompleteSystem(String[] sentences, int[] times):` ä½¿ç”¨æ•°ç»„`sentences` å’Œ `times` å¯¹å¯¹è±¡è¿›è¡Œåˆå§‹åŒ–ã€‚
  * `List<String> input(char c)` è¡¨ç¤ºç”¨æˆ·è¾“å…¥äº†å­—ç¬¦ `c` ã€‚ 
> 
> * å¦‚æœ `c == '#'` ï¼Œåˆ™è¿”å›ç©ºæ•°ç»„ `[]` ï¼Œå¹¶å°†è¾“å…¥çš„è¯­å¥å­˜å‚¨åœ¨ç³»ç»Ÿä¸­ã€‚
> 
> * è¿”å›å‰ `3` ä¸ªå†å²çƒ­é—¨å¥å­ï¼Œè¿™äº›å¥å­çš„å‰ç¼€ä¸å·²ç»è¾“å…¥çš„å¥å­çš„éƒ¨åˆ†ç›¸åŒã€‚å¦‚æœå°‘äº `3` ä¸ªåŒ¹é…é¡¹ï¼Œåˆ™å…¨éƒ¨è¿”å›ã€‚



**ç¤ºä¾‹ 1ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥**
> 
> ["AutocompleteSystem", "input", "input", "input", "input"]
> 
> [[["i love you", "island", "iroman", "i love leetcode"], [5, 3, 2, 2]], ["i"], [" "], ["a"], ["#"]]
> 
> **è¾“å‡º**
> 
> [null, ["i love you", "island", "i love leetcode"], ["i love you", "i love leetcode"], [], []]
> 
> 
> 
> **è§£é‡Š**
> 
> AutocompleteSystem obj = new AutocompleteSystem(["i love you", "island", "iroman", "i love leetcode"], [5, 3, 2, 2]);
> 
> obj.input("i"); // return ["i love you", "island", "i love leetcode"]. There are four sentences that have prefix "i". Among them, "ironman" and "i love leetcode" have same hot degree. Since ' ' has ASCII code 32 and 'r' has ASCII code 114, "i love leetcode" should be in front of "ironman". Also we only need to output top 3 hot sentences, so "ironman" will be ignored.
> 
> obj.input(" "); // return ["i love you", "i love leetcode"]. There are only two sentences that have prefix "i ".
> 
> obj.input("a"); // return []. There are no sentences that have prefix "i a".
> 
> obj.input("#"); // return []. The user finished the input, the sentence "i a" should be saved as a historical sentence in system. And the following input will be counted as a new search.
> 
> 



**æç¤º:**

  * `n == sentences.length`
  * `n == times.length`
  * `1 <= n <= 100`
  * `1 <= sentences[i].length <= 100`
  * `1 <= times[i] <= 50`
  * `c` æ˜¯å°å†™è‹±æ–‡å­—æ¯ï¼Œ `'#'`, æˆ–ç©ºæ ¼ `' '`
  * æ¯ä¸ªè¢«æµ‹è¯•çš„å¥å­å°†æ˜¯ä¸€ä¸ªä»¥å­—ç¬¦ `'#'` ç»“å°¾çš„å­—ç¬¦ `c` åºåˆ—ã€‚
  * æ¯ä¸ªè¢«æµ‹è¯•çš„å¥å­çš„é•¿åº¦èŒƒå›´ä¸º `[1,200]` 
  * æ¯ä¸ªè¾“å…¥å¥å­ä¸­çš„å•è¯ç”¨å•ä¸ªç©ºæ ¼éš”å¼€ã€‚
  * `input` æœ€å¤šè¢«è°ƒç”¨ `5000` æ¬¡


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 208 | [å®ç° Trie (å‰ç¼€æ ‘)](https://leetcode.com/problems/implement-trie-prefix-tree) | [[âœ“]](/problem/0208.md) |  [`è®¾è®¡`](/tag/design.md) [`å­—å…¸æ ‘`](/tag/trie.md) [`å“ˆå¸Œè¡¨`](/tag/hash-table.md) `1+` | <font color=#ffb800>Medium</font> |