# [449. åºåˆ—åŒ–å’Œååºåˆ—åŒ–äºŒå‰æœç´¢æ ‘](https://leetcode.com/problems/serialize-and-deserialize-bst)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ ‘`](/leetcode/outline/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/breadth-first-search.md) [`è®¾è®¡`](/leetcode/outline/tag/design.md) [`äºŒå‰æœç´¢æ ‘`](/leetcode/outline/tag/binary-search-tree.md) [`å­—ç¬¦ä¸²`](/leetcode/outline/tag/string.md) [`äºŒå‰æ ‘`](/leetcode/outline/tag/binary-tree.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/serialize-and-deserialize-bst)


## é¢˜ç›®

Serialization is converting a data structure or object into a sequence of bits
so that it can be stored in a file or memory buffer, or transmitted across a
network connection link to be reconstructed later in the same or another
computer environment.

Design an algorithm to serialize and deserialize a **binary search tree**.
There is no restriction on how your serialization/deserialization algorithm
should work. You need to ensure that a binary search tree can be serialized to
a string, and this string can be deserialized to the original tree structure.

**The encoded string should be as compact as possible.**



**Example 1:**

> Input: root = [2,1,3]
> 
> Output: [2,1,3]

**Example 2:**

> Input: root = []
> 
> Output: []

**Constraints:**

  * The number of nodes in the tree is in the range `[0, 104]`.
  * `0 <= Node.val <= 10^4`
  * The input tree is **guaranteed** to be a binary search tree.


## é¢˜ç›®å¤§æ„

åºåˆ—åŒ–æ˜¯å°†æ•°æ®ç»“æ„æˆ–å¯¹è±¡è½¬æ¢ä¸ºä¸€ç³»åˆ—ä½çš„è¿‡ç¨‹ï¼Œä»¥ä¾¿å®ƒå¯ä»¥å­˜å‚¨åœ¨æ–‡ä»¶æˆ–å†…å­˜ç¼“å†²åŒºä¸­ï¼Œæˆ–é€šè¿‡ç½‘ç»œè¿æ¥é“¾è·¯ä¼ è¾“ï¼Œä»¥ä¾¿ç¨ååœ¨åŒä¸€ä¸ªæˆ–å¦ä¸€ä¸ªè®¡ç®—æœºç¯å¢ƒä¸­é‡å»ºã€‚

è®¾è®¡ä¸€ä¸ªç®—æ³•æ¥åºåˆ—åŒ–å’Œååºåˆ—åŒ–**äºŒå‰æœç´¢æ ‘** ã€‚ å¯¹åºåˆ—åŒ–/ååºåˆ—åŒ–ç®—æ³•çš„å·¥ä½œæ–¹å¼æ²¡æœ‰é™åˆ¶ã€‚
æ‚¨åªéœ€ç¡®ä¿äºŒå‰æœç´¢æ ‘å¯ä»¥åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸²ï¼Œå¹¶ä¸”å¯ä»¥å°†è¯¥å­—ç¬¦ä¸²ååºåˆ—åŒ–ä¸ºæœ€åˆçš„äºŒå‰æœç´¢æ ‘ã€‚

**ç¼–ç çš„å­—ç¬¦ä¸²åº”å°½å¯èƒ½ç´§å‡‘ã€‚**



**ç¤ºä¾‹ 1ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** root = [2,1,3]
> 
> **è¾“å‡ºï¼š**[2,1,3]
> 
> 

**ç¤ºä¾‹ 2ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** root = []
> 
> **è¾“å‡ºï¼š**[]
> 
> 



**æç¤ºï¼š**

  * æ ‘ä¸­èŠ‚ç‚¹æ•°èŒƒå›´æ˜¯ `[0, 104]`
  * `0 <= Node.val <= 10^4`
  * é¢˜ç›®æ•°æ® **ä¿è¯** è¾“å…¥çš„æ ‘æ˜¯ä¸€æ£µäºŒå‰æœç´¢æ ‘ã€‚


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

:::: md-demo ç›¸å…³é¢˜ç›®
- [äºŒå‰æ ‘çš„åºåˆ—åŒ–ä¸ååºåˆ—åŒ–](https://leetcode.com/problems/serialize-and-deserialize-binary-tree)
- [å¯»æ‰¾é‡å¤çš„å­æ ‘](https://leetcode.com/problems/find-duplicate-subtrees)
- [åºåˆ—åŒ–å’Œååºåˆ—åŒ– N å‰æ ‘](https://leetcode.com/problems/serialize-and-deserialize-n-ary-tree)

::::
