# [1865. æ‰¾å‡ºå’Œä¸ºæŒ‡å®šå€¼çš„ä¸‹æ ‡å¯¹](https://leetcode.com/problems/finding-pairs-with-a-certain-sum)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`è®¾è®¡`](/leetcode/outline/tag/design.md) [`æ•°ç»„`](/leetcode/outline/tag/array.md) [`å“ˆå¸Œè¡¨`](/leetcode/outline/tag/hash-table.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/finding-pairs-with-a-certain-sum)


## é¢˜ç›®

You are given two integer arrays `nums1` and `nums2`. You are tasked to
implement a data structure that supports queries of two types:

  1. **Add** a positive integer to an element of a given index in the array `nums2`.
  2. **Count** the number of pairs `(i, j)` such that `nums1[i] + nums2[j]` equals a given value (`0 <= i < nums1.length` and `0 <= j < nums2.length`).

Implement the `FindSumPairs` class:

  * `FindSumPairs(int[] nums1, int[] nums2)` Initializes the `FindSumPairs` object with two integer arrays `nums1` and `nums2`.
  * `void add(int index, int val)` Adds `val` to `nums2[index]`, i.e., apply `nums2[index] += val`.
  * `int count(int tot)` Returns the number of pairs `(i, j)` such that `nums1[i] + nums2[j] == tot`.



**Example 1:**

> 
> 
> 
> 
> 
> **Input**
> 
> ["FindSumPairs", "count", "add", "count", "count", "add", "add", "count"]
> 
> [[[1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]], [7], [3, 2], [8], [4], [0, 1], [1, 1], [7]]
> 
> **Output**
> 
> [null, 8, null, 2, 1, null, null, 11]
> 
> 
> 
> **Explanation**
> 
> FindSumPairs findSumPairs = new FindSumPairs([1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]);
> 
> findSumPairs.count(7);  // return 8; pairs (2,2), (3,2), (4,2), (2,4), (3,4), (4,4) make 2 + 5 and pairs (5,1), (5,5) make 3 + 4
> 
> findSumPairs.add(3, 2); // now nums2 = [1,4,5,**_4_**,5,4]
> 
> findSumPairs.count(8);  // return 2; pairs (5,2), (5,4) make 3 + 5
> 
> findSumPairs.count(4);  // return 1; pair (5,0) makes 3 + 1
> 
> findSumPairs.add(0, 1); // now nums2 = [**_2_** ,4,5,4,5,4]
> 
> findSumPairs.add(1, 1); // now nums2 = [2,**_5_** ,5,4,5,4]
> 
> findSumPairs.count(7);  // return 11; pairs (2,1), (2,2), (2,4), (3,1), (3,2), (3,4), (4,1), (4,2), (4,4) make 2 + 5 and pairs (5,3), (5,5) make 3 + 4

**Constraints:**

  * `1 <= nums1.length <= 1000`
  * `1 <= nums2.length <= 10^5`
  * `1 <= nums1[i] <= 10^9`
  * `1 <= nums2[i] <= 10^5`
  * `0 <= index < nums2.length`
  * `1 <= val <= 10^5`
  * `1 <= tot <= 10^9`
  * At most `1000` calls are made to `add` and `count` **each**.


## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸¤ä¸ªæ•´æ•°æ•°ç»„ `nums1` å’Œ `nums2` ï¼Œè¯·ä½ å®ç°ä¸€ä¸ªæ”¯æŒä¸‹è¿°ä¸¤ç±»æŸ¥è¯¢çš„æ•°æ®ç»“æ„ï¼š

  1. **ç´¯åŠ ** ï¼Œå°†ä¸€ä¸ªæ­£æ•´æ•°åŠ åˆ° `nums2` ä¸­æŒ‡å®šä¸‹æ ‡å¯¹åº”å…ƒç´ ä¸Šã€‚
  2. **è®¡æ•°** ï¼Œç»Ÿè®¡æ»¡è¶³ `nums1[i] + nums2[j]` ç­‰äºæŒ‡å®šå€¼çš„ä¸‹æ ‡å¯¹ `(i, j)` æ•°ç›®ï¼ˆ`0 <= i < nums1.length` ä¸” `0 <= j < nums2.length`ï¼‰ã€‚

å®ç° `FindSumPairs` ç±»ï¼š

  * `FindSumPairs(int[] nums1, int[] nums2)` ä½¿ç”¨æ•´æ•°æ•°ç»„ `nums1` å’Œ `nums2` åˆå§‹åŒ– `FindSumPairs` å¯¹è±¡ã€‚
  * `void add(int index, int val)` å°† `val` åŠ åˆ° `nums2[index]` ä¸Šï¼Œå³ï¼Œæ‰§è¡Œ `nums2[index] += val` ã€‚
  * `int count(int tot)` è¿”å›æ»¡è¶³ `nums1[i] + nums2[j] == tot` çš„ä¸‹æ ‡å¯¹ `(i, j)` æ•°ç›®ã€‚

**ç¤ºä¾‹ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š**
> 
> ["FindSumPairs", "count", "add", "count", "count", "add", "add", "count"]
> 
> [[[1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]], [7], [3, 2], [8], [4], [0, 1], [1, 1], [7]]
> 
> **è¾“å‡ºï¼š**
> 
> [null, 8, null, 2, 1, null, null, 11]
> 
> 
> 
> **è§£é‡Šï¼š**
> 
> FindSumPairs findSumPairs = new FindSumPairs([1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]);
> 
> findSumPairs.count(7);  // è¿”å› 8 ; ä¸‹æ ‡å¯¹ (2,2), (3,2), (4,2), (2,4), (3,4), (4,4) æ»¡è¶³ 2 + 5 = 7 ï¼Œä¸‹æ ‡å¯¹ (5,1), (5,5) æ»¡è¶³ 3 + 4 = 7
> 
> findSumPairs.add(3, 2); // æ­¤æ—¶ nums2 = [1,4,5,_**4**_,5,4]
> 
> findSumPairs.count(8);  // è¿”å› 2 ï¼›ä¸‹æ ‡å¯¹ (5,2), (5,4) æ»¡è¶³ 3 + 5 = 8
> 
> findSumPairs.count(4);  // è¿”å› 1 ï¼›ä¸‹æ ‡å¯¹ (5,0) æ»¡è¶³ 3 + 1 = 4
> 
> findSumPairs.add(0, 1); // æ­¤æ—¶ nums2 = [_**2**_ ,4,5,4,5,4]
> 
> findSumPairs.add(1, 1); // æ­¤æ—¶ nums2 = [2,_**5**_ ,5,4,5,4]
> 
> findSumPairs.count(7);  // è¿”å› 11 ï¼›ä¸‹æ ‡å¯¹ (2,1), (2,2), (2,4), (3,1), (3,2), (3,4), (4,1), (4,2), (4,4) æ»¡è¶³ 2 + 5 = 7 ï¼Œä¸‹æ ‡å¯¹ (5,3), (5,5) æ»¡è¶³ 3 + 4 = 7
> 
> 

**æç¤ºï¼š**

  * `1 <= nums1.length <= 1000`
  * `1 <= nums2.length <= 10^5`
  * `1 <= nums1[i] <= 10^9`
  * `1 <= nums2[i] <= 10^5`
  * `0 <= index < nums2.length`
  * `1 <= val <= 10^5`
  * `1 <= tot <= 10^9`
  * æœ€å¤šè°ƒç”¨ `add` å’Œ `count` å‡½æ•°å„ `1000` æ¬¡


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

:::: md-demo ç›¸å…³é¢˜ç›®
- [2006. å·®çš„ç»å¯¹å€¼ä¸º K çš„æ•°å¯¹æ•°ç›®](https://leetcode.com/problems/count-number-of-pairs-with-absolute-difference-k)
- [2465. ä¸åŒçš„å¹³å‡å€¼æ•°ç›®](https://leetcode.com/problems/number-of-distinct-averages)
- [2563. ç»Ÿè®¡å…¬å¹³æ•°å¯¹çš„æ•°ç›®](https://leetcode.com/problems/count-the-number-of-fair-pairs)

::::
