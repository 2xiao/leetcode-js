# [1048. æœ€é•¿å­—ç¬¦ä¸²é“¾](https://leetcode.com/problems/longest-string-chain)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ•°ç»„`](/outline/tag/array.md) [`å“ˆå¸Œè¡¨`](/outline/tag/hash-table.md) [`åŒæŒ‡é’ˆ`](/outline/tag/two-pointers.md) [`å­—ç¬¦ä¸²`](/outline/tag/string.md) [`åŠ¨æ€è§„åˆ’`](/outline/tag/dynamic-programming.md) [`æ’åº`](/outline/tag/sorting.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/longest-string-chain)

## é¢˜ç›®

You are given an array of `words` where each word consists of lowercase
English letters.

`wordA` is a **predecessor** of `wordB` if and only if we can insert **exactly
one** letter anywhere in `wordA` **without changing the order of the other
characters** to make it equal to `wordB`.

  * For example, `"abc"` is a **predecessor** of `"ab _a_ c"`, while `"cba"` is not a **predecessor** of `"bcad"`.

A **word chain** __ is a sequence of words `[word1, word2, ..., wordk]` with
`k >= 1`, where `word1` is a **predecessor** of `word2`, `word2` is a
**predecessor** of `word3`, and so on. A single word is trivially a **word
chain** with `k == 1`.

Return _the**length** of the **longest possible word chain** with words chosen
from the given list of _`words`.



**Example 1:**

> Input: words = ["a","b","ba","bca","bda","bdca"]
> 
> Output: 4
> 
> **Explanation** : One of the longest word chains is ["a","_b_ a","b _d_ a","bd _c_ a"].

**Example 2:**

> Input: words = ["xbc","pcxbcf","xb","cxbc","pcxbc"]
> 
> Output: 5
> 
> Explanation: All the words can be put in a word chain ["xb", "xb _c_ ", "_c_ xbc", "_p_ cxbc", "pcxbc _f_ "].

**Example 3:**

> Input: words = ["abcd","dbqca"]
> 
> Output: 1
> 
> Explanation: The trivial word chain ["abcd"] is one of the longest word chains.
> 
> ["abcd","dbqca"] is not a valid word chain because the ordering of the letters is changed.

**Constraints:**

  * `1 <= words.length <= 1000`
  * `1 <= words[i].length <= 16`
  * `words[i]` only consists of lowercase English letters.


## é¢˜ç›®å¤§æ„

ç»™å‡ºä¸€ä¸ªå•è¯æ•°ç»„ `words` ï¼Œå…¶ä¸­æ¯ä¸ªå•è¯éƒ½ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆã€‚

å¦‚æœæˆ‘ä»¬å¯ä»¥ **ä¸æ”¹å˜å…¶ä»–å­—ç¬¦çš„é¡ºåº  **ï¼Œåœ¨ `wordA` çš„ä»»ä½•åœ°æ–¹æ·»åŠ  **æ°å¥½ä¸€ä¸ª** å­—æ¯ä½¿å…¶å˜æˆ `wordB` ï¼Œé‚£ä¹ˆæˆ‘ä»¬è®¤ä¸º
`wordA` æ˜¯ `wordB` çš„ **å‰èº«** ã€‚

  * ä¾‹å¦‚ï¼Œ`"abc"` æ˜¯ `"abac"` çš„ **å‰èº«**  ï¼Œè€Œ `"cba"` ä¸æ˜¯ `"bcad"` çš„ **å‰èº«**

**è¯é“¾** æ˜¯å•è¯ `[word_1, word_2, ..., word_k]` ç»„æˆçš„åºåˆ—ï¼Œ`k >= 1`ï¼Œå…¶ä¸­ `word1` æ˜¯ `word2`
çš„å‰èº«ï¼Œ`word2` æ˜¯ `word3` çš„å‰èº«ï¼Œä¾æ­¤ç±»æ¨ã€‚ä¸€ä¸ªå•è¯é€šå¸¸æ˜¯ `k == 1` çš„ **å•è¯é“¾**  ã€‚

ä»ç»™å®šå•è¯åˆ—è¡¨ `words` ä¸­é€‰æ‹©å•è¯ç»„æˆè¯é“¾ï¼Œè¿”å› è¯é“¾çš„ **æœ€é•¿å¯èƒ½é•¿åº¦** ã€‚  


**ç¤ºä¾‹ 1ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** words = ["a","b","ba","bca","bda","bdca"]
> 
> **è¾“å‡ºï¼š** 4
> 
> **è§£é‡Šï¼š** æœ€é•¿å•è¯é“¾ä¹‹ä¸€ä¸º ["a","_b_ a","b _d_ a","bd _c_ a"]
> 
> 

**ç¤ºä¾‹ 2:**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** words = ["xbc","pcxbcf","xb","cxbc","pcxbc"]
> 
> **è¾“å‡ºï¼š** 5
> 
> **è§£é‡Šï¼š** æ‰€æœ‰çš„å•è¯éƒ½å¯ä»¥æ”¾å…¥å•è¯é“¾ ["xb", "xb _c_ ", "_c_ xbc", "_p_ cxbc", "pcxbc _f_ "].
> 
> 

**ç¤ºä¾‹  3:**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** words = ["abcd","dbqca"]
> 
> **è¾“å‡ºï¼š** 1
> 
> **è§£é‡Šï¼š** å­—é“¾["abcd"]æ˜¯æœ€é•¿çš„å­—é“¾ä¹‹ä¸€ã€‚
> 
> ["abcd"ï¼Œ"dbqca"]ä¸æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„å•è¯é“¾ï¼Œå› ä¸ºå­—æ¯çš„é¡ºåºè¢«æ”¹å˜äº†ã€‚
> 
> 



**æç¤ºï¼š**

  * `1 <= words.length <= 1000`
  * `1 <= words[i].length <= 16`
  * `words[i]` ä»…ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆã€‚


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```