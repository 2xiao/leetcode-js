# [33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array)

## é¢˜ç›®

There is an integer array `nums` sorted in ascending order (with **distinct**
values).

Prior to being passed to your function, `nums` is **possibly rotated** at an
unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array
is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (
**0-indexed** ). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot
index `3` and become `[4,5,6,7,0,1,2]`.

Given the array `nums` **after** the possible rotation and an integer
`target`, return _the index of_`target` _if it is in_`nums` _, or_`-1` _if it
is not in_`nums`.

You must write an algorithm with `O(log n)` runtime complexity.



**Example 1:**

> Input: nums = [4,5,6,7,0,1,2], target = 0
> 
> Output: 4

**Example 2:**

> Input: nums = [4,5,6,7,0,1,2], target = 3
> 
> Output: -1

**Example 3:**

> Input: nums = [1], target = 0
> 
> Output: -1

**Constraints:**

  * `1 <= nums.length <= 5000`
  * `-104 <= nums[i] <= 104`
  * All values of `nums` are **unique**.
  * `nums` is an ascending array that is possibly rotated.
  * `-104 <= target <= 104`


## é¢˜ç›®å¤§æ„

## è§£é¢˜æ€è·¯

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

:::: md-demo ç›¸å…³é¢˜ç›®
- [81. æœç´¢æ—‹è½¬æŽ’åºæ•°ç»„ II](https://leetcode.com/problems/search-in-rotated-sorted-array-ii)
- [153. å¯»æ‰¾æ—‹è½¬æŽ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼](./0153.md)
- [ðŸ”’ Pour Water Between Buckets to Make Water Levels Equal](https://leetcode.com/problems/pour-water-between-buckets-to-make-water-levels-equal)

::::
