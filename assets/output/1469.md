---
title: 1469. 寻找所有的独生节点 🔒
description: LeetCode 1469. 寻找所有的独生节点 🔒题解，Find All The Lonely Nodes，包含解题思路、复杂度分析以及完整的 JavaScript 代码实现。
keywords:
  - LeetCode
  - 1469. 寻找所有的独生节点 🔒
  - 寻找所有的独生节点
  - Find All The Lonely Nodes
  - 解题思路
  - 树
  - 深度优先搜索
  - 广度优先搜索
  - 二叉树
---

# 1469. 寻找所有的独生节点 🔒

🟢 <font color=#15bd66>Easy</font>&emsp; 🔖&ensp; [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) [`二叉树`](/tag/binary-tree.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/find-all-the-lonely-nodes) [`LeetCode`](https://leetcode.com/problems/find-all-the-lonely-nodes)

## 题目

In a binary tree, a **lonely** node is a node that is the only child of its
parent node. The root of the tree is not lonely because it does not have a
parent node.

Given the `root` of a binary tree, return _an array containing the values of
all lonely nodes_ in the tree. Return the list **in any order**.



**Example 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1400-1499/1469.Find%20All%20The%20Lonely%20Nodes/images/e1.png)

> Input: root = [1,2,3,null,4]
> 
> Output: [4]
> 
> Explanation: Light blue node is the only lonely node.
> 
> Node 1 is the root and is not lonely.
> 
> Nodes 2 and 3 have the same parent and are not lonely.

**Example 2:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1400-1499/1469.Find%20All%20The%20Lonely%20Nodes/images/e2.png)

> Input: root = [7,1,4,6,null,5,3,null,null,null,null,null,2]
> 
> Output: [6,2]
> 
> Explanation: Light blue nodes are lonely nodes.
> 
> Please remember that order doesn't matter, [2,6] is also an acceptable answer.

**Example 3:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1400-1499/1469.Find%20All%20The%20Lonely%20Nodes/images/tree.png)

> Input: root = [11,99,88,77,null,null,66,55,null,null,44,33,null,null,22]
> 
> Output: [77,55,33,66,44,22]
> 
> Explanation: Nodes 99 and 88 share the same parent. Node 11 is the root.
> 
> All other nodes are lonely.

**Constraints:**

  * The number of nodes in the `tree` is in the range `[1, 1000].`
  * `1 <= Node.val <= 10^6`


## 题目大意

二叉树中，如果一个节点是其父节点的唯一子节点，则称这样的节点为 “**独生节点** ” 。二叉树的根节点不会是独生节点，因为它没有父节点。

给定一棵二叉树的根节点 `root` ，返回树中**所有的独生节点的值所构成的数组** 。数组的顺序**不限** 。



**示例 1：**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1400-1499/1469.Find%20All%20The%20Lonely%20Nodes/images/e1.png)

> 
> 
> 
> 
> 
> **输入：** root = [1,2,3,null,4]
> 
> **输出：**[4]
> 
> **解释：** 浅蓝色的节点是唯一的独生节点。
> 
> 节点 1 是根节点，不是独生的。
> 
> 节点 2 和 3 有共同的父节点，所以它们都不是独生的。
> 
> 

**示例 2：**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1400-1499/1469.Find%20All%20The%20Lonely%20Nodes/images/e2.png)

> 
> 
> 
> 
> 
> **输入：** root = [7,1,4,6,null,5,3,null,null,null,null,null,2]
> 
> **输出：**[6,2]
> 
> **输出：** 浅蓝色的节点是独生节点。
> 
> 请谨记，顺序是不限的。 [2,6] 也是一种可接受的答案。
> 
> 

**示例 3：**

**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1400-1499/1469.Find%20All%20The%20Lonely%20Nodes/images/tree.png)**

> 
> 
> 
> 
> 
> **输入：** root = [11,99,88,77,null,null,66,55,null,null,44,33,null,null,22]
> 
> **输出：**[77,55,33,66,44,22]
> 
> **解释：** 节点 99 和 88 有共同的父节点，节点 11 是根节点。
> 
> 其他所有节点都是独生节点。
> 
> 



**提示：**

  * `tree` 中节点个数的取值范围是 `[1, 1000]`。
  * `1 <= Node.val <= 10^6`


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 563 | 二叉树的坡度 | [[✓]](/problem/0563.md) |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`二叉树`](/tag/binary-tree.md) | 🟢 | [🀄️](https://leetcode.cn/problems/binary-tree-tilt) [🔗](https://leetcode.com/problems/binary-tree-tilt) |
| 965 | 单值二叉树 | [[✓]](/problem/0965.md) |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) `1+` | 🟢 | [🀄️](https://leetcode.cn/problems/univalued-binary-tree) [🔗](https://leetcode.com/problems/univalued-binary-tree) |