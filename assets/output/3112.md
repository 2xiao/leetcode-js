# [3112. è®¿é—®æ¶ˆå¤±èŠ‚ç‚¹çš„æœ€å°‘æ—¶é—´](https://leetcode.com/problems/minimum-time-to-visit-disappearing-nodes)

ðŸŸ  <font color=#ffb800>Medium</font>&emsp; ðŸ”–&ensp; [`å›¾`](/leetcode/outline/tag/graph.md) [`æ•°ç»„`](/leetcode/outline/tag/array.md) [`æœ€çŸ­è·¯`](/leetcode/outline/tag/shortest-path.md) [`å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰`](/leetcode/outline/tag/heap-priority-queue.md)&emsp; ðŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/minimum-time-to-visit-disappearing-nodes)


## é¢˜ç›®

There is an undirected graph of `n` nodes. You are given a 2D array `edges`,
where `edges[i] = [ui, vi, lengthi]` describes an edge between node `ui` and
node `vi` with a traversal time of `lengthi` units.

Additionally, you are given an array `disappear`, where `disappear[i]` denotes
the time when the node `i` disappears from the graph and you won't be able to
visit it.

**Note**  that the graph might be _disconnected_ and might contain _multiple
edges_.

Return the array `answer`, with `answer[i]` denoting the **minimum** units of
time required to reach node `i` from node 0. If node `i` is **unreachable**
from node 0 then `answer[i]` is `-1`.



**Example 1:**

**Input:** n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,1,5]

**Output:** [0,-1,4]

**Explanation:**

![](https://assets.leetcode.com/uploads/2024/08/11/output-onlinepngtools.png)

We are starting our journey from node 0, and our goal is to find the minimum
time required to reach each node before it disappears.

  * For node 0, we don't need any time as it is our starting point.
  * For node 1, we need at least 2 units of time to traverse `edges[0]`. Unfortunately, it disappears at that moment, so we won't be able to visit it.
  * For node 2, we need at least 4 units of time to traverse `edges[2]`.

**Example 2:**

**Input:** n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,3,5]

**Output:** [0,2,3]

**Explanation:**

![](https://assets.leetcode.com/uploads/2024/08/11/output-
onlinepngtools-1.png)

We are starting our journey from node 0, and our goal is to find the minimum
time required to reach each node before it disappears.

  * For node 0, we don't need any time as it is the starting point.
  * For node 1, we need at least 2 units of time to traverse `edges[0]`.
  * For node 2, we need at least 3 units of time to traverse `edges[0]` and `edges[1]`.

**Example 3:**

**Input:** n = 2, edges = [[0,1,1]], disappear = [1,1]

**Output:** [0,-1]

**Explanation:**

Exactly when we reach node 1, it disappears.



**Constraints:**

  * `1 <= n <= 5 * 10^4`
  * `0 <= edges.length <= 10^5`
  * `edges[i] == [ui, vi, lengthi]`
  * `0 <= ui, vi <= n - 1`
  * `1 <= lengthi <= 10^5`
  * `disappear.length == n`
  * `1 <= disappear[i] <= 10^5`


## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ªäºŒç»´æ•°ç»„ `edges` è¡¨ç¤ºä¸€ä¸ª `n` ä¸ªç‚¹çš„æ— å‘å›¾ï¼Œå…¶ä¸­ `edges[i] = [ui, vi, lengthi]` è¡¨ç¤ºèŠ‚ç‚¹ `ui`
å’ŒèŠ‚ç‚¹ `vi` ä¹‹é—´æœ‰ä¸€æ¡éœ€è¦ `lengthi` å•ä½æ—¶é—´é€šè¿‡çš„æ— å‘è¾¹ã€‚

åŒæ—¶ç»™ä½ ä¸€ä¸ªæ•°ç»„ `disappear` ï¼Œå…¶ä¸­ `disappear[i]` è¡¨ç¤ºèŠ‚ç‚¹ `i` ä»Žå›¾ä¸­æ¶ˆå¤±çš„æ—¶é—´ç‚¹ï¼Œåœ¨é‚£ä¸€åˆ»åŠä»¥åŽï¼Œä½ æ— æ³•å†è®¿é—®è¿™ä¸ªèŠ‚ç‚¹ã€‚

**æ³¨æ„** ï¼Œå›¾æœ‰å¯èƒ½ä¸€å¼€å§‹æ˜¯ä¸è¿žé€šçš„ï¼Œä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´ä¹Ÿå¯èƒ½æœ‰å¤šæ¡è¾¹ã€‚

è¯·ä½ è¿”å›žæ•°ç»„ `answer` ï¼Œ`answer[i]` è¡¨ç¤ºä»ŽèŠ‚ç‚¹ `0` åˆ°èŠ‚ç‚¹ `i` éœ€è¦çš„ **æœ€å°‘**  å•ä½æ—¶é—´ã€‚å¦‚æžœä»ŽèŠ‚ç‚¹ `0` å‡ºå‘
**æ— æ³•** åˆ°è¾¾èŠ‚ç‚¹ `i` ï¼Œé‚£ä¹ˆ `answer[i]` ä¸º `-1` ã€‚



**ç¤ºä¾‹ 1ï¼š**

![](https://assets.leetcode.com/uploads/2024/03/09/example1.png)

**è¾“å…¥ï¼š** n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,1,5]

**è¾“å‡ºï¼š**[0,-1,4]

**è§£é‡Šï¼š**

æˆ‘ä»¬ä»ŽèŠ‚ç‚¹ 0 å‡ºå‘ï¼Œç›®çš„æ˜¯ç”¨æœ€å°‘çš„æ—¶é—´åœ¨å…¶ä»–èŠ‚ç‚¹æ¶ˆå¤±ä¹‹å‰åˆ°è¾¾å®ƒä»¬ã€‚

  * å¯¹äºŽèŠ‚ç‚¹ 0 ï¼Œæˆ‘ä»¬ä¸éœ€è¦ä»»ä½•æ—¶é—´ï¼Œå› ä¸ºå®ƒå°±æ˜¯æˆ‘ä»¬çš„èµ·ç‚¹ã€‚
  * å¯¹äºŽèŠ‚ç‚¹ 1 ï¼Œæˆ‘ä»¬éœ€è¦è‡³å°‘ 2 å•ä½æ—¶é—´ï¼Œé€šè¿‡ `edges[0]` åˆ°è¾¾ã€‚ä½†å½“æˆ‘ä»¬åˆ°è¾¾çš„æ—¶å€™ï¼Œå®ƒå·²ç»æ¶ˆå¤±äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬æ— æ³•åˆ°è¾¾å®ƒã€‚
  * å¯¹äºŽèŠ‚ç‚¹ 2 ï¼Œæˆ‘ä»¬éœ€è¦è‡³å°‘ 4 å•ä½æ—¶é—´ï¼Œé€šè¿‡ `edges[2]` åˆ°è¾¾ã€‚

**ç¤ºä¾‹ 2ï¼š**

![](https://assets.leetcode.com/uploads/2024/03/09/example2.png)

**è¾“å…¥ï¼š** n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,3,5]

**è¾“å‡ºï¼š**[0,2,3]

**è§£é‡Šï¼š**

æˆ‘ä»¬ä»ŽèŠ‚ç‚¹ 0 å‡ºå‘ï¼Œç›®çš„æ˜¯ç”¨æœ€å°‘çš„æ—¶é—´åœ¨å…¶ä»–èŠ‚ç‚¹æ¶ˆå¤±ä¹‹å‰åˆ°è¾¾å®ƒä»¬ã€‚

  * å¯¹äºŽèŠ‚ç‚¹ 0 ï¼Œæˆ‘ä»¬ä¸éœ€è¦ä»»ä½•æ—¶é—´ï¼Œå› ä¸ºå®ƒå°±æ˜¯æˆ‘ä»¬çš„èµ·ç‚¹ã€‚
  * å¯¹äºŽèŠ‚ç‚¹ 1 ï¼Œæˆ‘ä»¬éœ€è¦è‡³å°‘ 2 å•ä½æ—¶é—´ï¼Œé€šè¿‡ `edges[0]` åˆ°è¾¾ã€‚
  * å¯¹äºŽèŠ‚ç‚¹ 2 ï¼Œæˆ‘ä»¬éœ€è¦è‡³å°‘ 3 å•ä½æ—¶é—´ï¼Œé€šè¿‡ `edges[0]` å’Œ `edges[1]` åˆ°è¾¾ã€‚

**ç¤ºä¾‹ 3ï¼š**

**è¾“å…¥ï¼š** n = 2, edges = [[0,1,1]], disappear = [1,1]

**è¾“å‡ºï¼š**[0,-1]

**è§£é‡Šï¼š**

å½“æˆ‘ä»¬åˆ°è¾¾èŠ‚ç‚¹ 1 çš„æ—¶å€™ï¼Œå®ƒæ°å¥½æ¶ˆå¤±ï¼Œæ‰€ä»¥æˆ‘ä»¬æ— æ³•åˆ°è¾¾èŠ‚ç‚¹ 1 ã€‚



**æç¤ºï¼š**

  * `1 <= n <= 5 * 10^4`
  * `0 <= edges.length <= 10^5`
  * `edges[i] == [ui, vi, lengthi]`
  * `0 <= ui, vi <= n - 1`
  * `1 <= lengthi <= 10^5`
  * `disappear.length == n`
  * `1 <= disappear[i] <= 10^5`


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æž

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

:::: md-demo ç›¸å…³é¢˜ç›®
- [3313. None](https://leetcode.com/problems/find-the-last-marked-nodes-in-tree)

::::
