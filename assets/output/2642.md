---
title: 2642. è®¾è®¡å¯ä»¥æ±‚æœ€çŸ­è·¯å¾„çš„å›¾ç±»
description: LeetCode,2642. è®¾è®¡å¯ä»¥æ±‚æœ€çŸ­è·¯å¾„çš„å›¾ç±»,è®¾è®¡å¯ä»¥æ±‚æœ€çŸ­è·¯å¾„çš„å›¾ç±»,Design Graph With Shortest Path Calculator,è§£é¢˜æ€è·¯,å›¾,è®¾è®¡,æœ€çŸ­è·¯,å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰
keywords:
  - LeetCode
  - 2642. è®¾è®¡å¯ä»¥æ±‚æœ€çŸ­è·¯å¾„çš„å›¾ç±»
  - è®¾è®¡å¯ä»¥æ±‚æœ€çŸ­è·¯å¾„çš„å›¾ç±»
  - Design Graph With Shortest Path Calculator
  - è§£é¢˜æ€è·¯
  - å›¾
  - è®¾è®¡
  - æœ€çŸ­è·¯
  - å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰
---

# 2642. è®¾è®¡å¯ä»¥æ±‚æœ€çŸ­è·¯å¾„çš„å›¾ç±»

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`å›¾`](/tag/graph.md) [`è®¾è®¡`](/tag/design.md) [`æœ€çŸ­è·¯`](/tag/shortest-path.md) [`å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰`](/tag/heap-priority-queue.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/design-graph-with-shortest-path-calculator) [`LeetCode`](https://leetcode.com/problems/design-graph-with-shortest-path-calculator)

## é¢˜ç›®

There is a **directed weighted** graph that consists of `n` nodes numbered
from `0` to `n - 1`. The edges of the graph are initially represented by the
given array `edges` where `edges[i] = [fromi, toi, edgeCosti]` meaning that
there is an edge from `fromi` to `toi` with the cost `edgeCosti`.

Implement the `Graph` class:

  * `Graph(int n, int[][] edges)` initializes the object with `n` nodes and the given edges.
  * `addEdge(int[] edge)` adds an edge to the list of edges where `edge = [from, to, edgeCost]`. It is guaranteed that there is no edge between the two nodes before adding this one.
  * `int shortestPath(int node1, int node2)` returns the **minimum** cost of a path from `node1` to `node2`. If no path exists, return `-1`. The cost of a path is the sum of the costs of the edges in the path.



**Example 1:**

![](https://assets.leetcode.com/uploads/2023/01/11/graph3drawio-2.png)

> 
> 
> 
> 
> 
> **Input**
> 
> ["Graph", "shortestPath", "shortestPath", "addEdge", "shortestPath"]
> 
> [[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]
> 
> **Output**
> 
> [null, 6, -1, null, 6]
> 
> 
> 
> **Explanation**
> 
> Graph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);
> 
> g.shortestPath(3, 2); // return 6. The shortest path from 3 to 2 in the first diagram above is 3 -> 0 -> 1 -> 2 with a total cost of 3 + 2 + 1 = 6.
> 
> g.shortestPath(0, 3); // return -1. There is no path from 0 to 3.
> 
> g.addEdge([1, 3, 4]); // We add an edge from node 1 to node 3, and we get the second diagram above.
> 
> g.shortestPath(0, 3); // return 6. The shortest path from 0 to 3 now is 0 -> 1 -> 3 with a total cost of 2 + 4 = 6.

**Constraints:**

  * `1 <= n <= 100`
  * `0 <= edges.length <= n * (n - 1)`
  * `edges[i].length == edge.length == 3`
  * `0 <= fromi, toi, from, to, node1, node2 <= n - 1`
  * `1 <= edgeCosti, edgeCost <= 10^6`
  * There are no repeated edges and no self-loops in the graph at any point.
  * At most `100` calls will be made for `addEdge`.
  * At most `100` calls will be made for `shortestPath`.


## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ªæœ‰ `n` ä¸ªèŠ‚ç‚¹çš„ **æœ‰å‘å¸¦æƒ**  å›¾ï¼ŒèŠ‚ç‚¹ç¼–å·ä¸º `0` åˆ° `n - 1` ã€‚å›¾ä¸­çš„åˆå§‹è¾¹ç”¨æ•°ç»„ `edges` è¡¨ç¤ºï¼Œå…¶ä¸­
`edges[i] = [fromi, toi, edgeCosti]` è¡¨ç¤ºä» `fromi` åˆ° `toi` æœ‰ä¸€æ¡ä»£ä»·ä¸º `edgeCosti`
çš„è¾¹ã€‚

è¯·ä½ å®ç°ä¸€ä¸ª `Graph` ç±»ï¼š

  * `Graph(int n, int[][] edges)` åˆå§‹åŒ–å›¾æœ‰ `n` ä¸ªèŠ‚ç‚¹ï¼Œå¹¶è¾“å…¥åˆå§‹è¾¹ã€‚
  * `addEdge(int[] edge)` å‘è¾¹é›†ä¸­æ·»åŠ ä¸€æ¡è¾¹ï¼Œå…¶ä¸­** **`edge = [from, to, edgeCost]` ã€‚æ•°æ®ä¿è¯æ·»åŠ è¿™æ¡è¾¹ä¹‹å‰å¯¹åº”çš„ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´æ²¡æœ‰æœ‰å‘è¾¹ã€‚
  * `int shortestPath(int node1, int node2)` è¿”å›ä»èŠ‚ç‚¹ `node1` åˆ° `node2` çš„è·¯å¾„**  æœ€å°** ä»£ä»·ã€‚å¦‚æœè·¯å¾„ä¸å­˜åœ¨ï¼Œè¿”å› `-1` ã€‚ä¸€æ¡è·¯å¾„çš„ä»£ä»·æ˜¯è·¯å¾„ä¸­æ‰€æœ‰è¾¹ä»£ä»·ä¹‹å’Œã€‚



**ç¤ºä¾‹ 1ï¼š**

![](https://assets.leetcode.com/uploads/2023/01/11/graph3drawio-2.png)

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š**
> 
> ["Graph", "shortestPath", "shortestPath", "addEdge", "shortestPath"]
> 
> [[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]
> 
> **è¾“å‡ºï¼š**
> 
> [null, 6, -1, null, 6]
> 
> 
> 
> **è§£é‡Šï¼š**
> 
> Graph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);
> 
> g.shortestPath(3, 2); // è¿”å› 6 ã€‚ä» 3 åˆ° 2 çš„æœ€çŸ­è·¯å¾„å¦‚ç¬¬ä¸€å¹…å›¾æ‰€ç¤ºï¼š3 -> 0 -> 1 -> 2 ï¼Œæ€»ä»£ä»·ä¸º 3 + 2 + 1 = 6 ã€‚
> 
> g.shortestPath(0, 3); // è¿”å› -1 ã€‚æ²¡æœ‰ä» 0 åˆ° 3 çš„è·¯å¾„ã€‚
> 
> g.addEdge([1, 3, 4]); // æ·»åŠ ä¸€æ¡èŠ‚ç‚¹ 1 åˆ°èŠ‚ç‚¹ 3 çš„è¾¹ï¼Œå¾—åˆ°ç¬¬äºŒå¹…å›¾ã€‚
> 
> g.shortestPath(0, 3); // è¿”å› 6 ã€‚ä» 0 åˆ° 3 çš„æœ€çŸ­è·¯å¾„ä¸º 0 -> 1 -> 3 ï¼Œæ€»ä»£ä»·ä¸º 2 + 4 = 6 ã€‚
> 
> 



**æç¤ºï¼š**

  * `1 <= n <= 100`
  * `0 <= edges.length <= n * (n - 1)`
  * `edges[i].length == edge.length == 3`
  * `0 <= fromi, toi, from, to, node1, node2 <= n - 1`
  * `1 <= edgeCosti, edgeCost <= 10^6`
  * å›¾ä¸­ä»»ä½•æ—¶å€™éƒ½ä¸ä¼šæœ‰é‡è¾¹å’Œè‡ªç¯ã€‚
  * è°ƒç”¨ `addEdge` è‡³å¤š `100` æ¬¡ã€‚
  * è°ƒç”¨ `shortestPath` è‡³å¤š `100` æ¬¡ã€‚


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ | åŠ›æ‰£ |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 1786 | ä»ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å‡ºå‘åˆ°æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„å—é™è·¯å¾„æ•° |  |  [`å›¾`](/tag/graph.md) [`æ‹“æ‰‘æ’åº`](/tag/topological-sort.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md) `2+` | ğŸŸ  | [ğŸ€„ï¸](https://leetcode.cn/problems/number-of-restricted-paths-from-first-to-last-node) [ğŸ”—](https://leetcode.com/problems/number-of-restricted-paths-from-first-to-last-node) |
| 2277 | æ ‘ä¸­æœ€æ¥è¿‘è·¯å¾„çš„èŠ‚ç‚¹ ğŸ”’ |  |  [`æ ‘`](/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/tag/breadth-first-search.md) `1+` | ğŸ”´ | [ğŸ€„ï¸](https://leetcode.cn/problems/closest-node-to-path-in-tree) [ğŸ”—](https://leetcode.com/problems/closest-node-to-path-in-tree) |