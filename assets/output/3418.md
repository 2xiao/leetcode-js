---
title: 3418. 机器人可以获得的最大金币数
description: LeetCode 3418. 机器人可以获得的最大金币数题解，Maximum Amount of Money Robot Can Earn，包含解题思路、复杂度分析以及完整的 JavaScript 代码实现。
keywords:
  - LeetCode
  - 3418. 机器人可以获得的最大金币数
  - 机器人可以获得的最大金币数
  - Maximum Amount of Money Robot Can Earn
  - 解题思路
  - 数组
  - 动态规划
  - 矩阵
---

# 3418. 机器人可以获得的最大金币数

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`数组`](/tag/array.md) [`动态规划`](/tag/dynamic-programming.md) [`矩阵`](/tag/matrix.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/maximum-amount-of-money-robot-can-earn) [`LeetCode`](https://leetcode.com/problems/maximum-amount-of-money-robot-can-earn)

## 题目

You are given an `m x n` grid. A robot starts at the top-left corner of the
grid `(0, 0)` and wants to reach the bottom-right corner `(m - 1, n - 1)`. The
robot can move either right or down at any point in time.

The grid contains a value `coins[i][j]` in each cell:

  * If `coins[i][j] >= 0`, the robot gains that many coins.
  * If `coins[i][j] < 0`, the robot encounters a robber, and the robber steals the **absolute** value of `coins[i][j]` coins.

The robot has a special ability to **neutralize robbers** in at most **2
cells** on its path, preventing them from stealing coins in those cells.

**Note:** The robot's total coins can be negative.

Return the **maximum** profit the robot can gain on the route.



**Example 1:**

**Input:** coins = [[0,1,-1],[1,-2,3],[2,-3,4]]

**Output:** 8

**Explanation:**

An optimal path for maximum coins is:

  1. Start at `(0, 0)` with `0` coins (total coins = `0`).
  2. Move to `(0, 1)`, gaining `1` coin (total coins = `0 + 1 = 1`).
  3. Move to `(1, 1)`, where there's a robber stealing `2` coins. The robot uses one neutralization here, avoiding the robbery (total coins = `1`).
  4. Move to `(1, 2)`, gaining `3` coins (total coins = `1 + 3 = 4`).
  5. Move to `(2, 2)`, gaining `4` coins (total coins = `4 + 4 = 8`).

**Example 2:**

**Input:** coins = [[10,10,10],[10,10,10]]

**Output:** 40

**Explanation:**

An optimal path for maximum coins is:

  1. Start at `(0, 0)` with `10` coins (total coins = `10`).
  2. Move to `(0, 1)`, gaining `10` coins (total coins = `10 + 10 = 20`).
  3. Move to `(0, 2)`, gaining another `10` coins (total coins = `20 + 10 = 30`).
  4. Move to `(1, 2)`, gaining the final `10` coins (total coins = `30 + 10 = 40`).



**Constraints:**

  * `m == coins.length`
  * `n == coins[i].length`
  * `1 <= m, n <= 500`
  * `-1000 <= coins[i][j] <= 1000`


## 题目大意

给你一个 `m x n` 的网格。一个机器人从网格的左上角 `(0, 0)` 出发，目标是到达网格的右下角 `(m - 1, n -
1)`。在任意时刻，机器人只能向右或向下移动。

网格中的每个单元格包含一个值 `coins[i][j]`：

  * 如果 `coins[i][j] >= 0`，机器人可以获得该单元格的金币。
  * 如果 `coins[i][j] < 0`，机器人会遇到一个强盗，强盗会抢走该单元格数值的 **绝对值** 的金币。

机器人有一项特殊能力，可以在行程中 **最多感化  **2个单元格的强盗，从而防止这些单元格的金币被抢走。

**注意：** 机器人的总金币数可以是负数。

返回机器人在路径上可以获得的 **最大金币数  **。



**示例 1：**

**输入：** coins = [[0,1,-1],[1,-2,3],[2,-3,4]]

**输出：** 8

**解释：**

一个获得最多金币的最优路径如下：

  1. 从 `(0, 0)` 出发，初始金币为 `0`（总金币 = `0`）。
  2. 移动到 `(0, 1)`，获得 `1` 枚金币（总金币 = `0 + 1 = 1`）。
  3. 移动到 `(1, 1)`，遇到强盗抢走 `2` 枚金币。机器人在此处使用一次感化能力，避免被抢（总金币 = `1`）。
  4. 移动到 `(1, 2)`，获得 `3` 枚金币（总金币 = `1 + 3 = 4`）。
  5. 移动到 `(2, 2)`，获得 `4` 枚金币（总金币 = `4 + 4 = 8`）。

**示例 2：**

**输入：** coins = [[10,10,10],[10,10,10]]

**输出：** 40

**解释：**

一个获得最多金币的最优路径如下：

  1. 从 `(0, 0)` 出发，初始金币为 `10`（总金币 = `10`）。
  2. 移动到 `(0, 1)`，获得 `10` 枚金币（总金币 = `10 + 10 = 20`）。
  3. 移动到 `(0, 2)`，再获得 `10` 枚金币（总金币 = `20 + 10 = 30`）。
  4. 移动到 `(1, 2)`，获得 `10` 枚金币（总金币 = `30 + 10 = 40`）。



**提示：**

  * `m == coins.length`
  * `n == coins[i].length`
  * `1 <= m, n <= 500`
  * `-1000 <= coins[i][j] <= 1000`


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```