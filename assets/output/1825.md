# [1825. æ±‚å‡º MK å¹³å‡å€¼](https://leetcode.com/problems/finding-mk-average)

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`è®¾è®¡`](/leetcode/outline/tag/design.md) [`é˜Ÿåˆ—`](/leetcode/outline/tag/queue.md) [`æ•°æ®æµ`](/leetcode/outline/tag/data-stream.md) [`æœ‰åºé›†åˆ`](/leetcode/outline/tag/ordered-set.md) [`å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰`](/leetcode/outline/tag/heap-priority-queue.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/finding-mk-average)


## é¢˜ç›®

You are given two integers, `m` and `k`, and a stream of integers. You are
tasked to implement a data structure that calculates the **MKAverage** for the
stream.

The **MKAverage** can be calculated using these steps:

  1. If the number of the elements in the stream is less than `m` you should consider the **MKAverage** to be `-1`. Otherwise, copy the last `m` elements of the stream to a separate container.
  2. Remove the smallest `k` elements and the largest `k` elements from the container.
  3. Calculate the average value for the rest of the elements **rounded down to the nearest integer**.

Implement the `MKAverage` class:

  * `MKAverage(int m, int k)` Initializes the **MKAverage** object with an empty stream and the two integers `m` and `k`.
  * `void addElement(int num)` Inserts a new element `num` into the stream.
  * `int calculateMKAverage()` Calculates and returns the **MKAverage** for the current stream **rounded down to the nearest integer**.



**Example 1:**

> 
> 
> 
> 
> 
> **Input**
> 
> ["MKAverage", "addElement", "addElement", "calculateMKAverage", "addElement", "calculateMKAverage", "addElement", "addElement", "addElement", "calculateMKAverage"]
> 
> [[3, 1], [3], [1], [], [10], [], [5], [5], [5], []]
> 
> **Output**
> 
> [null, null, null, -1, null, 3, null, null, null, 5]
> 
> 
> 
> **Explanation**
> 
> MKAverage obj = new MKAverage(3, 1); 
> 
> obj.addElement(3);> 
> > 
> // current elements are [3]
> 
> obj.addElement(1);> 
> > 
> // current elements are [3,1]
> 
> obj.calculateMKAverage(); // return -1, because m = 3 and only 2 elements exist.
> 
> obj.addElement(10);> 
>    // current elements are [3,1,10]
> 
> obj.calculateMKAverage(); // The last 3 elements are [3,1,10].
> 
> > 
> > 
> > 
> > 
> > 
> > 
>   // After removing smallest and largest 1 element the container will be [3].
> 
> > 
> > 
> > 
> > 
> > 
> > 
>   // The average of [3] equals 3/1 = 3, return 3
> 
> obj.addElement(5);> 
> > 
> // current elements are [3,1,10,5]
> 
> obj.addElement(5);> 
> > 
> // current elements are [3,1,10,5,5]
> 
> obj.addElement(5);> 
> > 
> // current elements are [3,1,10,5,5,5]
> 
> obj.calculateMKAverage(); // The last 3 elements are [5,5,5].
> 
> > 
> > 
> > 
> > 
> > 
> > 
>   // After removing smallest and largest 1 element the container will be [5].
> 
> > 
> > 
> > 
> > 
> > 
> > 
>   // The average of [5] equals 5/1 = 5, return 5

**Constraints:**

  * `3 <= m <= 10^5`
  * `1 <= k*2 < m`
  * `1 <= num <= 10^5`
  * At most `10^5` calls will be made to `addElement` and `calculateMKAverage`.


## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸¤ä¸ªæ•´æ•° `m` å’Œ `k` ï¼Œä»¥åŠæ•°æ®æµå½¢å¼çš„è‹¥å¹²æ•´æ•°ã€‚ä½ éœ€è¦å®ç°ä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œè®¡ç®—è¿™ä¸ªæ•°æ®æµçš„ **MK å¹³å‡å€¼**  ã€‚

**MK å¹³å‡å€¼**  æŒ‰ç…§å¦‚ä¸‹æ­¥éª¤è®¡ç®—ï¼š

  1. å¦‚æœæ•°æ®æµä¸­çš„æ•´æ•°å°‘äº `m` ä¸ªï¼Œ**MK å¹³å‡å€¼**  ä¸º `-1` ï¼Œå¦åˆ™å°†æ•°æ®æµä¸­æœ€å `m` ä¸ªå…ƒç´ æ‹·è´åˆ°ä¸€ä¸ªç‹¬ç«‹çš„å®¹å™¨ä¸­ã€‚
  2. ä»è¿™ä¸ªå®¹å™¨ä¸­åˆ é™¤æœ€å°çš„ `k` ä¸ªæ•°å’Œæœ€å¤§çš„ `k` ä¸ªæ•°ã€‚
  3. è®¡ç®—å‰©ä½™å…ƒç´ çš„å¹³å‡å€¼ï¼Œå¹¶ **å‘ä¸‹å–æ•´åˆ°æœ€è¿‘çš„æ•´æ•°**  ã€‚

è¯·ä½ å®ç° `MKAverage` ç±»ï¼š

  * `MKAverage(int m, int k)` ç”¨ä¸€ä¸ªç©ºçš„æ•°æ®æµå’Œä¸¤ä¸ªæ•´æ•° `m` å’Œ `k` åˆå§‹åŒ– **MKAverage**  å¯¹è±¡ã€‚
  * `void addElement(int num)` å¾€æ•°æ®æµä¸­æ’å…¥ä¸€ä¸ªæ–°çš„å…ƒç´  `num` ã€‚
  * `int calculateMKAverage()` å¯¹å½“å‰çš„æ•°æ®æµè®¡ç®—å¹¶è¿”å› **MK å¹³å‡æ•°**  ï¼Œç»“æœéœ€ **å‘ä¸‹å–æ•´åˆ°æœ€è¿‘çš„æ•´æ•°** ã€‚



**ç¤ºä¾‹ 1ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š**
> 
> ["MKAverage", "addElement", "addElement", "calculateMKAverage", "addElement", "calculateMKAverage", "addElement", "addElement", "addElement", "calculateMKAverage"]
> 
> [[3, 1], [3], [1], [], [10], [], [5], [5], [5], []]
> 
> **è¾“å‡ºï¼š**
> 
> [null, null, null, -1, null, 3, null, null, null, 5]
> 
> 
> 
> **è§£é‡Šï¼š**
> 
> MKAverage obj = new MKAverage(3, 1); 
> 
> obj.addElement(3);> 
> > 
> // å½“å‰å…ƒç´ ä¸º [3]
> 
> obj.addElement(1);> 
> > 
> // å½“å‰å…ƒç´ ä¸º [3,1]
> 
> obj.calculateMKAverage(); // è¿”å› -1 ï¼Œå› ä¸º m = 3 ï¼Œä½†æ•°æ®æµä¸­åªæœ‰ 2 ä¸ªå…ƒç´ 
> 
> obj.addElement(10);> 
>    // å½“å‰å…ƒç´ ä¸º [3,1,10]
> 
> obj.calculateMKAverage(); // æœ€å 3 ä¸ªå…ƒç´ ä¸º [3,1,10]
> 
> > 
> > 
> > 
> > 
> > 
> > 
>   // åˆ é™¤æœ€å°ä»¥åŠæœ€å¤§çš„ 1 ä¸ªå…ƒç´ åï¼Œå®¹å™¨ä¸º [3]
> 
> > 
> > 
> > 
> > 
> > 
> > 
>   // [3] çš„å¹³å‡å€¼ç­‰äº 3/1 = 3 ï¼Œæ•…è¿”å› 3
> 
> obj.addElement(5);> 
> > 
> // å½“å‰å…ƒç´ ä¸º [3,1,10,5]
> 
> obj.addElement(5);> 
> > 
> // å½“å‰å…ƒç´ ä¸º [3,1,10,5,5]
> 
> obj.addElement(5);> 
> > 
> // å½“å‰å…ƒç´ ä¸º [3,1,10,5,5,5]
> 
> obj.calculateMKAverage(); // æœ€å 3 ä¸ªå…ƒç´ ä¸º [5,5,5]
> 
> > 
> > 
> > 
> > 
> > 
> > 
>   // åˆ é™¤æœ€å°ä»¥åŠæœ€å¤§çš„ 1 ä¸ªå…ƒç´ åï¼Œå®¹å™¨ä¸º [5]
> 
> > 
> > 
> > 
> > 
> > 
> > 
>   // [5] çš„å¹³å‡å€¼ç­‰äº 5/1 = 5 ï¼Œæ•…è¿”å› 5
> 
> 



**æç¤ºï¼š**

  * `3 <= m <= 10^5`
  * `1 <= k*2 < m`
  * `1 <= num <= 10^5`
  * `addElement` ä¸ `calculateMKAverage` æ€»æ“ä½œæ¬¡æ•°ä¸è¶…è¿‡ `10^5` æ¬¡ã€‚


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

:::: md-demo ç›¸å…³é¢˜ç›®
- [æ•°æ®æµçš„ä¸­ä½æ•°](https://leetcode.com/problems/find-median-from-data-stream)
- [æ•°æ®æµä¸­çš„ç¬¬ K å¤§å…ƒç´ ](https://leetcode.com/problems/kth-largest-element-in-a-stream)
- [None](https://leetcode.com/problems/design-a-rate-limiting-system)
- [åºåˆ—é¡ºåºæŸ¥è¯¢](https://leetcode.com/problems/sequentially-ordinal-rank-tracker)

::::
