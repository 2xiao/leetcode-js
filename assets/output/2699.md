# [2699. ä¿®æ”¹å›¾ä¸­çš„è¾¹æƒ](https://leetcode.com/problems/modify-graph-edge-weights)

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`å›¾`](/leetcode/outline/tag/graph.md) [`æœ€çŸ­è·¯`](/leetcode/outline/tag/shortest-path.md) [`å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰`](/leetcode/outline/tag/heap-priority-queue.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/modify-graph-edge-weights)


## é¢˜ç›®

You are given an **undirected weighted** **connected** graph containing `n`
nodes labeled from `0` to `n - 1`, and an integer array `edges` where
`edges[i] = [ai, bi, wi]` indicates that there is an edge between nodes `ai`
and `bi` with weight `wi`.

Some edges have a weight of `-1` (`wi = -1`), while others have a **positive**
weight (`wi > 0`).

Your task is to modify **all edges** with a weight of `-1` by assigning them
**positive integer values** in the range `[1, 2 * 109]` so that the **shortest
distance** between the nodes `source` and `destination` becomes equal to an
integer `target`. If there are **multiple** **modifications** that make the
shortest distance between `source` and `destination` equal to `target`, any of
them will be considered correct.

Return _an array containing all edges (even unmodified ones) in any order if
it is possible to make the shortest distance from_`source` _to_`destination`
_equal to_`target` _, or an**empty array** if it's impossible._

**Note:** You are not allowed to modify the weights of edges with initial
positive weights.



**Example 1:**

**![](https://assets.leetcode.com/uploads/2023/04/18/graph.png)**

> Input: n = 5, edges = [[4,1,-1],[2,0,-1],[0,3,-1],[4,3,-1]], source = 0, destination = 1, target = 5
> 
> Output: [[4,1,1],[2,0,1],[0,3,3],[4,3,1]]
> 
> Explanation: The graph above shows a possible modification to the edges, making the distance from 0 to 1 equal to 5.

**Example 2:**

**![](https://assets.leetcode.com/uploads/2023/04/18/graph-2.png)**

> Input: n = 3, edges = [[0,1,-1],[0,2,5]], source = 0, destination = 2, target = 6
> 
> Output: []
> 
> Explanation: The graph above contains the initial edges. It is not possible to make the distance from 0 to 2 equal to 6 by modifying the edge with weight -1. So, an empty array is returned.

**Example 3:**

**![](https://assets.leetcode.com/uploads/2023/04/19/graph-3.png)**

> Input: n = 4, edges = [[1,0,4],[1,2,3],[2,3,5],[0,3,-1]], source = 0, destination = 2, target = 6
> 
> Output: [[1,0,4],[1,2,3],[2,3,5],[0,3,1]]
> 
> Explanation: The graph above shows a modified graph having the shortest distance from 0 to 2 as 6.

**Constraints:**

  * `1 <= n <= 100`
  * `1 <= edges.length <= n * (n - 1) / 2`
  * `edges[i].length == 3`
  * `0 <= ai, bi < n`
  * `wi = -1 `or `1 <= wi <= 10^7`
  * `ai != bi`
  * `0 <= source, destination < n`
  * `source != destination`
  * `1 <= target <= 10^9`
  * The graph is connected, and there are no self-loops or repeated edges


## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ª `n` ä¸ªèŠ‚ç‚¹çš„ **æ— å‘å¸¦æƒè¿é€š**  å›¾ï¼ŒèŠ‚ç‚¹ç¼–å·ä¸º `0` åˆ° `n - 1` ï¼Œå†ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `edges` ï¼Œå…¶ä¸­
`edges[i] = [ai, bi, wi]` è¡¨ç¤ºèŠ‚ç‚¹ `ai` å’Œ `bi` ä¹‹é—´æœ‰ä¸€æ¡è¾¹æƒä¸º `wi` çš„è¾¹ã€‚

éƒ¨åˆ†è¾¹çš„è¾¹æƒä¸º `-1`ï¼ˆ`wi = -1`ï¼‰ï¼Œå…¶ä»–è¾¹çš„è¾¹æƒéƒ½ä¸º **æ­£**  æ•°ï¼ˆ`wi > 0`ï¼‰ã€‚

ä½ éœ€è¦å°†æ‰€æœ‰è¾¹æƒä¸º `-1` çš„è¾¹éƒ½ä¿®æ”¹ä¸ºèŒƒå›´ `[1, 2 * 109]` ä¸­çš„ **æ­£æ•´æ•°**  ï¼Œä½¿å¾—ä»èŠ‚ç‚¹ `source` åˆ°èŠ‚ç‚¹
`destination` çš„ **æœ€çŸ­è·ç¦»**  ä¸ºæ•´æ•° `target` ã€‚å¦‚æœæœ‰ **å¤šç§**  ä¿®æ”¹æ–¹æ¡ˆå¯ä»¥ä½¿ `source` å’Œ
`destination` ä¹‹é—´çš„æœ€çŸ­è·ç¦»ç­‰äº `target` ï¼Œä½ å¯ä»¥è¿”å›ä»»æ„ä¸€ç§æ–¹æ¡ˆã€‚

å¦‚æœå­˜åœ¨ä½¿ `source` åˆ° `destination` æœ€çŸ­è·ç¦»ä¸º `target`
çš„æ–¹æ¡ˆï¼Œè¯·ä½ æŒ‰ä»»æ„é¡ºåºè¿”å›åŒ…å«æ‰€æœ‰è¾¹çš„æ•°ç»„ï¼ˆåŒ…æ‹¬æœªä¿®æ”¹è¾¹æƒçš„è¾¹ï¼‰ã€‚å¦‚æœä¸å­˜åœ¨è¿™æ ·çš„æ–¹æ¡ˆï¼Œè¯·ä½ è¿”å›ä¸€ä¸ª **ç©ºæ•°ç»„**  ã€‚

**æ³¨æ„ï¼š** ä½ ä¸èƒ½ä¿®æ”¹ä¸€å¼€å§‹è¾¹æƒä¸ºæ­£æ•°çš„è¾¹ã€‚



**ç¤ºä¾‹ 1ï¼š**

**![](https://assets.leetcode.com/uploads/2023/04/18/graph.png)**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** n = 5, edges = [[4,1,-1],[2,0,-1],[0,3,-1],[4,3,-1]], source = 0, destination = 1, target = 5
> 
> **è¾“å‡ºï¼š**[[4,1,1],[2,0,1],[0,3,3],[4,3,1]]
> 
> **è§£é‡Šï¼š** ä¸Šå›¾å±•ç¤ºäº†ä¸€ä¸ªæ»¡è¶³é¢˜æ„çš„ä¿®æ”¹æ–¹æ¡ˆï¼Œä» 0 åˆ° 1 çš„æœ€çŸ­è·ç¦»ä¸º 5 ã€‚
> 
> 

**ç¤ºä¾‹ 2ï¼š**

**![](https://assets.leetcode.com/uploads/2023/04/18/graph-2.png)**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** n = 3, edges = [[0,1,-1],[0,2,5]], source = 0, destination = 2, target = 6
> 
> **è¾“å‡ºï¼š**[]
> 
> **è§£é‡Šï¼š** ä¸Šå›¾æ˜¯ä¸€å¼€å§‹çš„å›¾ã€‚æ²¡æœ‰åŠæ³•é€šè¿‡ä¿®æ”¹è¾¹æƒä¸º -1 çš„è¾¹ï¼Œä½¿å¾— 0 åˆ° 2 çš„æœ€çŸ­è·ç¦»ç­‰äº 6 ï¼Œæ‰€ä»¥è¿”å›ä¸€ä¸ªç©ºæ•°ç»„ã€‚
> 
> 

**ç¤ºä¾‹ 3ï¼š**

**![](https://assets.leetcode.com/uploads/2023/04/19/graph-3.png)**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** n = 4, edges = [[1,0,4],[1,2,3],[2,3,5],[0,3,-1]], source = 0, destination = 2, target = 6
> 
> **è¾“å‡ºï¼š**[[1,0,4],[1,2,3],[2,3,5],[0,3,1]]
> 
> **è§£é‡Šï¼š** ä¸Šå›¾å±•ç¤ºäº†ä¸€ä¸ªæ»¡è¶³é¢˜æ„çš„ä¿®æ”¹æ–¹æ¡ˆï¼Œä» 0 åˆ° 2 çš„æœ€çŸ­è·ç¦»ä¸º 6 ã€‚
> 
> 



**æç¤ºï¼š**

  * `1 <= n <= 100`
  * `1 <= edges.length <= n * (n - 1) / 2`
  * `edges[i].length == 3`
  * `0 <= ai, bi < n`
  * `wi = -1` æˆ–è€… `1 <= wi <= 10^7`
  * `ai != bi`
  * `0 <= source, destination < n`
  * `source != destination`
  * `1 <= target <= 10^9`
  * è¾“å…¥çš„å›¾æ˜¯è¿é€šå›¾ï¼Œä¸”æ²¡æœ‰è‡ªç¯å’Œé‡è¾¹ã€‚


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```