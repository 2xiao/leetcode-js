# [2630. è®°å¿†å‡½æ•° II](https://leetcode.com/problems/memoize-ii)

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/memoize-ii)


## é¢˜ç›®

Given a function `fn`, return a **memoized**  version of that function.

A **memoized  **function is a function that will never be called twice with
the same inputs. Instead it will return a cached value.

`fn` can be any function and there are no constraints on what type of values
it accepts. Inputs are considered identical if they are `===` to each other.



**Example 1:**

> Input: 
> 
> getInputs = () => [[2,2],[2,2],[1,2]]
> 
> fn = function (a, b) { return a + b; }
> 
> Output: [{"val":4,"calls":1},{"val":4,"calls":1},{"val":3,"calls":2}]
> 
> Explanation:
> 
> const inputs = getInputs();
> 
> const memoized = memoize(fn);
> 
> for (const arr of inputs) {
> 
>   memoized(...arr);
> 
> }
> 
> 
> 
> For the inputs of (2, 2): 2 + 2 = 4, and it required a call to fn().
> 
> For the inputs of (2, 2): 2 + 2 = 4, but those inputs were seen before so no call to fn() was required.
> 
> For the inputs of (1, 2): 1 + 2 = 3, and it required another call to fn() for a total of 2.

**Example 2:**

> Input: 
> 
> getInputs = () => [[{},{}],[{},{}],[{},{}]] 
> 
> fn = function (a, b) { return ({...a, ...b}); }
> 
> Output: [{"val":{},"calls":1},{"val":{},"calls":2},{"val":{},"calls":3}]
> 
> Explanation:
> 
> Merging two empty objects will always result in an empty object. It may seem like there should only be 1 call to fn() because of cache-hits, however none of those objects are === to each other.

**Example 3:**

> Input: 
> 
> getInputs = () => { const o = {}; return [[o,o],[o,o],[o,o]]; }
> 
> fn = function (a, b) { return ({...a, ...b}); }
> 
> Output: [{"val":{},"calls":1},{"val":{},"calls":1},{"val":{},"calls":1}]
> 
> Explanation:
> 
> Merging two empty objects will always result in an empty object. The 2nd and 3rd third function calls result in a cache-hit. This is because every object passed in is identical.

**Constraints:**

  * `1 <= inputs.length <= 10^5`
  * `0 <= inputs.flat().length <= 10^5`
  * `inputs[i][j] != NaN`


## é¢˜ç›®å¤§æ„

ç°ç»™å®šä¸€ä¸ªå‡½æ•° `fn` ï¼Œè¿”å›è¯¥å‡½æ•°çš„ä¸€ä¸ª **è®°å¿†åŒ–** ç‰ˆæœ¬ã€‚

ä¸€ä¸ª **è®°å¿†åŒ–** çš„å‡½æ•°æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒä¸ä¼šè¢«ç›¸åŒçš„è¾“å…¥è°ƒç”¨ä¸¤æ¬¡ã€‚è€Œæ˜¯ä¼šè¿”å›ä¸€ä¸ªç¼“å­˜çš„å€¼ã€‚

å‡½æ•° `fn` å¯ä»¥æ˜¯ä»»ä½•å‡½æ•°ï¼Œå¯¹å®ƒæ‰€æ¥å—çš„å€¼ç±»å‹æ²¡æœ‰ä»»ä½•é™åˆ¶ã€‚å¦‚æœä¸¤ä¸ªè¾“å…¥å€¼åœ¨ JavaScript ä¸­ä½¿ç”¨ `===`
è¿ç®—ç¬¦æ¯”è¾ƒæ—¶ç›¸ç­‰ï¼Œåˆ™å®ƒä»¬è¢«è§†ä¸ºç›¸åŒã€‚



**ç¤ºä¾‹ 1ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** 
> 
> getInputs = () => [[2,2],[2,2],[1,2]]
> 
> fn = function (a, b) { return a + b; }
> 
> **è¾“å‡ºï¼š**[{"val":4,"calls":1},{"val":4,"calls":1},{"val":3,"calls":2}]
> 
> **è§£é‡Šï¼š**
> 
> const inputs = getInputs();
> 
> const memoized = memoize(fn);
> 
> for (const arr of inputs) {
> 
>   memoized(...arr);
> 
> }
> 
> 
> 
> å¯¹äºå‚æ•°ä¸º (2, 2) çš„è¾“å…¥: 2 + 2 = 4ï¼Œéœ€è¦è°ƒç”¨ fn() ã€‚
> 
> å¯¹äºå‚æ•°ä¸º (2, 2) çš„è¾“å…¥: 2 + 2 = 4ï¼Œè¿™äº›è¾“å…¥ä¹‹å‰å·²ç»å‡ºç°è¿‡ï¼Œå› æ­¤ä¸éœ€è¦å†æ¬¡è°ƒç”¨ fn()ã€‚
> 
> å¯¹äºå‚æ•°ä¸º (1, 2) çš„è¾“å…¥: 1 + 2 = 3ï¼Œéœ€è¦å†æ¬¡è°ƒç”¨ fn()ï¼Œæ€»å…±è°ƒç”¨äº† 2 æ¬¡ã€‚
> 
> 

**ç¤ºä¾‹ 2ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š**
> 
> getInputs = () => [[{},{}],[{},{}],[{},{}]] 
> 
> fn = function (a, b) { return a + b; }
> 
> **è¾“å‡ºï¼š**[{"val":{},"calls":1},{"val":{},"calls":2},{"val":{},"calls":3}]
> 
> **è§£é‡Šï¼š**
> 
> å°†ä¸¤ä¸ªç©ºå¯¹è±¡åˆå¹¶æ€»æ˜¯ä¼šå¾—åˆ°ä¸€ä¸ªç©ºå¯¹è±¡ã€‚å°½ç®¡çœ‹èµ·æ¥åº”è¯¥ç¼“å­˜å‘½ä¸­å¹¶åªè°ƒç”¨ä¸€æ¬¡ fn()ï¼Œä½†æ˜¯è¿™äº›ç©ºå¯¹è±¡å½¼æ­¤ä¹‹é—´éƒ½ä¸æ˜¯ === ç›¸ç­‰çš„ã€‚
> 
> 

**ç¤ºä¾‹ 3ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** 
> 
> getInputs = () => { const o = {}; return [[o,o],[o,o],[o,o]]; }
> 
> fn = function (a, b) { return ({...a, ...b}); }
> 
> **è¾“å‡ºï¼š**[{"val":{},"calls":1},{"val":{},"calls":1},{"val":{},"calls":1}]
> 
> **è§£é‡Šï¼š**
> 
> å°†ä¸¤ä¸ªç©ºå¯¹è±¡åˆå¹¶æ€»æ˜¯ä¼šå¾—åˆ°ä¸€ä¸ªç©ºå¯¹è±¡ã€‚å› ä¸ºä¼ å…¥çš„æ¯ä¸ªå¯¹è±¡éƒ½æ˜¯ç›¸åŒçš„ï¼Œæ‰€ä»¥ç¬¬äºŒä¸ªå’Œç¬¬ä¸‰ä¸ªå‡½æ•°è°ƒç”¨éƒ½ä¼šå‘½ä¸­ç¼“å­˜ã€‚
> 
> 



**æç¤ºï¼š**

  * `1 <= inputs.length <= 10^5`
  * `0 <= inputs.flat().length <= 10^5`
  * `inputs[i][j] != NaN`


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 2623 | [è®°å¿†å‡½æ•°](https://leetcode.com/problems/memoize) |  |  | <font color=#ffb800>Medium</font> |
| 2632 | [æŸ¯é‡ŒåŒ–](https://leetcode.com/problems/curry) |  |  | <font color=#ffb800>Medium</font> |

<style>
.blue {
    background-color: #096dd9;
    padding: 0.25rem 0.5rem;
    margin: 0;
    font-size: 0.85em;
    border-radius: 3px;
    color: white;
    font-weight: 500;
}
table th:first-of-type { width: 10%; }
table th:nth-of-type(2) { width: 35%; }
table th:nth-of-type(3) { width: 10%; }
table th:nth-of-type(4) { width: 35%; }
table th:nth-of-type(5) { width: 10%; }
</style>
