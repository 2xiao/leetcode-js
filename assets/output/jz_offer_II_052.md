# [52. 展平二叉搜索树](https://2xiao.github.io/leetcode-js/offer2/jz_offer_II_052.html)

🟢 <font color=#15bd66>Easy</font>&emsp; 🔖&ensp; [`栈`](/tag/stack.md) [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`二叉搜索树`](/tag/binary-search-tree.md) [`二叉树`](/tag/binary-tree.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/NYBBNL)

## 题目

English description is not available for the problem. Please switch to
Chinese.


## 题目大意

给你一棵二叉搜索树，请 **按中序遍历** 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。



**示例 1：**

![](https://assets.leetcode.com/uploads/2020/11/17/ex1.jpg)

> 
> 
> 
> 
> 
> **输入：** root = [5,3,6,2,4,null,8,1,null,null,null,7,9]
> 
> **输出：**[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]
> 
> 

**示例 2：**

![](https://assets.leetcode.com/uploads/2020/11/17/ex2.jpg)

> 
> 
> 
> 
> 
> **输入：** root = [5,1,7]
> 
> **输出：**[1,null,5,null,7]
> 
> 



**提示：**

  * 树中节点数的取值范围是 `[1, 100]`
  * `0 <= Node.val <= 1000`



注意：本题与主站 897 题相同： <https://leetcode-cn.com/problems/increasing-order-search-
tree/>


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```