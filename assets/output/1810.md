---
title: 1810. éšè—ç½‘æ ¼ä¸‹çš„æœ€å°æ¶ˆè€—è·¯å¾„ ğŸ”’
description: LeetCode,1810. éšè—ç½‘æ ¼ä¸‹çš„æœ€å°æ¶ˆè€—è·¯å¾„ ğŸ”’,éšè—ç½‘æ ¼ä¸‹çš„æœ€å°æ¶ˆè€—è·¯å¾„,Minimum Path Cost in a Hidden Grid,è§£é¢˜æ€è·¯,æ·±åº¦ä¼˜å…ˆæœç´¢,å¹¿åº¦ä¼˜å…ˆæœç´¢,å›¾,äº¤äº’,å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰
keywords:
  - LeetCode
  - 1810. éšè—ç½‘æ ¼ä¸‹çš„æœ€å°æ¶ˆè€—è·¯å¾„ ğŸ”’
  - éšè—ç½‘æ ¼ä¸‹çš„æœ€å°æ¶ˆè€—è·¯å¾„
  - Minimum Path Cost in a Hidden Grid
  - è§£é¢˜æ€è·¯
  - æ·±åº¦ä¼˜å…ˆæœç´¢
  - å¹¿åº¦ä¼˜å…ˆæœç´¢
  - å›¾
  - äº¤äº’
  - å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰
---

# 1810. éšè—ç½‘æ ¼ä¸‹çš„æœ€å°æ¶ˆè€—è·¯å¾„ ğŸ”’

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/tag/breadth-first-search.md) [`å›¾`](/tag/graph.md) [`äº¤äº’`](/tag/interactive.md) [`å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰`](/tag/heap-priority-queue.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/minimum-path-cost-in-a-hidden-grid) [`LeetCode`](https://leetcode.com/problems/minimum-path-cost-in-a-hidden-grid)

## é¢˜ç›®

This is an **interactive problem**.

There is a robot in a hidden grid, and you are trying to get it from its
starting cell to the target cell in this grid. The grid is of size `m x n`,
and each cell in the grid is either empty or blocked. It is **guaranteed**
that the starting cell and the target cell are different, and neither of them
is blocked.

Each cell has a **cost** that you need to pay each time you **move** to the
cell. The starting cell's cost is **not** applied before the robot moves.

You want to find the minimum total cost to move the robot to the target cell.
However, you **do not know** the grid's dimensions, the starting cell, nor the
target cell. You are only allowed to ask queries to the `GridMaster` object.

The `GridMaster` class has the following functions:

  * `boolean canMove(char direction)` Returns `true` if the robot can move in that direction. Otherwise, it returns `false`.
  * `int move(char direction)` Moves the robot in that direction and returns the cost of moving to that cell. If this move would move the robot to a blocked cell or off the grid, the move will be **ignored** , the robot will remain in the same position, and the function will return `-1`.
  * `boolean isTarget()` Returns `true` if the robot is currently on the target cell. Otherwise, it returns `false`.

Note that `direction` in the above functions should be a character from
`{'U','D','L','R'}`, representing the directions up, down, left, and right,
respectively.

Return _the**minimum total cost** to get the robot from its initial starting
cell to the target cell. If there is no valid path between the cells, return
_`-1`.

**Custom testing:**

The test input is read as a 2D matrix `grid` of size `m x n` and four integers
`r1`, `c1`, `r2`, and `c2` where:

  * `grid[i][j] == 0` indicates that the cell `(i, j)` is blocked.
  * `grid[i][j] >= 1` indicates that the cell `(i, j)` is empty and `grid[i][j]` is the **cost** to move to that cell.
  * `(r1, c1)` is the starting cell of the robot.
  * `(r2, c2)` is the target cell of the robot.

Remember that you will **not** have this information in your code.



**Example 1:**

> Input: grid = [[2,3],[1,1]], r1 = 0, c1 = 1, r2 = 1, c2 = 0
> 
> Output: 2
> 
> Explanation: One possible interaction is described below:
> 
> The robot is initially standing on cell (0, 1), denoted by the 3.
> - master.canMove('U') returns false.
> - master.canMove('D') returns true.
> - master.canMove('L') returns true.
> - master.canMove('R') returns false.
> - master.move('L') moves the robot to the cell (0, 0) and returns 2.
> - master.isTarget() returns false.
> - master.canMove('U') returns false.
> - master.canMove('D') returns true.
> - master.canMove('L') returns false.
> - master.canMove('R') returns true.
> - master.move('D') moves the robot to the cell (1, 0) and returns 1.
> - master.isTarget() returns true.
> - master.move('L') doesn't move the robot and returns -1.
> - master.move('R') moves the robot to the cell (1, 1) and returns 1.
> 
> We now know that the target is the cell (1, 0), and the minimum total cost to reach it is 2. 

**Example 2:**

> Input: grid = [[0,3,1],[3,4,2],[1,2,0]], r1 = 2, c1 = 0, r2 = 0, c2 = 2
> 
> Output: 9
> 
> Explanation: The minimum cost path is (2,0) -> (2,1) -> (1,1) -> (1,2) -> (0,2).

**Example 3:**

> Input: grid = [[1,0],[0,1]], r1 = 0, c1 = 0, r2 = 1, c2 = 1
> 
> Output: -1
> 
> Explanation: There is no path from the robot to the target cell.

**Constraints:**

  * `1 <= n, m <= 100`
  * `m == grid.length`
  * `n == grid[i].length`
  * `0 <= grid[i][j] <= 100`


## é¢˜ç›®å¤§æ„

è¿™æ˜¯ä¸€ä¸ªäº¤äº’é—®é¢˜ã€‚

æœ‰ä¸€ä¸ªæœºå™¨äººå­˜åœ¨äºç½‘æ ¼ä¸­ï¼Œä½ éœ€è¦é€šè¿‡ä¸æ–­å°è¯•ä½¿ä»–ä»åˆå§‹å•å…ƒåˆ°è¾¾ç›®æ ‡å•å…ƒã€‚ç½‘æ ¼çš„è§„æ ¼ä¸ºm x nï¼Œå¹¶ä¸”æ¯ä¸ªå•å…ƒçš„å±æ€§å€¼è¦ä¸ä¸ºç©ºï¼Œè¦ä¸å·²è¢«å ç”¨ã€‚é¢˜ç›®**ä¿è¯**
åˆå§‹ç½‘æ ¼å’Œç›®æ ‡ç½‘æ ¼ä¸åŒä¸”å‡ä¸ºç©ºã€‚

æ¯ä¸ªå•å…ƒæ ¼éƒ½æœ‰**æ¶ˆè€—** å€¼ï¼Œä½ éœ€è¦åœ¨æ¯æ¬¡**ç§»åŠ¨** è‡³æ­¤å•å…ƒæ ¼åæ”¯ä»˜è¯¥è´¹ç”¨ã€‚åœ¨æœºå™¨äººå¯åŠ¨å‰ï¼Œåˆå§‹å•å…ƒçš„è´¹ç”¨ä¸è¢«è®¡ç®—åœ¨å†…ã€‚

ä½ éœ€è¦æ‰¾åˆ°æœºå™¨äººç§»åŠ¨è‡³ç›®æ ‡ç½‘æ ¼çš„æœ€å°æ€»æ¶ˆè€—ã€‚ä½†å¯æƒœçš„æ˜¯ä½ å¹¶**ä¸çŸ¥é“**
ç½‘æ ¼çš„å°ºå¯¸ã€åˆå§‹å•å…ƒå’Œç›®æ ‡å•å…ƒã€‚ä½ åªå…è®¸é€šè¿‡è¯¢é—®`GridMaster`ç±»è·å¾—ä¿¡æ¯ã€‚

`GridMaster`ç±»å­˜åœ¨ä»¥ä¸‹åŠŸèƒ½ï¼š

  * `boolean canMove(char direction)` å½“æœºå™¨äººå¯ä»¥å‘è¿™ä¸ªæ–¹å‘ç§»åŠ¨æ—¶ï¼Œè¿”å›`true`ï¼›åä¹‹è¿”å›`false`ã€‚
  * `int move(char direction)` æ²¿è¯¥æ–¹å‘ç§»åŠ¨æœºå™¨äººï¼Œå¹¶è¿”å›ç§»åŠ¨åˆ°è¯¥å•å…ƒçš„æ¶ˆè€—å€¼ã€‚å¦‚æœæ­¤ç§»åŠ¨å°†æœºå™¨äººç§»åŠ¨åˆ°è¢«å æœ‰çš„å•å…ƒæ ¼æˆ–ç¦»å¼€ç½‘æ ¼ï¼Œåˆ™ç§»åŠ¨å°†è¢«**å¿½ç•¥** ï¼Œæœºå™¨äººå°†ä¿æŒåœ¨ç›¸åŒçš„ä½ç½®ï¼Œå‡½æ•°å°†è¿”å›`-1`ã€‚
  * `boolean isTarget()` ï¼šå¦‚æœæœºå™¨äººå½“å‰ä½äºç›®æ ‡å•å…ƒæ ¼ä¸Šï¼Œåˆ™è¿”å›`true`ï¼›åä¹‹è¿”å› `false` ã€‚

è¯·æ³¨æ„ï¼Œä¸Šè¿°å‡½æ•°ä¸­çš„æ–¹å‘åº”è¯¥æ˜¯`{ 'U'ã€'D'ã€'L'ã€'R' }`ä¸­çš„å­—ç¬¦ï¼Œåˆ†åˆ«è¡¨ç¤ºå‘ä¸Šã€å‘ä¸‹ã€å·¦å’Œå³æ–¹å‘ã€‚

è¿”å›ä½¿æœºå™¨äººä»å…¶åˆå§‹èµ·å§‹å•å…ƒåˆ°ç›®æ ‡å•å…ƒçš„**æœ€å°æ€»æ¶ˆè€—** ã€‚å¦‚æœå•å…ƒæ ¼ä¹‹é—´ä¸å­˜åœ¨æœ‰æ•ˆè·¯å¾„ï¼Œåˆ™è¿”å›`-1`ã€‚

**æµ‹è¯•å®ä¾‹:**

æµ‹è¯•è¾“å…¥ä¸€ä¸ªå¤§å°ä¸º`m x n`çš„äºŒç»´æ•°ç»„ `grid` å’Œå››ä¸ª`int`å‹å‚æ•° `r1`, `c1`, `r2`, å’Œ `c2` :

  * `grid[i][j] == 0` è¡¨ç¤ºç½‘æ ¼ `(i, j)` å·²è¢«å ç”¨ã€‚
  * `grid[i][j] >= 1` è¡¨ç¤ºç½‘æ ¼å•å…ƒ `(i, j)` ä¸ºç©ºå¹¶ä¸” `grid[i][j]` çš„å€¼ä¸ºç§»åŠ¨è‡³æ­¤ç½‘æ ¼çš„æˆæœ¬å€¼ã€‚
  * `(r1, c1)` ä¸ºåˆå§‹å•å…ƒã€‚
  * `(r2, c2)` ä¸ºç›®æ ‡å•å…ƒã€‚

è¯·æ³¨æ„ï¼Œä½ å°†æ— æ³•åœ¨ä½ çš„ä»£ç ä¸­è·çŸ¥è¿™äº›ä¿¡æ¯ã€‚

**ç¤ºä¾‹ 1:**

> 
> 
> 
> 
> 
> **è¾“å…¥:** grid = [[2,3],[1,1]], r1 = 0, c1 = 1, r2 = 1, c2 = 0
> 
> **è¾“å‡º:** 2
> 
> **è§£é‡Š:** å…¶ä¸­ä¸€ç§å¯èƒ½è·¯å¾„æè¿°å¦‚ä¸‹ï¼š
> 
> æœºå™¨äººæœ€å¼€å§‹ç«™åœ¨å•å…ƒæ ¼ (0, 1) ï¼Œç”¨ 3 è¡¨ç¤º
> - master.canMove('U') è¿”å› false
> - master.canMove('D') è¿”å› true
> - master.canMove('L') è¿”å› true
> - master.canMove('R') è¿”å› false
> - master.move('L') æœºå™¨äººç§»åŠ¨åˆ°å•å…ƒæ ¼ (0, 0) å¹¶è¿”å› 2
> - master.isTarget() è¿”å› false
> - master.canMove('U') è¿”å› false
> - master.canMove('D') è¿”å› true
> - master.canMove('L') è¿”å› false
> - master.canMove('R') è¿”å› true
> - master.move('D') æœºå™¨äººç§»åŠ¨åˆ°å•å…ƒæ ¼ (1, 0) å¹¶è¿”å› 1
> - master.isTarget() è¿”å› true
> - master.move('L') æœºå™¨äººä¸ç§»åŠ¨å¹¶è¿”å› -1
> - master.move('R') æœºå™¨äººç§»åŠ¨åˆ°å•å…ƒæ ¼ (1, 1) å¹¶è¿”å› 1
> 
> ç°åœ¨æˆ‘ä»¬çŸ¥é“äº†æœºå™¨äººè¾¾åˆ°ç›®æ ‡å•å…ƒ(1, 0)çš„æœ€å°æ¶ˆè€—æˆæœ¬ä¸º2ã€‚ 

**ç¤ºä¾‹ 2:**

> 
> 
> 
> 
> 
> **è¾“å…¥:** grid = [[0,3,1],[3,4,2],[1,2,0]], r1 = 2, c1 = 0, r2 = 0, c2 = 2
> 
> **è¾“å‡º:** 9
> 
> **è§£é‡Š:** æœ€å°æ¶ˆè€—è·¯å¾„ä¸º (2,0) -> (2,1) -> (1,1) -> (1,2) -> (0,2).
> 
> 

**ç¤ºä¾‹ 3:**

> 
> 
> 
> 
> 
> **è¾“å…¥:** grid = [[1,0],[0,1]], r1 = 0, c1 = 0, r2 = 1, c2 = 1
> 
> **è¾“å‡º:** -1
> 
> **è§£é‡Š:** ä¸å­˜åœ¨å¯ä½¿æœºå™¨äººåˆ°è¾¾ç›®æ ‡å•å…ƒçš„è·¯å¾„ã€‚
> 
> 

**æç¤º:**

  * `1 <= n, m <= 100`
  * `m == grid.length`
  * `n == grid[i].length`
  * `0 <= grid[i][j] <= 100`


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ | åŠ›æ‰£ |
| :------: | :------ | :------: | :------ | :------ | :------: |
| 489 | æ‰«åœ°æœºå™¨äºº ğŸ”’ |  |  [`å›æº¯`](/tag/backtracking.md) [`äº¤äº’`](/tag/interactive.md) | <font color=#ff334b>Hard</font> | [ğŸ€„ï¸](https://leetcode.cn/problems/robot-room-cleaner) [ğŸ”—](https://leetcode.com/problems/robot-room-cleaner) |
| 1778 | æœªçŸ¥ç½‘æ ¼ä¸­çš„æœ€çŸ­è·¯å¾„ ğŸ”’ |  |  [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/tag/breadth-first-search.md) [`å›¾`](/tag/graph.md) `1+` | <font color=#ffb800>Medium</font> | [ğŸ€„ï¸](https://leetcode.cn/problems/shortest-path-in-a-hidden-grid) [ğŸ”—](https://leetcode.com/problems/shortest-path-in-a-hidden-grid) |