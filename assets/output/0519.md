# [519. éšæœºç¿»è½¬çŸ©é˜µ](https://leetcode.com/problems/random-flip-matrix)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ°´å¡˜æŠ½æ ·`](/leetcode/outline/tag/reservoir-sampling.md) [`å“ˆå¸Œè¡¨`](/leetcode/outline/tag/hash-table.md) [`æ•°å­¦`](/leetcode/outline/tag/math.md) [`éšæœºåŒ–`](/leetcode/outline/tag/randomized.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/random-flip-matrix)


## é¢˜ç›®

There is an `m x n` binary grid `matrix` with all the values set `0`
initially. Design an algorithm to randomly pick an index `(i, j)` where
`matrix[i][j] == 0` and flips it to `1`. All the indices `(i, j)` where
`matrix[i][j] == 0` should be equally likely to be returned.

Optimize your algorithm to minimize the number of calls made to the **built-
in** random function of your language and optimize the time and space
complexity.

Implement the `Solution` class:

  * `Solution(int m, int n)` Initializes the object with the size of the binary matrix `m` and `n`.
  * `int[] flip()` Returns a random index `[i, j]` of the matrix where `matrix[i][j] == 0` and flips it to `1`.
  * `void reset()` Resets all the values of the matrix to be `0`.



**Example 1:**

> 
> 
> 
> 
> 
> **Input**
> 
> ["Solution", "flip", "flip", "flip", "reset", "flip"]
> 
> [[3, 1], [], [], [], [], []]
> 
> **Output**
> 
> [null, [1, 0], [2, 0], [0, 0], null, [2, 0]]
> 
> 
> 
> **Explanation**
> 
> Solution solution = new Solution(3, 1);
> 
> solution.flip();  // return [1, 0], [0,0], [1,0], and [2,0] should be equally likely to be returned.
> 
> solution.flip();  // return [2, 0], Since [1,0] was returned, [2,0] and [0,0]
> 
> solution.flip();  // return [0, 0], Based on the previously returned indices, only [0,0] can be returned.
> 
> solution.reset(); // All the values are reset to 0 and can be returned.
> 
> solution.flip();  // return [2, 0], [0,0], [1,0], and [2,0] should be equally likely to be returned.

**Constraints:**

  * `1 <= m, n <= 10^4`
  * There will be at least one free cell for each call to `flip`.
  * At most `1000` calls will be made to `flip` and `reset`.


## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ª `m x n` çš„äºŒå…ƒçŸ©é˜µ `matrix` ï¼Œä¸”æ‰€æœ‰å€¼è¢«åˆå§‹åŒ–ä¸º `0` ã€‚è¯·ä½ è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œéšæœºé€‰å–ä¸€ä¸ªæ»¡è¶³ `matrix[i][j] ==
0` çš„ä¸‹æ ‡ `(i, j)` ï¼Œå¹¶å°†å®ƒçš„å€¼å˜ä¸º `1` ã€‚æ‰€æœ‰æ»¡è¶³ `matrix[i][j] == 0` çš„ä¸‹æ ‡ `(i, j)`
è¢«é€‰å–çš„æ¦‚ç‡åº”å½“å‡ç­‰ã€‚

å°½é‡æœ€å°‘è°ƒç”¨å†…ç½®çš„éšæœºå‡½æ•°ï¼Œå¹¶ä¸”ä¼˜åŒ–æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦ã€‚

å®ç° `Solution` ç±»ï¼š

  * `Solution(int m, int n)` ä½¿ç”¨äºŒå…ƒçŸ©é˜µçš„å¤§å° `m` å’Œ `n` åˆå§‹åŒ–è¯¥å¯¹è±¡
  * `int[] flip()` è¿”å›ä¸€ä¸ªæ»¡è¶³ `matrix[i][j] == 0` çš„éšæœºä¸‹æ ‡ `[i, j]` ï¼Œå¹¶å°†å…¶å¯¹åº”æ ¼å­ä¸­çš„å€¼å˜ä¸º `1`
  * `void reset()` å°†çŸ©é˜µä¸­æ‰€æœ‰çš„å€¼é‡ç½®ä¸º `0`



**ç¤ºä¾‹ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥**
> 
> ["Solution", "flip", "flip", "flip", "reset", "flip"]
> 
> [[3, 1], [], [], [], [], []]
> 
> **è¾“å‡º**
> 
> [null, [1, 0], [2, 0], [0, 0], null, [2, 0]]
> 
> 
> 
> **è§£é‡Š**
> 
> Solution solution = new Solution(3, 1);
> 
> solution.flip();  // è¿”å› [1, 0]ï¼Œæ­¤æ—¶è¿”å› [0,0]ã€[1,0] å’Œ [2,0] çš„æ¦‚ç‡åº”å½“ç›¸åŒ
> 
> solution.flip();  // è¿”å› [2, 0]ï¼Œå› ä¸º [1,0] å·²ç»è¿”å›è¿‡äº†ï¼Œæ­¤æ—¶è¿”å› [2,0] å’Œ [0,0] çš„æ¦‚ç‡åº”å½“ç›¸åŒ
> 
> solution.flip();  // è¿”å› [0, 0]ï¼Œæ ¹æ®å‰é¢å·²ç»è¿”å›è¿‡çš„ä¸‹æ ‡ï¼Œæ­¤æ—¶åªèƒ½è¿”å› [0,0]
> 
> solution.reset(); // æ‰€æœ‰å€¼éƒ½é‡ç½®ä¸º 0 ï¼Œå¹¶å¯ä»¥å†æ¬¡é€‰æ‹©ä¸‹æ ‡è¿”å›
> 
> solution.flip();  // è¿”å› [2, 0]ï¼Œæ­¤æ—¶è¿”å› [0,0]ã€[1,0] å’Œ [2,0] çš„æ¦‚ç‡åº”å½“ç›¸åŒ



**æç¤ºï¼š**

  * `1 <= m, n <= 10^4`
  * æ¯æ¬¡è°ƒç”¨`flip` æ—¶ï¼ŒçŸ©é˜µä¸­è‡³å°‘å­˜åœ¨ä¸€ä¸ªå€¼ä¸º 0 çš„æ ¼å­ã€‚
  * æœ€å¤šè°ƒç”¨ `1000` æ¬¡ `flip` å’Œ `reset` æ–¹æ³•ã€‚


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```