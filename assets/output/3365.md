---
title: 3365. 重排子字符串以形成目标字符串
description: LeetCode 3365. 重排子字符串以形成目标字符串题解，Rearrange K Substrings to Form Target String，包含解题思路、复杂度分析以及完整的 JavaScript 代码实现。
keywords:
  - LeetCode
  - 3365. 重排子字符串以形成目标字符串
  - 重排子字符串以形成目标字符串
  - Rearrange K Substrings to Form Target String
  - 解题思路
  - 哈希表
  - 字符串
  - 排序
---

# 3365. 重排子字符串以形成目标字符串

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`哈希表`](/tag/hash-table.md) [`字符串`](/tag/string.md) [`排序`](/tag/sorting.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/rearrange-k-substrings-to-form-target-string) [`LeetCode`](https://leetcode.com/problems/rearrange-k-substrings-to-form-target-string)

## 题目

You are given two strings `s` and `t`, both of which are anagrams of each
other, and an integer `k`.

Your task is to determine whether it is possible to split the string `s` into
`k` equal-sized substrings, rearrange the substrings, and concatenate them in
_any order_ to create a new string that matches the given string `t`.

Return `true` if this is possible, otherwise, return `false`.

An **anagram** is a word or phrase formed by rearranging the letters of a
different word or phrase, using all the original letters exactly once.

A **substring** is a contiguous **non-empty** sequence of characters within a
string.



**Example 1:**

**Input:** s = "abcd", t = "cdab", k = 2

**Output:** true

**Explanation:**

  * Split `s` into 2 substrings of length 2: `["ab", "cd"]`.
  * Rearranging these substrings as `["cd", "ab"]`, and then concatenating them results in `"cdab"`, which matches `t`.

**Example 2:**

**Input:** s = "aabbcc", t = "bbaacc", k = 3

**Output:** true

**Explanation:**

  * Split `s` into 3 substrings of length 2: `["aa", "bb", "cc"]`.
  * Rearranging these substrings as `["bb", "aa", "cc"]`, and then concatenating them results in `"bbaacc"`, which matches `t`.

**Example 3:**

**Input:** s = "aabbcc", t = "bbaacc", k = 2

**Output:** false

**Explanation:**

  * Split `s` into 2 substrings of length 3: `["aab", "bcc"]`.
  * These substrings cannot be rearranged to form `t = "bbaacc"`, so the output is `false`.



**Constraints:**

  * `1 <= s.length == t.length <= 2 * 10^5`
  * `1 <= k <= s.length`
  * `s.length` is divisible by `k`.
  * `s` and `t` consist only of lowercase English letters.
  * The input is generated such that `s` and `t` are anagrams of each other.


## 题目大意

给你两个字符串 `s` 和 `t`（它们互为字母异位词），以及一个整数 `k`。

你的任务是判断是否可以将字符串 `s` 分割成 `k`
个等长的子字符串，然后重新排列这些子字符串，并以任意顺序连接它们，使得最终得到的新字符串与给定的字符串 `t` 相匹配。

如果可以做到，返回 `true`；否则，返回 `false`。

**字母异位词  **是指由另一个单词或短语的所有字母重新排列形成的单词或短语，使用所有原始字母恰好一次。

**子字符串  **是字符串中的一个连续 **非空  **字符序列。



**示例 1：**

**输入：** s = "abcd", t = "cdab", k = 2

**输出：** true

**解释：**

  * 将 `s` 分割成 2 个长度为 2 的子字符串：`["ab", "cd"]`。
  * 重新排列这些子字符串为 `["cd", "ab"]`，然后连接它们得到 `"cdab"`，与 `t` 相匹配。

**示例 2：**

**输入：** s = "aabbcc", t = "bbaacc", k = 3

**输出：** true

**解释：**

  * 将 `s` 分割成 3 个长度为 2 的子字符串：`["aa", "bb", "cc"]`。
  * 重新排列这些子字符串为 `["bb", "aa", "cc"]`，然后连接它们得到 `"bbaacc"`，与 `t` 相匹配。

**示例 3：**

**输入：** s = "aabbcc", t = "bbaacc", k = 2

**输出：** false

**解释：**

  * 将 `s` 分割成 2 个长度为 3 的子字符串：`["aab", "bcc"]`。
  * 这些子字符串无法重新排列形成 `t = "bbaacc"`，所以输出 `false`。



**提示：**

  * `1 <= s.length == t.length <= 2 * 10^5`
  * `1 <= k <= s.length`
  * `s.length` 能被 `k` 整除。
  * `s` 和 `t` 仅由小写英文字母组成。
  * 输入保证 `s` 和 `t` 互为字母异位词。


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```