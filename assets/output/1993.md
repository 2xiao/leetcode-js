# [1993. æ ‘ä¸Šçš„æ“ä½œ](https://leetcode.com/problems/operations-on-tree)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ ‘`](/leetcode/outline/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/breadth-first-search.md) [`è®¾è®¡`](/leetcode/outline/tag/design.md) [`æ•°ç»„`](/leetcode/outline/tag/array.md) [`å“ˆå¸Œè¡¨`](/leetcode/outline/tag/hash-table.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/operations-on-tree)

## é¢˜ç›®

You are given a tree with `n` nodes numbered from `0` to `n - 1` in the form
of a parent array `parent` where `parent[i]` is the parent of the `ith` node.
The root of the tree is node `0`, so `parent[0] = -1` since it has no parent.
You want to design a data structure that allows users to lock, unlock, and
upgrade nodes in the tree.

The data structure should support the following functions:

  * **Lock:** **Locks** the given node for the given user and prevents other users from locking the same node. You may only lock a node using this function if the node is unlocked.
  * **Unlock: Unlocks** the given node for the given user. You may only unlock a node using this function if it is currently locked by the same user.
  * **Upgrade****: Locks** the given node for the given user and **unlocks** all of its descendants **regardless** of who locked it. You may only upgrade a node if **all** 3 conditions are true: 
> 
> * The node is unlocked,
> 
> * It has at least one locked descendant (by **any** user), and
> 
> * It does not have any locked ancestors.

Implement the `LockingTree` class:

  * `LockingTree(int[] parent)` initializes the data structure with the parent array.
  * `lock(int num, int user)` returns `true` if it is possible for the user with id `user` to lock the node `num`, or `false` otherwise. If it is possible, the node `num` will become**locked** by the user with id `user`.
  * `unlock(int num, int user)` returns `true` if it is possible for the user with id `user` to unlock the node `num`, or `false` otherwise. If it is possible, the node `num` will become **unlocked**.
  * `upgrade(int num, int user)` returns `true` if it is possible for the user with id `user` to upgrade the node `num`, or `false` otherwise. If it is possible, the node `num` will be **upgraded**.



**Example 1:**

![](https://assets.leetcode.com/uploads/2021/07/29/untitled.png)

> 
> 
> 
> 
> 
> **Input**
> 
> ["LockingTree", "lock", "unlock", "unlock", "lock", "upgrade", "lock"]
> 
> [[[-1, 0, 0, 1, 1, 2, 2]], [2, 2], [2, 3], [2, 2], [4, 5], [0, 1], [0, 1]]
> 
> **Output**
> 
> [null, true, false, true, true, true, false]
> 
> 
> 
> **Explanation**
> 
> LockingTree lockingTree = new LockingTree([-1, 0, 0, 1, 1, 2, 2]);
> 
> lockingTree.lock(2, 2);> 
> // return true because node 2 is unlocked.
> 
> > 
> > 
> > 
> > 
> > 
> > 
>    // Node 2 will now be locked by user 2.
> 
> lockingTree.unlock(2, 3);  // return false because user 3 cannot unlock a node locked by user 2.
> 
> lockingTree.unlock(2, 2);  // return true because node 2 was previously locked by user 2.
> 
> > 
> > 
> > 
> > 
> > 
> > 
>    // Node 2 will now be unlocked.
> 
> lockingTree.lock(4, 5);> 
> // return true because node 4 is unlocked.
> 
> > 
> > 
> > 
> > 
> > 
> > 
>    // Node 4 will now be locked by user 5.
> 
> lockingTree.upgrade(0, 1); // return true because node 0 is unlocked and has at least one locked descendant (node 4).
> 
> > 
> > 
> > 
> > 
> > 
> > 
>    // Node 0 will now be locked by user 1 and node 4 will now be unlocked.
> 
> lockingTree.lock(0, 1);> 
> // return false because node 0 is already locked.

**Constraints:**

  * `n == parent.length`
  * `2 <= n <= 2000`
  * `0 <= parent[i] <= n - 1` for `i != 0`
  * `parent[0] == -1`
  * `0 <= num <= n - 1`
  * `1 <= user <= 10^4`
  * `parent` represents a valid tree.
  * At most `2000` calls **in total** will be made to `lock`, `unlock`, and `upgrade`.


## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€æ£µ `n` ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œç¼–å·ä» `0` åˆ° `n - 1` ï¼Œä»¥çˆ¶èŠ‚ç‚¹æ•°ç»„ `parent` çš„å½¢å¼ç»™å‡ºï¼Œå…¶ä¸­ `parent[i]` æ˜¯ç¬¬ `i`
ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ã€‚æ ‘çš„æ ¹èŠ‚ç‚¹ä¸º `0` å·èŠ‚ç‚¹ï¼Œæ‰€ä»¥ `parent[0] = -1`
ï¼Œå› ä¸ºå®ƒæ²¡æœ‰çˆ¶èŠ‚ç‚¹ã€‚ä½ æƒ³è¦è®¾è®¡ä¸€ä¸ªæ•°æ®ç»“æ„å®ç°æ ‘é‡Œé¢å¯¹èŠ‚ç‚¹çš„åŠ é”ï¼Œè§£é”å’Œå‡çº§æ“ä½œã€‚

æ•°æ®ç»“æ„éœ€è¦æ”¯æŒå¦‚ä¸‹å‡½æ•°ï¼š

  * **Lockï¼š** æŒ‡å®šç”¨æˆ·ç»™æŒ‡å®šèŠ‚ç‚¹ **ä¸Šé”**  ï¼Œä¸Šé”åå…¶ä»–ç”¨æˆ·å°†æ— æ³•ç»™åŒä¸€èŠ‚ç‚¹ä¸Šé”ã€‚åªæœ‰å½“èŠ‚ç‚¹å¤„äºæœªä¸Šé”çš„çŠ¶æ€ä¸‹ï¼Œæ‰èƒ½è¿›è¡Œä¸Šé”æ“ä½œã€‚
  * **Unlockï¼š** æŒ‡å®šç”¨æˆ·ç»™æŒ‡å®šèŠ‚ç‚¹ **è§£é”**  ï¼Œåªæœ‰å½“æŒ‡å®šèŠ‚ç‚¹å½“å‰æ­£è¢«æŒ‡å®šç”¨æˆ·é”ä½æ—¶ï¼Œæ‰èƒ½æ‰§è¡Œè¯¥è§£é”æ“ä½œã€‚
  * **Upgradeï¼š** æŒ‡å®šç”¨æˆ·ç»™æŒ‡å®šèŠ‚ç‚¹ **ä¸Šé”**  ï¼Œå¹¶ä¸”å°†è¯¥èŠ‚ç‚¹çš„æ‰€æœ‰å­å­™èŠ‚ç‚¹ **è§£é”**  ã€‚åªæœ‰å¦‚ä¸‹ 3 ä¸ªæ¡ä»¶ **å…¨éƒ¨** æ»¡è¶³æ—¶æ‰èƒ½æ‰§è¡Œå‡çº§æ“ä½œï¼š 
> 
> * æŒ‡å®šèŠ‚ç‚¹å½“å‰çŠ¶æ€ä¸ºæœªä¸Šé”ã€‚
> 
> * æŒ‡å®šèŠ‚ç‚¹è‡³å°‘æœ‰ä¸€ä¸ªä¸Šé”çŠ¶æ€çš„å­å­™èŠ‚ç‚¹ï¼ˆå¯ä»¥æ˜¯ **ä»»æ„**  ç”¨æˆ·ä¸Šé”çš„ï¼‰ã€‚
> 
> * æŒ‡å®šèŠ‚ç‚¹æ²¡æœ‰ä»»ä½•ä¸Šé”çš„ç¥–å…ˆèŠ‚ç‚¹ã€‚

è¯·ä½ å®ç° `LockingTree` ç±»ï¼š

  * `LockingTree(int[] parent)` ç”¨çˆ¶èŠ‚ç‚¹æ•°ç»„åˆå§‹åŒ–æ•°æ®ç»“æ„ã€‚
  * `lock(int num, int user)` å¦‚æœ id ä¸º `user` çš„ç”¨æˆ·å¯ä»¥ç»™èŠ‚ç‚¹ `num` ä¸Šé”ï¼Œé‚£ä¹ˆè¿”å› `true` ï¼Œå¦åˆ™è¿”å› `false` ã€‚å¦‚æœå¯ä»¥æ‰§è¡Œæ­¤æ“ä½œï¼ŒèŠ‚ç‚¹ `num` ä¼šè¢« id ä¸º `user` çš„ç”¨æˆ· **ä¸Šé”**  ã€‚
  * `unlock(int num, int user)` å¦‚æœ id ä¸º `user` çš„ç”¨æˆ·å¯ä»¥ç»™èŠ‚ç‚¹ `num` è§£é”ï¼Œé‚£ä¹ˆè¿”å› `true` ï¼Œå¦åˆ™è¿”å› `false` ã€‚å¦‚æœå¯ä»¥æ‰§è¡Œæ­¤æ“ä½œï¼ŒèŠ‚ç‚¹ `num` å˜ä¸º **æœªä¸Šé”**  çŠ¶æ€ã€‚
  * `upgrade(int num, int user)` å¦‚æœ id ä¸º `user` çš„ç”¨æˆ·å¯ä»¥ç»™èŠ‚ç‚¹ `num` å‡çº§ï¼Œé‚£ä¹ˆè¿”å› `true` ï¼Œå¦åˆ™è¿”å› `false` ã€‚å¦‚æœå¯ä»¥æ‰§è¡Œæ­¤æ“ä½œï¼ŒèŠ‚ç‚¹ `num` ä¼šè¢« **å‡çº§** ã€‚



**ç¤ºä¾‹ 1ï¼š**

![](https://assets.leetcode.com/uploads/2021/07/29/untitled.png)

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š**
> 
> ["LockingTree", "lock", "unlock", "unlock", "lock", "upgrade", "lock"]
> 
> [[[-1, 0, 0, 1, 1, 2, 2]], [2, 2], [2, 3], [2, 2], [4, 5], [0, 1], [0, 1]]
> 
> **è¾“å‡ºï¼š**
> 
> [null, true, false, true, true, true, false]
> 
> 
> 
> **è§£é‡Šï¼š**
> 
> LockingTree lockingTree = new LockingTree([-1, 0, 0, 1, 1, 2, 2]);
> 
> lockingTree.lock(2, 2);> 
> // è¿”å› true ï¼Œå› ä¸ºèŠ‚ç‚¹ 2 æœªä¸Šé”ã€‚
> 
> > 
> > 
> > 
> > 
> > 
> > 
>    // èŠ‚ç‚¹ 2 è¢«ç”¨æˆ· 2 ä¸Šé”ã€‚
> 
> lockingTree.unlock(2, 3);  // è¿”å› false ï¼Œå› ä¸ºç”¨æˆ· 3 æ— æ³•è§£é”è¢«ç”¨æˆ· 2 ä¸Šé”çš„èŠ‚ç‚¹ã€‚
> 
> lockingTree.unlock(2, 2);  // è¿”å› true ï¼Œå› ä¸ºèŠ‚ç‚¹ 2 ä¹‹å‰è¢«ç”¨æˆ· 2 ä¸Šé”ã€‚
> 
> > 
> > 
> > 
> > 
> > 
> > 
>    // èŠ‚ç‚¹ 2 ç°åœ¨å˜ä¸ºæœªä¸Šé”çŠ¶æ€ã€‚
> 
> lockingTree.lock(4, 5);> 
> // è¿”å› true ï¼Œå› ä¸ºèŠ‚ç‚¹ 4 æœªä¸Šé”ã€‚
> 
> > 
> > 
> > 
> > 
> > 
> > 
>    // èŠ‚ç‚¹ 4 è¢«ç”¨æˆ· 5 ä¸Šé”ã€‚
> 
> lockingTree.upgrade(0, 1); // è¿”å› true ï¼Œå› ä¸ºèŠ‚ç‚¹ 0 æœªä¸Šé”ä¸”è‡³å°‘æœ‰ä¸€ä¸ªè¢«ä¸Šé”çš„å­å­™èŠ‚ç‚¹ï¼ˆèŠ‚ç‚¹ 4ï¼‰ã€‚
> 
> > 
> > 
> > 
> > 
> > 
> > 
>    // èŠ‚ç‚¹ 0 è¢«ç”¨æˆ· 1 ä¸Šé”ï¼ŒèŠ‚ç‚¹ 4 å˜ä¸ºæœªä¸Šé”ã€‚
> 
> lockingTree.lock(0, 1);> 
> // è¿”å› false ï¼Œå› ä¸ºèŠ‚ç‚¹ 0 å·²ç»è¢«ä¸Šé”äº†ã€‚
> 
> 



**æç¤ºï¼š**

  * `n == parent.length`
  * `2 <= n <= 2000`
  * å¯¹äº `i != 0` ï¼Œæ»¡è¶³ `0 <= parent[i] <= n - 1`
  * `parent[0] == -1`
  * `0 <= num <= n - 1`
  * `1 <= user <= 10^4`
  * `parent` è¡¨ç¤ºä¸€æ£µåˆæ³•çš„æ ‘ã€‚
  * `lock` ï¼Œ`unlock` å’Œ `upgrade` çš„è°ƒç”¨ **æ€»å…±  **ä¸è¶…è¿‡ `2000` æ¬¡ã€‚


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 1600 | [ç‹ä½ç»§æ‰¿é¡ºåº](https://leetcode.com/problems/throne-inheritance) |  |  [`æ ‘`](/leetcode/outline/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/depth-first-search.md) [`è®¾è®¡`](/leetcode/outline/tag/design.md) `1+` | <font color=#ffb800>Medium</font> |

<style>
.blue {
    background-color: #096dd9;
    padding: 0.25rem 0.5rem;
    margin: 0;
    font-size: 0.85em;
    border-radius: 3px;
    color: white;
    font-weight: 500;
}
table th:first-of-type { width: 10%; }
table th:nth-of-type(2) { width: 35%; }
table th:nth-of-type(3) { width: 10%; }
table th:nth-of-type(4) { width: 35%; }
table th:nth-of-type(5) { width: 10%; }
</style>
