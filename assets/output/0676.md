# [676. å®ç°ä¸€ä¸ªé­”æ³•å­—å…¸](https://leetcode.com/problems/implement-magic-dictionary)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/depth-first-search.md) [`è®¾è®¡`](/leetcode/outline/tag/design.md) [`å­—å…¸æ ‘`](/leetcode/outline/tag/trie.md) [`å“ˆå¸Œè¡¨`](/leetcode/outline/tag/hash-table.md) [`å­—ç¬¦ä¸²`](/leetcode/outline/tag/string.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/implement-magic-dictionary)


## é¢˜ç›®

Design a data structure that is initialized with a list of **different**
words. Provided a string, you should determine if you can change exactly one
character in this string to match any word in the data structure.

Implement the `MagicDictionary` class:

  * `MagicDictionary()` Initializes the object.
  * `void buildDict(String[] dictionary)` Sets the data structure with an array of distinct strings `dictionary`.
  * `bool search(String searchWord)` Returns `true` if you can change **exactly one character** in `searchWord` to match any string in the data structure, otherwise returns `false`.



**Example 1:**

> 
> 
> 
> 
> 
> **Input**
> 
> ["MagicDictionary", "buildDict", "search", "search", "search", "search"]
> 
> [[], [["hello", "leetcode"]], ["hello"], ["hhllo"], ["hell"], ["leetcoded"]]
> 
> **Output**
> 
> [null, null, false, true, false, false]
> 
> 
> 
> **Explanation**
> 
> MagicDictionary magicDictionary = new MagicDictionary();
> 
> magicDictionary.buildDict(["hello", "leetcode"]);
> 
> magicDictionary.search("hello"); // return False
> 
> magicDictionary.search("hhllo"); // We can change the second 'h' to 'e' to match "hello" so we return True
> 
> magicDictionary.search("hell"); // return False
> 
> magicDictionary.search("leetcoded"); // return False

**Constraints:**

  * `1 <= dictionary.length <= 100`
  * `1 <= dictionary[i].length <= 100`
  * `dictionary[i]` consists of only lower-case English letters.
  * All the strings in `dictionary` are **distinct**.
  * `1 <= searchWord.length <= 100`
  * `searchWord` consists of only lower-case English letters.
  * `buildDict` will be called only once before `search`.
  * At most `100` calls will be made to `search`.


## é¢˜ç›®å¤§æ„

è®¾è®¡ä¸€ä¸ªä½¿ç”¨å•è¯åˆ—è¡¨è¿›è¡Œåˆå§‹åŒ–çš„æ•°æ®ç»“æ„ï¼Œå•è¯åˆ—è¡¨ä¸­çš„å•è¯ **äº’ä¸ç›¸åŒ** ã€‚ å¦‚æœç»™å‡ºä¸€ä¸ªå•è¯ï¼Œè¯·åˆ¤å®šèƒ½å¦åªå°†è¿™ä¸ªå•è¯ä¸­**ä¸€ä¸ª**
å­—æ¯æ¢æˆå¦ä¸€ä¸ªå­—æ¯ï¼Œä½¿å¾—æ‰€å½¢æˆçš„æ–°å•è¯å­˜åœ¨äºä½ æ„å»ºçš„å­—å…¸ä¸­ã€‚

å®ç° `MagicDictionary` ç±»ï¼š

  * `MagicDictionary()` åˆå§‹åŒ–å¯¹è±¡
  * `void buildDict(String[] dictionary)` ä½¿ç”¨å­—ç¬¦ä¸²æ•°ç»„ `dictionary` è®¾å®šè¯¥æ•°æ®ç»“æ„ï¼Œ`dictionary` ä¸­çš„å­—ç¬¦ä¸²äº’ä¸ç›¸åŒ
  * `bool search(String searchWord)` ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² `searchWord` ï¼Œåˆ¤å®šèƒ½å¦åªå°†å­—ç¬¦ä¸²ä¸­**ä¸€ä¸ª** å­—æ¯æ¢æˆå¦ä¸€ä¸ªå­—æ¯ï¼Œä½¿å¾—æ‰€å½¢æˆçš„æ–°å­—ç¬¦ä¸²èƒ½å¤Ÿä¸å­—å…¸ä¸­çš„ä»»ä¸€å­—ç¬¦ä¸²åŒ¹é…ã€‚å¦‚æœå¯ä»¥ï¼Œè¿”å› `true` ï¼›å¦åˆ™ï¼Œè¿”å› `false` ã€‚

**ç¤ºä¾‹ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥**
> 
> ["MagicDictionary", "buildDict", "search", "search", "search", "search"]
> 
> [[], [["hello", "leetcode"]], ["hello"], ["hhllo"], ["hell"], ["leetcoded"]]
> 
> **è¾“å‡º**
> 
> [null, null, false, true, false, false]
> 
> 
> 
> **è§£é‡Š**
> 
> MagicDictionary magicDictionary = new MagicDictionary();
> 
> magicDictionary.buildDict(["hello", "leetcode"]);
> 
> magicDictionary.search("hello"); // è¿”å› False
> 
> magicDictionary.search("hhllo"); // å°†ç¬¬äºŒä¸ª 'h' æ›¿æ¢ä¸º 'e' å¯ä»¥åŒ¹é… "hello" ï¼Œæ‰€ä»¥è¿”å› True
> 
> magicDictionary.search("hell"); // è¿”å› False
> 
> magicDictionary.search("leetcoded"); // è¿”å› False
> 
> 

**æç¤ºï¼š**

  * `1 <= dictionary.length <= 100`
  * `1 <= dictionary[i].length <= 100`
  * `dictionary[i]` ä»…ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆ
  * `dictionary` ä¸­çš„æ‰€æœ‰å­—ç¬¦ä¸² **äº’ä¸ç›¸åŒ**
  * `1 <= searchWord.length <= 100`
  * `searchWord` ä»…ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆ
  * `buildDict` ä»…åœ¨ `search` ä¹‹å‰è°ƒç”¨ä¸€æ¬¡
  * æœ€å¤šè°ƒç”¨ `100` æ¬¡ `search`


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 208 | [å®ç° Trie (å‰ç¼€æ ‘)](https://leetcode.com/problems/implement-trie-prefix-tree) | [[âœ“]](https://2xiao.github.io/leetcode-js/leetcode/problem/0208) |  [`è®¾è®¡`](/leetcode/outline/tag/design.md) [`å­—å…¸æ ‘`](/leetcode/outline/tag/trie.md) [`å“ˆå¸Œè¡¨`](/leetcode/outline/tag/hash-table.md) `1+` | <font color=#ffb800>Medium</font> |
| 720 | [è¯å…¸ä¸­æœ€é•¿çš„å•è¯](https://leetcode.com/problems/longest-word-in-dictionary) |  |  [`å­—å…¸æ ‘`](/leetcode/outline/tag/trie.md) [`æ•°ç»„`](/leetcode/outline/tag/array.md) [`å“ˆå¸Œè¡¨`](/leetcode/outline/tag/hash-table.md) `2+` | <font color=#ffb800>Medium</font> |

<style>
.blue {
    background-color: #096dd9;
    padding: 0.25rem 0.5rem;
    margin: 0;
    font-size: 0.85em;
    border-radius: 3px;
    color: white;
    font-weight: 500;
}
table th:first-of-type { width: 10%; }
table th:nth-of-type(2) { width: 35%; }
table th:nth-of-type(3) { width: 10%; }
table th:nth-of-type(4) { width: 35%; }
table th:nth-of-type(5) { width: 10%; }
</style>
