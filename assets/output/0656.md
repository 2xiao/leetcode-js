---
title: 656. 成本最小路径 🔒
description: LeetCode 656. 成本最小路径 🔒题解，Coin Path，包含解题思路、复杂度分析以及完整的 JavaScript 代码实现。
keywords:
  - LeetCode
  - 656. 成本最小路径 🔒
  - 成本最小路径
  - Coin Path
  - 解题思路
  - 数组
  - 动态规划
---

# 656. 成本最小路径 🔒

🔴 <font color=#ff334b>Hard</font>&emsp; 🔖&ensp; [`数组`](/tag/array.md) [`动态规划`](/tag/dynamic-programming.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/coin-path) [`LeetCode`](https://leetcode.com/problems/coin-path)

## 题目

You are given an integer array `coins` (**1-indexed**) of length `n` and an
integer `maxJump`. You can jump to any index `i` of the array `coins` if
`coins[i] != -1` and you have to pay `coins[i]` when you visit index `i`. In
addition to that, if you are currently at index `i`, you can only jump to any
index `i + k` where `i + k <= n` and `k` is a value in the range `[1,
maxJump]`.

You are initially positioned at index `1` (`coins[1]` is not `-1`). You want
to find the path that reaches index n with the minimum cost.

Return an integer array of the indices that you will visit in order so that
you can reach index n with the minimum cost. If there are multiple paths with
the same cost, return the **lexicographically smallest** such path. If it is
not possible to reach index n, return an empty array.

A path `p1 = [Pa1, Pa2, ..., Pax]` of length `x` is **lexicographically
smaller** than `p2 = [Pb1, Pb2, ..., Pbx]` of length `y`, if and only if at
the first `j` where `Paj` and `Pbj` differ, `Paj < Pbj`; when no such `j`
exists, then `x < y`.



**Example 1:**

> Input: coins = [1,2,4,-1,2], maxJump = 2
> 
> Output: [1,3,5]

**Example 2:**

> Input: coins = [1,2,4,-1,2], maxJump = 1
> 
> Output: []

**Constraints:**

  * `1 <= coins.length <= 1000`
  * `-1 <= coins[i] <= 100`
  * `coins[1] != -1`
  * `1 <= maxJump <= 100`


## 题目大意

给你一个整数数组 `coins`（下标从 **1** 开始）长度为 `n`，以及一个整数 `maxJump`。你可以跳到数组 `coins` 的任意下标
`i`（满足 `coins[i] != -1`），访问下标 `i` 时需要支付 `coins[i]`。此外，如果你当前位于下标 `i`，你只能跳到下标 `i
+ k`（满足 `i + k <= n`），其中 `k` 是范围 `[1, maxJump]` 内的一个值。

初始时你位于下标 `1`（`coins[1]` 不是 `-1`）。你的目标是找到一条到达下标 `n` 的成本最小路径。

返回一个整数数组，包含你访问的下标顺序，以便你以最小成本达到下标 `n` 。如果存在多条成本相同的路径，返回**字典序最小** 的路径。如果无法达到下标
`n` ，返回一个空数组。

路径 `p1 = [Pa1, Pa2, ..., Pax]` 的长度为 `x`，路径 `p2 = [Pb1, Pb2, ..., Pbx]` 的长度为
`y` ，如果在两条路径的第一个不同的下标 `j` 处，`Paj` 小于 `Pbj`，则 `p1` 在字典序上小于 `p2`；如果不存在这样的
`j`，则较短的路径字典序较小。



**示例 1：**

> 
> 
> 
> 
> 
> **输入：** coins = [1,2,4,-1,2], maxJump = 2
> 
> **输出：**[1,3,5]
> 
> 

**示例 2：**

> 
> 
> 
> 
> 
> **输入：** coins = [1,2,4,-1,2], maxJump = 1
> 
> **输出：**[]
> 
> 



**提示：**

  * `1 <= coins.length <= 1000`
  * `-1 <= coins[i] <= 100`
  * `coins[1] != -1`
  * `1 <= maxJump <= 100`


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 198 | 打家劫舍 | [[✓]](/problem/0198.md) |  [`数组`](/tag/array.md) [`动态规划`](/tag/dynamic-programming.md) | 🟠 | [🀄️](https://leetcode.cn/problems/house-robber) [🔗](https://leetcode.com/problems/house-robber) |
| 213 | 打家劫舍 II | [[✓]](/problem/0213.md) |  [`数组`](/tag/array.md) [`动态规划`](/tag/dynamic-programming.md) | 🟠 | [🀄️](https://leetcode.cn/problems/house-robber-ii) [🔗](https://leetcode.com/problems/house-robber-ii) |