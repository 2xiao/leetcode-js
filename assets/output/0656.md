---
title: 656. æˆæœ¬æœ€å°è·¯å¾„ ğŸ”’
description: LeetCode 656. æˆæœ¬æœ€å°è·¯å¾„ ğŸ”’é¢˜è§£ï¼ŒCoin Pathï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 656. æˆæœ¬æœ€å°è·¯å¾„ ğŸ”’
  - æˆæœ¬æœ€å°è·¯å¾„
  - Coin Path
  - è§£é¢˜æ€è·¯
  - æ•°ç»„
  - åŠ¨æ€è§„åˆ’
---

# 656. æˆæœ¬æœ€å°è·¯å¾„ ğŸ”’

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`æ•°ç»„`](/tag/array.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/coin-path) [`LeetCode`](https://leetcode.com/problems/coin-path)

## é¢˜ç›®

You are given an integer array `coins` (**1-indexed**) of length `n` and an
integer `maxJump`. You can jump to any index `i` of the array `coins` if
`coins[i] != -1` and you have to pay `coins[i]` when you visit index `i`. In
addition to that, if you are currently at index `i`, you can only jump to any
index `i + k` where `i + k <= n` and `k` is a value in the range `[1,
maxJump]`.

You are initially positioned at index `1` (`coins[1]` is not `-1`). You want
to find the path that reaches index n with the minimum cost.

Return an integer array of the indices that you will visit in order so that
you can reach index n with the minimum cost. If there are multiple paths with
the same cost, return the **lexicographically smallest** such path. If it is
not possible to reach index n, return an empty array.

A path `p1 = [Pa1, Pa2, ..., Pax]` of length `x` is **lexicographically
smaller** than `p2 = [Pb1, Pb2, ..., Pbx]` of length `y`, if and only if at
the first `j` where `Paj` and `Pbj` differ, `Paj < Pbj`; when no such `j`
exists, then `x < y`.



**Example 1:**

> Input: coins = [1,2,4,-1,2], maxJump = 2
> 
> Output: [1,3,5]

**Example 2:**

> Input: coins = [1,2,4,-1,2], maxJump = 1
> 
> Output: []

**Constraints:**

  * `1 <= coins.length <= 1000`
  * `-1 <= coins[i] <= 100`
  * `coins[1] != -1`
  * `1 <= maxJump <= 100`


## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `coins`ï¼ˆä¸‹æ ‡ä» **1** å¼€å§‹ï¼‰é•¿åº¦ä¸º `n`ï¼Œä»¥åŠä¸€ä¸ªæ•´æ•° `maxJump`ã€‚ä½ å¯ä»¥è·³åˆ°æ•°ç»„ `coins` çš„ä»»æ„ä¸‹æ ‡
`i`ï¼ˆæ»¡è¶³ `coins[i] != -1`ï¼‰ï¼Œè®¿é—®ä¸‹æ ‡ `i` æ—¶éœ€è¦æ”¯ä»˜ `coins[i]`ã€‚æ­¤å¤–ï¼Œå¦‚æœä½ å½“å‰ä½äºä¸‹æ ‡ `i`ï¼Œä½ åªèƒ½è·³åˆ°ä¸‹æ ‡ `i
+ k`ï¼ˆæ»¡è¶³ `i + k <= n`ï¼‰ï¼Œå…¶ä¸­ `k` æ˜¯èŒƒå›´ `[1, maxJump]` å†…çš„ä¸€ä¸ªå€¼ã€‚

åˆå§‹æ—¶ä½ ä½äºä¸‹æ ‡ `1`ï¼ˆ`coins[1]` ä¸æ˜¯ `-1`ï¼‰ã€‚ä½ çš„ç›®æ ‡æ˜¯æ‰¾åˆ°ä¸€æ¡åˆ°è¾¾ä¸‹æ ‡ `n` çš„æˆæœ¬æœ€å°è·¯å¾„ã€‚

è¿”å›ä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼ŒåŒ…å«ä½ è®¿é—®çš„ä¸‹æ ‡é¡ºåºï¼Œä»¥ä¾¿ä½ ä»¥æœ€å°æˆæœ¬è¾¾åˆ°ä¸‹æ ‡ `n` ã€‚å¦‚æœå­˜åœ¨å¤šæ¡æˆæœ¬ç›¸åŒçš„è·¯å¾„ï¼Œè¿”å›**å­—å…¸åºæœ€å°** çš„è·¯å¾„ã€‚å¦‚æœæ— æ³•è¾¾åˆ°ä¸‹æ ‡
`n` ï¼Œè¿”å›ä¸€ä¸ªç©ºæ•°ç»„ã€‚

è·¯å¾„ `p1 = [Pa1, Pa2, ..., Pax]` çš„é•¿åº¦ä¸º `x`ï¼Œè·¯å¾„ `p2 = [Pb1, Pb2, ..., Pbx]` çš„é•¿åº¦ä¸º
`y` ï¼Œå¦‚æœåœ¨ä¸¤æ¡è·¯å¾„çš„ç¬¬ä¸€ä¸ªä¸åŒçš„ä¸‹æ ‡ `j` å¤„ï¼Œ`Paj` å°äº `Pbj`ï¼Œåˆ™ `p1` åœ¨å­—å…¸åºä¸Šå°äº `p2`ï¼›å¦‚æœä¸å­˜åœ¨è¿™æ ·çš„
`j`ï¼Œåˆ™è¾ƒçŸ­çš„è·¯å¾„å­—å…¸åºè¾ƒå°ã€‚



**ç¤ºä¾‹ 1ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** coins = [1,2,4,-1,2], maxJump = 2
> 
> **è¾“å‡ºï¼š**[1,3,5]
> 
> 

**ç¤ºä¾‹ 2ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** coins = [1,2,4,-1,2], maxJump = 1
> 
> **è¾“å‡ºï¼š**[]
> 
> 



**æç¤ºï¼š**

  * `1 <= coins.length <= 1000`
  * `-1 <= coins[i] <= 100`
  * `coins[1] != -1`
  * `1 <= maxJump <= 100`


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ | åŠ›æ‰£ |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 198 | æ‰“å®¶åŠ«èˆ | [[âœ“]](/problem/0198.md) |  [`æ•°ç»„`](/tag/array.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md) | ğŸŸ  | [ğŸ€„ï¸](https://leetcode.cn/problems/house-robber) [ğŸ”—](https://leetcode.com/problems/house-robber) |
| 213 | æ‰“å®¶åŠ«èˆ II |  |  [`æ•°ç»„`](/tag/array.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md) | ğŸŸ  | [ğŸ€„ï¸](https://leetcode.cn/problems/house-robber-ii) [ğŸ”—](https://leetcode.com/problems/house-robber-ii) |