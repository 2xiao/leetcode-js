# [2646. æœ€å°åŒ–æ—…è¡Œçš„ä»·æ ¼æ€»å’Œ](https://leetcode.com/problems/minimize-the-total-price-of-the-trips)

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`æ ‘`](/leetcode/outline/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/depth-first-search.md) [`å›¾`](/leetcode/outline/tag/graph.md) [`æ•°ç»„`](/leetcode/outline/tag/array.md) [`åŠ¨æ€è§„åˆ’`](/leetcode/outline/tag/dynamic-programming.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/minimize-the-total-price-of-the-trips)

## é¢˜ç›®

There exists an undirected and unrooted tree with `n` nodes indexed from `0`
to `n - 1`. You are given the integer `n` and a 2D integer array `edges` of
length `n - 1`, where `edges[i] = [ai, bi]` indicates that there is an edge
between nodes `ai` and `bi` in the tree.

Each node has an associated price. You are given an integer array `price`,
where `price[i]` is the price of the `ith` node.

The **price sum** of a given path is the sum of the prices of all nodes lying
on that path.

Additionally, you are given a 2D integer array `trips`, where `trips[i] =
[starti, endi]` indicates that you start the `ith` trip from the node `starti`
and travel to the node `endi` by any path you like.

Before performing your first trip, you can choose some **non-adjacent** nodes
and halve the prices.

Return _the minimum total price sum to perform all the given trips_.



**Example 1:**

![](https://assets.leetcode.com/uploads/2023/03/16/diagram2.png)

> Input: n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]
> 
> Output: 23
> 
> Explanation: The diagram above denotes the tree after rooting it at node 2. The first part shows the initial tree and the second part shows the tree after choosing nodes 0, 2, and 3, and making their price half.
> 
> For the 1st trip, we choose path [0,1,3]. The price sum of that path is 1 + 2 + 3 = 6.
> 
> For the 2nd trip, we choose path [2,1]. The price sum of that path is 2 + 5 = 7.
> 
> For the 3rd trip, we choose path [2,1,3]. The price sum of that path is 5 + 2 + 3 = 10.
> 
> The total price sum of all trips is 6 + 7 + 10 = 23.
> 
> It can be proven, that 23 is the minimum answer that we can achieve.

**Example 2:**

![](https://assets.leetcode.com/uploads/2023/03/16/diagram3.png)

> Input: n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]
> 
> Output: 1
> 
> Explanation: The diagram above denotes the tree after rooting it at node 0. The first part shows the initial tree and the second part shows the tree after choosing node 0, and making its price half.
> 
> For the 1st trip, we choose path [0]. The price sum of that path is 1.
> 
> The total price sum of all trips is 1. It can be proven, that 1 is the minimum answer that we can achieve.

**Constraints:**

  * `1 <= n <= 50`
  * `edges.length == n - 1`
  * `0 <= ai, bi <= n - 1`
  * `edges` represents a valid tree.
  * `price.length == n`
  * `price[i]` is an even integer.
  * `1 <= price[i] <= 1000`
  * `1 <= trips.length <= 100`
  * `0 <= starti, endi <= n - 1`


## é¢˜ç›®å¤§æ„

ç°æœ‰ä¸€æ£µæ— å‘ã€æ— æ ¹çš„æ ‘ï¼Œæ ‘ä¸­æœ‰ `n` ä¸ªèŠ‚ç‚¹ï¼ŒæŒ‰ä» `0` åˆ° `n - 1` ç¼–å·ã€‚ç»™ä½ ä¸€ä¸ªæ•´æ•° `n` å’Œä¸€ä¸ªé•¿åº¦ä¸º `n - 1` çš„äºŒç»´æ•´æ•°æ•°ç»„
`edges` ï¼Œå…¶ä¸­ `edges[i] = [ai, bi]` è¡¨ç¤ºæ ‘ä¸­èŠ‚ç‚¹ `ai` å’Œ `bi` ä¹‹é—´å­˜åœ¨ä¸€æ¡è¾¹ã€‚

æ¯ä¸ªèŠ‚ç‚¹éƒ½å…³è”ä¸€ä¸ªä»·æ ¼ã€‚ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `price` ï¼Œå…¶ä¸­ `price[i]` æ˜¯ç¬¬ `i` ä¸ªèŠ‚ç‚¹çš„ä»·æ ¼ã€‚

ç»™å®šè·¯å¾„çš„ **ä»·æ ¼æ€»å’Œ** æ˜¯è¯¥è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„ä»·æ ¼ä¹‹å’Œã€‚

å¦ç»™ä½ ä¸€ä¸ªäºŒç»´æ•´æ•°æ•°ç»„ `trips` ï¼Œå…¶ä¸­ `trips[i] = [starti, endi]` è¡¨ç¤ºæ‚¨ä»èŠ‚ç‚¹ `starti` å¼€å§‹ç¬¬ `i`
æ¬¡æ—…è¡Œï¼Œå¹¶é€šè¿‡ä»»ä½•ä½ å–œæ¬¢çš„è·¯å¾„å‰å¾€èŠ‚ç‚¹ `endi` ã€‚

åœ¨æ‰§è¡Œç¬¬ä¸€æ¬¡æ—…è¡Œä¹‹å‰ï¼Œä½ å¯ä»¥é€‰æ‹©ä¸€äº› **éç›¸é‚»èŠ‚ç‚¹** å¹¶å°†ä»·æ ¼å‡åŠã€‚

è¿”å›æ‰§è¡Œæ‰€æœ‰æ—…è¡Œçš„æœ€å°ä»·æ ¼æ€»å’Œã€‚



**ç¤ºä¾‹ 1ï¼š**

![](https://assets.leetcode.com/uploads/2023/03/16/diagram2.png)

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]
> 
> **è¾“å‡ºï¼š** 23
> 
> **è§£é‡Šï¼š** ä¸Šå›¾è¡¨ç¤ºå°†èŠ‚ç‚¹ 2 è§†ä¸ºæ ¹ä¹‹åçš„æ ‘ç»“æ„ã€‚ç¬¬ä¸€ä¸ªå›¾è¡¨ç¤ºåˆå§‹æ ‘ï¼Œç¬¬äºŒä¸ªå›¾è¡¨ç¤ºé€‰æ‹©èŠ‚ç‚¹ 0 ã€2 å’Œ 3 å¹¶ä½¿å…¶ä»·æ ¼å‡åŠåçš„æ ‘ã€‚
> 
> ç¬¬ 1 æ¬¡æ—…è¡Œï¼Œé€‰æ‹©è·¯å¾„ [0,1,3] ã€‚è·¯å¾„çš„ä»·æ ¼æ€»å’Œä¸º 1 + 2 + 3 = 6 ã€‚
> 
> ç¬¬ 2 æ¬¡æ—…è¡Œï¼Œé€‰æ‹©è·¯å¾„ [2,1] ã€‚è·¯å¾„çš„ä»·æ ¼æ€»å’Œä¸º 2 + 5 = 7 ã€‚
> 
> ç¬¬ 3 æ¬¡æ—…è¡Œï¼Œé€‰æ‹©è·¯å¾„ [2,1,3] ã€‚è·¯å¾„çš„ä»·æ ¼æ€»å’Œä¸º 5 + 2 + 3 = 10 ã€‚
> 
> æ‰€æœ‰æ—…è¡Œçš„ä»·æ ¼æ€»å’Œä¸º 6 + 7 + 10 = 23 ã€‚å¯ä»¥è¯æ˜ï¼Œ23 æ˜¯å¯ä»¥å®ç°çš„æœ€å°ç­”æ¡ˆã€‚

**ç¤ºä¾‹ 2ï¼š**

![](https://assets.leetcode.com/uploads/2023/03/16/diagram3.png)

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]
> 
> **è¾“å‡ºï¼š** 1
> 
> **è§£é‡Šï¼š**
> 
> ä¸Šå›¾è¡¨ç¤ºå°†èŠ‚ç‚¹ 0 è§†ä¸ºæ ¹ä¹‹åçš„æ ‘ç»“æ„ã€‚ç¬¬ä¸€ä¸ªå›¾è¡¨ç¤ºåˆå§‹æ ‘ï¼Œç¬¬äºŒä¸ªå›¾è¡¨ç¤ºé€‰æ‹©èŠ‚ç‚¹ 0 å¹¶ä½¿å…¶ä»·æ ¼å‡åŠåçš„æ ‘ã€‚ 
> 
> ç¬¬ 1 æ¬¡æ—…è¡Œï¼Œé€‰æ‹©è·¯å¾„ [0] ã€‚è·¯å¾„çš„ä»·æ ¼æ€»å’Œä¸º 1 ã€‚ 
> 
> æ‰€æœ‰æ—…è¡Œçš„ä»·æ ¼æ€»å’Œä¸º 1 ã€‚å¯ä»¥è¯æ˜ï¼Œ1 æ˜¯å¯ä»¥å®ç°çš„æœ€å°ç­”æ¡ˆã€‚
> 
> 



**æç¤ºï¼š**

  * `1 <= n <= 50`
  * `edges.length == n - 1`
  * `0 <= ai, bi <= n - 1`
  * `edges` è¡¨ç¤ºä¸€æ£µæœ‰æ•ˆçš„æ ‘
  * `price.length == n`
  * `price[i]` æ˜¯ä¸€ä¸ªå¶æ•°
  * `1 <= price[i] <= 1000`
  * `1 <= trips.length <= 100`
  * `0 <= starti, endi <= n - 1`


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```