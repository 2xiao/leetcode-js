---
title: 2378. é€‰æ‹©è¾¹æ¥æœ€å¤§åŒ–æ ‘çš„å¾—åˆ† ğŸ”’
description: LeetCode 2378. é€‰æ‹©è¾¹æ¥æœ€å¤§åŒ–æ ‘çš„å¾—åˆ† ğŸ”’é¢˜è§£ï¼ŒChoose Edges to Maximize Score in a Treeï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 2378. é€‰æ‹©è¾¹æ¥æœ€å¤§åŒ–æ ‘çš„å¾—åˆ† ğŸ”’
  - é€‰æ‹©è¾¹æ¥æœ€å¤§åŒ–æ ‘çš„å¾—åˆ†
  - Choose Edges to Maximize Score in a Tree
  - è§£é¢˜æ€è·¯
  - æ ‘
  - æ·±åº¦ä¼˜å…ˆæœç´¢
  - åŠ¨æ€è§„åˆ’
---

# 2378. é€‰æ‹©è¾¹æ¥æœ€å¤§åŒ–æ ‘çš„å¾—åˆ† ğŸ”’

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ ‘`](/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/choose-edges-to-maximize-score-in-a-tree) [`LeetCode`](https://leetcode.com/problems/choose-edges-to-maximize-score-in-a-tree)

## é¢˜ç›®

You are given a **weighted** tree consisting of `n` nodes numbered from `0` to
`n - 1`.

The tree is **rooted** at node `0` and represented with a **2D** array `edges`
of size `n` where `edges[i] = [pari, weighti]` indicates that node `pari` is
the **parent** of node `i`, and the edge between them has a weight equal to
`weighti`. Since the root does **not** have a parent, you have `edges[0] =
[-1, -1]`.

Choose some edges from the tree such that no two chosen edges are **adjacent**
and the **sum** of the weights of the chosen edges is maximized.

Return _the**maximum** sum of the chosen edges_.

**Note** :

  * You are allowed to **not** choose any edges in the tree, the sum of weights in this case will be `0`.
  * Two edges `Edge1` and `Edge2` in the tree are **adjacent** if they have a **common** node. 
> 
> * In other words, they are adjacent if `Edge1` connects nodes `a` and `b` and `Edge2` connects nodes `b` and `c`.



**Example 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2300-2399/2378.Choose%20Edges%20to%20Maximize%20Score%20in%20a%20Tree/images/treedrawio.png)

> Input: edges = [[-1,-1],[0,5],[0,10],[2,6],[2,4]]
> 
> Output: 11
> 
> Explanation: The above diagram shows the edges that we have to choose colored in red.
> 
> The total score is 5 + 6 = 11.
> 
> It can be shown that no better score can be obtained.

**Example 2:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2300-2399/2378.Choose%20Edges%20to%20Maximize%20Score%20in%20a%20Tree/images/treee1293712983719827.png)

> Input: edges = [[-1,-1],[0,5],[0,-6],[0,7]]
> 
> Output: 7
> 
> Explanation: We choose the edge with weight 7.
> 
> Note that we cannot choose more than one edge because all edges are adjacent to each other.

**Constraints:**

  * `n == edges.length`
  * `1 <= n <= 10^5`
  * `edges[i].length == 2`
  * `par0 == weight0 == -1`
  * `0 <= pari <= n - 1` for all `i >= 1`.
  * `pari != i`
  * `-10^6 <= weighti <= 10^6` for all `i >= 1`.
  * `edges` represents a valid tree.


## é¢˜ç›®å¤§æ„

ç»™å®šä¸€ä¸ª **åŠ æƒ  **æ ‘ï¼Œç”± `n` ä¸ªèŠ‚ç‚¹ç»„æˆï¼Œä» `0` åˆ° `n - 1`ã€‚

è¯¥æ ‘ä»¥èŠ‚ç‚¹ 0 ä¸º **æ ¹** ï¼Œç”¨å¤§å°ä¸º `n` çš„äºŒç»´æ•°ç»„ `edges` è¡¨ç¤ºï¼Œå…¶ä¸­ `edges[i] = [pari, weighti]`
è¡¨ç¤ºèŠ‚ç‚¹ `pari` æ˜¯èŠ‚ç‚¹ `i` çš„ **çˆ¶  **èŠ‚ç‚¹ï¼Œå®ƒä»¬ä¹‹é—´çš„è¾¹çš„æƒé‡ç­‰äº `weighti`ã€‚å› ä¸ºæ ¹ç»“ç‚¹ **æ²¡æœ‰  **çˆ¶ç»“ç‚¹ï¼Œæ‰€ä»¥æœ‰
`edges[0] = [-1, -1]`ã€‚

ä»æ ‘ä¸­é€‰æ‹©ä¸€äº›è¾¹ï¼Œä½¿æ‰€é€‰çš„ä¸¤æ¡è¾¹éƒ½ä¸ **ç›¸é‚»** ï¼Œæ‰€é€‰è¾¹çš„æƒå€¼ä¹‹ **å’Œ** æœ€å¤§ã€‚



è¿”å› _æ‰€é€‰è¾¹çš„  **æœ€å¤§  **å’Œã€‚_

**æ³¨æ„** :

  * ä½ å¯ä»¥ **ä¸é€‰æ‹©  **æ ‘ä¸­çš„ä»»ä½•è¾¹ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹æƒå€¼å’Œå°†ä¸º `0`ã€‚
  * å¦‚æœæ ‘ä¸­çš„ä¸¤æ¡è¾¹ `Edge1` å’Œ `Edge2` æœ‰ä¸€ä¸ª **å…¬å…±  **èŠ‚ç‚¹ï¼Œå®ƒä»¬å°±æ˜¯ **ç›¸é‚»  **çš„ã€‚ 
> 
> * æ¢å¥è¯è¯´ï¼Œå¦‚æœ `Edge1`è¿æ¥èŠ‚ç‚¹ `a` å’Œ `b`, `Edge2` è¿æ¥èŠ‚ç‚¹ `b` å’Œ `c`ï¼Œå®ƒä»¬æ˜¯ç›¸é‚»çš„ã€‚



**ç¤ºä¾‹ 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2300-2399/2378.Choose%20Edges%20to%20Maximize%20Score%20in%20a%20Tree/images/treedrawio.png)

> 
> 
> 
> 
> 
> **è¾“å…¥:** edges = [[-1,-1],[0,5],[0,10],[2,6],[2,4]]
> 
> **è¾“å‡º:** 11
> 
> **è§£é‡Š:** ä¸Šé¢çš„å›¾è¡¨æ˜¾ç¤ºäº†æˆ‘ä»¬å¿…é¡»é€‰æ‹©çº¢è‰²çš„è¾¹ã€‚
> 
> æ€»åˆ†æ˜¯ 5 + 6 = 11.
> 
> å¯ä»¥çœ‹å‡ºï¼Œæ²¡æœ‰æ›´å¥½çš„åˆ†æ•°å¯ä»¥è·å¾—ã€‚
> 
> 

**ç¤ºä¾‹ 2:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2300-2399/2378.Choose%20Edges%20to%20Maximize%20Score%20in%20a%20Tree/images/treee1293712983719827.png)

> 
> 
> 
> 
> 
> **è¾“å…¥:** edges = [[-1,-1],[0,5],[0,-6],[0,7]]
> 
> **è¾“å‡º:** 7
> 
> **è§£é‡Š:** æˆ‘ä»¬é€‰æ‹©æƒå€¼ä¸º 7 çš„è¾¹ã€‚
> 
> æ³¨æ„ï¼Œæˆ‘ä»¬ä¸èƒ½é€‰æ‹©ä¸€æ¡ä»¥ä¸Šçš„è¾¹ï¼Œå› ä¸ºæ‰€æœ‰çš„è¾¹éƒ½æ˜¯å½¼æ­¤ç›¸é‚»çš„ã€‚
> 
> 



**æç¤º:**

  * `n == edges.length`
  * `1 <= n <= 10^5`
  * `edges[i].length == 2`
  * `par0 == weight0 == -1`
  * `i >= 1` æ—¶ `0 <= pari <= n - 1` ã€‚
  * `pari != i`
  * `i >= 1` æ—¶ `-10^6 <= weighti <= 10^6` ã€‚
  * `edges` è¡¨ç¤ºæœ‰æ•ˆçš„æ ‘ã€‚


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ | åŠ›æ‰£ |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 968 | ç›‘æ§äºŒå‰æ ‘ |  |  [`æ ‘`](/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md) `1+` | ğŸ”´ | [ğŸ€„ï¸](https://leetcode.cn/problems/binary-tree-cameras) [ğŸ”—](https://leetcode.com/problems/binary-tree-cameras) |
| 2246 | ç›¸é‚»å­—ç¬¦ä¸åŒçš„æœ€é•¿è·¯å¾„ |  |  [`æ ‘`](/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`å›¾`](/tag/graph.md) `3+` | ğŸ”´ | [ğŸ€„ï¸](https://leetcode.cn/problems/longest-path-with-different-adjacent-characters) [ğŸ”—](https://leetcode.com/problems/longest-path-with-different-adjacent-characters) |