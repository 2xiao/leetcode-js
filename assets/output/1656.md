# [1656. è®¾è®¡æœ‰åºæµ](https://leetcode.com/problems/design-an-ordered-stream)

ğŸŸ¢ <font color=#15bd66>Easy</font>&emsp; ğŸ”–&ensp; [`è®¾è®¡`](/leetcode/outline/tag/design.md) [`æ•°ç»„`](/leetcode/outline/tag/array.md) [`å“ˆå¸Œè¡¨`](/leetcode/outline/tag/hash-table.md) [`æ•°æ®æµ`](/leetcode/outline/tag/data-stream.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/design-an-ordered-stream)


## é¢˜ç›®

There is a stream of `n` `(idKey, value)` pairs arriving in an **arbitrary**
order, where `idKey` is an integer between `1` and `n` and `value` is a
string. No two pairs have the same `id`.

Design a stream that returns the values in **increasing order of their IDs**
by returning a **chunk** (list) of values after each insertion. The
concatenation of all the **chunks** should result in a list of the sorted
values.

Implement the `OrderedStream` class:

  * `OrderedStream(int n)` Constructs the stream to take `n` values.
  * `String[] insert(int idKey, String value)` Inserts the pair `(idKey, value)` into the stream, then returns the **largest possible chunk** of currently inserted values that appear next in the order.



**Example:**

**![](https://assets.leetcode.com/uploads/2020/11/10/q1.gif)**

> 
> 
> 
> 
> 
> **Input**
> 
> ["OrderedStream", "insert", "insert", "insert", "insert", "insert"]
> 
> [[5], [3, "ccccc"], [1, "aaaaa"], [2, "bbbbb"], [5, "eeeee"], [4, "ddddd"]]
> 
> **Output**
> 
> [null, [], ["aaaaa"], ["bbbbb", "ccccc"], [], ["ddddd", "eeeee"]]
> 
> 
> 
> **Explanation**
> 
> // Note that the values ordered by ID is ["aaaaa", "bbbbb", "ccccc", "ddddd", "eeeee"].
> 
> OrderedStream os = new OrderedStream(5);
> 
> os.insert(3, "ccccc"); // Inserts (3, "ccccc"), returns [].
> 
> os.insert(1, "aaaaa"); // Inserts (1, "aaaaa"), returns ["aaaaa"].
> 
> os.insert(2, "bbbbb"); // Inserts (2, "bbbbb"), returns ["bbbbb", "ccccc"].
> 
> os.insert(5, "eeeee"); // Inserts (5, "eeeee"), returns [].
> 
> os.insert(4, "ddddd"); // Inserts (4, "ddddd"), returns ["ddddd", "eeeee"].
> 
> // Concatentating all the chunks returned:
> 
> // [] + ["aaaaa"] + ["bbbbb", "ccccc"] + [] + ["ddddd", "eeeee"] = ["aaaaa", "bbbbb", "ccccc", "ddddd", "eeeee"]
> 
> // The resulting order is the same as the order above.

**Constraints:**

  * `1 <= n <= 1000`
  * `1 <= id <= n`
  * `value.length == 5`
  * `value` consists only of lowercase letters.
  * Each call to `insert` will have a unique `id.`
  * Exactly `n` calls will be made to `insert`.


## é¢˜ç›®å¤§æ„

æœ‰ `n` ä¸ª `(id, value)` å¯¹ï¼Œå…¶ä¸­ `id` æ˜¯ `1` åˆ° `n` ä¹‹é—´çš„ä¸€ä¸ªæ•´æ•°ï¼Œ`value` æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚ä¸å­˜åœ¨ `id`
ç›¸åŒçš„ä¸¤ä¸ª `(id, value)` å¯¹ã€‚

è®¾è®¡ä¸€ä¸ªæµï¼Œä»¥ **ä»»æ„** é¡ºåºè·å– `n` ä¸ª `(id, value)` å¯¹ï¼Œå¹¶åœ¨å¤šæ¬¡è°ƒç”¨æ—¶ **æŒ‰`id` é€’å¢çš„é¡ºåº** è¿”å›ä¸€äº›å€¼ã€‚

å®ç° `OrderedStream` ç±»ï¼š

  * `OrderedStream(int n)` æ„é€ ä¸€ä¸ªèƒ½æ¥æ”¶ `n` ä¸ªå€¼çš„æµï¼Œå¹¶å°†å½“å‰æŒ‡é’ˆ `ptr` è®¾ä¸º `1` ã€‚
  * `String[] insert(int id, String value)` å‘æµä¸­å­˜å‚¨æ–°çš„ `(id, value)` å¯¹ã€‚å­˜å‚¨åï¼š 
> 
> * å¦‚æœæµå­˜å‚¨æœ‰ `id = ptr` çš„ `(id, value)` å¯¹ï¼Œåˆ™æ‰¾å‡ºä» `id = ptr` å¼€å§‹çš„ **æœ€é•¿ id è¿ç»­é€’å¢åºåˆ—** ï¼Œå¹¶ **æŒ‰é¡ºåº** è¿”å›ä¸è¿™äº› id å…³è”çš„å€¼çš„åˆ—è¡¨ã€‚ç„¶åï¼Œå°† `ptr` æ›´æ–°ä¸ºæœ€åé‚£ä¸ª `id + 1` ã€‚
> 
> * å¦åˆ™ï¼Œè¿”å›ä¸€ä¸ªç©ºåˆ—è¡¨ã€‚

**ç¤ºä¾‹ï¼š**

**![](https://assets.leetcode-cn.com/aliyun-lc-
upload/uploads/2020/11/15/q1.gif)**

> 
> 
> 
> 
> 
> **è¾“å…¥**
> 
> ["OrderedStream", "insert", "insert", "insert", "insert", "insert"]
> 
> [[5], [3, "ccccc"], [1, "aaaaa"], [2, "bbbbb"], [5, "eeeee"], [4, "ddddd"]]
> 
> **è¾“å‡º**
> 
> [null, [], ["aaaaa"], ["bbbbb", "ccccc"], [], ["ddddd", "eeeee"]]
> 
> 
> 
> **è§£é‡Š**
> 
> OrderedStream os= new OrderedStream(5);
> 
> os.insert(3, "ccccc"); // æ’å…¥ (3, "ccccc")ï¼Œè¿”å› []
> 
> os.insert(1, "aaaaa"); // æ’å…¥ (1, "aaaaa")ï¼Œè¿”å› ["aaaaa"]
> 
> os.insert(2, "bbbbb"); // æ’å…¥ (2, "bbbbb")ï¼Œè¿”å› ["bbbbb", "ccccc"]
> 
> os.insert(5, "eeeee"); // æ’å…¥ (5, "eeeee")ï¼Œè¿”å› []
> 
> os.insert(4, "ddddd"); // æ’å…¥ (4, "ddddd")ï¼Œè¿”å› ["ddddd", "eeeee"]
> 
> 

**æç¤ºï¼š**

  * `1 <= n <= 1000`
  * `1 <= id <= n`
  * `value.length == 5`
  * `value` ä»…ç”±å°å†™å­—æ¯ç»„æˆ
  * æ¯æ¬¡è°ƒç”¨ `insert` éƒ½ä¼šä½¿ç”¨ä¸€ä¸ªå”¯ä¸€çš„ `id`
  * æ°å¥½è°ƒç”¨ `n` æ¬¡ `insert`


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 2424 | [æœ€é•¿ä¸Šä¼ å‰ç¼€](https://leetcode.com/problems/longest-uploaded-prefix) |  |  [`å¹¶æŸ¥é›†`](/leetcode/outline/tag/union-find.md) [`è®¾è®¡`](/leetcode/outline/tag/design.md) [`æ ‘çŠ¶æ•°ç»„`](/leetcode/outline/tag/binary-indexed-tree.md) `4+` | <font color=#ffb800>Medium</font> |

<style>
.blue {
    background-color: #096dd9;
    padding: 0.25rem 0.5rem;
    margin: 0;
    font-size: 0.85em;
    border-radius: 3px;
    color: white;
    font-weight: 500;
}
table th:first-of-type { width: 10%; }
table th:nth-of-type(2) { width: 35%; }
table th:nth-of-type(3) { width: 10%; }
table th:nth-of-type(4) { width: 35%; }
table th:nth-of-type(5) { width: 10%; }
</style>
