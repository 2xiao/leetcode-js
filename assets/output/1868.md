---
title: 1868. ä¸¤ä¸ªè¡Œç¨‹ç¼–ç æ•°ç»„çš„ç§¯ ğŸ”’
description: LeetCode,1868. ä¸¤ä¸ªè¡Œç¨‹ç¼–ç æ•°ç»„çš„ç§¯ ğŸ”’,ä¸¤ä¸ªè¡Œç¨‹ç¼–ç æ•°ç»„çš„ç§¯,Product of Two Run-Length Encoded Arrays,è§£é¢˜æ€è·¯,æ•°ç»„,åŒæŒ‡é’ˆ
keywords:
  - LeetCode
  - 1868. ä¸¤ä¸ªè¡Œç¨‹ç¼–ç æ•°ç»„çš„ç§¯ ğŸ”’
  - ä¸¤ä¸ªè¡Œç¨‹ç¼–ç æ•°ç»„çš„ç§¯
  - Product of Two Run-Length Encoded Arrays
  - è§£é¢˜æ€è·¯
  - æ•°ç»„
  - åŒæŒ‡é’ˆ
---

# 1868. ä¸¤ä¸ªè¡Œç¨‹ç¼–ç æ•°ç»„çš„ç§¯ ğŸ”’

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ•°ç»„`](/tag/array.md) [`åŒæŒ‡é’ˆ`](/tag/two-pointers.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/product-of-two-run-length-encoded-arrays) [`LeetCode`](https://leetcode.com/problems/product-of-two-run-length-encoded-arrays)

## é¢˜ç›®

**Run-length encoding** is a compression algorithm that allows for an integer
array `nums` with many segments of **consecutive repeated** numbers to be
represented by a (generally smaller) 2D array `encoded`. Each `encoded[i] =
[vali, freqi]` describes the `ith` segment of repeated numbers in `nums` where
`vali` is the value that is repeated `freqi` times.

  * For example, `nums = [1,1,1,2,2,2,2,2]` is represented by the **run-length encoded** array `encoded = [[1,3],[2,5]]`. Another way to read this is "three `1`'s followed by five `2`'s".

The **product** of two run-length encoded arrays `encoded1` and `encoded2` can
be calculated using the following steps:

  1. **Expand** both `encoded1` and `encoded2` into the full arrays `nums1` and `nums2` respectively.
  2. Create a new array `prodNums` of length `nums1.length` and set `prodNums[i] = nums1[i] * nums2[i]`.
  3. **Compress** `prodNums` into a run-length encoded array and return it.

You are given two **run-length encoded** arrays `encoded1` and `encoded2`
representing full arrays `nums1` and `nums2` respectively. Both `nums1` and
`nums2` have the **same length**. Each `encoded1[i] = [vali, freqi]` describes
the `ith` segment of `nums1`, and each `encoded2[j] = [valj, freqj]` describes
the `jth` segment of `nums2`.

Return _the**product** of _`encoded1` _and_`encoded2`.

**Note:** Compression should be done such that the run-length encoded array
has the **minimum** possible length.



**Example 1:**

> Input: encoded1 = [[1,3],[2,3]], encoded2 = [[6,3],[3,3]]
> 
> Output: [[6,6]]
> 
> Explanation: encoded1 expands to [1,1,1,2,2,2] and encoded2 expands to [6,6,6,3,3,3].
> 
> prodNums = [6,6,6,6,6,6], which is compressed into the run-length encoded array [[6,6]].

**Example 2:**

> Input: encoded1 = [[1,3],[2,1],[3,2]], encoded2 = [[2,3],[3,3]]
> 
> Output: [[2,3],[6,1],[9,2]]
> 
> Explanation: encoded1 expands to [1,1,1,2,3,3] and encoded2 expands to [2,2,2,3,3,3].
> 
> prodNums = [2,2,2,6,9,9], which is compressed into the run-length encoded array [[2,3],[6,1],[9,2]].

**Constraints:**

  * `1 <= encoded1.length, encoded2.length <= 10^5`
  * `encoded1[i].length == 2`
  * `encoded2[j].length == 2`
  * `1 <= vali, freqi <= 10^4` for each `encoded1[i]`.
  * `1 <= valj, freqj <= 10^4` for each `encoded2[j]`.
  * The full arrays that `encoded1` and `encoded2` represent are the same length.


## é¢˜ç›®å¤§æ„

**è¡Œç¨‹ç¼–ç ï¼ˆ****Run-length encodingï¼‰** æ˜¯ä¸€ç§å‹ç¼©ç®—æ³•ï¼Œèƒ½è®©ä¸€ä¸ªå«æœ‰è®¸å¤šæ®µ**è¿ç»­é‡å¤** æ•°å­—çš„æ•´æ•°ç±»å‹æ•°ç»„ `nums`
ä»¥ä¸€ä¸ªï¼ˆé€šå¸¸æ›´å°çš„ï¼‰äºŒç»´æ•°ç»„ `encoded` è¡¨ç¤ºã€‚æ¯ä¸ª `encoded[i] = [vali, freqi]` è¡¨ç¤º `nums` ä¸­ç¬¬ `i`
æ®µé‡å¤æ•°å­—ï¼Œå…¶ä¸­ `vali` æ˜¯è¯¥æ®µé‡å¤æ•°å­—ï¼Œé‡å¤äº† `freqi` æ¬¡ã€‚

  * ä¾‹å¦‚ï¼Œ `nums = [1,1,1,2,2,2,2,2]` å¯è¡¨ç¤ºç§°è¡Œç¨‹ç¼–ç æ•°ç»„ `encoded = [[1,3],[2,5]]` ã€‚å¯¹æ­¤æ•°ç»„çš„å¦ä¸€ç§è¯»æ³•æ˜¯â€œä¸‰ä¸ª `1` ï¼Œåé¢æœ‰äº”ä¸ª `2` â€ã€‚

ä¸¤ä¸ªè¡Œç¨‹ç¼–ç æ•°ç»„ `encoded1` å’Œ `encoded2` çš„ç§¯å¯ä»¥æŒ‰ä¸‹åˆ—æ­¥éª¤è®¡ç®—ï¼š

  1. å°† `encoded1` å’Œ `encoded2` åˆ†åˆ«**æ‰©å±•** æˆå®Œæ•´æ•°ç»„ `nums1` å’Œ `nums2` ã€‚
  2. åˆ›å»ºä¸€ä¸ªæ–°çš„æ•°ç»„ `prodNums` ï¼Œé•¿åº¦ä¸º `nums1.length` å¹¶è®¾ `prodNums[i] = nums1[i] * nums2[i]` ã€‚
  3. å°† `prodNums` **å‹ç¼©** æˆä¸€ä¸ªè¡Œç¨‹ç¼–ç æ•°ç»„å¹¶è¿”å›ä¹‹ã€‚

ç»™å®šä¸¤ä¸ª**è¡Œç¨‹ç¼–ç ** æ•°ç»„ `encoded1` å’Œ `encoded2` ï¼Œåˆ†åˆ«è¡¨ç¤ºå®Œæ•´æ•°ç»„ `nums1` å’Œ `nums2` ã€‚`nums1` å’Œ
`nums2` çš„**é•¿åº¦ç›¸åŒ** ã€‚ æ¯ä¸€ä¸ª `encoded1[i] = [vali, freqi]` è¡¨ç¤º `nums1` ä¸­çš„ç¬¬ `i` æ®µï¼Œæ¯ä¸€ä¸ª
`encoded2[j] = [valj, freqj]` è¡¨ç¤º `nums2` ä¸­çš„ç¬¬ `j` æ®µã€‚

è¿”å› __`encoded1` å’Œ `encoded2` çš„**ä¹˜ç§¯** ã€‚

**æ³¨ï¼š** è¡Œç¨‹ç¼–ç æ•°ç»„éœ€å‹ç¼©æˆå¯èƒ½çš„**æœ€å°** é•¿åº¦ã€‚

**ç¤ºä¾‹ 1:**

> 
> 
> 
> 
> 
> **è¾“å…¥:** encoded1 = [[1,3],[2,3]], encoded2 = [[6,3],[3,3]]
> 
> **è¾“å‡º:** [[6,6]]
> 
> **è§£é‡Šn:** encoded1 æ‰©å±•ä¸º [1,1,1,2,2,2] ï¼Œencoded2 æ‰©å±•ä¸º [6,6,6,3,3,3]ã€‚
> 
> prodNums = [6,6,6,6,6,6]ï¼Œå‹ç¼©æˆè¡Œç¨‹ç¼–ç æ•°ç»„ [[6,6]]ã€‚
> 
> 

**ç¤ºä¾‹ 2:**

> 
> 
> 
> 
> 
> **è¾“å…¥:** encoded1 = [[1,3],[2,1],[3,2]], encoded2 = [[2,3],[3,3]]
> 
> **è¾“å‡º:** [[2,3],[6,1],[9,2]]
> 
> **è§£é‡Š:** encoded1 æ‰©å±•ä¸º [1,1,1,2,3,3] ï¼Œencoded2 æ‰©å±•ä¸º [2,2,2,3,3,3]ã€‚
> 
> prodNums = [2,2,2,6,9,9]ï¼Œå‹ç¼©æˆè¡Œç¨‹ç¼–ç æ•°ç»„ [[2,3],[6,1],[9,2]]ã€‚
> 
> 

**æç¤ºï¼š**

  * `1 <= encoded1.length, encoded2.length <= 10^5`
  * `encoded1[i].length == 2`
  * `encoded2[j].length == 2`
  * å¯¹äºæ¯ä¸€ä¸ª `encoded1[i]`ï¼Œ `1 <= vali, freqi <= 10^4`
  * å¯¹äºæ¯ä¸€ä¸ª `encoded2[j]`ï¼Œ `1 <= valj, freqj <= 10^4`
  * `encoded1` å’Œ `encoded2` è¡¨ç¤ºçš„å®Œæ•´æ•°ç»„é•¿åº¦ç›¸åŒã€‚


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```