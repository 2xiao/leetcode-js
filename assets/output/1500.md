# [1500. è®¾è®¡æ–‡ä»¶åˆ†äº«ç³»ç»Ÿ ğŸ”’](https://2xiao.github.io/leetcode-js/problem/1500.html)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`è®¾è®¡`](/tag/design.md) [`å“ˆå¸Œè¡¨`](/tag/hash-table.md) [`æ•°æ®æµ`](/tag/data-stream.md) [`æ’åº`](/tag/sorting.md) [`å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰`](/tag/heap-priority-queue.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/design-a-file-sharing-system) [`LeetCode`](https://leetcode.com/problems/design-a-file-sharing-system)

## é¢˜ç›®

We will use a file-sharing system to share a very large file which consists of
`m` small **chunks** with IDs from `1` to `m`.

When users join the system, the system should assign **a unique** ID to them.
The unique ID should be used **once** for each user, but when a user leaves
the system, the ID can be **reused** again.

Users can request a certain chunk of the file, the system should return a list
of IDs of all the users who own this chunk. If the user receives a non-empty
list of IDs, they receive the requested chunk successfully.

  
Implement the `FileSharing` class:

  * `FileSharing(int m)` Initializes the object with a file of `m` chunks.
  * `int join(int[] ownedChunks)`: A new user joined the system owning some chunks of the file, the system should assign an id to the user which is the **smallest positive integer** not taken by any other user. Return the assigned id.
  * `void leave(int userID)`: The user with `userID` will leave the system, you cannot take file chunks from them anymore.
  * `int[] request(int userID, int chunkID)`: The user `userID` requested the file chunk with `chunkID`. Return a list of the IDs of all users that own this chunk sorted in ascending order.



**Example:**

> Input:
> 
> ["FileSharing","join","join","join","request","request","leave","request","leave","join"]
> 
> [[4],[[1,2]],[[2,3]],[[4]],[1,3],[2,2],[1],[2,1],[2],[[]]]
> 
> Output:
> 
> [null,1,2,3,[2],[1,2],null,[],null,1]
> 
> Explanation:
> 
> FileSharing fileSharing = new FileSharing(4); // We use the system to share a file of 4 chunks.
> 
> 
> 
> fileSharing.join([1, 2]);> 
> // A user who has chunks [1,2] joined the system, assign id = 1 to them and return 1.
> 
> 
> 
> fileSharing.join([2, 3]);> 
> // A user who has chunks [2,3] joined the system, assign id = 2 to them and return 2.
> 
> 
> 
> fileSharing.join([4]);> 
>    // A user who has chunk [4] joined the system, assign id = 3 to them and return 3.
> 
> 
> 
> fileSharing.request(1, 3);   // The user with id = 1 requested the third file chunk, as only the user with id = 2 has the file, return [2] . Notice that user 1 now has chunks [1,2,3].
> 
> 
> 
> fileSharing.request(2, 2);   // The user with id = 2 requested the second file chunk, users with ids [1,2] have this chunk, thus we return [1,2].
> 
> 
> 
> fileSharing.leave(1);> 
> > 
> // The user with id = 1 left the system, all the file chunks with them are no longer available for other users.
> 
> 
> 
> fileSharing.request(2, 1);   // The user with id = 2 requested the first file chunk, no one in the system has this chunk, we return empty list [].
> 
> 
> 
> fileSharing.leave(2);> 
> > 
> // The user with id = 2 left the system.
> 
> 
> 
> fileSharing.join([]);> 
> > 
> // A user who doesn't have any chunks joined the system, assign id = 1 to them and return 1. Notice that ids 1 and 2 are free and we can reuse them.

**Constraints:**

  * `1 <= m <= 10^5`
  * `0 <= ownedChunks.length <= min(100, m)`
  * `1 <= ownedChunks[i] <= m`
  * Values of `ownedChunks` are unique.
  * `1 <= chunkID <= m`
  * `userID` is guaranteed to be a user in the system if you **assign** the IDs **correctly**.
  * At most `10^4` calls will be made to `join`, `leave` and `request`.
  * Each call to `leave` will have a matching call for `join`.



**Follow-up:**

  * What happens if the system identifies the user by their IP address instead of their unique ID and users disconnect and connect from the system with the same IP?
  * If the users in the system join and leave the system frequently without requesting any chunks, will your solution still be efficient?
  * If all users join the system one time, request all files, and then leave, will your solution still be efficient?
  * If the system will be used to share `n` files where the `ith` file consists of `m[i]`, what are the changes you have to make?


## é¢˜ç›®å¤§æ„

æˆ‘ä»¬éœ€è¦ä½¿ç”¨ä¸€å¥—æ–‡ä»¶åˆ†äº«ç³»ç»Ÿæ¥åˆ†äº«ä¸€ä¸ªéå¸¸å¤§çš„æ–‡ä»¶ï¼Œè¯¥æ–‡ä»¶ç”± `m` ä¸ªä» `1` åˆ° `m` ç¼–å·çš„ **æ–‡ä»¶å—** ç»„æˆã€‚

å½“ç”¨æˆ·åŠ å…¥ç³»ç»Ÿæ—¶ï¼Œç³»ç»Ÿåº”ä¸ºå…¶æ³¨å†Œ **ä¸€ä¸ªç‹¬æœ‰  **çš„ IDã€‚è¿™ä¸ªç‹¬æœ‰çš„ ID åº”å½“è¢«ç›¸åº”çš„ç”¨æˆ·ä½¿ç”¨ **ä¸€æ¬¡** ï¼Œä½†æ˜¯å½“ç”¨æˆ·ç¦»å¼€ç³»ç»Ÿæ—¶ï¼Œå…¶ ID
åº”å¯ä»¥è¢«ï¼ˆåç»­æ–°æ³¨å†Œçš„ç”¨æˆ·ï¼‰**å†æ¬¡ä½¿ç”¨** ã€‚

ç”¨æˆ·å¯ä»¥è¯·æ±‚æ–‡ä»¶ä¸­çš„æŸä¸ªæŒ‡å®šçš„æ–‡ä»¶å—ï¼Œç³»ç»Ÿåº”å½“è¿”å›æ‹¥æœ‰è¿™ä¸ªæ–‡ä»¶å—çš„æ‰€æœ‰ç”¨æˆ·çš„ IDã€‚å¦‚æœç”¨æˆ·æ”¶åˆ° ID çš„éç©ºåˆ—è¡¨ï¼Œå°±è¡¨ç¤ºæˆåŠŸæ¥æ”¶åˆ°è¯·æ±‚çš„æ–‡ä»¶å—ã€‚

  
å®ç° `FileSharing` ç±»ï¼š

  * `FileSharing(int m)` åˆå§‹åŒ–è¯¥å¯¹è±¡ï¼Œæ–‡ä»¶æœ‰ `m` ä¸ªæ–‡ä»¶å—ã€‚
  * `int join(int[] ownedChunks)`ï¼šä¸€ä¸ªæ–°ç”¨æˆ·åŠ å…¥ç³»ç»Ÿï¼Œå¹¶æ‹¥æœ‰æ–‡ä»¶çš„ä¸€äº›æ–‡ä»¶å—ã€‚ç³»ç»Ÿåº”å½“ä¸ºè¯¥ç”¨æˆ·æ³¨å†Œä¸€ä¸ª IDï¼Œè¯¥ ID åº”æ˜¯æœªè¢«å…¶ä»–ç”¨æˆ·å ç”¨çš„**æœ€å°æ­£æ•´æ•°** ã€‚è¿”å›æ³¨å†Œçš„ IDã€‚
  * `void leave(int userID)`ï¼šID ä¸º `userID` çš„ç”¨æˆ·å°†ç¦»å¼€ç³»ç»Ÿï¼Œä½ ä¸èƒ½å†ä»è¯¥ç”¨æˆ·æå–æ–‡ä»¶å—äº†ã€‚
  * `int[] request(int userID, int chunkID)`ï¼šID ä¸º `userID` çš„ç”¨æˆ·è¯·æ±‚ç¼–å·ä¸º `chunkID` çš„æ–‡ä»¶å—ã€‚è¿”å›æ‹¥æœ‰è¿™ä¸ªæ–‡ä»¶å—çš„æ‰€æœ‰ç”¨æˆ·çš„ ID æ‰€æ„æˆçš„åˆ—è¡¨æˆ–æ•°ç»„ï¼ŒæŒ‰å‡åºæ’åˆ—ã€‚



**ç¤ºä¾‹:**

> 
> 
> 
> 
> 
> **è¾“å…¥:**
> 
> ["FileSharing","join","join","join","request","request","leave","request","leave","join"]
> 
> [[4],[[1,2]],[[2,3]],[[4]],[1,3],[2,2],[1],[2,1],[2],[[]]]
> 
> **è¾“å‡º:**
> 
> [null,1,2,3,[2],[1,2],null,[],null,1]
> 
> **è§£é‡Š:**
> 
> FileSharing fileSharing = new FileSharing(4); // æˆ‘ä»¬ç”¨è¯¥ç³»ç»Ÿåˆ†äº«ç”± 4 ä¸ªæ–‡ä»¶å—ç»„æˆçš„æ–‡ä»¶ã€‚
> 
> 
> 
> fileSharing.join([1, 2]);> 
> // ä¸€ä¸ªæ‹¥æœ‰æ–‡ä»¶å— [1,2] çš„ç”¨æˆ·åŠ å…¥ç³»ç»Ÿï¼Œä¸ºå…¶æ³¨å†Œ id = 1 å¹¶è¿”å› 1ã€‚
> 
> 
> 
> fileSharing.join([2, 3]);> 
> // ä¸€ä¸ªæ‹¥æœ‰æ–‡ä»¶å— [2,3] çš„ç”¨æˆ·åŠ å…¥ç³»ç»Ÿï¼Œä¸ºå…¶æ³¨å†Œ id = 2 å¹¶è¿”å› 2ã€‚
> 
> 
> 
> fileSharing.join([4]);> 
>    // ä¸€ä¸ªæ‹¥æœ‰æ–‡ä»¶å— [4] çš„ç”¨æˆ·åŠ å…¥ç³»ç»Ÿï¼Œä¸ºå…¶æ³¨å†Œ id = 3 å¹¶è¿”å› 3ã€‚
> 
> 
> 
> fileSharing.request(1, 3);   // id = 1 çš„ç”¨æˆ·è¯·æ±‚ç¬¬ 3 ä¸ªæ–‡ä»¶å—ï¼Œåªæœ‰ id = 2 çš„ç”¨æˆ·æ‹¥æœ‰æ–‡ä»¶å—ï¼Œè¿”å› [2] ã€‚æ³¨æ„ï¼Œç°åœ¨ç”¨æˆ· 1 ç°æ‹¥æœ‰æ–‡ä»¶å— [1,2,3]ã€‚
> 
> 
> 
> fileSharing.request(2, 2);   // id = 2 çš„ç”¨æˆ·è¯·æ±‚ç¬¬ 2 ä¸ªæ–‡ä»¶å—ï¼Œid ä¸º [1,2] çš„ç”¨æˆ·æ‹¥æœ‰è¯¥æ–‡ä»¶å—ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿”å› [1,2] ã€‚
> 
> 
> 
> fileSharing.leave(1);> 
> > 
> // id = 1 çš„ç”¨æˆ·ç¦»å¼€ç³»ç»Ÿï¼Œå…¶æ‰€æ‹¥æœ‰çš„æ‰€æœ‰æ–‡ä»¶å—ä¸å†å¯¹å…¶ä»–ç”¨æˆ·å¯ç”¨ã€‚
> 
> 
> 
> fileSharing.request(2, 1);   // id = 2 çš„ç”¨æˆ·è¯·æ±‚ç¬¬ 1 ä¸ªæ–‡ä»¶å—ï¼Œç³»ç»Ÿä¸­æ²¡æœ‰ç”¨æˆ·æ‹¥æœ‰è¯¥æ–‡ä»¶å—ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿”å›ç©ºåˆ—è¡¨ [] ã€‚
> 
> 
> 
> fileSharing.leave(2);> 
> > 
> // id = 2 çš„ç”¨æˆ·ç¦»å¼€ç³»ç»Ÿã€‚
> 
> 
> 
> fileSharing.join([]);> 
> > 
> // ä¸€ä¸ªä¸æ‹¥æœ‰ä»»ä½•æ–‡ä»¶å—çš„ç”¨æˆ·åŠ å…¥ç³»ç»Ÿï¼Œä¸ºå…¶æ³¨å†Œ id = 1 å¹¶è¿”å› 1 ã€‚æ³¨æ„ï¼Œid 1 å’Œ 2 ç©ºé—²ï¼Œå¯ä»¥é‡æ–°ä½¿ç”¨ã€‚
> 
> 



**æç¤º:**

  * `1 <= m <= 10^5`
  * `0 <= ownedChunks.length <= min(100, m)`
  * `1 <= ownedChunks[i] <= m`
  * `ownedChunks` çš„å€¼æ˜¯äº’ä¸ç›¸åŒçš„ã€‚
  * `1 <= chunkID <= m`
  * å½“ä½ **æ­£ç¡®åœ°æ³¨å†Œ** ç”¨æˆ· ID æ—¶ï¼Œé¢˜ç›®ä¿è¯ `userID` æ˜¯ç³»ç»Ÿä¸­çš„ä¸€ä¸ªå·²æ³¨å†Œç”¨æˆ·ã€‚
  * `join`ã€ `leave` å’Œ `request` æœ€å¤šè¢«è°ƒç”¨ `10^4` æ¬¡ã€‚
  * æ¯æ¬¡å¯¹ `leave` çš„è°ƒç”¨éƒ½æœ‰å¯¹åº”çš„å¯¹ `join` çš„è°ƒç”¨ã€‚



**è¿›é˜¶ï¼š**

  * å½“ç³»ç»Ÿä»¥ç”¨æˆ·çš„ IP åœ°å€è€Œä¸æ˜¯ç‹¬æœ‰ ID æ¥è¯†åˆ«ç”¨æˆ·ï¼Œä¸”ç”¨æˆ·æ–­å¼€è¿æ¥åä»¥ç›¸åŒ IP é‡æ–°è¿æ¥ç³»ç»Ÿæ—¶ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
  * å½“ç”¨æˆ·é¢‘ç¹åŠ å…¥å¹¶é€€å‡ºç³»ç»Ÿï¼Œä¸”è¯¥ç”¨æˆ·ä¸è¯·æ±‚ä»»ä½•æ–‡ä»¶å—æ—¶ï¼Œä½ çš„è§£å†³æ–¹æ¡ˆä»ç„¶ä¿æŒé«˜æ•ˆå—ï¼Ÿ
  * å½“æ‰€æœ‰ç”¨æˆ·åŒæ—¶åŠ å…¥ç³»ç»Ÿï¼Œè¯·æ±‚æ‰€æœ‰æ–‡ä»¶å¹¶ç¦»å¼€æ—¶ï¼Œä½ çš„è§£å†³æ–¹æ¡ˆä»ç„¶ä¿æŒé«˜æ•ˆå—ï¼Ÿ
  * å¦‚æœç³»ç»Ÿç”¨äºåˆ†äº« `n` ä¸ªæ–‡ä»¶ï¼Œå…¶ä¸­ç¬¬  `i` ä¸ªæ–‡ä»¶ç”± `m[i]` ç»„æˆï¼Œä½ éœ€è¦å¦‚ä½•ä¿®æ”¹ï¼Ÿ


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 355 | [è®¾è®¡æ¨ç‰¹](https://leetcode.com/problems/design-twitter) | [[âœ“]](/problem/0355.md) |  [`è®¾è®¡`](/tag/design.md) [`å“ˆå¸Œè¡¨`](/tag/hash-table.md) [`é“¾è¡¨`](/tag/linked-list.md) `1+` | <font color=#ffb800>Medium</font> |