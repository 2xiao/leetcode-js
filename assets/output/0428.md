---
title: 428. 序列化和反序列化 N 叉树 🔒
description: LeetCode 428. 序列化和反序列化 N 叉树 🔒题解，Serialize and Deserialize N-ary Tree，包含解题思路、复杂度分析以及完整的 JavaScript 代码实现。
keywords:
  - LeetCode
  - 428. 序列化和反序列化 N 叉树 🔒
  - 序列化和反序列化 N 叉树
  - Serialize and Deserialize N-ary Tree
  - 解题思路
  - 树
  - 深度优先搜索
  - 广度优先搜索
  - 字符串
---

# 428. 序列化和反序列化 N 叉树 🔒

🔴 <font color=#ff334b>Hard</font>&emsp; 🔖&ensp; [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) [`字符串`](/tag/string.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/serialize-and-deserialize-n-ary-tree) [`LeetCode`](https://leetcode.com/problems/serialize-and-deserialize-n-ary-tree)

## 题目

Serialization is the process of converting a data structure or object into a
sequence of bits so that it can be stored in a file or memory buffer, or
transmitted across a network connection link to be reconstructed later in the
same or another computer environment.

Design an algorithm to serialize and deserialize an N-ary tree. An N-ary tree
is a rooted tree in which each node has no more than N children. There is no
restriction on how your serialization/deserialization algorithm should work.
You just need to ensure that an N-ary tree can be serialized to a string and
this string can be deserialized to the original tree structure.

For example, you may serialize the following `3-ary` tree

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0400-0499/0428.Serialize%20and%20Deserialize%20N-ary%20Tree/images/narytreeexample.png)



as `[1 [3[5 6] 2 4]]`. Note that this is just an example, you do not
necessarily need to follow this format.

Or you can follow LeetCode's level order traversal serialization format, where
each group of children is separated by the null value.

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0400-0499/0428.Serialize%20and%20Deserialize%20N-ary%20Tree/images/sample_4_964.png)



For example, the above tree may be serialized as
`[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]`.

You do not necessarily need to follow the above-suggested formats, there are
many more different formats that work so please be creative and come up with
different approaches yourself.



**Example 1:**

> Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
> 
> Output: [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]

**Example 2:**

> Input: root = [1,null,3,2,4,null,5,6]
> 
> Output: [1,null,3,2,4,null,5,6]

**Example 3:**

> Input: root = []
> 
> Output: []

**Constraints:**

  * The number of nodes in the tree is in the range `[0, 104]`.
  * `0 <= Node.val <= 10^4`
  * The height of the n-ary tree is less than or equal to `1000`
  * Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.


## 题目大意

序列化是指将一个数据结构转化为位序列的过程，因此可以将其存储在文件中或内存缓冲区中，以便稍后在相同或不同的计算机环境中恢复结构。

设计一个序列化和反序列化 N 叉树的算法。一个 N 叉树是指每个节点都有不超过 N 个孩子节点的有根树。序列化 /
反序列化算法的算法实现没有限制。你只需要保证 N 叉树可以被序列化为一个字符串并且该字符串可以被反序列化成原树结构即可。

例如，你需要序列化下面的 `3-叉` 树。



![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0400-0499/0428.Serialize%20and%20Deserialize%20N-ary%20Tree/images/1727093143-BPVnoI-
image.png)



为 `[1 [3[5 6] 2 4]]`。你不需要以这种形式完成，你可以自己创造和实现不同的方法。

或者，您可以遵循 LeetCode 的层序遍历序列化格式，其中每组孩子节点由空值分隔。

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/0400-0499/0428.Serialize%20and%20Deserialize%20N-ary%20Tree/images/1727093169-WGFOps-
image.png)

例如，上面的树可以序列化为
`[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]`

你不一定要遵循以上建议的格式，有很多不同的格式，所以请发挥创造力，想出不同的方法来完成本题。



**示例 1:**

> 
> 
> 
> 
> 
> **输入:** root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
> 
> **输出:** [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
> 
> 

**示例 2:**

> 
> 
> 
> 
> 
> **输入:** root = [1,null,3,2,4,null,5,6]
> 
> **输出:** [1,null,3,2,4,null,5,6]
> 
> 

**示例 3:**

> 
> 
> 
> 
> 
> **输入:** root = []
> 
> **输出:** []
> 
> 



**提示：**

  * 树中节点数目的范围是 `[0, 104]`.
  * `0 <= Node.val <= 10^4`
  * N 叉树的高度小于等于 `1000`
  * 不要使用类成员 / 全局变量 / 静态变量来存储状态。你的序列化和反序列化算法应是无状态的。


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 297 | 二叉树的序列化与反序列化 | [[✓]](/problem/0297.md) |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) `3+` | 🔴 | [🀄️](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree) [🔗](https://leetcode.com/problems/serialize-and-deserialize-binary-tree) |
| 431 | 将 N 叉树编码为二叉树 🔒 |  |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) `2+` | 🔴 | [🀄️](https://leetcode.cn/problems/encode-n-ary-tree-to-binary-tree) [🔗](https://leetcode.com/problems/encode-n-ary-tree-to-binary-tree) |
| 449 | 序列化和反序列化二叉搜索树 | [[✓]](/problem/0449.md) |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) `4+` | 🟠 | [🀄️](https://leetcode.cn/problems/serialize-and-deserialize-bst) [🔗](https://leetcode.com/problems/serialize-and-deserialize-bst) |