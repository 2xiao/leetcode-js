# [2936. åŒ…å«ç›¸ç­‰å€¼æ•°å­—å—çš„æ•°é‡](https://leetcode.com/problems/number-of-equal-numbers-blocks)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ•°ç»„`](/tag/array.md) [`äºŒåˆ†æŸ¥æ‰¾`](/tag/binary-search.md) [`äº¤äº’`](/tag/interactive.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/number-of-equal-numbers-blocks)

## é¢˜ç›®

You are given a **0-indexed** array of integers, `nums`. The following
property holds for `nums`:

  * All occurrences of a value are adjacent. In other words, if there are two indices `i < j` such that `nums[i] == nums[j]`, then for every index `k` that `i < k < j`, `nums[k] == nums[i]`.

Since `nums` is a very large array, you are given an instance of the class
`BigArray` which has the following functions:

  * `int at(long long index)`: Returns the value of `nums[i]`.
  * `void size()`: Returns `nums.length`.

Let's partition the array into **maximal** blocks such that each block
contains **equal values**. Return _the number of these blocks._

**Note** that if you want to test your solution using a custom test, behavior
for tests with `nums.length > 10` is undefined.



**Example 1:**

> Input: nums = [3,3,3,3,3]
> 
> Output: 1
> 
> Explanation: There is only one block here which is the whole array (because all numbers are equal) and that is: [_3,3,3,3,3_]. So the answer would be 1. 

**Example 2:**

> Input: nums = [1,1,1,3,9,9,9,2,10,10]
> 
> Output: 5
> 
> Explanation: There are 5 blocks here:
> 
> Block number 1: [_1,1,1_ ,3,9,9,9,2,10,10]
> 
> Block number 2: [1,1,1,_3_ ,9,9,9,2,10,10]
> 
> Block number 3: [1,1,1,3,_9,9,9_ ,2,10,10]
> 
> Block number 4: [1,1,1,3,9,9,9,_2_ ,10,10]
> 
> Block number 5: [1,1,1,3,9,9,9,2,_10,10_]
> 
> So the answer would be 5.

**Example 3:**

> Input: nums = [1,2,3,4,5,6,7]
> 
> Output: 7
> 
> Explanation: Since all numbers are distinct, there are 7 blocks here and each element representing one block. So the answer would be 7. 

**Constraints:**

  * `1 <= nums.length <= 1015`
  * `1 <= nums[i] <= 10^9`
  * The input is generated such that all equal values are adjacent.
  * The sum of the elements of `nums` is at most `1015`.


## é¢˜ç›®å¤§æ„

ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums`ï¼Œå…¶ **ä¸‹æ ‡ä» 0 å¼€å§‹** ã€‚å¯¹äº `nums`ï¼Œæœ‰ä»¥ä¸‹æ€§è´¨ï¼š

  * æ‰€æœ‰ç›¸åŒå€¼çš„å…ƒç´ éƒ½æ˜¯ç›¸é‚»çš„ã€‚æ¢å¥è¯è¯´ï¼Œå¦‚æœå­˜åœ¨ä¸¤ä¸ªä¸‹æ ‡ `i < j`ï¼Œä½¿å¾— `nums[i] == nums[j]`ï¼Œé‚£ä¹ˆå¯¹äºæ‰€æœ‰ä¸‹æ ‡ `k`ï¼Œæ»¡è¶³ `i < k < j`ï¼Œéƒ½æœ‰ `nums[k] == nums[i]`ã€‚

ç”±äº `nums` æ˜¯ä¸€ä¸ªéå¸¸å¤§çš„æ•°ç»„ï¼Œè¿™é‡Œæä¾›äº†ä¸€ä¸ª `BigArray` ç±»çš„å®ä¾‹ï¼Œè¯¥å®ä¾‹å…·æœ‰ä»¥ä¸‹å‡½æ•°ï¼š

  * `int at(long long index)`: è¿”å› `nums[i]` çš„å€¼ã€‚
  * `long long size()`: è¿”å› `nums.length`ã€‚

è®©æˆ‘ä»¬æŠŠæ•°ç»„åˆ†æˆ **æœ€å¤§**  çš„å—ï¼Œä½¿å¾—æ¯ä¸ªå—åŒ…å« **ç›¸ç­‰çš„å€¼** ã€‚è¿”å›è¿™äº›å—çš„æ•°é‡ã€‚

**è¯·æ³¨æ„** ï¼Œå¦‚æœè¦ä½¿ç”¨è‡ªå®šä¹‰æµ‹è¯•æµ‹è¯•è§£å†³æ–¹æ¡ˆï¼Œå¯¹äº `nums.length > 10` çš„æµ‹è¯•è¡Œä¸ºæ˜¯æœªå®šä¹‰çš„ã€‚



**ç¤ºä¾‹ 1ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** nums = [3,3,3,3,3]
> 
> **è¾“å‡ºï¼š** 1
> 
> **è§£é‡Šï¼š** è¿™é‡Œåªæœ‰ä¸€ä¸ªå—ï¼Œä¹Ÿå°±æ˜¯æ•´ä¸ªæ•°ç»„ï¼ˆå› ä¸ºæ‰€æœ‰æ•°å­—éƒ½ç›¸ç­‰ï¼‰ï¼Œå³ï¼š[3,3,3,3,3]ã€‚å› æ­¤ç­”æ¡ˆæ˜¯ 1ã€‚ 
> 
> 

**ç¤ºä¾‹ 2ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** nums = [1,1,1,3,9,9,9,2,10,10]
> 
> **è¾“å‡ºï¼š** 5
> 
> **è§£é‡Šï¼š** è¿™é‡Œæœ‰ 5 ä¸ªå—ï¼š
> 
> å—å· 1: [_1,1,1_ ,3,9,9,9,2,10,10]
> 
> å—å· 2: [1,1,1,_3_ ,9,9,9,2,10,10]
> 
> å—å· 3: [1,1,1,3,_9,9,9_ ,2,10,10]
> 
> å—å· 4: [1,1,1,3,9,9,9,_2_ ,10,10]
> 
> å—å· 5: [1,1,1,3,9,9,9,2,_10,10_]
> 
> å› æ­¤ç­”æ¡ˆæ˜¯ 5ã€‚

**ç¤ºä¾‹ 3ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** nums = [1,2,3,4,5,6,7]
> 
> **è¾“å‡ºï¼š** 7
> 
> **è§£é‡Šï¼š** ç”±äºæ‰€æœ‰æ•°å­—éƒ½æ˜¯ä¸åŒçš„ï¼Œè¿™é‡Œæœ‰ 7 ä¸ªå—ï¼Œæ¯ä¸ªå…ƒç´ ä»£è¡¨ä¸€ä¸ªå—ã€‚å› æ­¤ç­”æ¡ˆæ˜¯ 7ã€‚ 
> 
> 



**æç¤ºï¼š**

  * `1 <= nums.length <= 1015`
  * `1 <= nums[i] <= 10^9`
  * åœ¨ç”Ÿæˆçš„è¾“å…¥ä¸­æ‰€æœ‰ç›¸åŒå€¼çš„å…ƒç´ æ˜¯ç›¸é‚»çš„ã€‚
  * `nums` çš„æ‰€æœ‰å…ƒç´ ä¹‹å’Œæœ€å¤šä¸º `1015`ã€‚


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```