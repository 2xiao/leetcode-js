# [2227. åŠ å¯†è§£å¯†å­—ç¬¦ä¸²](https://leetcode.com/problems/encrypt-and-decrypt-strings)

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`è®¾è®¡`](/leetcode/outline/tag/design.md) [`å­—å…¸æ ‘`](/leetcode/outline/tag/trie.md) [`æ•°ç»„`](/leetcode/outline/tag/array.md) [`å“ˆå¸Œè¡¨`](/leetcode/outline/tag/hash-table.md) [`å­—ç¬¦ä¸²`](/leetcode/outline/tag/string.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/encrypt-and-decrypt-strings)

## é¢˜ç›®

You are given a character array `keys` containing **unique** characters and a
string array `values` containing strings of length 2. You are also given
another string array `dictionary` that contains all permitted original strings
after decryption. You should implement a data structure that can encrypt or
decrypt a **0-indexed** string.

A string is **encrypted** with the following process:

  1. For each character `c` in the string, we find the index `i` satisfying `keys[i] == c` in `keys`.
  2. Replace `c` with `values[i]` in the string.

Note that in case a character of the string is **not present** in `keys`, the
encryption process cannot be carried out, and an empty string `""` is
returned.

A string is **decrypted** with the following process:

  1. For each substring `s` of length 2 occurring at an even index in the string, we find an `i` such that `values[i] == s`. If there are multiple valid `i`, we choose **any** one of them. This means a string could have multiple possible strings it can decrypt to.
  2. Replace `s` with `keys[i]` in the string.

Implement the `Encrypter` class:

  * `Encrypter(char[] keys, String[] values, String[] dictionary)` Initializes the `Encrypter` class with `keys, values`, and `dictionary`.
  * `String encrypt(String word1)` Encrypts `word1` with the encryption process described above and returns the encrypted string.
  * `int decrypt(String word2)` Returns the number of possible strings `word2` could decrypt to that also appear in `dictionary`.



**Example 1:**

> 
> 
> 
> 
> 
> **Input**
> 
> ["Encrypter", "encrypt", "decrypt"]
> 
> [[['a', 'b', 'c', 'd'], ["ei", "zf", "ei", "am"], ["abcd", "acbd", "adbc", "badc", "dacb", "cadb", "cbda", "abad"]], ["abcd"], ["eizfeiam"]]
> 
> **Output**
> 
> [null, "eizfeiam", 2]
> 
> 
> 
> **Explanation**
> 
> Encrypter encrypter = new Encrypter([['a', 'b', 'c', 'd'], ["ei", "zf", "ei", "am"], ["abcd", "acbd", "adbc", "badc", "dacb", "cadb", "cbda", "abad"]);
> 
> encrypter.encrypt("abcd"); // return "eizfeiam". 
> 
> > 
> > 
> > 
> > 
> > 
> > 
>    // 'a' maps to "ei", 'b' maps to "zf", 'c' maps to "ei", and 'd' maps to "am".
> 
> encrypter.decrypt("eizfeiam"); // return 2. 
> 
> > 
> > 
> > 
> > 
> > 
> > 
> > 
>   // "ei" can map to 'a' or 'c', "zf" maps to 'b', and "am" maps to 'd'. 
> 
> > 
> > 
> > 
> > 
> > 
> > 
> > 
>   // Thus, the possible strings after decryption are "abad", "cbad", "abcd", and "cbcd". 
> 
> > 
> > 
> > 
> > 
> > 
> > 
> > 
>   // 2 of those strings, "abad" and "abcd", appear in dictionary, so the answer is 2.

**Constraints:**

  * `1 <= keys.length == values.length <= 26`
  * `values[i].length == 2`
  * `1 <= dictionary.length <= 100`
  * `1 <= dictionary[i].length <= 100`
  * All `keys[i]` and `dictionary[i]` are **unique**.
  * `1 <= word1.length <= 2000`
  * `1 <= word2.length <= 200`
  * All `word1[i]` appear in `keys`.
  * `word2.length` is even.
  * `keys`, `values[i]`, `dictionary[i]`, `word1`, and `word2` only contain lowercase English letters.
  * At most `200` calls will be made to `encrypt` and `decrypt` **in total**.


## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ªå­—ç¬¦æ•°ç»„ `keys` ï¼Œç”±è‹¥å¹² **äº’ä¸ç›¸åŒ** çš„å­—ç¬¦ç»„æˆã€‚è¿˜æœ‰ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ `values` ï¼Œå†…å«è‹¥å¹²é•¿åº¦ä¸º 2
çš„å­—ç¬¦ä¸²ã€‚å¦ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ `dictionary` ï¼ŒåŒ…å«è§£å¯†åæ‰€æœ‰å…è®¸çš„åŸå­—ç¬¦ä¸²ã€‚è¯·ä½ è®¾è®¡å¹¶å®ç°ä¸€ä¸ªæ”¯æŒåŠ å¯†åŠè§£å¯†ä¸‹æ ‡ä» **0**
å¼€å§‹å­—ç¬¦ä¸²çš„æ•°æ®ç»“æ„ã€‚

å­—ç¬¦ä¸² **åŠ å¯†** æŒ‰ä¸‹è¿°æ­¥éª¤è¿›è¡Œï¼š

  1. å¯¹å­—ç¬¦ä¸²ä¸­çš„æ¯ä¸ªå­—ç¬¦ `c` ï¼Œå…ˆä» `keys` ä¸­æ‰¾å‡ºæ»¡è¶³ `keys[i] == c` çš„ä¸‹æ ‡ `i` ã€‚
  2. åœ¨å­—ç¬¦ä¸²ä¸­ï¼Œç”¨ `values[i]` æ›¿æ¢å­—ç¬¦ `c` ã€‚

è¯·æ³¨æ„ï¼Œå¦‚æœ `keys` ä¸­ä¸å­˜åœ¨å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦ï¼Œåˆ™æ— æ³•æ‰§è¡ŒåŠ å¯†è¿‡ç¨‹ï¼Œè¿”å›ç©ºå­—ç¬¦ä¸² `""`ã€‚

å­—ç¬¦ä¸² **è§£å¯†** æŒ‰ä¸‹è¿°æ­¥éª¤è¿›è¡Œï¼š

  1. å°†å­—ç¬¦ä¸²æ¯ç›¸é‚» 2 ä¸ªå­—ç¬¦åˆ’åˆ†ä¸ºä¸€ä¸ªå­å­—ç¬¦ä¸²ï¼Œå¯¹äºæ¯ä¸ªå­å­—ç¬¦ä¸² `s` ï¼Œæ‰¾å‡ºæ»¡è¶³ `values[i] == s` çš„ä¸€ä¸ªä¸‹æ ‡ `i` ã€‚å¦‚æœå­˜åœ¨å¤šä¸ªæœ‰æ•ˆçš„ `i` ï¼Œä»ä¸­é€‰æ‹© **ä»»æ„** ä¸€ä¸ªã€‚è¿™æ„å‘³ç€ä¸€ä¸ªå­—ç¬¦ä¸²è§£å¯†å¯èƒ½å¾—åˆ°å¤šä¸ªè§£å¯†å­—ç¬¦ä¸²ã€‚
  2. åœ¨å­—ç¬¦ä¸²ä¸­ï¼Œç”¨ `keys[i]` æ›¿æ¢ `s` ã€‚

å®ç° `Encrypter` ç±»ï¼š

  * `Encrypter(char[] keys, String[] values, String[] dictionary)` ç”¨ `keys`ã€`values` å’Œ `dictionary` åˆå§‹åŒ– `Encrypter` ç±»ã€‚
  * `String encrypt(String word1)` æŒ‰ä¸Šè¿°åŠ å¯†è¿‡ç¨‹å®Œæˆå¯¹ `word1` çš„åŠ å¯†ï¼Œå¹¶è¿”å›åŠ å¯†åçš„å­—ç¬¦ä¸²ã€‚
  * `int decrypt(String word2)` ç»Ÿè®¡å¹¶è¿”å›å¯ä»¥ç”± `word2` è§£å¯†å¾—åˆ°ä¸”å‡ºç°åœ¨ `dictionary` ä¸­çš„å­—ç¬¦ä¸²æ•°ç›®ã€‚



**ç¤ºä¾‹ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š**
> 
> ["Encrypter", "encrypt", "decrypt"]
> 
> [[['a', 'b', 'c', 'd'], ["ei", "zf", "ei", "am"], ["abcd", "acbd", "adbc", "badc", "dacb", "cadb", "cbda", "abad"]], ["abcd"], ["eizfeiam"]]
> 
> **è¾“å‡ºï¼š**
> 
> [null, "eizfeiam", 2]
> 
> 
> 
> **è§£é‡Šï¼š**
> 
> Encrypter encrypter = new Encrypter([['a', 'b', 'c', 'd'], ["ei", "zf", "ei", "am"], ["abcd", "acbd", "adbc", "badc", "dacb", "cadb", "cbda", "abad"]);
> 
> encrypter.encrypt("abcd"); // è¿”å› "eizfeiam"ã€‚ 
> 
> > 
> > 
> > 
> > 
> > 
> > 
>    // 'a' æ˜ å°„ä¸º "ei"ï¼Œ'b' æ˜ å°„ä¸º "zf"ï¼Œ'c' æ˜ å°„ä¸º "ei"ï¼Œ'd' æ˜ å°„ä¸º "am"ã€‚
> 
> encrypter.decrypt("eizfeiam"); // return 2. 
> 
> > 
> > 
> > 
> > 
> > 
> > 
> > 
>   // "ei" å¯ä»¥æ˜ å°„ä¸º 'a' æˆ– 'c'ï¼Œ"zf" æ˜ å°„ä¸º 'b'ï¼Œ"am" æ˜ å°„ä¸º 'd'ã€‚ 
> 
> > 
> > 
> > 
> > 
> > 
> > 
> > 
>   // å› æ­¤ï¼Œè§£å¯†åå¯ä»¥å¾—åˆ°çš„å­—ç¬¦ä¸²æ˜¯ "abad"ï¼Œ"cbad"ï¼Œ"abcd" å’Œ "cbcd"ã€‚ 
> 
> > 
> > 
> > 
> > 
> > 
> > 
> > 
>   // å…¶ä¸­ 2 ä¸ªå­—ç¬¦ä¸²ï¼Œ"abad" å’Œ "abcd"ï¼Œåœ¨ dictionary ä¸­å‡ºç°ï¼Œæ‰€ä»¥ç­”æ¡ˆæ˜¯ 2 ã€‚
> 
> 



**æç¤ºï¼š**

  * `1 <= keys.length == values.length <= 26`
  * `values[i].length == 2`
  * `1 <= dictionary.length <= 100`
  * `1 <= dictionary[i].length <= 100`
  * æ‰€æœ‰ `keys[i]` å’Œ `dictionary[i]` **äº’ä¸ç›¸åŒ**
  * `1 <= word1.length <= 2000`
  * `1 <= word2.length <= 200`
  * æ‰€æœ‰ `word1[i]` éƒ½å‡ºç°åœ¨ `keys` ä¸­
  * `word2.length` æ˜¯å¶æ•°
  * `keys`ã€`values[i]`ã€`dictionary[i]`ã€`word1` å’Œ `word2` åªå«å°å†™è‹±æ–‡å­—æ¯
  * è‡³å¤šè°ƒç”¨ `encrypt` å’Œ `decrypt` **æ€»è®¡** `200` æ¬¡


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 208 | [å®ç° Trie (å‰ç¼€æ ‘)](https://leetcode.com/problems/implement-trie-prefix-tree) | [[âœ“]](https://2xiao.github.io/leetcode-js/leetcode/problem/0208) |  [`è®¾è®¡`](/leetcode/outline/tag/design.md) [`å­—å…¸æ ‘`](/leetcode/outline/tag/trie.md) [`å“ˆå¸Œè¡¨`](/leetcode/outline/tag/hash-table.md) `1+` | <font color=#ffb800>Medium</font> |
| 212 | [å•è¯æœç´¢ II](https://leetcode.com/problems/word-search-ii) | [[âœ“]](https://2xiao.github.io/leetcode-js/leetcode/problem/0212) |  [`å­—å…¸æ ‘`](/leetcode/outline/tag/trie.md) [`æ•°ç»„`](/leetcode/outline/tag/array.md) [`å­—ç¬¦ä¸²`](/leetcode/outline/tag/string.md) `2+` | <font color=#ff334b>Hard</font> |
| 1804 | [å®ç° Trie ï¼ˆå‰ç¼€æ ‘ï¼‰ II](https://leetcode.com/problems/implement-trie-ii-prefix-tree) |  |  [`è®¾è®¡`](/leetcode/outline/tag/design.md) [`å­—å…¸æ ‘`](/leetcode/outline/tag/trie.md) [`å“ˆå¸Œè¡¨`](/leetcode/outline/tag/hash-table.md) `1+` | <font color=#ffb800>Medium</font> |
| 3079 | [æ±‚å‡ºåŠ å¯†æ•´æ•°çš„å’Œ](https://leetcode.com/problems/find-the-sum-of-encrypted-integers) |  |  [`æ•°ç»„`](/leetcode/outline/tag/array.md) [`æ•°å­¦`](/leetcode/outline/tag/math.md) | <font color=#15bd66>Easy</font> |

<style>
.blue {
    background-color: #096dd9;
    padding: 0.25rem 0.5rem;
    margin: 0;
    font-size: 0.85em;
    border-radius: 3px;
    color: white;
    font-weight: 500;
}
table th:first-of-type { width: 10%; }
table th:nth-of-type(2) { width: 35%; }
table th:nth-of-type(3) { width: 10%; }
table th:nth-of-type(4) { width: 35%; }
table th:nth-of-type(5) { width: 10%; }
</style>
