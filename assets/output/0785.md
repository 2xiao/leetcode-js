---
title: 785. åˆ¤æ–­äºŒåˆ†å›¾
description: LeetCode 785. åˆ¤æ–­äºŒåˆ†å›¾é¢˜è§£ï¼ŒIs Graph Bipartite?ï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 785. åˆ¤æ–­äºŒåˆ†å›¾
  - åˆ¤æ–­äºŒåˆ†å›¾
  - Is Graph Bipartite?
  - è§£é¢˜æ€è·¯
  - æ·±åº¦ä¼˜å…ˆæœç´¢
  - å¹¿åº¦ä¼˜å…ˆæœç´¢
  - å¹¶æŸ¥é›†
  - å›¾
---

# 785. åˆ¤æ–­äºŒåˆ†å›¾

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/tag/breadth-first-search.md) [`å¹¶æŸ¥é›†`](/tag/union-find.md) [`å›¾`](/tag/graph.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/is-graph-bipartite) [`LeetCode`](https://leetcode.com/problems/is-graph-bipartite)

## é¢˜ç›®

There is an **undirected** graph with `n` nodes, where each node is numbered
between `0` and `n - 1`. You are given a 2D array `graph`, where `graph[u]` is
an array of nodes that node `u` is adjacent to. More formally, for each `v` in
`graph[u]`, there is an undirected edge between node `u` and node `v`. The
graph has the following properties:

  * There are no self-edges (`graph[u]` does not contain `u`).
  * There are no parallel edges (`graph[u]` does not contain duplicate values).
  * If `v` is in `graph[u]`, then `u` is in `graph[v]` (the graph is undirected).
  * The graph may not be connected, meaning there may be two nodes `u` and `v` such that there is no path between them.

A graph is **bipartite** if the nodes can be partitioned into two independent
sets `A` and `B` such that **every** edge in the graph connects a node in set
`A` and a node in set `B`.

Return `true` _if and only if it is**bipartite**_.



**Example 1:**

![](https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg)

> Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]]
> 
> Output: false
> 
> Explanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg)

> Input: graph = [[1,3],[0,2],[1,3],[0,2]]
> 
> Output: true
> 
> Explanation: We can partition the nodes into two sets: {0, 2} and {1, 3}.



**Constraints:**

  * `graph.length == n`
  * `1 <= n <= 100`
  * `0 <= graph[u].length < n`
  * `0 <= graph[u][i] <= n - 1`
  * `graph[u]` does not contain `u`.
  * All the values of `graph[u]` are **unique**.
  * If `graph[u]` contains `v`, then `graph[v]` contains `u`.


## é¢˜ç›®å¤§æ„

å­˜åœ¨ä¸€ä¸ª **æ— å‘å›¾** ï¼Œå›¾ä¸­æœ‰ `n` ä¸ªèŠ‚ç‚¹ã€‚å…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªä»‹äº `0` åˆ° `n - 1` ä¹‹é—´çš„å”¯ä¸€ç¼–å·ã€‚ç»™ä½ ä¸€ä¸ªäºŒç»´æ•°ç»„ `graph`
ï¼Œå…¶ä¸­ `graph[u]` æ˜¯ä¸€ä¸ªèŠ‚ç‚¹æ•°ç»„ï¼Œç”±èŠ‚ç‚¹ `u` çš„é‚»æ¥èŠ‚ç‚¹ç»„æˆã€‚å½¢å¼ä¸Šï¼Œå¯¹äº `graph[u]` ä¸­çš„æ¯ä¸ª `v` ï¼Œéƒ½å­˜åœ¨ä¸€æ¡ä½äºèŠ‚ç‚¹
`u` å’ŒèŠ‚ç‚¹ `v` ä¹‹é—´çš„æ— å‘è¾¹ã€‚è¯¥æ— å‘å›¾åŒæ—¶å…·æœ‰ä»¥ä¸‹å±æ€§ï¼š

  * ä¸å­˜åœ¨è‡ªç¯ï¼ˆ`graph[u]` ä¸åŒ…å« `u`ï¼‰ã€‚
  * ä¸å­˜åœ¨å¹³è¡Œè¾¹ï¼ˆ`graph[u]` ä¸åŒ…å«é‡å¤å€¼ï¼‰ã€‚
  * å¦‚æœ `v` åœ¨ `graph[u]` å†…ï¼Œé‚£ä¹ˆ `u` ä¹Ÿåº”è¯¥åœ¨ `graph[v]` å†…ï¼ˆè¯¥å›¾æ˜¯æ— å‘å›¾ï¼‰
  * è¿™ä¸ªå›¾å¯èƒ½ä¸æ˜¯è¿é€šå›¾ï¼Œä¹Ÿå°±æ˜¯è¯´ä¸¤ä¸ªèŠ‚ç‚¹ `u` å’Œ `v` ä¹‹é—´å¯èƒ½ä¸å­˜åœ¨ä¸€æ¡è¿é€šå½¼æ­¤çš„è·¯å¾„ã€‚

**äºŒåˆ†å›¾** å®šä¹‰ï¼šå¦‚æœèƒ½å°†ä¸€ä¸ªå›¾çš„èŠ‚ç‚¹é›†åˆåˆ†å‰²æˆä¸¤ä¸ªç‹¬ç«‹çš„å­é›† `A` å’Œ `B` ï¼Œå¹¶ä½¿å›¾ä¸­çš„æ¯ä¸€æ¡è¾¹çš„ä¸¤ä¸ªèŠ‚ç‚¹ä¸€ä¸ªæ¥è‡ª `A` é›†åˆï¼Œä¸€ä¸ªæ¥è‡ª
`B` é›†åˆï¼Œå°±å°†è¿™ä¸ªå›¾ç§°ä¸º **äºŒåˆ†å›¾** ã€‚

å¦‚æœå›¾æ˜¯äºŒåˆ†å›¾ï¼Œè¿”å› `true` __ ï¼›å¦åˆ™ï¼Œè¿”å› `false` ã€‚

**ç¤ºä¾‹ 1ï¼š**

![](https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg)

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** graph = [[1,2,3],[0,2],[0,1,3],[0,2]]
> 
> **è¾“å‡ºï¼š** false
> 
> **è§£é‡Šï¼š**ä¸èƒ½å°†èŠ‚ç‚¹åˆ†å‰²æˆä¸¤ä¸ªç‹¬ç«‹çš„å­é›†ï¼Œä»¥ä½¿æ¯æ¡è¾¹éƒ½è¿é€šä¸€ä¸ªå­é›†ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹ä¸å¦ä¸€ä¸ªå­é›†ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹ã€‚

**ç¤ºä¾‹ 2ï¼š**

![](https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg)

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** graph = [[1,3],[0,2],[1,3],[0,2]]
> 
> **è¾“å‡ºï¼š** true
> 
> **è§£é‡Šï¼š**å¯ä»¥å°†èŠ‚ç‚¹åˆ†æˆä¸¤ç»„: {0, 2} å’Œ {1, 3} ã€‚

**æç¤ºï¼š**

  * `graph.length == n`
  * `1 <= n <= 100`
  * `0 <= graph[u].length < n`
  * `0 <= graph[u][i] <= n - 1`
  * `graph[u]` ä¸ä¼šåŒ…å« `u`
  * `graph[u]` çš„æ‰€æœ‰å€¼ **äº’ä¸ç›¸åŒ**
  * å¦‚æœ `graph[u]` åŒ…å« `v`ï¼Œé‚£ä¹ˆ `graph[v]` ä¹Ÿä¼šåŒ…å« `u`


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ | åŠ›æ‰£ |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 2493 | å°†èŠ‚ç‚¹åˆ†æˆå°½å¯èƒ½å¤šçš„ç»„ |  |  [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/tag/breadth-first-search.md) [`å¹¶æŸ¥é›†`](/tag/union-find.md) [`å›¾`](/tag/graph.md) | ğŸ”´ | [ğŸ€„ï¸](https://leetcode.cn/problems/divide-nodes-into-the-maximum-number-of-groups) [ğŸ”—](https://leetcode.com/problems/divide-nodes-into-the-maximum-number-of-groups) |