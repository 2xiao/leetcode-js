---
title: 3417. 跳过交替单元格的之字形遍历
description: LeetCode 3417. 跳过交替单元格的之字形遍历题解，Zigzag Grid Traversal With Skip，包含解题思路、复杂度分析以及完整的 JavaScript 代码实现。
keywords:
  - LeetCode
  - 3417. 跳过交替单元格的之字形遍历
  - 跳过交替单元格的之字形遍历
  - Zigzag Grid Traversal With Skip
  - 解题思路
  - 数组
  - 矩阵
  - 模拟
---

# 3417. 跳过交替单元格的之字形遍历

🟢 <font color=#15bd66>Easy</font>&emsp; 🔖&ensp; [`数组`](/tag/array.md) [`矩阵`](/tag/matrix.md) [`模拟`](/tag/simulation.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/zigzag-grid-traversal-with-skip) [`LeetCode`](https://leetcode.com/problems/zigzag-grid-traversal-with-skip)

## 题目

You are given an `m x n` 2D array `grid` of **positive** integers.

Your task is to traverse `grid` in a **zigzag** pattern while skipping every
**alternate** cell.

Zigzag pattern traversal is defined as following the below actions:

  * Start at the top-left cell `(0, 0)`.
  * Move _right_ within a row until the end of the row is reached.
  * Drop down to the next row, then traverse _left_ until the beginning of the row is reached.
  * Continue **alternating** between right and left traversal until every row has been traversed.

**Note** that you **must skip** every _alternate_ cell during the traversal.

Return an array of integers `result` containing, **in order** , the value of
the cells visited during the zigzag traversal with skips.



**Example 1:**

**Input:** grid = [[1,2],[3,4]]

**Output:** [1,4]

**Explanation:**

**![](https://assets.leetcode.com/uploads/2024/11/23/4012_example0.png)**

**Example 2:**

**Input:** grid = [[2,1],[2,1],[2,1]]

**Output:** [2,1,2]

**Explanation:**

![](https://assets.leetcode.com/uploads/2024/11/23/4012_example1.png)

**Example 3:**

**Input:** grid = [[1,2,3],[4,5,6],[7,8,9]]

**Output:** [1,3,5,7,9]

**Explanation:**

![](https://assets.leetcode.com/uploads/2024/11/23/4012_example2.png)



**Constraints:**

  * `2 <= n == grid.length <= 50`
  * `2 <= m == grid[i].length <= 50`
  * `1 <= grid[i][j] <= 2500`


## 题目大意

给你一个 `m x n` 的二维数组 `grid`，数组由 **正整数** 组成。

你的任务是以 **之字形  **遍历 `grid`，同时跳过每个 **交替  **的单元格。

之字形遍历的定义如下：

  * 从左上角的单元格 `(0, 0)` 开始。
  * 在当前行中向 **右** 移动，直到到达该行的末尾。
  * 下移到下一行，然后在该行中向 **左** _ _ 移动，直到到达该行的开头。
  * 继续在行间交替向右和向左移动，直到所有行都被遍历完。

**注意：** 在遍历过程中，必须跳过每个 **交替  **的单元格。

返回一个整数数组 `result`，其中包含按 **顺序  **记录的、且跳过交替单元格后的之字形遍历中访问到的单元格值。



**示例 1：**

**输入：** grid = [[1,2],[3,4]]

**输出：** [1,4]

**解释：**

**![](https://assets.leetcode.com/uploads/2024/11/23/4012_example0.png)**

**示例 2：**

**输入：** grid = [[2,1],[2,1],[2,1]]

**输出：** [2,1,2]

**解释：**

![](https://assets.leetcode.com/uploads/2024/11/23/4012_example1.png)

**示例 3：**

**输入：** grid = [[1,2,3],[4,5,6],[7,8,9]]

**输出：** [1,3,5,7,9]

**解释：**

![](https://assets.leetcode.com/uploads/2024/11/23/4012_example2.png)



**提示：**

  * `2 <= n == grid.length <= 50`
  * `2 <= m == grid[i].length <= 50`
  * `1 <= grid[i][j] <= 2500`


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 103 | 二叉树的锯齿形层序遍历 | [[✓]](/problem/0103.md) |  [`树`](/tag/tree.md) [`广度优先搜索`](/tag/breadth-first-search.md) [`二叉树`](/tag/binary-tree.md) | 🟠 | [🀄️](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal) [🔗](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal) |
| 1372 | 二叉树中的最长交错路径 | [[✓]](/problem/1372.md) |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`动态规划`](/tag/dynamic-programming.md) `1+` | 🟠 | [🀄️](https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree) [🔗](https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree) |