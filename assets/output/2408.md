---
title: 2408. 设计 SQL 🔒
description: LeetCode 2408. 设计 SQL 🔒题解，Design SQL，包含解题思路、复杂度分析以及完整的 JavaScript 代码实现。
keywords:
  - LeetCode
  - 2408. 设计 SQL 🔒
  - 设计 SQL
  - Design SQL
  - 解题思路
  - 设计
  - 数组
  - 哈希表
  - 字符串
---

# 2408. 设计 SQL 🔒

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`设计`](/tag/design.md) [`数组`](/tag/array.md) [`哈希表`](/tag/hash-table.md) [`字符串`](/tag/string.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/design-sql) [`LeetCode`](https://leetcode.com/problems/design-sql)

## 题目

You are given two string arrays, `names` and `columns`, both of size `n`. The
`ith` table is represented by the name `names[i]` and contains `columns[i]`
number of columns.

You need to implement a class that supports the following **operations** :

  * **Insert** a row in a specific table with an id assigned using an _auto-increment_ method, where the id of the first inserted row is 1, and the id of each _new_ row inserted into the same table is **one greater** than the id of the **last inserted** row, even if the last row was _removed_.
  * **Remove** a row from a specific table. Removing a row **does not** affect the id of the next inserted row.
  * **Select** a specific cell from any table and return its value.
  * **Export** all rows from any table in csv format.

Implement the `SQL` class:

  * `SQL(String[] names, int[] columns)`
> 
> * Creates the `n` tables.
  * `bool ins(String name, String[] row)`
> 
> * Inserts `row` into the table `name` and returns `true`.
> 
> * If `row.length` **does not** match the expected number of columns, or `name` is **not** a valid table, returns `false` without any insertion.
  * `void rmv(String name, int rowId)`
> 
> * Removes the row `rowId` from the table `name`.
> 
> * If `name` is **not** a valid table or there is no row with id `rowId`, no removal is performed.
  * `String sel(String name, int rowId, int columnId)`
> 
> * Returns the value of the cell at the specified `rowId` and `columnId` in the table `name`.
> 
> * If `name` is **not** a valid table, or the cell `(rowId, columnId)` is **invalid** , returns `"<null>"`.
  * `String[] exp(String name)`
> 
> * Returns the rows present in the table `name`.
> 
> * If name is **not** a valid table, returns an empty array. Each row is represented as a string, with each cell value (**including** the row's id) separated by a `","`.



**Example 1:**

**Input:**

> 
> 
> 
> 
> 
> ["SQL","ins","sel","ins","exp","rmv","sel","exp"]
> 
> [[["one","two","three"],[2,3,1]],["two",["first","second","third"]],["two",1,3],["two",["fourth","fifth","sixth"]],["two"],["two",1],["two",2,2],["two"]]
> 
> 

**Output:**

> 
> 
> 
> 
> 
> [null,true,"third",true,["1,first,second,third","2,fourth,fifth,sixth"],null,"fifth",["2,fourth,fifth,sixth"]]

**Explanation:**

> 
> 
> 
> 
> 
> // Creates three tables.
> 
> SQL sql = new SQL(["one", "two", "three"], [2, 3, 1]);
> 
> 
> 
> // Adds a row to the table "two" with id 1. Returns True.
> 
> sql.ins("two", ["first", "second", "third"]);
> 
> 
> 
> // Returns the value "third" from the third column
> 
> // in the row with id 1 of the table "two".
> 
> sql.sel("two", 1, 3);
> 
> 
> 
> // Adds another row to the table "two" with id 2. Returns True.
> 
> sql.ins("two", ["fourth", "fifth", "sixth"]);
> 
> 
> 
> // Exports the rows of the table "two".
> 
> // Currently, the table has 2 rows with ids 1 and 2.
> 
> sql.exp("two");
> 
> 
> 
> // Removes the first row of the table "two". Note that the second row
> 
> // will still have the id 2.
> 
> sql.rmv("two", 1);
> 
> 
> 
> // Returns the value "fifth" from the second column
> 
> // in the row with id 2 of the table "two".
> 
> sql.sel("two", 2, 2);
> 
> 
> 
> // Exports the rows of the table "two".
> 
> // Currently, the table has 1 row with id 2.
> 
> sql.exp("two");

**Example 2:**

**Input:**

> 
> 
> 
> 
> 
> ["SQL","ins","sel","rmv","sel","ins","ins"]
> 
> [[["one","two","three"],[2,3,1]],["two",["first","second","third"]],["two",1,3],["two",1],["two",1,2],["two",["fourth","fifth"]],["two",["fourth","fifth","sixth"]]]
> 
> 

**Output:**

> 
> 
> 
> 
> 
> [null,true,"third",null,"<null>",false,true]
> 
> 

**Explanation:**

> 
> 
> 
> 
> 
> // Creates three tables.
> 
> SQL sQL = new SQL(["one", "two", "three"], [2, 3, 1]); 
> 
> 
> 
> // Adds a row to the table "two" with id 1. Returns True. 
> 
> sQL.ins("two", ["first", "second", "third"]); 
> 
> 
> 
> // Returns the value "third" from the third column 
> 
> // in the row with id 1 of the table "two".
> 
> sQL.sel("two", 1, 3); 
> 
> 
> 
> // Removes the first row of the table "two".
> 
> sQL.rmv("two", 1); 
> 
> 
> 
> // Returns "<null>" as the cell with id 1 
> 
> // has been removed from table "two".
> 
> sQL.sel("two", 1, 2); 
> 
> 
> 
> // Returns False as number of columns are not correct.
> 
> sQL.ins("two", ["fourth", "fifth"]); 
> 
> 
> 
> // Adds a row to the table "two" with id 2. Returns True.
> 
> sQL.ins("two", ["fourth", "fifth", "sixth"]); 

**Constraints:**

  * `n == names.length == columns.length`
  * `1 <= n <= 10^4`
  * `1 <= names[i].length, row[i].length, name.length <= 10`
  * `names[i]`, `row[i]`, and `name` consist only of lowercase English letters.
  * `1 <= columns[i] <= 10`
  * `1 <= row.length <= 10`
  * All `names[i]` are **distinct**.
  * At most `2000` calls will be made to `ins` and `rmv`.
  * At most `10^4` calls will be made to `sel`.
  * At most `500` calls will be made to `exp`.



**Follow-up:** Which approach would you choose if the table might become
sparse due to many deletions, and why? Consider the impact on memory usage and
performance.


## 题目大意

给定两个字符串数组 `names` 和 `columns`，大小都为 `n`。其中 `names[i]` 是第 `i` 个表的名称，`columns[i]`
是第 `i` 个表的列数。

您需要实现一个支持以下 **操作  **的类：

  * 在特定的表中 **插入  **一行。插入的每一行都有一个 id。id 是使用自动递增方法分配的，其中第一个插入行的 id 为 1，同一个表中的后续其他行的 id 为上一个插入行的 id (即使它已被删除) 加 1。
  * 从指定表中 **删除  **一行。**注意** ，删除一行 **不会** 影响下一个插入行的 id。
  * 从任何表中 **查询  **一个特定的单元格并返回其值。
  * 从任何表以 csv 格式 **导出** 所有行。

实现 `SQL` 类:

  * `SQL(String[] names, int[] columns)`
> 
> * 创建 `n` 个表。
  * `bool ins(String name, String[] row)`
> 
> * 将 `row` 插入表 `name` 中并返回 `true`。
> 
> * 如果 `row.length` **不** 匹配列的预期数量，或者 `name` **不是** 一个合法的表，不进行任何插入并返回 `false`。
  * `void rmv(String name, int rowId, int columnId)`
> 
> * 从表 `name` 中移除行 `rowId`。
> 
> * 如果 `name` **不是** 一个合法的表或者没有 id 为 `rowId` 的行，不进行删除。
  * `String sel(String name, int rowId, int columnId)`
> 
> * 返回表 `name` 中位于特定的 `rowId` 和 `columnId` 的单元格的值。
> 
> * 如果 name **不是  **一个合法的表，或者单元格 `(rowId, columnId)` **不合法** ，返回 `"<null>"`。
  * `String[] exp(String name)`
> 
> * 返回表 `name` 中出现的行。
> 
> * 如果 `name` **不是** 一个合法的表，返回一个空数组。每一行以字符串表示，每个单元格的值（**包括** 行的 id）以 `","` 分隔。

**示例 1：**

**输入：**

> 
> 
> 
> 
> 
> ["SQL","ins","sel","ins","exp","rmv","sel","exp"]
> 
> [[["one","two","three"],[2,3,1]],["two",["first","second","third"]],["two",1,3],["two",["fourth","fifth","sixth"]],["two"],["two",1],["two",2,2],["two"]]
> 
> 

**输出：**

> 
> 
> 
> 
> 
> [null,true,"third",true,["1,first,second,third","2,fourth,fifth,sixth"],null,"fifth",["2,fourth,fifth,sixth"]]

**解释：**

> 
> 
> 
> 
> 
> // 创建 3 张表。
> 
> SQL sql = new SQL(["one", "two", "three"], [2, 3, 1]);
> 
> 
> 
> // 将 id 为 1 的行添加到表 "two"。返回 True。
> 
> sql.ins("two", ["first", "second", "third"]);
> 
> 
> 
> // 从表 "two" 中 id 为 1 的行 
> 
> // 其中第 3 列返回值 "third"。
> 
> sql.sel("two", 1, 3);
> 
> 
> 
> // 将另外一个 id 为 2 的行添加到表 "two"。返回 True。
> 
> sql.ins("two", ["fourth", "fifth", "sixth"]);
> 
> 
> 
> // 导出表 "two" 的行。
> 
> // 目前表中有两行 id 为 1 和 2 。
> 
> sql.exp("two");
> 
> 
> 
> // 删除表 "two" 当中的第一行。注意第二行的 id
> 
> // 依然为 2。
> 
> sql.rmv("two", 1);
> 
> 
> 
> // 从表 "two" 中 id 为 2 的行
> 
> // 其中第 2 列返回值 "fifth"。
> 
> sql.sel("two", 2, 2);
> 
> 
> 
> // 导出表 "two" 的行。
> 
> // 目前表中有一行 id 为 2。
> 
> sql.exp("two");
> 
> 

**示例 2：**

**输入：**

> 
> 
> 
> 
> 
> ["SQL","ins","sel","ins","exp","rmv","sel","exp"]
> 
> [[["one","two","three"],[2,3,1]],["two",["first","second","third"]],["two",1,3],["two",["fourth","fifth","sixth"]],["two"],["two",1],["two",2,2],["two"]]
> 
> 

**输出：**

> 
> 
> 
> 
> 
> [null,true,"third",true,["1,first,second,third","2,fourth,fifth,sixth"],null,"fifth",["2,fourth,fifth,sixth"]]
> 
> 

**解释：**

> 
> 
> 
> 
> 
> // 创建 3 张表
> 
> SQL sQL = new SQL(["one", "two", "three"], [2, 3, 1]); 
> 
> 
> 
> // 将 id 为 1 的行添加到表 "two"。返回 True。
> 
> sQL.ins("two", ["first", "second", "third"]); 
> 
> 
> 
> // 从表 "two" 中 id 为 1 的行
> 
> // 其中第 3 列返回值 "third"。
> 
> sQL.sel("two", 1, 3); 
> 
> 
> 
> // 删除表 "two" 的第一行。
> 
> sQL.rmv("two", 1); 
> 
> 
> 
> // 返回 "<null>" 因为 id 为 1 的单元格
> 
> // 已经从表 "two" 中删除。
> 
> sQL.sel("two", 1, 2); 
> 
> 
> 
> // 返回 False 因为列的数量不正确。
> 
> sQL.ins("two", ["fourth", "fifth"]); 
> 
> 
> 
> // 将 id 为 2 的行添加到表 "two"。返回 True。
> 
> sQL.ins("two", ["fourth", "fifth", "sixth"]); 
> 
> 



**提示:**

  * `n == names.length == columns.length`
  * `1 <= n <= 10^4`
  * `1 <= names[i].length, row[i].length, name.length <= 10`
  * `names[i]`, `row[i]`, `name` 由小写英文字母组成。
  * `1 <= columns[i] <= 10`
  * `1 <= row.length <= 10`
  * 所有的 `names[i]` 都是 **不同  **的。
  * 最多调用 `ins` 和 `rmv` `2000` 次。
  * 最多调用 `sel` `10^4` 次。
  * 最多调用 `exp` `500` 次。

**进阶：** 如果表因多次删除而变得稀疏，您会选择哪种方法？为什么？考虑对内存使用和性能的影响。


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```