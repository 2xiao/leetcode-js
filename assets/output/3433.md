---
title: 3433. 统计用户被提及情况
description: LeetCode 3433. 统计用户被提及情况题解，Count Mentions Per User，包含解题思路、复杂度分析以及完整的 JavaScript 代码实现。
keywords:
  - LeetCode
  - 3433. 统计用户被提及情况
  - 统计用户被提及情况
  - Count Mentions Per User
  - 解题思路
  - 数组
  - 数学
  - 排序
  - 模拟
---

# 3433. 统计用户被提及情况

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`数组`](/tag/array.md) [`数学`](/tag/math.md) [`排序`](/tag/sorting.md) [`模拟`](/tag/simulation.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/count-mentions-per-user) [`LeetCode`](https://leetcode.com/problems/count-mentions-per-user)

## 题目

You are given an integer `numberOfUsers` representing the total number of
users and an array `events` of size `n x 3`.

Each `events[i]` can be either of the following two types:

  1. **Message Event:** `["MESSAGE", "timestampi", "mentions_stringi"]`
> 
>  * This event indicates that a set of users was mentioned in a message at `timestampi`.
> 
>  * The `mentions_stringi` string can contain one of the following tokens: 
> 
>    * `id<number>`: where `<number>` is an integer in range `[0,numberOfUsers - 1]`. There can be **multiple** ids separated by a single whitespace and may contain duplicates. This can mention even the offline users.
> 
>    * `ALL`: mentions **all** users.
> 
>    * `HERE`: mentions all **online** users.
  2. **Offline Event:** `["OFFLINE", "timestampi", "idi"]`
> 
>  * This event indicates that the user `idi` had become offline at `timestampi` for **60 time units**. The user will automatically be online again at time `timestampi + 60`.

Return an array `mentions` where `mentions[i]` represents the number of
mentions the user with id `i` has across all `MESSAGE` events.

All users are initially online, and if a user goes offline or comes back
online, their status change is processed _before_ handling any message event
that occurs at the same timestamp.

**Note** that a user can be mentioned **multiple** times in a **single**
message event, and each mention should be counted **separately**.



**Example 1:**

**Input:** numberOfUsers = 2, events = [["MESSAGE","10","id1
id0"],["OFFLINE","11","0"],["MESSAGE","71","HERE"]]

**Output:** [2,2]

**Explanation:**

Initially, all users are online.

At timestamp 10, `id1` and `id0` are mentioned. `mentions = [1,1]`

At timestamp 11, `id0` goes **offline.**

At timestamp 71, `id0` comes back **online** and `"HERE"` is mentioned.
`mentions = [2,2]`

**Example 2:**

**Input:** numberOfUsers = 2, events = [["MESSAGE","10","id1
id0"],["OFFLINE","11","0"],["MESSAGE","12","ALL"]]

**Output:** [2,2]

**Explanation:**

Initially, all users are online.

At timestamp 10, `id1` and `id0` are mentioned. `mentions = [1,1]`

At timestamp 11, `id0` goes **offline.**

At timestamp 12, `"ALL"` is mentioned. This includes offline users, so both
`id0` and `id1` are mentioned. `mentions = [2,2]`

**Example 3:**

**Input:** numberOfUsers = 2, events =
[["OFFLINE","10","0"],["MESSAGE","12","HERE"]]

**Output:** [0,1]

**Explanation:**

Initially, all users are online.

At timestamp 10, `id0` goes **offline.**

At timestamp 12, `"HERE"` is mentioned. Because `id0` is still offline, they
will not be mentioned. `mentions = [0,1]`



**Constraints:**

  * `1 <= numberOfUsers <= 100`
  * `1 <= events.length <= 100`
  * `events[i].length == 3`
  * `events[i][0]` will be one of `MESSAGE` or `OFFLINE`.
  * `1 <= int(events[i][1]) <= 10^5`
  * The number of `id<number>` mentions in any `"MESSAGE"` event is between `1` and `100`.
  * `0 <= <number> <= numberOfUsers - 1`
  * It is **guaranteed** that the user id referenced in the `OFFLINE` event is **online** at the time the event occurs.


## 题目大意

给你一个整数 `numberOfUsers` 表示用户总数，另有一个大小为 `n x 3` 的数组 `events` 。

每个 `events[i]` 都属于下述两种类型之一：

  1. **消息事件（Message Event）：**`["MESSAGE", "timestampi", "mentions_stringi"]`
> 
>  * 事件表示在 `timestampi` 时，一组用户被消息提及。
> 
>  * `mentions_stringi` 字符串包含下述标识符之一： 
> 
>    * `id<number>`：其中 `<number>` 是一个区间 `[0,numberOfUsers - 1]` 内的整数。可以用单个空格分隔 **多个** id ，并且 id 可能重复。此外，这种形式可以提及离线用户。
> 
>    * `ALL`：提及 **所有** 用户。
> 
>    * `HERE`：提及所有 **在线** 用户。
  2. **离线事件（Offline Event）：**`["OFFLINE", "timestampi", "idi"]`
> 
>  * 事件表示用户 `idi` 在 `timestampi` 时变为离线状态 **60 个单位时间** 。用户会在 `timestampi + 60` 时自动再次上线。

返回数组 `mentions` ，其中 `mentions[i]` 表示  id 为  `i` 的用户在所有 `MESSAGE` 事件中被提及的次数。

最初所有用户都处于在线状态，并且如果某个用户离线或者重新上线，其对应的状态变更将会在所有相同时间发生的消息事件之前进行处理和同步。

**注意** 在单条消息中，同一个用户可能会被提及多次。每次提及都需要被 **分别** 统计。



**示例 1：**

**输入：** numberOfUsers = 2, events = [["MESSAGE","10","id1
id0"],["OFFLINE","11","0"],["MESSAGE","71","HERE"]]

**输出：**[2,2]

**解释：**

最初，所有用户都在线。

时间戳 10 ，`id1` 和 `id0` 被提及，`mentions = [1,1]`

时间戳 11 ，`id0` **离线** 。

时间戳 71 ，`id0` 再次 **上线**  并且 `"HERE"` 被提及，`mentions = [2,2]`

**示例 2：**

**输入：** numberOfUsers = 2, events = [["MESSAGE","10","id1
id0"],["OFFLINE","11","0"],["MESSAGE","12","ALL"]]

**输出：**[2,2]

**解释：**

最初，所有用户都在线。

时间戳 10 ，`id1` 和 `id0` 被提及，`mentions = [1,1]`

时间戳 11 ，`id0` **离线** 。

时间戳 12 ，`"ALL"` 被提及。这种方式将会包括所有离线用户，所以 `id0` 和 `id1` 都被提及，`mentions = [2,2]`

**示例 3：**

**输入：** numberOfUsers = 2, events =
[["OFFLINE","10","0"],["MESSAGE","12","HERE"]]

**输出：**[0,1]

**解释：**

最初，所有用户都在线。

时间戳 10 ，`id0` **离线**  **。**

时间戳 12 ，`"HERE"` 被提及。由于 `id0` 仍处于离线状态，其将不会被提及，`mentions = [0,1]`



**提示：**

  * `1 <= numberOfUsers <= 100`
  * `1 <= events.length <= 100`
  * `events[i].length == 3`
  * `events[i][0]` 的值为 `MESSAGE` 或 `OFFLINE` 。
  * `1 <= int(events[i][1]) <= 10^5`
  * 在任意 `"MESSAGE"` 事件中，以 `id<number>` 形式提及的用户数目介于 `1` 和 `100` 之间。
  * `0 <= <number> <= numberOfUsers - 1`
  * 题目保证 `OFFLINE` 引用的用户 id 在事件发生时处于 **在线** 状态。


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```