# [1128. ç­‰ä»·å¤šç±³è¯ºéª¨ç‰Œå¯¹çš„æ•°é‡](https://2xiao.github.io/leetcode-js/problem/1128.html)

ğŸŸ¢ <font color=#15bd66>Easy</font>&emsp; ğŸ”–&ensp; [`æ•°ç»„`](/tag/array.md) [`å“ˆå¸Œè¡¨`](/tag/hash-table.md) [`è®¡æ•°`](/tag/counting.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/number-of-equivalent-domino-pairs) [`LeetCode`](https://leetcode.com/problems/number-of-equivalent-domino-pairs)

## é¢˜ç›®

Given a list of `dominoes`, `dominoes[i] = [a, b]` is **equivalent to**
`dominoes[j] = [c, d]` if and only if either (`a == c` and `b == d`), or (`a
== d` and `b == c`) - that is, one domino can be rotated to be equal to
another domino.

Return _the number of pairs_`(i, j)`_for which_`0 <= i < j < dominoes.length`
_, and_`dominoes[i]`_is**equivalent to** _`dominoes[j]`.



**Example 1:**

> Input: dominoes = [[1,2],[2,1],[3,4],[5,6]]
> 
> Output: 1

**Example 2:**

> Input: dominoes = [[1,2],[1,2],[1,1],[1,2],[2,2]]
> 
> Output: 3

**Constraints:**

  * `1 <= dominoes.length <= 4 * 10^4`
  * `dominoes[i].length == 2`
  * `1 <= dominoes[i][j] <= 9`


## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ç»„å¤šç±³è¯ºéª¨ç‰Œ `dominoes` ã€‚

å½¢å¼ä¸Šï¼Œ`dominoes[i] = [a, b]` ä¸ `dominoes[j] = [c, d]` **ç­‰ä»·** å½“ä¸”ä»…å½“ (`a == c` ä¸” `b
== d`) æˆ–è€… (`a == d` ä¸” `b == c`) ã€‚å³ä¸€å¼ éª¨ç‰Œå¯ä»¥é€šè¿‡æ—‹è½¬ `0` åº¦æˆ– `180` åº¦å¾—åˆ°å¦ä¸€å¼ å¤šç±³è¯ºéª¨ç‰Œã€‚

åœ¨ `0 <= i < j < dominoes.length` çš„å‰æä¸‹ï¼Œæ‰¾å‡ºæ»¡è¶³ `dominoes[i]` å’Œ `dominoes[j]`
ç­‰ä»·çš„éª¨ç‰Œå¯¹ `(i, j)` çš„æ•°é‡ã€‚



**ç¤ºä¾‹ 1ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** dominoes = [[1,2],[2,1],[3,4],[5,6]]
> 
> **è¾“å‡ºï¼š** 1
> 
> 

**ç¤ºä¾‹ 2ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** dominoes = [[1,2],[1,2],[1,1],[1,2],[2,2]]
> 
> **è¾“å‡ºï¼š** 3
> 
> 



**æç¤ºï¼š**

  * `1 <= dominoes.length <= 4 * 10^4`
  * `dominoes[i].length == 2`
  * `1 <= dominoes[i][j] <= 9`


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```