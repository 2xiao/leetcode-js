---
title: 3431. 对数字排序的最小解锁下标 🔒
description: LeetCode 3431. 对数字排序的最小解锁下标 🔒题解，Minimum Unlocked Indices to Sort Nums，包含解题思路、复杂度分析以及完整的 JavaScript 代码实现。
keywords:
  - LeetCode
  - 3431. 对数字排序的最小解锁下标 🔒
  - 对数字排序的最小解锁下标
  - Minimum Unlocked Indices to Sort Nums
  - 解题思路
  - 数组
  - 哈希表
---

# 3431. 对数字排序的最小解锁下标 🔒

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`数组`](/tag/array.md) [`哈希表`](/tag/hash-table.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/minimum-unlocked-indices-to-sort-nums) [`LeetCode`](https://leetcode.com/problems/minimum-unlocked-indices-to-sort-nums)

## 题目

You are given an array `nums` consisting of integers between 1 and 3, and a
**binary** array `locked` of the same size.

We consider `nums` **sortable** if it can be sorted using adjacent swaps,
where a swap between two indices `i` and `i + 1` is allowed if `nums[i] -
nums[i + 1] == 1` and `locked[i] == 0`.

In one operation, you can unlock any index `i` by setting `locked[i]` to 0.

Return the **minimum** number of operations needed to make `nums`
**sortable**. If it is not possible to make `nums` sortable, return -1.



**Example 1:**

**Input:** nums = [1,2,1,2,3,2], locked = [1,0,1,1,0,1]

**Output:** 0

**Explanation:**

We can sort `nums` using the following swaps:

  * swap indices 1 with 2
  * swap indices 4 with 5

So, there is no need to unlock any index.

**Example 2:**

**Input:** nums = [1,2,1,1,3,2,2], locked = [1,0,1,1,0,1,0]

**Output:** 2

**Explanation:**

If we unlock indices 2 and 5, we can sort `nums` using the following swaps:

  * swap indices 1 with 2
  * swap indices 2 with 3
  * swap indices 4 with 5
  * swap indices 5 with 6

**Example 3:**

**Input:** nums = [1,2,1,2,3,2,1], locked = [0,0,0,0,0,0,0]

**Output:** -1

**Explanation:**

Even if all indices are unlocked, it can be shown that `nums` is not sortable.



**Constraints:**

  * `1 <= nums.length <= 10^5`
  * `1 <= nums[i] <= 3`
  * `locked.length == nums.length`
  * `0 <= locked[i] <= 1`


## 题目大意

给定一个仅包含 1、2、3 的整数的数组 `nums`，以及一个相同大小的 **二进制**  数组 `locked`。

当满足 `nums[i] - nums[i + 1] == 1` 且 `locked[i] == 0`时，则允许交换下标 `i` 和 `i + 1`
处的元素；如果可以通过交换相邻元素将 `nums` 升序排序，我们认为 `nums` 是 **可排序的。**

你可以进行若干次操作，每次操作可以将 `locked[i]` 设置为 `0`，从而解锁下标 `i`。

返回使 `nums` 满足 **可排序的** 所需 **最小**  操作次数。如果不可能使 `nums` **可排序** ，返回 -1。



**示例 1：**

**输入：** nums = [1,2,1,2,3,2], locked = [1,0,1,1,0,1]

**输出：** 0

**解释：**

我们可以按如下交换来排序 `nums`。

  * 交换下标 1 和 2
  * 交换下标 4 和 5

所以，不需要解锁任何下标。

**示例 2：**

**输入：** nums = [1,2,1,1,3,2,2], locked = [1,0,1,1,0,1,0]

**输出：** 2

**解释：**

如果我们解锁下标 2 和 5，我们可以按如下交换来排序 `nums`。

  * 交换下标 1 和 2
  * 交换下标 2 和 3
  * 交换下标 4 和 5
  * 交换下标 5 和 6

**示例 3：**

**输入：** nums = [1,2,1,2,3,2,1], locked = [0,0,0,0,0,0,0]

**输出：** -1

**解释：**

尽管所有下标都是解锁的，可以发现 `nums` 不可排序。



**提示：**

  * `1 <= nums.length <= 10^5`
  * `1 <= nums[i] <= 3`
  * `locked.length == nums.length`
  * `0 <= locked[i] <= 1`


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```