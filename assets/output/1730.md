---
title: 1730. 获取食物的最短路径 🔒
description: LeetCode 1730. 获取食物的最短路径 🔒题解，Shortest Path to Get Food，包含解题思路、复杂度分析以及完整的 JavaScript 代码实现。
keywords:
  - LeetCode
  - 1730. 获取食物的最短路径 🔒
  - 获取食物的最短路径
  - Shortest Path to Get Food
  - 解题思路
  - 广度优先搜索
  - 数组
  - 矩阵
---

# 1730. 获取食物的最短路径 🔒

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`广度优先搜索`](/tag/breadth-first-search.md) [`数组`](/tag/array.md) [`矩阵`](/tag/matrix.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/shortest-path-to-get-food) [`LeetCode`](https://leetcode.com/problems/shortest-path-to-get-food)

## 题目

You are starving and you want to eat food as quickly as possible. You want to
find the shortest path to arrive at any food cell.

You are given an `m x n` character matrix, `grid`, of these different types of
cells:

  * `'*'` is your location. There is **exactly one**`'*'` cell.
  * `'#'` is a food cell. There may be **multiple** food cells.
  * `'O'` is free space, and you can travel through these cells.
  * `'X'` is an obstacle, and you cannot travel through these cells.

You can travel to any adjacent cell north, east, south, or west of your
current location if there is not an obstacle.

Return _the**length** of the shortest path for you to reach **any** food
cell_. If there is no path for you to reach food, return `-1`.



**Example 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1700-1799/1730.Shortest%20Path%20to%20Get%20Food/images/img1.jpg)

> Input: grid = [["X","X","X","X","X","X"],["X","*","O","O","O","X"],["X","O","O","#","O","X"],["X","X","X","X","X","X"]]
> 
> Output: 3
> 
> Explanation: It takes 3 steps to reach the food.

**Example 2:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1700-1799/1730.Shortest%20Path%20to%20Get%20Food/images/img2.jpg)

> Input: grid = [["X","X","X","X","X"],["X","*","X","O","X"],["X","O","X","#","X"],["X","X","X","X","X"]]
> 
> Output: -1
> 
> Explanation: It is not possible to reach the food.

**Example 3:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1700-1799/1730.Shortest%20Path%20to%20Get%20Food/images/img3.jpg)

> Input: grid = [["X","X","X","X","X","X","X","X"],["X","*","O","X","O","#","O","X"],["X","O","O","X","O","O","X","X"],["X","O","O","O","O","#","O","X"],["X","X","X","X","X","X","X","X"]]
> 
> Output: 6
> 
> Explanation: There can be multiple food cells. It only takes 6 steps to reach the bottom food.

**Example 4:**

> Input: grid = [["X","X","X","X","X","X","X","X"],["X","*","O","X","O","#","O","X"],["X","O","O","X","O","O","X","X"],["X","O","O","O","O","#","O","X"],["O","O","O","O","O","O","O","O"]]
> 
> Output: 5



**Constraints:**

  * `m == grid.length`
  * `n == grid[i].length`
  * `1 <= m, n <= 200`
  * `grid[row][col]` is `'*'`, `'X'`, `'O'`, or `'#'`.
  * The `grid` contains **exactly one** `'*'`.


## 题目大意

你现在很饿，想要尽快找东西吃。你需要找到最短的路径到达一个食物所在的格子。

给定一个 `m x n` 的字符矩阵 `grid` ，包含下列不同类型的格子：

  * `'*'` 是你的位置。矩阵中**有且只有一个  **`'*'` 格子。
  * `'#'` 是食物。矩阵中可能存在**多个** 食物。
  * `'O'` 是空地，你可以穿过这些格子。
  * `'X'` 是障碍，你不可以穿过这些格子。

返回你到任意食物的最短路径的长度。如果不存在你到任意食物的路径，返回 `-1`。



**示例 1:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1700-1799/1730.Shortest%20Path%20to%20Get%20Food/images/img1.jpg)

> 
> 
> 
> 
> 
> **输入：** grid = [["X","X","X","X","X","X"],["X","*","O","O","O","X"],["X","O","O","#","O","X"],["X","X","X","X","X","X"]]
> 
> **输出：** 3
> 
> **解释：** 要拿到食物，你需要走 3 步。

**Example 2:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1700-1799/1730.Shortest%20Path%20to%20Get%20Food/images/img2.jpg)

> 
> 
> 
> 
> 
> **输入：** grid = [["X","X","X","X","X"],["X","*","X","O","X"],["X","O","X","#","X"],["X","X","X","X","X"]]
> 
> **输出：** -1
> 
> **解释：** 你不可能拿到食物。
> 
> 

**示例  3:**

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1700-1799/1730.Shortest%20Path%20to%20Get%20Food/images/img3.jpg)

> 
> 
> 
> 
> 
> **输入:** grid = [["X","X","X","X","X","X","X","X"],["X","*","O","X","O","#","O","X"],["X","O","O","X","O","O","X","X"],["X","O","O","O","O","#","O","X"],["X","X","X","X","X","X","X","X"]]
> 
> **输出:** 6
> 
> **解释:** 这里有多个食物。拿到下边的食物仅需走 6 步。

**示例 4：**

> 
> 
> 
> 
> 
> **输入：** grid = [["X","X","X","X","X","X","X","X"],["X","*","O","X","O","#","O","X"],["X","O","O","X","O","O","X","X"],["X","O","O","O","O","#","O","X"],["O","O","O","O","O","O","O","O"]]
> 
> **输出：** 5



**提示：**

  * `m == grid.length`
  * `n == grid[i].length`
  * `1 <= m, n <= 200`
  * `grid[row][col]` 是 `'*'`、 `'X'`、 `'O'` 或 `'#'` 。
  * `grid` 中**有且只有一个**  `'*'` 。


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 542 | 01 矩阵 | [[✓]](/problem/0542.md) |  [`广度优先搜索`](/tag/breadth-first-search.md) [`数组`](/tag/array.md) [`动态规划`](/tag/dynamic-programming.md) `1+` | 🟠 | [🀄️](https://leetcode.cn/problems/01-matrix) [🔗](https://leetcode.com/problems/01-matrix) |
| 1293 | 网格中的最短路径 |  |  [`广度优先搜索`](/tag/breadth-first-search.md) [`数组`](/tag/array.md) [`矩阵`](/tag/matrix.md) | 🔴 | [🀄️](https://leetcode.cn/problems/shortest-path-in-a-grid-with-obstacles-elimination) [🔗](https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination) |
| 2385 | 感染二叉树需要的总时间 |  |  [`树`](/tag/tree.md) [`深度优先搜索`](/tag/depth-first-search.md) [`广度优先搜索`](/tag/breadth-first-search.md) `2+` | 🟠 | [🀄️](https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected) [🔗](https://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected) |