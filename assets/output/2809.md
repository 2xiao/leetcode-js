---
title: 2809. ä½¿æ•°ç»„å’Œå°äºç­‰äº x çš„æœ€å°‘æ—¶é—´
description: LeetCode 2809. ä½¿æ•°ç»„å’Œå°äºç­‰äº x çš„æœ€å°‘æ—¶é—´é¢˜è§£ï¼ŒMinimum Time to Make Array Sum At Most xï¼ŒåŒ…å«è§£é¢˜æ€è·¯ã€å¤æ‚åº¦åˆ†æä»¥åŠå®Œæ•´çš„ JavaScript ä»£ç å®ç°ã€‚
keywords:
  - LeetCode
  - 2809. ä½¿æ•°ç»„å’Œå°äºç­‰äº x çš„æœ€å°‘æ—¶é—´
  - ä½¿æ•°ç»„å’Œå°äºç­‰äº x çš„æœ€å°‘æ—¶é—´
  - Minimum Time to Make Array Sum At Most x
  - è§£é¢˜æ€è·¯
  - æ•°ç»„
  - åŠ¨æ€è§„åˆ’
  - æ’åº
---

# 2809. ä½¿æ•°ç»„å’Œå°äºç­‰äº x çš„æœ€å°‘æ—¶é—´

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`æ•°ç»„`](/tag/array.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md) [`æ’åº`](/tag/sorting.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/minimum-time-to-make-array-sum-at-most-x) [`LeetCode`](https://leetcode.com/problems/minimum-time-to-make-array-sum-at-most-x)

## é¢˜ç›®

You are given two **0-indexed** integer arrays `nums1` and `nums2` of equal
length. Every second, for all indices `0 <= i < nums1.length`, value of
`nums1[i]` is incremented by `nums2[i]`. **After** this is done, you can do
the following operation:

  * Choose an index `0 <= i < nums1.length` and make `nums1[i] = 0`.

You are also given an integer `x`.

Return _the**minimum** time in which you can make the sum of all elements of
_`nums1` _to be**less than or equal** to _`x`, _or_`-1` _if this is not
possible._



**Example 1:**

> Input: nums1 = [1,2,3], nums2 = [1,2,3], x = 4
> 
> Output: 3
> 
> Explanation: 
> 
> For the 1st second, we apply the operation on i = 0. Therefore nums1 = [0,2+2,3+3] = [0,4,6]. 
> 
> For the 2nd second, we apply the operation on i = 1. Therefore nums1 = [0+1,0,6+3] = [1,0,9]. 
> 
> For the 3rd second, we apply the operation on i = 2. Therefore nums1 = [1+1,0+2,0] = [2,2,0]. 
> 
> Now sum of nums1 = 4. It can be shown that these operations are optimal, so we return 3.
> 
> 

**Example 2:**

> Input: nums1 = [1,2,3], nums2 = [3,3,3], x = 4
> 
> Output: -1
> 
> Explanation: It can be shown that the sum of nums1 will always be greater than x, no matter which operations are performed.

**Constraints:**

  * `1 <= nums1.length <= 10^3`
  * `1 <= nums1[i] <= 10^3`
  * `0 <= nums2[i] <= 10^3`
  * `nums1.length == nums2.length`
  * `0 <= x <= 10^6`


## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸¤ä¸ªé•¿åº¦ç›¸ç­‰ä¸‹æ ‡ä» **0**  å¼€å§‹çš„æ•´æ•°æ•°ç»„ `nums1` å’Œ `nums2` ã€‚æ¯ä¸€ç§’ï¼Œå¯¹äºæ‰€æœ‰ä¸‹æ ‡ `0 <= i <
nums1.length` ï¼Œ`nums1[i]` çš„å€¼éƒ½å¢åŠ  `nums2[i]` ã€‚æ“ä½œ **å®Œæˆå**  ï¼Œä½ å¯ä»¥è¿›è¡Œå¦‚ä¸‹æ“ä½œï¼š

  * é€‰æ‹©ä»»ä¸€æ»¡è¶³ `0 <= i < nums1.length` çš„ä¸‹æ ‡ `i` ï¼Œå¹¶ä½¿ `nums1[i] = 0` ã€‚

åŒæ—¶ç»™ä½ ä¸€ä¸ªæ•´æ•° `x` ã€‚

è¯·ä½ è¿”å›ä½¿ `nums1` ä¸­æ‰€æœ‰å…ƒç´ ä¹‹å’Œ **å°äºç­‰äº**  `x` æ‰€éœ€è¦çš„ **æœ€å°‘**  æ—¶é—´ï¼Œå¦‚æœæ— æ³•å®ç°ï¼Œé‚£ä¹ˆè¿”å› `-1` ã€‚



**ç¤ºä¾‹ 1ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** nums1 = [1,2,3], nums2 = [1,2,3], x = 4
> 
> **è¾“å‡ºï¼š** 3
> 
> **è§£é‡Šï¼š**
> 
> ç¬¬ 1 ç§’ï¼Œæˆ‘ä»¬å¯¹ i = 0 è¿›è¡Œæ“ä½œï¼Œå¾—åˆ° nums1 = [0,2+2,3+3] = [0,4,6] ã€‚
> 
> ç¬¬ 2 ç§’ï¼Œæˆ‘ä»¬å¯¹ i = 1 è¿›è¡Œæ“ä½œï¼Œå¾—åˆ° nums1 = [0+1,0,6+3] = [1,0,9] ã€‚
> 
> ç¬¬ 3 ç§’ï¼Œæˆ‘ä»¬å¯¹ i = 2 è¿›è¡Œæ“ä½œï¼Œå¾—åˆ° nums1 = [1+1,0+2,0] = [2,2,0] ã€‚
> 
> ç°åœ¨ nums1 çš„å’Œä¸º 4 ã€‚ä¸å­˜åœ¨æ›´å°‘æ¬¡æ•°çš„æ“ä½œï¼Œæ‰€ä»¥æˆ‘ä»¬è¿”å› 3 ã€‚
> 
> 

**ç¤ºä¾‹ 2ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** nums1 = [1,2,3], nums2 = [3,3,3], x = 4
> 
> **è¾“å‡ºï¼š** -1
> 
> **è§£é‡Šï¼š** ä¸ç®¡å¦‚ä½•æ“ä½œï¼Œnums1 çš„å’Œæ€»æ˜¯ä¼šè¶…è¿‡ x ã€‚
> 
> 



**æç¤ºï¼š**

  * `1 <= nums1.length <= 10^3`
  * `1 <= nums1[i] <= 10^3`
  * `0 <= nums2[i] <= 10^3`
  * `nums1.length == nums2.length`
  * `0 <= x <= 10^6`


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```