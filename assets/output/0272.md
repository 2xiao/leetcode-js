# [272. Closest Binary Search Tree Value II](https://leetcode.com/problems/closest-binary-search-tree-value-ii/)

ðŸ”´ <font color=#ff334b>Hard</font>&emsp; ðŸ”–&ensp; [`æ ˆ`](/leetcode/outline/tag/stack.md) [`æ ‘`](/leetcode/outline/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/leetcode/outline/tag/depth-first-search.md) [`äºŒå‰æœç´¢æ ‘`](/leetcode/outline/tag/binary-search-tree.md) [`åŒæŒ‡é’ˆ`](/leetcode/outline/tag/two-pointers.md) [`äºŒå‰æ ‘`](/leetcode/outline/tag/binary-tree.md) [`å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰`](/leetcode/outline/tag/heap-priority-queue.md)&emsp; ðŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/closest-binary-search-tree-value-ii/)

## é¢˜ç›®

Given a non-empty binary search tree and a target value, find `k` values in the BST that are closest to the target.

**Note:**

- Given target value is a floating point.
- You may assume `k` is always valid, that is: `k â‰¤ total nodes`.
- You are guaranteed to have only one unique set of `k` values in the BST that are closest to the target.

**Example:**

        4
       / \
      2   5
     / \
    1   3

> Input: root = [4,2,5,1,3], target = 3.714286, and k = 2
>
> Output: [4,3]

**Follow up:**

Assume that the BST is balanced, could you solve it in less than `O(n)` runtime (where `n = total nodes`)?

## é¢˜ç›®å¤§æ„

ç»™å®šä¸€ä¸ªä¸ä¸ºç©ºçš„äºŒå‰æœç´¢æ ‘å’Œä¸€ä¸ªç›®æ ‡å€¼ `target`ï¼Œè¯·åœ¨è¯¥äºŒå‰æœç´¢æ ‘ä¸­æ‰¾åˆ°æœ€æŽ¥è¿‘ç›®æ ‡å€¼ `target` çš„ `k` ä¸ªå€¼ã€‚

**æ³¨æ„ï¼š**

- ç»™å®šçš„ç›®æ ‡å€¼ `target` æ˜¯ä¸€ä¸ªæµ®ç‚¹æ•°
- ä½ å¯ä»¥é»˜è®¤ `k` å€¼æ°¸è¿œæ˜¯æœ‰æ•ˆçš„ï¼Œå³ `k` â‰¤ æ€»ç»“ç‚¹æ•°
- é¢˜ç›®ä¿è¯è¯¥äºŒå‰æœç´¢æ ‘ä¸­åªä¼šå­˜åœ¨ä¸€ç§ `k` ä¸ªå€¼é›†åˆæœ€æŽ¥è¿‘ç›®æ ‡å€¼

**æ‹“å±•ï¼š**

å‡è®¾è¯¥äºŒå‰æœç´¢æ ‘æ˜¯å¹³è¡¡çš„ï¼Œè¯·é—®æ‚¨æ˜¯å¦èƒ½åœ¨å°äºŽ `O(n)`ï¼ˆ`n` ä¸ºæ€»ç»“ç‚¹æ•°ï¼‰çš„æ—¶é—´å¤æ‚åº¦å†…è§£å†³è¯¥é—®é¢˜å‘¢ï¼Ÿ

## è§£é¢˜æ€è·¯

### æ€è·¯ä¸€ï¼šä¸­åºéåŽ†

è§£å†³è¿™ä¸ªé—®é¢˜çš„ä¸€ç§æ–¹æ³•æ˜¯é€šè¿‡ä¸­åºéåŽ†å¾—åˆ°ä¸€ä¸ªæŒ‰ç…§æ•°å€¼å‡åºæŽ’åˆ—çš„æ•°ç»„ï¼Œç„¶åŽä»Žæ•°ç»„ä¸­æ‰¾åˆ°è·ç¦»ç›®æ ‡å€¼æœ€è¿‘çš„ `k` ä¸ªæ•°ã€‚è¿™ä¸ªæ–¹æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ `O(n)`ï¼Œå…¶ä¸­ `n` æ˜¯æ ‘çš„èŠ‚ç‚¹æ•°é‡ã€‚

### æ€è·¯äºŒï¼šäºŒåˆ†æŸ¥æ‰¾

å¦‚æžœè¦åœ¨æ›´çŸ­çš„æ—¶é—´å†…è§£å†³é—®é¢˜ï¼Œå¯ä»¥åˆ©ç”¨äºŒåˆ†æœç´¢æ‰¾åˆ°ç¦»ç›®æ ‡å€¼æœ€è¿‘çš„èŠ‚ç‚¹ï¼Œç„¶åŽå‘ä¸¤ä¾§æ‰©å±•ï¼Œé€‰æ‹©æœ€æŽ¥è¿‘çš„ `k` ä¸ªèŠ‚ç‚¹ã€‚åœ¨æ¯æ¬¡æœç´¢æ—¶ï¼Œç”±äºŽä½¿ç”¨äº†äºŒåˆ†æœç´¢ï¼Œå¯ä»¥å°†æœç´¢èŒƒå›´ç¼©å°åˆ°å½“å‰èŠ‚ç‚¹çš„å·¦å­æ ‘æˆ–å³å­æ ‘ï¼Œè¿™æ ·æ¯æ¬¡æœç´¢éƒ½èƒ½å‡åŠå€™é€‰èŠ‚ç‚¹çš„æ•°é‡ã€‚å› æ­¤ï¼Œåœ¨å¹³è¡¡çš„æƒ…å†µä¸‹ï¼Œæ•´ä½“çš„æ—¶é—´å¤æ‚åº¦æ˜¯ `O(log n)`ã€‚

## ä»£ç 

::: code-tabs

@tab ä¸­åºéåŽ†

```javascript
/**
 * @param {TreeNode} root
 * @param {number} target
 * @param {number} k
 * @return {number[]}
 */
var closestKValues = function (root, target, k) {
	let arr = [];
	const tarverse = (root) => {
		if (!root) return;
		tarverse(root.left);
		arr.push(root.val);
		tarverse(root.right);
	};
	traverse(root);

	const res = [];
	let left = 0;
	let right = arr.length - 1;
	while (k > 0) {}
};
```

@tab äºŒåˆ†æŸ¥æ‰¾

```javascript

```

:::
