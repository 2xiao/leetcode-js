# [3117. åˆ’åˆ†æ•°ç»„å¾—åˆ°æœ€å°çš„å€¼ä¹‹å’Œ](https://leetcode.com/problems/minimum-sum-of-values-by-dividing-array)

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`ä½è¿ç®—`](/leetcode/outline/tag/bit-manipulation.md) [`çº¿æ®µæ ‘`](/leetcode/outline/tag/segment-tree.md) [`é˜Ÿåˆ—`](/leetcode/outline/tag/queue.md) [`æ•°ç»„`](/leetcode/outline/tag/array.md) [`äºŒåˆ†æŸ¥æ‰¾`](/leetcode/outline/tag/binary-search.md) [`åŠ¨æ€è§„åˆ’`](/leetcode/outline/tag/dynamic-programming.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/minimum-sum-of-values-by-dividing-array)


## é¢˜ç›®

You are given two arrays `nums` and `andValues` of length `n` and `m`
respectively.

The **value** of an array is equal to the **last** element of that array.

You have to divide `nums` into `m` **disjoint contiguous** subarrays such that
for the `ith` subarray `[li, ri]`, the bitwise `AND` of the subarray elements
is equal to `andValues[i]`, in other words, `nums[li] & nums[li + 1] & ... &
nums[ri] == andValues[i]` for all `1 <= i <= m`, where `&` represents the
bitwise `AND` operator.

Return _the**minimum** possible sum of the **values** of the _`m`
_subarrays_`nums` _is divided into_. _If it is not possible to divide_`nums`
_into_`m` _subarrays satisfying these conditions, return_ `-1`.



**Example 1:**

**Input:** nums = [1,4,3,3,2], andValues = [0,3,3,2]

**Output:** 12

**Explanation:**

The only possible way to divide `nums` is:

  1. `[1,4]` as `1 & 4 == 0`.
  2. `[3]` as the bitwise `AND` of a single element subarray is that element itself.
  3. `[3]` as the bitwise `AND` of a single element subarray is that element itself.
  4. `[2]` as the bitwise `AND` of a single element subarray is that element itself.

The sum of the values for these subarrays is `4 + 3 + 3 + 2 = 12`.

**Example 2:**

**Input:** nums = [2,3,5,7,7,7,5], andValues = [0,7,5]

**Output:** 17

**Explanation:**

There are three ways to divide `nums`:

  1. `[[2,3,5],[7,7,7],[5]]` with the sum of the values `5 + 7 + 5 == 17`.
  2. `[[2,3,5,7],[7,7],[5]]` with the sum of the values `7 + 7 + 5 == 19`.
  3. `[[2,3,5,7,7],[7],[5]]` with the sum of the values `7 + 7 + 5 == 19`.

The minimum possible sum of the values is `17`.

**Example 3:**

**Input:** nums = [1,2,3,4], andValues = [2]

**Output:** -1

**Explanation:**

The bitwise `AND` of the entire array `nums` is `0`. As there is no possible
way to divide `nums` into a single subarray to have the bitwise `AND` of
elements `2`, return `-1`.



**Constraints:**

  * `1 <= n == nums.length <= 10^4`
  * `1 <= m == andValues.length <= min(n, 10)`
  * `1 <= nums[i] < 10^5`
  * `0 <= andValues[j] < 10^5`


## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸¤ä¸ªæ•°ç»„ `nums` å’Œ `andValues`ï¼Œé•¿åº¦åˆ†åˆ«ä¸º `n` å’Œ `m`ã€‚

æ•°ç»„çš„ **å€¼** ç­‰äºè¯¥æ•°ç»„çš„ **æœ€åä¸€ä¸ª** å…ƒç´ ã€‚

ä½ éœ€è¦å°† `nums` åˆ’åˆ†ä¸º `m` ä¸ª **ä¸ç›¸äº¤çš„è¿ç»­** å­æ•°ç»„ï¼Œå¯¹äºç¬¬ `ith` ä¸ªå­æ•°ç»„ `[li, ri]`ï¼Œå­æ•°ç»„å…ƒç´ çš„æŒ‰ä½ `AND`
è¿ç®—ç»“æœç­‰äº `andValues[i]`ï¼Œæ¢å¥è¯è¯´ï¼Œå¯¹æ‰€æœ‰çš„ `1 <= i <= m`ï¼Œ`nums[li] & nums[li + 1] & ... &
nums[ri] == andValues[i]` ï¼Œå…¶ä¸­ `&` è¡¨ç¤ºæŒ‰ä½ `AND` è¿ç®—ç¬¦ã€‚

è¿”å›å°† `nums` åˆ’åˆ†ä¸º `m` ä¸ªå­æ•°ç»„æ‰€èƒ½å¾—åˆ°çš„å¯èƒ½çš„ **æœ€å°** å­æ•°ç»„ **å€¼** ä¹‹å’Œã€‚å¦‚æœæ— æ³•å®Œæˆè¿™æ ·çš„åˆ’åˆ†ï¼Œåˆ™è¿”å› `-1` ã€‚



**ç¤ºä¾‹ 1ï¼š**

**è¾“å…¥ï¼š** nums = [1,4,3,3,2], andValues = [0,3,3,2]

**è¾“å‡ºï¼š** 12

**è§£é‡Šï¼š**

å”¯ä¸€å¯èƒ½çš„åˆ’åˆ†æ–¹æ³•ä¸ºï¼š

  1. `[1,4]` å› ä¸º `1 & 4 == 0`
  2. `[3]` å› ä¸ºå•å…ƒç´ å­æ•°ç»„çš„æŒ‰ä½ `AND` ç»“æœå°±æ˜¯è¯¥å…ƒç´ æœ¬èº«
  3. `[3]` å› ä¸ºå•å…ƒç´ å­æ•°ç»„çš„æŒ‰ä½ `AND` ç»“æœå°±æ˜¯è¯¥å…ƒç´ æœ¬èº«
  4. `[2]` å› ä¸ºå•å…ƒç´ å­æ•°ç»„çš„æŒ‰ä½ `AND` ç»“æœå°±æ˜¯è¯¥å…ƒç´ æœ¬èº«

è¿™äº›å­æ•°ç»„çš„å€¼ä¹‹å’Œä¸º `4 + 3 + 3 + 2 = 12`

**ç¤ºä¾‹ 2ï¼š**

**è¾“å…¥ï¼š** nums = [2,3,5,7,7,7,5], andValues = [0,7,5]

**è¾“å‡ºï¼š** 17

**è§£é‡Šï¼š**

åˆ’åˆ† `nums` çš„ä¸‰ç§æ–¹å¼ä¸ºï¼š

  1. `[[2,3,5],[7,7,7],[5]]` å…¶ä¸­å­æ•°ç»„çš„å€¼ä¹‹å’Œä¸º `5 + 7 + 5 = 17`
  2. `[[2,3,5,7],[7,7],[5]]` å…¶ä¸­å­æ•°ç»„çš„å€¼ä¹‹å’Œä¸º `7 + 7 + 5 = 19`
  3. `[[2,3,5,7,7],[7],[5]]` å…¶ä¸­å­æ•°ç»„çš„å€¼ä¹‹å’Œä¸º `7 + 7 + 5 = 19`

å­æ•°ç»„å€¼ä¹‹å’Œçš„æœ€å°å¯èƒ½å€¼ä¸º `17`

**ç¤ºä¾‹ 3ï¼š**

**è¾“å…¥ï¼š** nums = [1,2,3,4], andValues = [2]

**è¾“å‡ºï¼š** -1

**è§£é‡Šï¼š**

æ•´ä¸ªæ•°ç»„ `nums` çš„æŒ‰ä½ `AND` ç»“æœä¸º `0`ã€‚ç”±äºæ— æ³•å°† `nums` åˆ’åˆ†ä¸ºå•ä¸ªå­æ•°ç»„ä½¿å¾—å…ƒç´ çš„æŒ‰ä½ `AND` ç»“æœä¸º `2`ï¼Œå› æ­¤è¿”å›
`-1`ã€‚



**æç¤ºï¼š**

  * `1 <= n == nums.length <= 10^4`
  * `1 <= m == andValues.length <= min(n, 10)`
  * `1 <= nums[i] < 10^5`
  * `0 <= andValues[j] < 10^5`


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 2547 | [æ‹†åˆ†æ•°ç»„çš„æœ€å°ä»£ä»·](https://leetcode.com/problems/minimum-cost-to-split-an-array) |  |  [`æ•°ç»„`](/leetcode/outline/tag/array.md) [`å“ˆå¸Œè¡¨`](/leetcode/outline/tag/hash-table.md) [`åŠ¨æ€è§„åˆ’`](/leetcode/outline/tag/dynamic-programming.md) `1+` | <font color=#ff334b>Hard</font> |
| 2578 | [æœ€å°å’Œåˆ†å‰²](https://leetcode.com/problems/split-with-minimum-sum) |  |  [`è´ªå¿ƒ`](/leetcode/outline/tag/greedy.md) [`æ•°å­¦`](/leetcode/outline/tag/math.md) [`æ’åº`](/leetcode/outline/tag/sorting.md) | <font color=#15bd66>Easy</font> |
| 3171 | [æ‰¾åˆ°æŒ‰ä½æˆ–æœ€æ¥è¿‘ K çš„å­æ•°ç»„](https://leetcode.com/problems/find-subarray-with-bitwise-or-closest-to-k) |  |  [`ä½è¿ç®—`](/leetcode/outline/tag/bit-manipulation.md) [`çº¿æ®µæ ‘`](/leetcode/outline/tag/segment-tree.md) [`æ•°ç»„`](/leetcode/outline/tag/array.md) `1+` | <font color=#ff334b>Hard</font> |

<style>
.blue {
    background-color: #096dd9;
    padding: 0.25rem 0.5rem;
    margin: 0;
    font-size: 0.85em;
    border-radius: 3px;
    color: white;
    font-weight: 500;
}
table th:first-of-type { width: 10%; }
table th:nth-of-type(2) { width: 35%; }
table th:nth-of-type(3) { width: 10%; }
table th:nth-of-type(4) { width: 35%; }
table th:nth-of-type(5) { width: 10%; }
</style>
