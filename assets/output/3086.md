# [3086. æ‹¾èµ· K ä¸ª 1 éœ€è¦çš„æœ€å°‘è¡ŒåŠ¨æ¬¡æ•°](https://2xiao.github.io/leetcode-js/problem/3086.html)

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`è´ªå¿ƒ`](/tag/greedy.md) [`æ•°ç»„`](/tag/array.md) [`å‰ç¼€å’Œ`](/tag/prefix-sum.md) [`æ»‘åŠ¨çª—å£`](/tag/sliding-window.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/minimum-moves-to-pick-k-ones) [`LeetCode`](https://leetcode.com/problems/minimum-moves-to-pick-k-ones)

## é¢˜ç›®

You are given a binary array `nums` of length `n`, a **positive** integer `k`
and a **non-negative** integer `maxChanges`.

Alice plays a game, where the goal is for Alice to pick up `k` ones from
`nums` using the **minimum** number of **moves**. When the game starts, Alice
picks up any index `aliceIndex` in the range `[0, n - 1]` and stands there. If
`nums[aliceIndex] == 1` , Alice picks up the one and `nums[aliceIndex]`
becomes `0`(this **does not** count as a move). After this, Alice can make
**any** number of **moves** (**including** **zero**) where in each move Alice
must perform **exactly** one of the following actions:

  * Select any index `j != aliceIndex` such that `nums[j] == 0` and set `nums[j] = 1`. This action can be performed **at** **most** `maxChanges` times.
  * Select any two adjacent indices `x` and `y` (`|x - y| == 1`) such that `nums[x] == 1`, `nums[y] == 0`, then swap their values (set `nums[y] = 1` and `nums[x] = 0`). If `y == aliceIndex`, Alice picks up the one after this move and `nums[y]` becomes `0`.

Return _the**minimum** number of moves required by Alice to pick
**exactly**_`k` _ones_.



**Example 1:**

**Input:** nums = [1,1,0,0,0,1,1,0,0,1], k = 3, maxChanges = 1

**Output:** 3

**Explanation:** Alice can pick up `3` ones in `3` moves, if Alice performs
the following actions in each move when standing at `aliceIndex == 1`:

  * At the start of the game Alice picks up the one and `nums[1]` becomes `0`. `nums` becomes `[1,**_0_** ,0,0,0,1,1,0,0,1]`.
  * Select `j == 2` and perform an action of the first type. `nums` becomes `[1,**_0_** ,1,0,0,1,1,0,0,1]`
  * Select `x == 2` and `y == 1`, and perform an action of the second type. `nums` becomes `[1,**_1_** ,0,0,0,1,1,0,0,1]`. As `y == aliceIndex`, Alice picks up the one and `nums` becomes `[1,**_0_** ,0,0,0,1,1,0,0,1]`.
  * Select `x == 0` and `y == 1`, and perform an action of the second type. `nums` becomes `[0,**_1_** ,0,0,0,1,1,0,0,1]`. As `y == aliceIndex`, Alice picks up the one and `nums` becomes `[0,**_0_** ,0,0,0,1,1,0,0,1]`.

Note that it may be possible for Alice to pick up `3` ones using some other
sequence of `3` moves.

**Example 2:**

**Input:** nums = [0,0,0,0], k = 2, maxChanges = 3

**Output:** 4

**Explanation:** Alice can pick up `2` ones in `4` moves, if Alice performs
the following actions in each move when standing at `aliceIndex == 0`:

  * Select `j == 1` and perform an action of the first type. `nums` becomes `[**_0_** ,1,0,0]`.
  * Select `x == 1` and `y == 0`, and perform an action of the second type. `nums` becomes `[**_1_** ,0,0,0]`. As `y == aliceIndex`, Alice picks up the one and `nums` becomes `[**_0_** ,0,0,0]`.
  * Select `j == 1` again and perform an action of the first type. `nums` becomes `[**_0_** ,1,0,0]`.
  * Select `x == 1` and `y == 0` again, and perform an action of the second type. `nums` becomes `[**_1_** ,0,0,0]`. As `y == aliceIndex`, Alice picks up the one and `nums` becomes `[**_0_** ,0,0,0]`.



**Constraints:**

  * `2 <= n <= 10^5`
  * `0 <= nums[i] <= 1`
  * `1 <= k <= 10^5`
  * `0 <= maxChanges <= 10^5`
  * `maxChanges + sum(nums) >= k`


## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ªä¸‹æ ‡ä» **0** å¼€å§‹çš„äºŒè¿›åˆ¶æ•°ç»„ `nums`ï¼Œå…¶é•¿åº¦ä¸º `n` ï¼›å¦ç»™ä½ ä¸€ä¸ª **æ­£æ•´æ•°**`k` ä»¥åŠä¸€ä¸ª
**éè´Ÿæ•´æ•°**`maxChanges` ã€‚

Alice åœ¨ç©ä¸€ä¸ªæ¸¸æˆï¼Œæ¸¸æˆçš„ç›®æ ‡æ˜¯è®© Alice ä½¿ç”¨ **æœ€å°‘** æ•°é‡çš„ **è¡ŒåŠ¨** æ¬¡æ•°ä» `nums` ä¸­æ‹¾èµ· `k` ä¸ª 1
ã€‚æ¸¸æˆå¼€å§‹æ—¶ï¼ŒAlice å¯ä»¥é€‰æ‹©æ•°ç»„ `[0, n - 1]` èŒƒå›´å†…çš„ä»»ä½•ç´¢å¼• `aliceIndex` ç«™ç«‹ã€‚å¦‚æœ `nums[aliceIndex]
== 1` ï¼ŒAlice ä¼šæ‹¾èµ·ä¸€ä¸ª 1 ï¼Œå¹¶ä¸” `nums[aliceIndex]` å˜æˆ`0`ï¼ˆè¿™**ä¸ç®—** ä½œä¸€æ¬¡è¡ŒåŠ¨ï¼‰ã€‚ä¹‹åï¼ŒAlice å¯ä»¥æ‰§è¡Œ
**ä»»æ„æ•°é‡** çš„ **è¡ŒåŠ¨** ï¼ˆ**åŒ…æ‹¬****é›¶æ¬¡** ï¼‰ï¼Œåœ¨æ¯æ¬¡è¡ŒåŠ¨ä¸­ Alice å¿…é¡» **æ°å¥½** æ‰§è¡Œä»¥ä¸‹åŠ¨ä½œä¹‹ä¸€ï¼š

  * é€‰æ‹©ä»»æ„ä¸€ä¸ªä¸‹æ ‡ `j != aliceIndex` ä¸”æ»¡è¶³ `nums[j] == 0` ï¼Œç„¶åå°† `nums[j]` è®¾ç½®ä¸º `1` ã€‚è¿™ä¸ªåŠ¨ä½œæœ€å¤šå¯ä»¥æ‰§è¡Œ `maxChanges` æ¬¡ã€‚
  * é€‰æ‹©ä»»æ„ä¸¤ä¸ªç›¸é‚»çš„ä¸‹æ ‡ `x` å’Œ `y`ï¼ˆ`|x - y| == 1`ï¼‰ä¸”æ»¡è¶³ `nums[x] == 1`, `nums[y] == 0` ï¼Œç„¶åäº¤æ¢å®ƒä»¬çš„å€¼ï¼ˆå°† `nums[y] = 1` å’Œ `nums[x] = 0`ï¼‰ã€‚å¦‚æœ `y == aliceIndex`ï¼Œåœ¨è¿™æ¬¡è¡ŒåŠ¨å Alice æ‹¾èµ·ä¸€ä¸ª 1 ï¼Œå¹¶ä¸” `nums[y]` å˜æˆ `0` ã€‚

è¿”å› Alice æ‹¾èµ· **æ°å¥½**`k` ä¸ª 1 æ‰€éœ€çš„ **æœ€å°‘** è¡ŒåŠ¨æ¬¡æ•°ã€‚



**ç¤ºä¾‹ 1ï¼š**

**è¾“å…¥ï¼š** nums = [1,1,0,0,0,1,1,0,0,1], k = 3, maxChanges = 1

**è¾“å‡ºï¼š** 3

**è§£é‡Šï¼š** å¦‚æœæ¸¸æˆå¼€å§‹æ—¶ Alice åœ¨ `aliceIndex == 1` çš„ä½ç½®ä¸Šï¼ŒæŒ‰ç…§ä»¥ä¸‹æ­¥éª¤æ‰§è¡Œæ¯ä¸ªåŠ¨ä½œï¼Œä»–å¯ä»¥åˆ©ç”¨ `3` æ¬¡è¡ŒåŠ¨æ‹¾å–
`3` ä¸ª 1 ï¼š

  * æ¸¸æˆå¼€å§‹æ—¶ Alice æ‹¾å–äº†ä¸€ä¸ª 1 ï¼Œ`nums[1]` å˜æˆäº† `0`ã€‚æ­¤æ—¶ `nums` å˜ä¸º `[1,**_0_** ,0,0,0,1,1,0,0,1]` ã€‚
  * é€‰æ‹© `j == 2` å¹¶æ‰§è¡Œç¬¬ä¸€ç§ç±»å‹çš„åŠ¨ä½œã€‚`nums` å˜ä¸º `[1,**_0_** ,1,0,0,1,1,0,0,1]`
  * é€‰æ‹© `x == 2` å’Œ `y == 1` ï¼Œå¹¶æ‰§è¡Œç¬¬äºŒç§ç±»å‹çš„åŠ¨ä½œã€‚`nums` å˜ä¸º `[1,**_1_** ,0,0,0,1,1,0,0,1]` ã€‚ç”±äº `y == aliceIndex`ï¼ŒAlice æ‹¾å–äº†ä¸€ä¸ª 1 ï¼Œ`nums` å˜ä¸º  `[1,**_0_** ,0,0,0,1,1,0,0,1]` ã€‚
  * é€‰æ‹© `x == 0` å’Œ `y == 1` ï¼Œå¹¶æ‰§è¡Œç¬¬äºŒç§ç±»å‹çš„åŠ¨ä½œã€‚`nums` å˜ä¸º `[0,**_1_** ,0,0,0,1,1,0,0,1]` ã€‚ç”±äº `y == aliceIndex`ï¼ŒAlice æ‹¾å–äº†ä¸€ä¸ª 1 ï¼Œ`nums` å˜ä¸º  `[0,**_0_** ,0,0,0,1,1,0,0,1]` ã€‚

è¯·æ³¨æ„ï¼ŒAlice ä¹Ÿå¯èƒ½æ‰§è¡Œå…¶ä»–çš„ `3` æ¬¡è¡ŒåŠ¨åºåˆ—è¾¾æˆæ‹¾å– `3` ä¸ª 1 ã€‚

**ç¤ºä¾‹ 2ï¼š**

**è¾“å…¥ï¼š** nums = [0,0,0,0], k = 2, maxChanges = 3

**è¾“å‡ºï¼š** 4

**è§£é‡Šï¼š** å¦‚æœæ¸¸æˆå¼€å§‹æ—¶ Alice åœ¨ `aliceIndex == 0` çš„ä½ç½®ä¸Šï¼ŒæŒ‰ç…§ä»¥ä¸‹æ­¥éª¤æ‰§è¡Œæ¯ä¸ªåŠ¨ä½œï¼Œä»–å¯ä»¥åˆ©ç”¨ `4` æ¬¡è¡ŒåŠ¨æ‹¾å–
`2` ä¸ª 1 ï¼š

  * é€‰æ‹© `j == 1` å¹¶æ‰§è¡Œç¬¬ä¸€ç§ç±»å‹çš„åŠ¨ä½œã€‚`nums` å˜ä¸º `[**_0_** ,1,0,0]` ã€‚
  * é€‰æ‹© `x == 1` å’Œ `y == 0` ï¼Œå¹¶æ‰§è¡Œç¬¬äºŒç§ç±»å‹çš„åŠ¨ä½œã€‚`nums` å˜ä¸º `[**_1_** ,0,0,0]` ã€‚ç”±äº `y == aliceIndex`ï¼ŒAlice æ‹¾èµ·äº†ä¸€ä¸ª 1 ï¼Œ`nums` å˜ä¸º `[**_0_** ,0,0,0]` ã€‚
  * å†æ¬¡é€‰æ‹© `j == 1` å¹¶æ‰§è¡Œç¬¬ä¸€ç§ç±»å‹çš„åŠ¨ä½œã€‚`nums` å˜ä¸º `[**_0_** ,1,0,0]` ã€‚
  * å†æ¬¡é€‰æ‹© `x == 1` å’Œ `y == 0` ï¼Œå¹¶æ‰§è¡Œç¬¬äºŒç§ç±»å‹çš„åŠ¨ä½œã€‚`nums` å˜ä¸º `[**_1_** ,0,0,0]` ã€‚ç”±äº`y == aliceIndex`ï¼ŒAlice æ‹¾èµ·äº†ä¸€ä¸ª 1 ï¼Œ`nums` å˜ä¸º `[**_0_** ,0,0,0]` ã€‚



**æç¤ºï¼š**

  * `2 <= n <= 10^5`
  * `0 <= nums[i] <= 1`
  * `1 <= k <= 10^5`
  * `0 <= maxChanges <= 10^5`
  * `maxChanges + sum(nums) >= k`


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 1151 | [æœ€å°‘äº¤æ¢æ¬¡æ•°æ¥ç»„åˆæ‰€æœ‰çš„ 1 ğŸ”’](https://leetcode.com/problems/minimum-swaps-to-group-all-1s-together) |  |  [`æ•°ç»„`](/tag/array.md) [`æ»‘åŠ¨çª—å£`](/tag/sliding-window.md) | <font color=#ffb800>Medium</font> |