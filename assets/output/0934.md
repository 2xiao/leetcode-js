# [934. æœ€çŸ­çš„æ¡¥](https://leetcode.com/problems/shortest-bridge)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/outline/tag/depth-first-search.md) [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/outline/tag/breadth-first-search.md) [`æ•°ç»„`](/outline/tag/array.md) [`çŸ©é˜µ`](/outline/tag/matrix.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/shortest-bridge)

## é¢˜ç›®

You are given an `n x n` binary matrix `grid` where `1` represents land and
`0` represents water.

An **island** is a 4-directionally connected group of `1`'s not connected to
any other `1`'s. There are **exactly two islands** in `grid`.

You may change `0`'s to `1`'s to connect the two islands to form **one
island**.

Return _the smallest number of_`0` _' s you must flip to connect the two
islands_.



**Example 1:**

> Input: grid = [[0,1],[1,0]]
> 
> Output: 1

**Example 2:**

> Input: grid = [[0,1,0],[0,0,0],[0,0,1]]
> 
> Output: 2

**Example 3:**

> Input: grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]
> 
> Output: 1

**Constraints:**

  * `n == grid.length == grid[i].length`
  * `2 <= n <= 100`
  * `grid[i][j]` is either `0` or `1`.
  * There are exactly two islands in `grid`.


## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ªå¤§å°ä¸º `n x n` çš„äºŒå…ƒçŸ©é˜µ `grid` ï¼Œå…¶ä¸­ `1` è¡¨ç¤ºé™†åœ°ï¼Œ`0` è¡¨ç¤ºæ°´åŸŸã€‚

**å²›** æ˜¯ç”±å››é¢ç›¸è¿çš„ `1` å½¢æˆçš„ä¸€ä¸ªæœ€å¤§ç»„ï¼Œå³ä¸ä¼šä¸éç»„å†…çš„ä»»ä½•å…¶ä»– `1` ç›¸è¿ã€‚`grid` ä¸­ **æ°å¥½å­˜åœ¨ä¸¤åº§å²›** ã€‚

ä½ å¯ä»¥å°†ä»»æ„æ•°é‡çš„ `0` å˜ä¸º `1` ï¼Œä»¥ä½¿ä¸¤åº§å²›è¿æ¥èµ·æ¥ï¼Œå˜æˆ **ä¸€åº§å²›** ã€‚

è¿”å›å¿…é¡»ç¿»è½¬çš„ `0` çš„æœ€å°æ•°ç›®ã€‚



**ç¤ºä¾‹ 1ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** grid = [[0,1],[1,0]]
> 
> **è¾“å‡ºï¼š** 1
> 
> 

**ç¤ºä¾‹ 2ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** grid = [[0,1,0],[0,0,0],[0,0,1]]
> 
> **è¾“å‡ºï¼š** 2
> 
> 

**ç¤ºä¾‹ 3ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]
> 
> **è¾“å‡ºï¼š** 1
> 
> 



**æç¤ºï¼š**

  * `n == grid.length == grid[i].length`
  * `2 <= n <= 100`
  * `grid[i][j]` ä¸º `0` æˆ– `1`
  * `grid` ä¸­æ°æœ‰ä¸¤ä¸ªå²›


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 2998 | [ä½¿ X å’Œ Y ç›¸ç­‰çš„æœ€å°‘æ“ä½œæ¬¡æ•°](https://leetcode.com/problems/minimum-number-of-operations-to-make-x-and-y-equal) |  |  [`å¹¿åº¦ä¼˜å…ˆæœç´¢`](/outline/tag/breadth-first-search.md) [`è®°å¿†åŒ–æœç´¢`](/outline/tag/memoization.md) [`åŠ¨æ€è§„åˆ’`](/outline/tag/dynamic-programming.md) | <font color=#ffb800>Medium</font> |

<style>
.blue {
    background-color: #096dd9;
    padding: 0.25rem 0.5rem;
    margin: 0;
    font-size: 0.85em;
    border-radius: 3px;
    color: white;
    font-weight: 500;
}
table th:first-of-type { width: 10%; }
table th:nth-of-type(2) { width: 35%; }
table th:nth-of-type(3) { width: 10%; }
table th:nth-of-type(4) { width: 35%; }
table th:nth-of-type(5) { width: 10%; }
</style>
