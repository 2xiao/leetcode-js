# [960. åˆ åˆ—é€ åº III](https://leetcode.com/problems/delete-columns-to-make-sorted-iii)

ğŸ”´ <font color=#ff334b>Hard</font>&emsp; ğŸ”–&ensp; [`æ•°ç»„`](/leetcode/outline/tag/array.md) [`å­—ç¬¦ä¸²`](/leetcode/outline/tag/string.md) [`åŠ¨æ€è§„åˆ’`](/leetcode/outline/tag/dynamic-programming.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/delete-columns-to-make-sorted-iii)

## é¢˜ç›®

You are given an array of `n` strings `strs`, all of the same length.

We may choose any deletion indices, and we delete all the characters in those
indices for each string.

For example, if we have `strs = ["abcdef","uvwxyz"]` and deletion indices `{0,
2, 3}`, then the final array after deletions is `["bef", "vyz"]`.

Suppose we chose a set of deletion indices `answer` such that after deletions,
the final array has **every string (row) in lexicographic** order. (i.e.,
`(strs[0][0] <= strs[0][1] <= ... <= strs[0][strs[0].length - 1])`, and
`(strs[1][0] <= strs[1][1] <= ... <= strs[1][strs[1].length - 1])`, and so
on). Return _the minimum possible value of_ `answer.length`.



**Example 1:**

> Input: strs = ["babca","bbazb"]
> 
> Output: 3
> 
> Explanation: After deleting columns 0, 1, and 4, the final array is strs = ["bc", "az"].
> 
> Both these rows are individually in lexicographic order (ie. strs[0][0] <= strs[0][1] and strs[1][0] <= strs[1][1]).
> 
> Note that strs[0] > strs[1] - the array strs is not necessarily in lexicographic order.

**Example 2:**

> Input: strs = ["edcba"]
> 
> Output: 4
> 
> Explanation: If we delete less than 4 columns, the only row will not be lexicographically sorted.

**Example 3:**

> Input: strs = ["ghi","def","abc"]
> 
> Output: 0
> 
> Explanation: All rows are already lexicographically sorted.

**Constraints:**

  * `n == strs.length`
  * `1 <= n <= 100`
  * `1 <= strs[i].length <= 100`
  * `strs[i]` consists of lowercase English letters.

  *  


## é¢˜ç›®å¤§æ„

ç»™å®šç”± `n` ä¸ªå°å†™å­—æ¯å­—ç¬¦ä¸²ç»„æˆçš„æ•°ç»„ `strs` ï¼Œå…¶ä¸­æ¯ä¸ªå­—ç¬¦ä¸²é•¿åº¦ç›¸ç­‰ã€‚

é€‰å–ä¸€ä¸ªåˆ é™¤ç´¢å¼•åºåˆ—ï¼Œå¯¹äº `strs` ä¸­çš„æ¯ä¸ªå­—ç¬¦ä¸²ï¼Œåˆ é™¤å¯¹åº”æ¯ä¸ªç´¢å¼•å¤„çš„å­—ç¬¦ã€‚

æ¯”å¦‚ï¼Œæœ‰ `strs = ["abcdef","uvwxyz"]` ï¼Œåˆ é™¤ç´¢å¼•åºåˆ— `{0, 2, 3}` ï¼Œåˆ é™¤åä¸º `["bef", "vyz"]` ã€‚

å‡è®¾ï¼Œæˆ‘ä»¬é€‰æ‹©äº†ä¸€ç»„åˆ é™¤ç´¢å¼• `answer` ï¼Œé‚£ä¹ˆåœ¨æ‰§è¡Œåˆ é™¤æ“ä½œä¹‹åï¼Œæœ€ç»ˆå¾—åˆ°çš„æ•°ç»„çš„è¡Œä¸­çš„ **æ¯ä¸ªå…ƒç´ ** éƒ½æ˜¯æŒ‰**å­—å…¸åº** æ’åˆ—çš„ï¼ˆå³
`(strs[0][0] <= strs[0][1] <= ... <= strs[0][strs[0].length - 1])` å’Œ
`(strs[1][0] <= strs[1][1] <= ... <= strs[1][strs[1].length - 1])` ï¼Œä¾æ­¤ç±»æ¨ï¼‰ã€‚

è¯·è¿”å› _ `answer.length` çš„æœ€å°å¯èƒ½å€¼_ ã€‚



**ç¤ºä¾‹ 1ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** strs = ["babca","bbazb"]
> 
> **è¾“å‡ºï¼š** 3
> 
> **è§£é‡Šï¼š** åˆ é™¤ 0ã€1 å’Œ 4 è¿™ä¸‰åˆ—åï¼Œæœ€ç»ˆå¾—åˆ°çš„æ•°ç»„æ˜¯ strs = ["bc", "az"]ã€‚
> 
> è¿™ä¸¤è¡Œæ˜¯åˆ†åˆ«æŒ‰å­—å…¸åºæ’åˆ—çš„ï¼ˆå³ï¼Œstrs[0][0] <= strs[0][1] ä¸” strs[1][0] <= strs[1][1]ï¼‰ã€‚
> 
> æ³¨æ„ï¼Œstrs[0] > strs[1] â€”â€” æ•°ç»„ strs ä¸ä¸€å®šæ˜¯æŒ‰å­—å…¸åºæ’åˆ—çš„ã€‚
> 
> 

**ç¤ºä¾‹ 2ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** strs = ["edcba"]
> 
> **è¾“å‡ºï¼š** 4
> 
> **è§£é‡Šï¼š** å¦‚æœåˆ é™¤çš„åˆ—å°‘äº 4 åˆ—ï¼Œåˆ™å‰©ä¸‹çš„è¡Œéƒ½ä¸ä¼šæŒ‰å­—å…¸åºæ’åˆ—ã€‚
> 
> 

**ç¤ºä¾‹ 3ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** strs = ["ghi","def","abc"]
> 
> **è¾“å‡ºï¼š** 0
> 
> **è§£é‡Šï¼š** æ‰€æœ‰è¡Œéƒ½å·²æŒ‰å­—å…¸åºæ’åˆ—ã€‚
> 
> 



**æç¤ºï¼š**

  * `n == strs.length`
  * `1 <= n <= 100`
  * `1 <= strs[i].length <= 100`
  * `strs[i]` ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆ


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```