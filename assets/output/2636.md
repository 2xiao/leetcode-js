# [2636. Promise å¯¹è±¡æ±  ğŸ”’](https://2xiao.github.io/leetcode-js/problem/2636.html)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/promise-pool) [`LeetCode`](https://leetcode.com/problems/promise-pool)

## é¢˜ç›®

Given an array of asynchronous functions `functions` and a **pool limit**
`n`, return an asynchronous function `promisePool`. It should return a promise
that resolves when all the input functions resolve.

**Pool limit** is defined as the maximum number promises that can be pending
at once. `promisePool` should begin execution of as many functions as possible
and continue executing new functions when old promises resolve. `promisePool`
should execute `functions[i]` then `functions[i + 1]` then `functions[i + 2]`,
etc. When the last promise resolves, `promisePool` should also resolve.

For example, if `n = 1`, `promisePool` will execute one function at a time in
series. However, if `n = 2`, it first executes two functions. When either of
the two functions resolve, a 3rd function should be executed (if available),
and so on until there are no functions left to execute.

You can assume all `functions` never reject. It is acceptable for
`promisePool` to return a promise that resolves any value.



**Example 1:**

> Input: 
> 
> functions = [
> 
>   () => new Promise(res => setTimeout(res, 300)),
> 
>   () => new Promise(res => setTimeout(res, 400)),
> 
>   () => new Promise(res => setTimeout(res, 200))
> 
> ]
> 
> n = 2
> 
> Output: [[300,400,500],500]
> 
> Explanation:
> 
> Three functions are passed in. They sleep for 300ms, 400ms, and 200ms respectively.
> 
> They resolve at 300ms, 400ms, and 500ms respectively. The returned promise resolves at 500ms.
> 
> At t=0, the first 2 functions are executed. The pool size limit of 2 is reached.
> 
> At t=300, the 1st function resolves, and the 3rd function is executed. Pool size is 2.
> 
> At t=400, the 2nd function resolves. There is nothing left to execute. Pool size is 1.
> 
> At t=500, the 3rd function resolves. Pool size is zero so the returned promise also resolves.

**Example 2:**

> Input: functions = [
> 
>   () => new Promise(res => setTimeout(res, 300)),
> 
>   () => new Promise(res => setTimeout(res, 400)),
> 
>   () => new Promise(res => setTimeout(res, 200))
> 
> ]
> 
> n = 5
> 
> Output: [[300,400,200],400]
> 
> Explanation:
> 
> The three input promises resolve at 300ms, 400ms, and 200ms respectively.
> 
> The returned promise resolves at 400ms.
> 
> At t=0, all 3 functions are executed. The pool limit of 5 is never met.
> 
> At t=200, the 3rd function resolves. Pool size is 2.
> 
> At t=300, the 1st function resolved. Pool size is 1.
> 
> At t=400, the 2nd function resolves. Pool size is 0, so the returned promise also resolves.

**Example 3:**

> Input:
> 
> functions = [
> 
>   () => new Promise(res => setTimeout(res, 300)),
> 
>   () => new Promise(res => setTimeout(res, 400)),
> 
>   () => new Promise(res => setTimeout(res, 200))
> 
> ]
> 
> n = 1
> 
> Output: [[300,700,900],900]
> 
> Explanation: The three input promises resolve at 300ms, 700ms, and 900ms respectively.
> 
> The returned promise resolves at 900ms.
> 
> At t=0, the 1st function is executed. Pool size is 1.
> 
> At t=300, the 1st function resolves and the 2nd function is executed. Pool size is 1.
> 
> At t=700, the 2nd function resolves and the 3rd function is executed. Pool size is 1.
> 
> At t=900, the 3rd function resolves. Pool size is 0 so the returned promise resolves.

**Constraints:**

  * `0 <= functions.length <= 10`
  * `1 <= n <= 10`


## é¢˜ç›®å¤§æ„

è¯·ä½ ç¼–å†™ä¸€ä¸ªå¼‚æ­¥å‡½æ•° `promisePool` ï¼Œå®ƒæ¥æ”¶ä¸€ä¸ªå¼‚æ­¥å‡½æ•°æ•°ç»„ `functions` å’Œ **æ± é™åˆ¶** `n`ã€‚å®ƒåº”è¯¥è¿”å›ä¸€ä¸ª
promise å¯¹è±¡ï¼Œå½“æ‰€æœ‰è¾“å…¥å‡½æ•°éƒ½æ‰§è¡Œå®Œæ¯•åï¼Œpromise å¯¹è±¡å°±æ‰§è¡Œå®Œæ¯•ã€‚

**æ± é™åˆ¶** å®šä¹‰æ˜¯ä¸€æ¬¡å¯ä»¥æŒ‚èµ·çš„æœ€å¤š promise å¯¹è±¡çš„æ•°é‡ã€‚`promisePool` åº”è¯¥å¼€å§‹æ‰§è¡Œå°½å¯èƒ½å¤šçš„å‡½æ•°ï¼Œå¹¶åœ¨æ—§çš„ promise
æ‰§è¡Œå®Œæ¯•åç»§ç»­æ‰§è¡Œæ–°å‡½æ•°ã€‚`promisePool` åº”è¯¥å…ˆæ‰§è¡Œ `functions[i]`ï¼Œå†æ‰§è¡Œ `functions[i + 1]`ï¼Œç„¶åæ‰§è¡Œ
`functions[i + 2]`ï¼Œç­‰ç­‰ã€‚å½“æœ€åä¸€ä¸ª promise æ‰§è¡Œå®Œæ¯•æ—¶ï¼Œ`promisePool` ä¹Ÿåº”è¯¥æ‰§è¡Œå®Œæ¯•ã€‚

ä¾‹å¦‚ï¼Œå¦‚æœ `n = 1` , `promisePool` åœ¨åºåˆ—ä¸­æ¯æ¬¡æ‰§è¡Œä¸€ä¸ªå‡½æ•°ã€‚ç„¶è€Œï¼Œå¦‚æœ `n = 2`
ï¼Œå®ƒé¦–å…ˆæ‰§è¡Œä¸¤ä¸ªå‡½æ•°ã€‚å½“ä¸¤ä¸ªå‡½æ•°ä¸­çš„ä»»ä½•ä¸€ä¸ªæ‰§è¡Œå®Œæ¯•åï¼Œå†æ‰§è¡Œç¬¬ä¸‰ä¸ªå‡½æ•°(å¦‚æœå®ƒæ˜¯å¯ç”¨çš„)ï¼Œä¾æ­¤ç±»æ¨ï¼Œç›´åˆ°æ²¡æœ‰å‡½æ•°è¦æ‰§è¡Œä¸ºæ­¢ã€‚

ä½ å¯ä»¥å‡è®¾æ‰€æœ‰çš„ `functions` éƒ½ä¸ä¼šè¢«æ‹’ç»ã€‚å¯¹äº `promisePool` æ¥è¯´ï¼Œè¿”å›ä¸€ä¸ªå¯ä»¥è§£æä»»ä½•å€¼çš„ promise éƒ½æ˜¯å¯ä»¥æ¥å—çš„ã€‚



**ç¤ºä¾‹ 1ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š**
> 
> functions = [
> 
>   () => new Promise(res => setTimeout(res, 300)),
> 
>   () => new Promise(res => setTimeout(res, 400)),
> 
>   () => new Promise(res => setTimeout(res, 200))
> 
> ]
> 
> n = 2
> 
> **è¾“å‡ºï¼š**[[300,400,500],500]
> 
> **è§£é‡Š**
> 
> ä¼ é€’äº†ä¸‰ä¸ªå‡½æ•°ã€‚å®ƒä»¬çš„ç¡çœ æ—¶é—´åˆ†åˆ«ä¸º 300msã€ 400ms å’Œ 200msã€‚
> 
> åœ¨ t=0 æ—¶ï¼Œæ‰§è¡Œå‰ä¸¤ä¸ªå‡½æ•°ã€‚æ± å¤§å°é™åˆ¶è¾¾åˆ° 2ã€‚
> 
> å½“ t=300 æ—¶ï¼Œç¬¬ä¸€ä¸ªå‡½æ•°æ‰§è¡Œå®Œæ¯•åï¼Œæ‰§è¡Œç¬¬3ä¸ªå‡½æ•°ã€‚æ± å¤§å°ä¸º 2ã€‚
> 
> åœ¨ t=400 æ—¶ï¼Œç¬¬äºŒä¸ªå‡½æ•°æ‰§è¡Œå®Œæ¯•åã€‚æ²¡æœ‰ä»€ä¹ˆå¯æ‰§è¡Œçš„äº†ã€‚æ± å¤§å°ä¸º 1ã€‚
> 
> åœ¨ t=500 æ—¶ï¼Œç¬¬ä¸‰ä¸ªå‡½æ•°æ‰§è¡Œå®Œæ¯•åã€‚æ± å¤§å°ä¸º 0ï¼Œå› æ­¤è¿”å›çš„ promise ä¹Ÿæ‰§è¡Œå®Œæˆã€‚
> 
> 

**ç¤ºä¾‹ 2ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** functions = [
> 
>   () => new Promise(res => setTimeout(res, 300)),
> 
>   () => new Promise(res => setTimeout(res, 400)),
> 
>   () => new Promise(res => setTimeout(res, 200))
> 
> ]
> 
> n = 5
> 
> **è¾“å‡ºï¼š**[[300,400,200],400]
> 
> **è§£é‡Šï¼š**
> 
> åœ¨ t=0 æ—¶ï¼Œæ‰€æœ‰3ä¸ªå‡½æ•°éƒ½è¢«æ‰§è¡Œã€‚æ± çš„é™åˆ¶å¤§å° 5 æ°¸è¿œä¸ä¼šæ»¡è¶³ã€‚
> 
> åœ¨ t=200 æ—¶ï¼Œç¬¬ä¸‰ä¸ªå‡½æ•°æ‰§è¡Œå®Œæ¯•åã€‚æ± å¤§å°ä¸º 2ã€‚
> 
> åœ¨ t=300 æ—¶ï¼Œç¬¬ä¸€ä¸ªå‡½æ•°æ‰§è¡Œå®Œæ¯•åã€‚æ± å¤§å°ä¸º 1ã€‚
> 
> åœ¨ t=400 æ—¶ï¼Œç¬¬äºŒä¸ªå‡½æ•°æ‰§è¡Œå®Œæ¯•åã€‚æ± å¤§å°ä¸º 0ï¼Œå› æ­¤è¿”å›çš„ promise ä¹Ÿæ‰§è¡Œå®Œæˆã€‚
> 
> 

**ç¤ºä¾‹ 3ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š**
> 
> functions = [
> 
>   () => new Promise(res => setTimeout(res, 300)),
> 
>   () => new Promise(res => setTimeout(res, 400)),
> 
>   () => new Promise(res => setTimeout(res, 200))
> 
> ]
> 
> n = 1
> 
> **è¾“å‡ºï¼š**[[300,700,900],900]
> 
> **è§£é‡Šï¼š**
> 
> åœ¨ t=0 æ—¶ï¼Œæ‰§è¡Œç¬¬ä¸€ä¸ªå‡½æ•°ã€‚æ± å¤§å°ä¸º1ã€‚
> 
> å½“ t=300 æ—¶ï¼Œç¬¬ä¸€ä¸ªå‡½æ•°æ‰§è¡Œå®Œæ¯•åï¼Œæ‰§è¡Œç¬¬äºŒä¸ªå‡½æ•°ã€‚æ± å¤§å°ä¸º 1ã€‚
> 
> å½“ t=700 æ—¶ï¼Œç¬¬äºŒä¸ªå‡½æ•°æ‰§è¡Œå®Œæ¯•åï¼Œæ‰§è¡Œç¬¬ä¸‰ä¸ªå‡½æ•°ã€‚æ± å¤§å°ä¸º 1ã€‚
> 
> åœ¨ t=900 æ—¶ï¼Œç¬¬ä¸‰ä¸ªå‡½æ•°æ‰§è¡Œå®Œæ¯•åã€‚æ± å¤§å°ä¸º 0ï¼Œå› æ­¤è¿”å›çš„ Promise ä¹Ÿæ‰§è¡Œå®Œæˆã€‚
> 
> 



**æç¤ºï¼š**

  * `0 <= functions.length <= 10`
  * `1 <= n <= 10`


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 2621 | [ç¡çœ å‡½æ•°](https://leetcode.com/problems/sleep) | [[âœ“]](/problem/2621.md) |  | <font color=#15bd66>Easy</font> |
| 2622 | [æœ‰æ—¶é—´é™åˆ¶çš„ç¼“å­˜](https://leetcode.com/problems/cache-with-time-limit) | [[âœ“]](/problem/2622.md) |  | <font color=#ffb800>Medium</font> |
| 2637 | [æœ‰æ—¶é—´é™åˆ¶çš„ Promise å¯¹è±¡](https://leetcode.com/problems/promise-time-limit) | [[âœ“]](/problem/2637.md) |  | <font color=#ffb800>Medium</font> |
| 2676 | [èŠ‚æµ ğŸ”’](https://leetcode.com/problems/throttle) | [[âœ“]](/problem/2676.md) |  | <font color=#ffb800>Medium</font> |