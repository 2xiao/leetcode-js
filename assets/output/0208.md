---
title: 208. 实现 Trie (前缀树)
description: LeetCode 208. 实现 Trie (前缀树)题解，Implement Trie (Prefix Tree)，包含解题思路、复杂度分析以及完整的 JavaScript 代码实现。
keywords:
  - LeetCode
  - 208. 实现 Trie (前缀树)
  - 实现 Trie (前缀树)
  - Implement Trie (Prefix Tree)
  - 解题思路
  - 设计
  - 字典树
  - 哈希表
  - 字符串
---

# 208. 实现 Trie (前缀树)

🟠 <font color=#ffb800>Medium</font>&emsp; 🔖&ensp; [`设计`](/tag/design.md) [`字典树`](/tag/trie.md) [`哈希表`](/tag/hash-table.md) [`字符串`](/tag/string.md)&emsp; 🔗&ensp;[`力扣`](https://leetcode.cn/problems/implement-trie-prefix-tree) [`LeetCode`](https://leetcode.com/problems/implement-trie-prefix-tree)

## 题目

A [**trie**](https://en.wikipedia.org/wiki/Trie) (pronounced as "try") or
**prefix tree** is a tree data structure used to efficiently store and
retrieve keys in a dataset of strings. There are various applications of this
data structure, such as autocomplete and spellchecker.

Implement the Trie class:

  * `Trie()` Initializes the trie object.
  * `void insert(String word)` Inserts the string `word` into the trie.
  * `boolean search(String word)` Returns `true` if the string `word` is in the trie (i.e., was inserted before), and `false` otherwise.
  * `boolean startsWith(String prefix)` Returns `true` if there is a previously inserted string `word` that has the prefix `prefix`, and `false` otherwise.



**Example 1:**

> 
> 
> 
> 
> 
> **Input**
> 
> ["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
> 
> [[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
> 
> **Output**
> 
> [null, null, true, false, true, null, true]
> 
> 
> 
> **Explanation**
> 
> Trie trie = new Trie();
> 
> trie.insert("apple");
> 
> trie.search("apple");   // return True
> 
> trie.search("app");> 
>  // return False
> 
> trie.startsWith("app"); // return True
> 
> trie.insert("app");
> 
> trie.search("app");> 
>  // return True

**Constraints:**

  * `1 <= word.length, prefix.length <= 2000`
  * `word` and `prefix` consist only of lowercase English letters.
  * At most `3 * 10^4` calls **in total** will be made to `insert`, `search`, and `startsWith`.


## 题目大意

**[Trie](https://baike.baidu.com/item/字典树/9825209?fr=aladdin)** （发音类似
"try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。

请你实现 Trie 类：

  * `Trie()` 初始化前缀树对象。
  * `void insert(String word)` 向前缀树中插入字符串 `word` 。
  * `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
  * `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。



**示例：**

> 
> 
> 
> 
> 
> **输入**
> 
> ["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
> 
> [[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
> 
> **输出**
> 
> [null, null, true, false, true, null, true]
> 
> 
> 
> **解释**
> 
> Trie trie = new Trie();
> 
> trie.insert("apple");
> 
> trie.search("apple");   // 返回 True
> 
> trie.search("app");> 
>  // 返回 False
> 
> trie.startsWith("app"); // 返回 True
> 
> trie.insert("app");
> 
> trie.search("app");> 
>  // 返回 True
> 
> 



**提示：**

  * `1 <= word.length, prefix.length <= 2000`
  * `word` 和 `prefix` 仅由小写英文字母组成
  * `insert`、`search` 和 `startsWith` 调用次数 **总计** 不超过 `3 * 10^4` 次


## 解题思路

#### 复杂度分析

- **时间复杂度**：`O()`，
- **空间复杂度**：`O()`，

## 代码

```javascript

```

## 相关题目

<!-- prettier-ignore -->
| 题号 | 标题 | 题解 | 标签 | 难度 | 力扣 |
| :------: | :------ | :------: | :------ | :------: | :------: |
| 211 | 添加与搜索单词 - 数据结构设计 | [[✓]](/problem/0211.md) |  [`深度优先搜索`](/tag/depth-first-search.md) [`设计`](/tag/design.md) [`字典树`](/tag/trie.md) `1+` | 🟠 | [🀄️](https://leetcode.cn/problems/design-add-and-search-words-data-structure) [🔗](https://leetcode.com/problems/design-add-and-search-words-data-structure) |
| 642 | 设计搜索自动补全系统 🔒 |  |  [`深度优先搜索`](/tag/depth-first-search.md) [`设计`](/tag/design.md) [`字典树`](/tag/trie.md) `4+` | 🔴 | [🀄️](https://leetcode.cn/problems/design-search-autocomplete-system) [🔗](https://leetcode.com/problems/design-search-autocomplete-system) |
| 648 | 单词替换 |  |  [`字典树`](/tag/trie.md) [`数组`](/tag/array.md) [`哈希表`](/tag/hash-table.md) `1+` | 🟠 | [🀄️](https://leetcode.cn/problems/replace-words) [🔗](https://leetcode.com/problems/replace-words) |
| 676 | 实现一个魔法字典 |  |  [`深度优先搜索`](/tag/depth-first-search.md) [`设计`](/tag/design.md) [`字典树`](/tag/trie.md) `2+` | 🟠 | [🀄️](https://leetcode.cn/problems/implement-magic-dictionary) [🔗](https://leetcode.com/problems/implement-magic-dictionary) |
| 1804 | 实现 Trie （前缀树） II 🔒 |  |  [`设计`](/tag/design.md) [`字典树`](/tag/trie.md) [`哈希表`](/tag/hash-table.md) `1+` | 🟠 | [🀄️](https://leetcode.cn/problems/implement-trie-ii-prefix-tree) [🔗](https://leetcode.com/problems/implement-trie-ii-prefix-tree) |
| 2227 | 加密解密字符串 |  |  [`设计`](/tag/design.md) [`字典树`](/tag/trie.md) [`数组`](/tag/array.md) `2+` | 🔴 | [🀄️](https://leetcode.cn/problems/encrypt-and-decrypt-strings) [🔗](https://leetcode.com/problems/encrypt-and-decrypt-strings) |
| 3042 | 统计前后缀下标对 I | [[✓]](/problem/3042.md) |  [`字典树`](/tag/trie.md) [`数组`](/tag/array.md) [`字符串`](/tag/string.md) `3+` | 🟢 | [🀄️](https://leetcode.cn/problems/count-prefix-and-suffix-pairs-i) [🔗](https://leetcode.com/problems/count-prefix-and-suffix-pairs-i) |
| 3045 | 统计前后缀下标对 II |  |  [`字典树`](/tag/trie.md) [`数组`](/tag/array.md) [`字符串`](/tag/string.md) `3+` | 🔴 | [🀄️](https://leetcode.cn/problems/count-prefix-and-suffix-pairs-ii) [🔗](https://leetcode.com/problems/count-prefix-and-suffix-pairs-ii) |