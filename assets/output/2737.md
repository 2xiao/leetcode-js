# [2737. æ‰¾åˆ°æœ€è¿‘çš„æ ‡è®°èŠ‚ç‚¹](https://leetcode.com/problems/find-the-closest-marked-node)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`å›¾`](/tag/graph.md) [`æ•°ç»„`](/tag/array.md) [`æœ€çŸ­è·¯`](/tag/shortest-path.md) [`å †ï¼ˆä¼˜å…ˆé˜Ÿåˆ—ï¼‰`](/tag/heap-priority-queue.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/find-the-closest-marked-node)

## é¢˜ç›®

You are given a positive integer `n` which is the number of nodes of a
**0-indexed directed weighted** graph and a **0-indexed** **2D array** `edges`
where `edges[i] = [ui, vi, wi]` indicates that there is an edge from node `ui`
to node `vi` with weight `wi`.

You are also given a node `s` and a node array `marked`; your task is to find
the **minimum** distance from `s` to **any** of the nodes in `marked`.

Return _an integer denoting the minimum distance from_`s` _to any node
in_`marked` _or_`-1` _if there are no paths from s to any of the marked
nodes_.



**Example 1:**

> Input: n = 4, edges = [[0,1,1],[1,2,3],[2,3,2],[0,3,4]], s = 0, marked = [2,3]
> 
> Output: 4
> 
> Explanation: There is one path from node 0 (the green node) to node 2 (a red node), which is 0->1->2, and has a distance of 1 + 3 = 4.
> 
> There are two paths from node 0 to node 3 (a red node), which are 0->1->2->3 and 0->3, the first one has a distance of 1 + 3 + 2 = 6 and the second one has a distance of 4.
> 
> The minimum of them is 4.
> 
> 

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2700-2799/2737.Find%20the%20Closest%20Marked%20Node/images/image_2023-06-13_16-34-38.png)

**Example 2:**

> Input: n = 5, edges = [[0,1,2],[0,2,4],[1,3,1],[2,3,3],[3,4,2]], s = 1, marked = [0,4]
> 
> Output: 3
> 
> Explanation: There are no paths from node 1 (the green node) to node 0 (a red node).
> 
> There is one path from node 1 to node 4 (a red node), which is 1->3->4, and has a distance of 1 + 2 = 3.
> 
> So the answer is 3.
> 
> 

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2700-2799/2737.Find%20the%20Closest%20Marked%20Node/images/image_2023-06-13_16-35-13.png)

**Example 3:**

> Input: n = 4, edges = [[0,1,1],[1,2,3],[2,3,2]], s = 3, marked = [0,1]
> 
> Output: -1
> 
> Explanation: There are no paths from node 3 (the green node) to any of the marked nodes (the red nodes), so the answer is -1.
> 
> 

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2700-2799/2737.Find%20the%20Closest%20Marked%20Node/images/image_2023-06-13_16-35-47.png)



**Constraints:**

  * `2 <= n <= 500`
  * `1 <= edges.length <= 10^4`
  * `edges[i].length = 3`
  * `0 <= edges[i][0], edges[i][1] <= n - 1`
  * `1 <= edges[i][2] <= 10^6`
  * `1 <= marked.length <= n - 1`
  * `0 <= s, marked[i] <= n - 1`
  * `s != marked[i]`
  * `marked[i] != marked[j]` for every `i != j`
  * The graph might have **repeated edges**.
  * The graph is generated such that it has no **self-loops**.


## é¢˜ç›®å¤§æ„

ç»™å®šä¸€ä¸ªæ­£æ•´æ•° `n` ï¼Œè¡¨ç¤ºä¸€ä¸ª **ç´¢å¼•ä» 0 å¼€å§‹çš„æœ‰å‘åŠ æƒ** å›¾çš„èŠ‚ç‚¹æ•°é‡ï¼Œä»¥åŠä¸€ä¸ª **ç´¢å¼•ä» 0 å¼€å§‹çš„äºŒç»´æ•°ç»„** `edges` ï¼Œå…¶ä¸­
`edges[i] = [ui, vi, wi]` è¡¨ç¤ºä»èŠ‚ç‚¹ `ui` åˆ°èŠ‚ç‚¹ `vi` çš„ä¸€æ¡æƒé‡ä¸º `wi` çš„è¾¹ã€‚

å¹¶ç»™å®šä¸€ä¸ªèŠ‚ç‚¹ `s` å’Œä¸€ä¸ªèŠ‚ç‚¹æ•°ç»„ `marked` ï¼›ä½ çš„ä»»åŠ¡æ˜¯æ‰¾åˆ°ä» `s` åˆ° `marked` ä¸­ **ä»»ä½•** èŠ‚ç‚¹çš„ **æœ€çŸ­** è·ç¦»ã€‚

è¿”å›ä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºä» `s` åˆ° `marked` ä¸­ä»»ä½•èŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»ï¼Œå¦‚æœä» s åˆ°ä»»ä½•æ ‡è®°èŠ‚ç‚¹æ²¡æœ‰è·¯å¾„ï¼Œåˆ™è¿”å› `-1` ã€‚



**ç¤ºä¾‹ 1ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** n = 4, edges = [[0,1,1],[1,2,3],[2,3,2],[0,3,4]], s = 0, marked = [2,3]
> 
> **è¾“å‡ºï¼š** 4
> 
> **è§£é‡Šï¼š** ä»èŠ‚ç‚¹ 0ï¼ˆç»¿è‰²èŠ‚ç‚¹ï¼‰åˆ°èŠ‚ç‚¹ 2ï¼ˆçº¢è‰²èŠ‚ç‚¹ï¼‰æœ‰ä¸€æ¡è·¯å¾„ï¼Œå³ 0->1->2ï¼Œè·ç¦»ä¸º 1 + 3 = 4ã€‚ 
> 
> ä»èŠ‚ç‚¹ 0 åˆ°èŠ‚ç‚¹ 3ï¼ˆçº¢è‰²èŠ‚ç‚¹ï¼‰æœ‰ä¸¤æ¡è·¯å¾„ï¼Œå³ 0->1->2->3 å’Œ 0->3ï¼Œåˆ†åˆ«è·ç¦»ä¸º 1 + 3 + 2 = 6 å’Œ 4ã€‚ 
> 
> å®ƒä»¬ä¸­çš„æœ€å°å€¼æ˜¯ 4ã€‚
> 
> 

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2700-2799/2737.Find%20the%20Closest%20Marked%20Node/images/image_2023-06-13_16-34-38.png)

**ç¤ºä¾‹ 2ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** n = 5, edges = [[0,1,2],[0,2,4],[1,3,1],[2,3,3],[3,4,2]], s = 1, marked = [0,4]
> 
> **è¾“å‡ºï¼š** 3
> 
> **è§£é‡Šï¼š** ä»èŠ‚ç‚¹ 1ï¼ˆç»¿è‰²èŠ‚ç‚¹ï¼‰åˆ°èŠ‚ç‚¹ 0ï¼ˆçº¢è‰²èŠ‚ç‚¹ï¼‰æ²¡æœ‰è·¯å¾„ã€‚ 
> 
> ä»èŠ‚ç‚¹ 1 åˆ°èŠ‚ç‚¹ 4ï¼ˆçº¢è‰²èŠ‚ç‚¹ï¼‰æœ‰ä¸€æ¡è·¯å¾„ï¼Œå³ 1->3->4ï¼Œè·ç¦»ä¸º 1 + 2 = 3ã€‚ 
> 
> å› æ­¤ç­”æ¡ˆæ˜¯ 3ã€‚
> 
> 

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2700-2799/2737.Find%20the%20Closest%20Marked%20Node/images/image_2023-06-13_16-35-13.png)

**ç¤ºä¾‹ 3ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** n = 4, edges = [[0,1,1],[1,2,3],[2,3,2]], s = 3, marked = [0,1]
> 
> **è¾“å‡ºï¼š** -1
> 
> **è§£é‡Šï¼š** ä»èŠ‚ç‚¹ 3ï¼ˆç»¿è‰²èŠ‚ç‚¹ï¼‰åˆ°ä»»ä½•ä¸€ä¸ªæ ‡è®°èŠ‚ç‚¹ï¼ˆçº¢è‰²èŠ‚ç‚¹ï¼‰éƒ½æ²¡æœ‰è·¯å¾„ï¼Œå› æ­¤ç­”æ¡ˆæ˜¯ -1ã€‚
> 
> 

![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/2700-2799/2737.Find%20the%20Closest%20Marked%20Node/images/image_2023-06-13_16-35-47.png)



**æç¤ºï¼š**

  * `2 <= n <= 500`
  * `1 <= edges.length <= 10^4`
  * `edges[i].length = 3`
  * `0 <= edges[i][0], edges[i][1] <= n - 1`
  * `1 <= edges[i][2] <= 10^6`
  * `1 <= marked.length <= n - 1`
  * `0 <= s, marked[i] <= n - 1`
  * `s != marked[i]`
  * å¦‚æœ `i != j` åˆ™ `marked[i] != marked[j]`
  * å›¾ä¸­å¯èƒ½æœ‰ **é‡å¤çš„è¾¹ ã€‚**
  * å›¾çš„ç”Ÿæˆä¸ä¼šå‡ºç° **è‡ªç¯** ã€‚


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```