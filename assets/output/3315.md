# [3315. æ„é€ æœ€å°ä½è¿ç®—æ•°ç»„ II](https://2xiao.github.io/leetcode-js/problem/3315.html)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`ä½è¿ç®—`](/tag/bit-manipulation.md) [`æ•°ç»„`](/tag/array.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/construct-the-minimum-bitwise-array-ii) [`LeetCode`](https://leetcode.com/problems/construct-the-minimum-bitwise-array-ii)

## é¢˜ç›®

You are given an array `nums` consisting of `n` prime integers.

You need to construct an array `ans` of length `n`, such that, for each index
`i`, the bitwise `OR` of `ans[i]` and `ans[i] + 1` is equal to `nums[i]`, i.e.
`ans[i] OR (ans[i] + 1) == nums[i]`.

Additionally, you must **minimize** each value of `ans[i]` in the resulting
array.

If it is _not possible_ to find such a value for `ans[i]` that satisfies the
**condition** , then set `ans[i] = -1`.



**Example 1:**

**Input:** nums = [2,3,5,7]

**Output:** [-1,1,4,3]

**Explanation:**

  * For `i = 0`, as there is no value for `ans[0]` that satisfies `ans[0] OR (ans[0] + 1) = 2`, so `ans[0] = -1`.
  * For `i = 1`, the smallest `ans[1]` that satisfies `ans[1] OR (ans[1] + 1) = 3` is `1`, because `1 OR (1 + 1) = 3`.
  * For `i = 2`, the smallest `ans[2]` that satisfies `ans[2] OR (ans[2] + 1) = 5` is `4`, because `4 OR (4 + 1) = 5`.
  * For `i = 3`, the smallest `ans[3]` that satisfies `ans[3] OR (ans[3] + 1) = 7` is `3`, because `3 OR (3 + 1) = 7`.

**Example 2:**

**Input:** nums = [11,13,31]

**Output:** [9,12,15]

**Explanation:**

  * For `i = 0`, the smallest `ans[0]` that satisfies `ans[0] OR (ans[0] + 1) = 11` is `9`, because `9 OR (9 + 1) = 11`.
  * For `i = 1`, the smallest `ans[1]` that satisfies `ans[1] OR (ans[1] + 1) = 13` is `12`, because `12 OR (12 + 1) = 13`.
  * For `i = 2`, the smallest `ans[2]` that satisfies `ans[2] OR (ans[2] + 1) = 31` is `15`, because `15 OR (15 + 1) = 31`.



**Constraints:**

  * `1 <= nums.length <= 100`
  * `2 <= nums[i] <= 10^9`
  * `nums[i]` is a prime number.


## é¢˜ç›®å¤§æ„

ç»™ä½ ä¸€ä¸ªé•¿åº¦ä¸º `n` çš„è´¨æ•°æ•°ç»„ `nums` ã€‚ä½ çš„ä»»åŠ¡æ˜¯è¿”å›ä¸€ä¸ªé•¿åº¦ä¸º `n` çš„æ•°ç»„ `ans` ï¼Œå¯¹äºæ¯ä¸ªä¸‹æ ‡ `i` ï¼Œä»¥ä¸‹**  æ¡ä»¶**
å‡æˆç«‹ï¼š

  * `ans[i] OR (ans[i] + 1) == nums[i]`

é™¤æ­¤ä»¥å¤–ï¼Œä½ éœ€è¦ **æœ€å°åŒ–**  ç»“æœæ•°ç»„é‡Œæ¯ä¸€ä¸ª `ans[i]` ã€‚

å¦‚æœæ²¡æ³•æ‰¾åˆ°ç¬¦åˆ **æ¡ä»¶**  çš„ `ans[i]` ï¼Œé‚£ä¹ˆ `ans[i] = -1` ã€‚

**è´¨æ•°**  æŒ‡çš„æ˜¯ä¸€ä¸ªå¤§äº 1 çš„è‡ªç„¶æ•°ï¼Œä¸”å®ƒåªæœ‰ 1 å’Œè‡ªå·±ä¸¤ä¸ªå› æ•°ã€‚



**ç¤ºä¾‹ 1ï¼š**

**è¾“å…¥ï¼š** nums = [2,3,5,7]

**è¾“å‡ºï¼š**[-1,1,4,3]

**è§£é‡Šï¼š**

  * å¯¹äº `i = 0` ï¼Œä¸å­˜åœ¨ `ans[0]` æ»¡è¶³ `ans[0] OR (ans[0] + 1) = 2` ï¼Œæ‰€ä»¥ `ans[0] = -1` ã€‚
  * å¯¹äº `i = 1` ï¼Œæ»¡è¶³ `ans[1] OR (ans[1] + 1) = 3` çš„æœ€å° `ans[1]` ä¸º `1` ï¼Œå› ä¸º `1 OR (1 + 1) = 3` ã€‚
  * å¯¹äº `i = 2` ï¼Œæ»¡è¶³ `ans[2] OR (ans[2] + 1) = 5` çš„æœ€å° `ans[2]` ä¸º `4` ï¼Œå› ä¸º `4 OR (4 + 1) = 5` ã€‚
  * å¯¹äº `i = 3` ï¼Œæ»¡è¶³ `ans[3] OR (ans[3] + 1) = 7` çš„æœ€å° `ans[3]` ä¸º `3` ï¼Œå› ä¸º `3 OR (3 + 1) = 7` ã€‚

**ç¤ºä¾‹ 2ï¼š**

**è¾“å…¥ï¼š** nums = [11,13,31]

**è¾“å‡ºï¼š**[9,12,15]

**è§£é‡Šï¼š**

  * å¯¹äº `i = 0` ï¼Œæ»¡è¶³ `ans[0] OR (ans[0] + 1) = 11` çš„æœ€å° `ans[0]` ä¸º `9` ï¼Œå› ä¸º `9 OR (9 + 1) = 11` ã€‚
  * å¯¹äº `i = 1` ï¼Œæ»¡è¶³ `ans[1] OR (ans[1] + 1) = 13` çš„æœ€å° `ans[1]` ä¸º `12` ï¼Œå› ä¸º `12 OR (12 + 1) = 13` ã€‚
  * å¯¹äº `i = 2` ï¼Œæ»¡è¶³ `ans[2] OR (ans[2] + 1) = 31` çš„æœ€å° `ans[2]` ä¸º `15` ï¼Œå› ä¸º `15 OR (15 + 1) = 31` ã€‚



**æç¤ºï¼š**

  * `1 <= nums.length <= 100`
  * `2 <= nums[i] <= 10^9`
  * `nums[i]` æ˜¯ä¸€ä¸ªè´¨æ•°ã€‚


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```