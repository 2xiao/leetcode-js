---
title: 1612. æ£€æŸ¥ä¸¤æ£µäºŒå‰è¡¨è¾¾å¼æ ‘æ˜¯å¦ç­‰ä»· ğŸ”’
description: LeetCode,1612. æ£€æŸ¥ä¸¤æ£µäºŒå‰è¡¨è¾¾å¼æ ‘æ˜¯å¦ç­‰ä»· ğŸ”’,æ£€æŸ¥ä¸¤æ£µäºŒå‰è¡¨è¾¾å¼æ ‘æ˜¯å¦ç­‰ä»·,Check If Two Expression Trees are Equivalent,è§£é¢˜æ€è·¯,æ ‘,æ·±åº¦ä¼˜å…ˆæœç´¢,å“ˆå¸Œè¡¨,äºŒå‰æ ‘,è®¡æ•°
keywords:
  - LeetCode
  - 1612. æ£€æŸ¥ä¸¤æ£µäºŒå‰è¡¨è¾¾å¼æ ‘æ˜¯å¦ç­‰ä»· ğŸ”’
  - æ£€æŸ¥ä¸¤æ£µäºŒå‰è¡¨è¾¾å¼æ ‘æ˜¯å¦ç­‰ä»·
  - Check If Two Expression Trees are Equivalent
  - è§£é¢˜æ€è·¯
  - æ ‘
  - æ·±åº¦ä¼˜å…ˆæœç´¢
  - å“ˆå¸Œè¡¨
  - äºŒå‰æ ‘
  - è®¡æ•°
---

# 1612. æ£€æŸ¥ä¸¤æ£µäºŒå‰è¡¨è¾¾å¼æ ‘æ˜¯å¦ç­‰ä»· ğŸ”’

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`æ ‘`](/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`å“ˆå¸Œè¡¨`](/tag/hash-table.md) [`äºŒå‰æ ‘`](/tag/binary-tree.md) [`è®¡æ•°`](/tag/counting.md)&emsp; ğŸ”—&ensp;[`åŠ›æ‰£`](https://leetcode.cn/problems/check-if-two-expression-trees-are-equivalent) [`LeetCode`](https://leetcode.com/problems/check-if-two-expression-trees-are-equivalent)

## é¢˜ç›®

A **[binary expression
tree](https://en.wikipedia.org/wiki/Binary_expression_tree)** is a kind of
binary tree used to represent arithmetic expressions. Each node of a binary
expression tree has either zero or two children. Leaf nodes (nodes with 0
children) correspond to operands (variables), and internal nodes (nodes with
two children) correspond to the operators. In this problem, we only consider
the `'+'` operator (i.e. addition).

You are given the roots of two binary expression trees, `root1` and `root2`.
Return `true` _if the two binary expression trees are equivalent_. Otherwise,
return `false`.

Two binary expression trees are equivalent if they **evaluate to the same
value** regardless of what the variables are set to.



**Example 1:**

> Input: root1 = [x], root2 = [x]
> 
> Output: true

**Example 2:**

**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1600-1699/1612.Check%20If%20Two%20Expression%20Trees%20are%20Equivalent/images/tree1.png)**

> Input: root1 = [+,a,+,null,null,b,c], root2 = [+,+,a,b,c]
> 
> Output: true
> 
> **Explanation****:** a + (b + c) == (b + c) + a

**Example 3:**

**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1600-1699/1612.Check%20If%20Two%20Expression%20Trees%20are%20Equivalent/images/tree2.png)**

> Input: root1 = [+,a,+,null,null,b,c], root2 = [+,+,a,b,d]
> 
> Output: false
> 
> **Explanation****:** a + (b + c) != (b + d) + a

**Constraints:**

  * The number of nodes in both trees are equal, odd and, in the range `[1, 4999]`.
  * `Node.val` is `'+'` or a lower-case English letter.
  * It's **guaranteed** that the tree given is a valid binary expression tree.



**Follow up:** What will you change in your solution if the tree also supports
the `'-'` operator (i.e. subtraction)?


## é¢˜ç›®å¤§æ„

**[äºŒå‰è¡¨è¾¾å¼æ ‘](https://en.wikipedia.org/wiki/Binary_expression_tree)**
æ˜¯ä¸€ç§è¡¨è¾¾ç®—æœ¯è¡¨è¾¾å¼çš„äºŒå‰æ ‘ã€‚äºŒå‰è¡¨è¾¾å¼æ ‘ä¸­çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹éƒ½æœ‰é›¶ä¸ªæˆ–ä¸¤ä¸ªå­èŠ‚ç‚¹ã€‚ å¶èŠ‚ç‚¹ï¼ˆæœ‰ 0 ä¸ªå­èŠ‚ç‚¹çš„èŠ‚ç‚¹ï¼‰è¡¨ç¤ºæ“ä½œæ•°ï¼Œéå¶èŠ‚ç‚¹ï¼ˆæœ‰ 2
ä¸ªå­èŠ‚ç‚¹çš„èŠ‚ç‚¹ï¼‰è¡¨ç¤ºè¿ç®—ç¬¦ã€‚åœ¨æœ¬é¢˜ä¸­ï¼Œæˆ‘ä»¬åªè€ƒè™‘ `'+'` è¿ç®—ç¬¦ï¼ˆå³åŠ æ³•ï¼‰ã€‚

ç»™å®šä¸¤æ£µäºŒå‰è¡¨è¾¾å¼æ ‘çš„æ ¹èŠ‚ç‚¹ `root1` å’Œ `root2` ã€‚ _å¦‚æœä¸¤æ£µäºŒå‰è¡¨è¾¾å¼æ ‘ç­‰ä»·_ ï¼Œè¿”å› `true` ï¼Œå¦åˆ™è¿”å› `false` ã€‚

å½“ä¸¤æ£µäºŒå‰æœç´¢æ ‘ä¸­çš„å˜é‡å–ä»»æ„å€¼ï¼Œ**åˆ†åˆ«æ±‚å¾—çš„å€¼éƒ½ç›¸ç­‰** æ—¶ï¼Œæˆ‘ä»¬ç§°è¿™ä¸¤æ£µäºŒå‰è¡¨è¾¾å¼æ ‘æ˜¯ç­‰ä»·çš„ã€‚



**ç¤ºä¾‹ 1:**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** root1 = [x], root2 = [x]
> 
> **è¾“å‡ºï¼š** true
> 
> 

**ç¤ºä¾‹ 2:**

**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1600-1699/1612.Check%20If%20Two%20Expression%20Trees%20are%20Equivalent/images/tree1.png)**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** root1 = [+,a,+,null,null,b,c], root2 = [+,+,a,b,c]
> 
> **è¾“å‡ºï¼š** true
> 
> **è§£é‡Šï¼š** a + (b + c) == (b + c) + a

**ç¤ºä¾‹ 3:**

**![](https://fastly.jsdelivr.net/gh/doocs/leetcode@main/solution/1600-1699/1612.Check%20If%20Two%20Expression%20Trees%20are%20Equivalent/images/tree2.png)**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** root1 = [+,a,+,null,null,b,c], root2 = [+,+,a,b,d]
> 
> **è¾“å‡ºï¼š** false
> 
> **è§£é‡Šï¼š** a + (b + c) != (b + d) + a
> 
> 



**æç¤ºï¼š**

  * ä¸¤æ£µæ ‘ä¸­çš„èŠ‚ç‚¹ä¸ªæ•°ç›¸ç­‰ï¼Œä¸”èŠ‚ç‚¹ä¸ªæ•°ä¸ºèŒƒå›´ `[1, 4999]` å†…çš„å¥‡æ•°ã€‚
  * `Node.val` æ˜¯ `'+'` æˆ–å°å†™è‹±æ–‡å­—æ¯ã€‚
  * ç»™å®šçš„æ ‘**ä¿è¯** æ˜¯æœ‰æ•ˆçš„äºŒå‰è¡¨è¾¾å¼æ ‘ã€‚



**è¿›é˜¶ï¼š** å½“ä½ çš„ç­”æ¡ˆéœ€åŒæ—¶æ”¯æŒ `'-'` è¿ç®—ç¬¦ï¼ˆå‡æ³•ï¼‰æ—¶ï¼Œä½ è¯¥å¦‚ä½•ä¿®æ”¹ä½ çš„ç­”æ¡ˆ


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 1597 | [æ ¹æ®ä¸­ç¼€è¡¨è¾¾å¼æ„é€ äºŒå‰è¡¨è¾¾å¼æ ‘ ğŸ”’](https://leetcode.com/problems/build-binary-expression-tree-from-infix-expression) |  |  [`æ ˆ`](/tag/stack.md) [`æ ‘`](/tag/tree.md) [`å­—ç¬¦ä¸²`](/tag/string.md) `1+` | <font color=#ff334b>Hard</font> |
| 2313 | [äºŒå‰æ ‘ä¸­å¾—åˆ°ç»“æœæ‰€éœ€çš„æœ€å°‘ç¿»è½¬æ¬¡æ•° ğŸ”’](https://leetcode.com/problems/minimum-flips-in-binary-tree-to-get-result) |  |  [`æ ‘`](/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`åŠ¨æ€è§„åˆ’`](/tag/dynamic-programming.md) `1+` | <font color=#ff334b>Hard</font> |
| 2331 | [è®¡ç®—å¸ƒå°”äºŒå‰æ ‘çš„å€¼](https://leetcode.com/problems/evaluate-boolean-binary-tree) |  |  [`æ ‘`](/tag/tree.md) [`æ·±åº¦ä¼˜å…ˆæœç´¢`](/tag/depth-first-search.md) [`äºŒå‰æ ‘`](/tag/binary-tree.md) | <font color=#15bd66>Easy</font> |