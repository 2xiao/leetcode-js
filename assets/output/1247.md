# [1247. äº¤æ¢å­—ç¬¦ä½¿å¾—å­—ç¬¦ä¸²ç›¸åŒ](https://leetcode.com/problems/minimum-swaps-to-make-strings-equal)

ğŸŸ  <font color=#ffb800>Medium</font>&emsp; ğŸ”–&ensp; [`è´ªå¿ƒ`](/leetcode/outline/tag/greedy.md) [`æ•°å­¦`](/leetcode/outline/tag/math.md) [`å­—ç¬¦ä¸²`](/leetcode/outline/tag/string.md)&emsp; ğŸ”—&ensp;[`LeetCode`](https://leetcode.com/problems/minimum-swaps-to-make-strings-equal)

## é¢˜ç›®

You are given two strings `s1` and `s2` of equal length consisting of letters
`"x"` and `"y"` **only**. Your task is to make these two strings equal to each
other. You can swap any two characters that belong to **different** strings,
which means: swap `s1[i]` and `s2[j]`.

Return the minimum number of swaps required to make `s1` and `s2` equal, or
return `-1` if it is impossible to do so.



**Example 1:**

> Input: s1 = "xx", s2 = "yy"
> 
> Output: 1
> 
> Explanation: Swap s1[0] and s2[1], s1 = "yx", s2 = "yx".

**Example 2:**

> Input: s1 = "xy", s2 = "yx"
> 
> Output: 2
> 
> Explanation: Swap s1[0] and s2[0], s1 = "yy", s2 = "xx".
> 
> Swap s1[0] and s2[1], s1 = "xy", s2 = "xy".
> 
> Note that you cannot swap s1[0] and s1[1] to make s1 equal to "yx", cause we can only swap chars in different strings.

**Example 3:**

> Input: s1 = "xx", s2 = "xy"
> 
> Output: -1

**Constraints:**

  * `1 <= s1.length, s2.length <= 1000`
  * `s1.length == s2.length`
  * `s1, s2` only contain `'x'` or `'y'`.


## é¢˜ç›®å¤§æ„

æœ‰ä¸¤ä¸ªé•¿åº¦ç›¸åŒçš„å­—ç¬¦ä¸² `s1` å’Œ `s2`ï¼Œä¸”å®ƒä»¬å…¶ä¸­ **åªå«æœ‰**  å­—ç¬¦ `"x"` å’Œ
`"y"`ï¼Œä½ éœ€è¦é€šè¿‡ã€Œäº¤æ¢å­—ç¬¦ã€çš„æ–¹å¼ä½¿è¿™ä¸¤ä¸ªå­—ç¬¦ä¸²ç›¸åŒã€‚

æ¯æ¬¡ã€Œäº¤æ¢å­—ç¬¦ã€çš„æ—¶å€™ï¼Œä½ éƒ½å¯ä»¥åœ¨ä¸¤ä¸ªå­—ç¬¦ä¸²ä¸­å„é€‰ä¸€ä¸ªå­—ç¬¦è¿›è¡Œäº¤æ¢ã€‚

äº¤æ¢åªèƒ½å‘ç”Ÿåœ¨ä¸¤ä¸ªä¸åŒçš„å­—ç¬¦ä¸²ä¹‹é—´ï¼Œç»å¯¹ä¸èƒ½å‘ç”Ÿåœ¨åŒä¸€ä¸ªå­—ç¬¦ä¸²å†…éƒ¨ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å¯ä»¥äº¤æ¢ `s1[i]` å’Œ `s2[j]`ï¼Œä½†ä¸èƒ½äº¤æ¢ `s1[i]`
å’Œ `s1[j]`ã€‚

æœ€åï¼Œè¯·ä½ è¿”å›ä½¿ `s1` å’Œ `s2` ç›¸åŒçš„æœ€å°äº¤æ¢æ¬¡æ•°ï¼Œå¦‚æœæ²¡æœ‰æ–¹æ³•èƒ½å¤Ÿä½¿å¾—è¿™ä¸¤ä¸ªå­—ç¬¦ä¸²ç›¸åŒï¼Œåˆ™è¿”å› `-1` ã€‚



**ç¤ºä¾‹ 1ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** s1 = "xx", s2 = "yy"
> 
> **è¾“å‡ºï¼š** 1
> 
> **è§£é‡Šï¼š** äº¤æ¢ s1[0] å’Œ s2[1]ï¼Œå¾—åˆ° s1 = "yx"ï¼Œs2 = "yx"ã€‚

**ç¤ºä¾‹ 2ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** s1 = "xy", s2 = "yx"
> 
> **è¾“å‡ºï¼š** 2
> 
> **è§£é‡Šï¼š** äº¤æ¢ s1[0] å’Œ s2[0]ï¼Œå¾—åˆ° s1 = "yy"ï¼Œs2 = "xx" ã€‚
> 
> äº¤æ¢ s1[0] å’Œ s2[1]ï¼Œå¾—åˆ° s1 = "xy"ï¼Œs2 = "xy" ã€‚
> 
> æ³¨æ„ï¼Œä½ ä¸èƒ½äº¤æ¢ s1[0] å’Œ s1[1] ä½¿å¾— s1 å˜æˆ "yx"ï¼Œå› ä¸ºæˆ‘ä»¬åªèƒ½äº¤æ¢å±äºä¸¤ä¸ªä¸åŒå­—ç¬¦ä¸²çš„å­—ç¬¦ã€‚

**ç¤ºä¾‹ 3ï¼š**

> 
> 
> 
> 
> 
> **è¾“å…¥ï¼š** s1 = "xx", s2 = "xy"
> 
> **è¾“å‡ºï¼š** -1
> 
> 



**æç¤ºï¼š**

  * `1 <= s1.length, s2.length <= 1000`
  * `s1.length == s2.length`
  * `s1, s2` åªåŒ…å« `'x'` æˆ– `'y'`ã€‚


## è§£é¢˜æ€è·¯

#### å¤æ‚åº¦åˆ†æ

- **æ—¶é—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ
- **ç©ºé—´å¤æ‚åº¦**ï¼š`O()`ï¼Œ

## ä»£ç 

```javascript

```

## ç›¸å…³é¢˜ç›®

<!-- prettier-ignore -->
| é¢˜å· | æ ‡é¢˜ | é¢˜è§£ | æ ‡ç­¾ | éš¾åº¦ |
| :------: | :------ | :------: | :------ | :------ |
| 1657 | [ç¡®å®šä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦æ¥è¿‘](https://leetcode.com/problems/determine-if-two-strings-are-close) |  |  [`å“ˆå¸Œè¡¨`](/leetcode/outline/tag/hash-table.md) [`å­—ç¬¦ä¸²`](/leetcode/outline/tag/string.md) [`è®¡æ•°`](/leetcode/outline/tag/counting.md) `1+` | <font color=#ffb800>Medium</font> |
| 2531 | [ä½¿å­—ç¬¦ä¸²ä¸­ä¸åŒå­—ç¬¦çš„æ•°ç›®ç›¸ç­‰](https://leetcode.com/problems/make-number-of-distinct-characters-equal) |  |  [`å“ˆå¸Œè¡¨`](/leetcode/outline/tag/hash-table.md) [`å­—ç¬¦ä¸²`](/leetcode/outline/tag/string.md) [`è®¡æ•°`](/leetcode/outline/tag/counting.md) | <font color=#ffb800>Medium</font> |

<style>
.blue {
    background-color: #096dd9;
    padding: 0.25rem 0.5rem;
    margin: 0;
    font-size: 0.85em;
    border-radius: 3px;
    color: white;
    font-weight: 500;
}
table th:first-of-type { width: 10%; }
table th:nth-of-type(2) { width: 35%; }
table th:nth-of-type(3) { width: 10%; }
table th:nth-of-type(4) { width: 35%; }
table th:nth-of-type(5) { width: 10%; }
</style>
