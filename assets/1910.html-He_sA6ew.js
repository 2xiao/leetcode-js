import{_ as p,r as c,o as r,c as u,a as t,b as n,d as s,w as a,f as i,e as d}from"./app-B5EG-zH0.js";const k={},g=t("h1",{id:"_1910-删除一个字符串中所有出现的给定子字符串",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#_1910-删除一个字符串中所有出现的给定子字符串","aria-hidden":"true"},"#"),n(" 1910. 删除一个字符串中所有出现的给定子字符串")],-1),b=t("code",null,"栈",-1),m=t("code",null,"字符串",-1),q=t("code",null,"模拟",-1),h={href:"https://leetcode.cn/problems/remove-all-occurrences-of-a-substring",target:"_blank",rel:"noopener noreferrer"},x=t("code",null,"力扣",-1),y={href:"https://leetcode.com/problems/remove-all-occurrences-of-a-substring",target:"_blank",rel:"noopener noreferrer"},_=t("code",null,"LeetCode",-1),v=d(`<h2 id="题目" tabindex="-1"><a class="header-anchor" href="#题目" aria-hidden="true">#</a> 题目</h2><p>Given two strings <code>s</code> and <code>part</code>, perform the following operation on <code>s</code> until <strong>all</strong> occurrences of the substring <code>part</code> are removed:</p><ul><li>Find the <strong>leftmost</strong> occurrence of the substring <code>part</code> and <strong>remove</strong> it from <code>s</code>.</li></ul><p>Return <code>s</code> <em>after removing all occurrences of</em> <code>part</code>.</p><p>A <strong>substring</strong> is a contiguous sequence of characters in a string.</p><p><strong>Example 1:</strong></p><blockquote><p>Input: s = &quot;daabcbaabcbc&quot;, part = &quot;abc&quot;</p><p>Output: &quot;dab&quot;</p><p><strong>Explanation</strong> : The following operations are done:</p><ul><li>s = &quot;da** <em>abc</em>** baabcbc&quot;, remove &quot;abc&quot; starting at index 2, so s = &quot;dabaabcbc&quot;.</li><li>s = &quot;daba** <em>abc</em>** bc&quot;, remove &quot;abc&quot; starting at index 4, so s = &quot;dababc&quot;.</li><li>s = &quot;dab** <em>abc</em>** &quot;, remove &quot;abc&quot; starting at index 3, so s = &quot;dab&quot;.</li></ul><p>Now s has no occurrences of &quot;abc&quot;.</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p>Input: s = &quot;axxxxyyyyb&quot;, part = &quot;xy&quot;</p><p>Output: &quot;ab&quot;</p><p><strong>Explanation</strong> : The following operations are done:</p><ul><li>s = &quot;axxx**<em>xy</em>** yyyb&quot;, remove &quot;xy&quot; starting at index 4 so s = &quot;axxxyyyb&quot;.</li><li>s = &quot;axx**<em>xy</em>** yyb&quot;, remove &quot;xy&quot; starting at index 3 so s = &quot;axxyyb&quot;.</li><li>s = &quot;ax**<em>xy</em>** yb&quot;, remove &quot;xy&quot; starting at index 2 so s = &quot;axyb&quot;.</li><li>s = &quot;a**<em>xy</em>** b&quot;, remove &quot;xy&quot; starting at index 1 so s = &quot;ab&quot;.</li></ul><p>Now s has no occurrences of &quot;xy&quot;.</p></blockquote><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>1 &lt;= part.length &lt;= 1000</code></li><li><code>s</code>​​​​​​ and <code>part</code> consists of lowercase English letters.</li></ul><h2 id="题目大意" tabindex="-1"><a class="header-anchor" href="#题目大意" aria-hidden="true">#</a> 题目大意</h2><p>给你两个字符串 <code>s</code> 和 <code>part</code> ，请你对 <code>s</code> 反复执行以下操作直到 <strong>所有</strong> 子字符串 <code>part</code> 都被删除：</p><ul><li>找到 <code>s</code> 中 <strong>最左边</strong> 的子字符串 <code>part</code> ，并将它从 <code>s</code> 中删除。</li></ul><p>请你返回从 <code>s</code> 中删除所有 <code>part</code> 子字符串以后得到的剩余字符串。</p><p>一个 <strong>子字符串</strong> 是一个字符串中连续的字符序列。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> s = &quot;daabcbaabcbc&quot;, part = &quot;abc&quot;</p><p><strong>输出：</strong> &quot;dab&quot;</p><p><strong>解释：</strong> 以下操作按顺序执行：</p><ul><li>s = &quot;da<strong>abc</strong> baabcbc&quot; ，删除下标从 2 开始的 &quot;abc&quot; ，得到 s = &quot;dabaabcbc&quot; 。</li><li>s = &quot;daba<strong>abc</strong> bc&quot; ，删除下标从 4 开始的 &quot;abc&quot; ，得到 s = &quot;dababc&quot; 。</li><li>s = &quot;dab<strong>abc</strong> &quot; ，删除下标从 3 开始的 &quot;abc&quot; ，得到 s = &quot;dab&quot; 。</li></ul><p>此时 s 中不再含有子字符串 &quot;abc&quot; 。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> s = &quot;axxxxyyyyb&quot;, part = &quot;xy&quot;</p><p><strong>输出：</strong> &quot;ab&quot;</p><p><strong>解释：</strong> 以下操作按顺序执行：</p><ul><li>s = &quot;axxx<strong>xy</strong> yyyb&quot; ，删除下标从 4 开始的 &quot;xy&quot; ，得到 s = &quot;axxxyyyb&quot; 。</li><li>s = &quot;axx<strong>xy</strong> yyb&quot; ，删除下标从 3 开始的 &quot;xy&quot; ，得到 s = &quot;axxyyb&quot; 。</li><li>s = &quot;ax<strong>xy</strong> yb&quot; ，删除下标从 2 开始的 &quot;xy&quot; ，得到 s = &quot;axyb&quot; 。</li><li>s = &quot;a<strong>xy</strong> b&quot; ，删除下标从 1 开始的 &quot;xy&quot; ，得到 s = &quot;ab&quot; 。</li></ul><p>此时 s 中不再含有子字符串 &quot;xy&quot; 。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>1 &lt;= part.length &lt;= 1000</code></li><li><code>s</code>​​​​​​ 和 <code>part</code> 只包小写英文字母。</li></ul><h2 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路" aria-hidden="true">#</a> 解题思路</h2><p>我们可以利用栈来高效完成字符串匹配与移除操作：</p><ul><li><p>遍历字符串 <code>s</code>，逐字符压入栈 <code>stack</code>。</p></li><li><p>每次压入字符后，检查栈顶是否出现了子串 <code>part</code>。</p><ul><li>判断当前栈长度是否大于等于 <code>part.length</code>，且栈顶元素与<code>part</code> 的最后一个字符是否相同，这样能够避免频繁构建新字符串，从而提升效率。</li><li>通过 <code>stack.slice(-n).join(&#39;&#39;) === part</code> 判断是否匹配子串。</li><li>若匹配成功，通过 <code>stack.length -= n</code> 将栈截断，完成子串的删除操作，避免复杂的数组切片操作。</li></ul></li><li><p>遍历结束后，将栈中的剩余元素拼接成字符串返回。</p></li></ul><h4 id="复杂度分析" tabindex="-1"><a class="header-anchor" href="#复杂度分析" aria-hidden="true">#</a> 复杂度分析</h4><ul><li><strong>时间复杂度</strong>：<code>O(m * n)</code>，其中 <code>m</code> 为字符串 <code>s</code> 的长度，<code>n</code> 为子串 <code>part</code> 的长度。遍历一次字符串，每次匹配子串需要 <code>O(n)</code>。</li><li><strong>空间复杂度</strong>：<code>O(m)</code>，需要额外的栈空间来存储部分字符串。</li></ul><h2 id="代码" tabindex="-1"><a class="header-anchor" href="#代码" aria-hidden="true">#</a> 代码</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>string<span class="token punctuation">}</span></span> <span class="token parameter">s</span>
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>string<span class="token punctuation">}</span></span> <span class="token parameter">part</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>string<span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">removeOccurrences</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">s<span class="token punctuation">,</span> part</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">const</span> n <span class="token operator">=</span> part<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
	<span class="token keyword">const</span> lastChar <span class="token operator">=</span> part<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 记录 part 的最后一个字符</span>
	<span class="token keyword">let</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 用于存储字符串构建的栈</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> char <span class="token keyword">of</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 添加当前字符</span>
		<span class="token comment">// 检查是否匹配 part</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>
			stack<span class="token punctuation">.</span>length <span class="token operator">&gt;=</span> n <span class="token operator">&amp;&amp;</span>
			char <span class="token operator">===</span> lastChar <span class="token operator">&amp;&amp;</span>
			stack<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token operator">-</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&#39;&#39;</span><span class="token punctuation">)</span> <span class="token operator">===</span> part
		<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			stack<span class="token punctuation">.</span>length <span class="token operator">-=</span> n<span class="token punctuation">;</span> <span class="token comment">// 删除匹配部分</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> stack<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&#39;&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回最终结果</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="相关题目" tabindex="-1"><a class="header-anchor" href="#相关题目" aria-hidden="true">#</a> 相关题目</h2>`,30),f=t("thead",null,[t("tr",null,[t("th",{style:{"text-align":"center"}},"题号"),t("th",{style:{"text-align":"left"}},"标题"),t("th",{style:{"text-align":"center"}},"题解"),t("th",{style:{"text-align":"left"}},"标签"),t("th",{style:{"text-align":"center"}},"难度"),t("th",{style:{"text-align":"center"}},"力扣")])],-1),w=t("td",{style:{"text-align":"center"}},"2430",-1),E=t("td",{style:{"text-align":"left"}},"对字母串可执行的最大删除数",-1),C=t("td",{style:{"text-align":"center"}},null,-1),N={style:{"text-align":"left"}},j=t("code",null,"字符串",-1),O=t("code",null,"动态规划",-1),L=t("code",null,"字符串匹配",-1),V=t("code",null,"2+",-1),I=t("td",{style:{"text-align":"center"}},"🔴",-1),B={style:{"text-align":"center"}},R={href:"https://leetcode.cn/problems/maximum-deletions-on-a-string",target:"_blank",rel:"noopener noreferrer"},T={href:"https://leetcode.com/problems/maximum-deletions-on-a-string",target:"_blank",rel:"noopener noreferrer"};function A(F,G){const l=c("font"),o=c("RouterLink"),e=c("ExternalLinkIcon");return r(),u("div",null,[g,t("p",null,[n("🟠 "),s(l,{color:"#ffb800"},{default:a(()=>[n("Medium")]),_:1}),n("  🔖  "),s(o,{to:"/tag/stack.html"},{default:a(()=>[b]),_:1}),n(),s(o,{to:"/tag/string.html"},{default:a(()=>[m]),_:1}),n(),s(o,{to:"/tag/simulation.html"},{default:a(()=>[q]),_:1}),n("  🔗 "),t("a",h,[x,s(e)]),n(),t("a",y,[_,s(e)])]),v,i(" prettier-ignore "),t("table",null,[f,t("tbody",null,[t("tr",null,[w,E,C,t("td",N,[s(o,{to:"/tag/string.html"},{default:a(()=>[j]),_:1}),n(),s(o,{to:"/tag/dynamic-programming.html"},{default:a(()=>[O]),_:1}),n(),s(o,{to:"/tag/string-matching.html"},{default:a(()=>[L]),_:1}),n(),V]),I,t("td",B,[t("a",R,[n("🀄️"),s(e)]),n(),t("a",T,[n("🔗"),s(e)])])])])])])}const S=p(k,[["render",A],["__file","1910.html.vue"]]);export{S as default};
