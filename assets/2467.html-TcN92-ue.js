import{_ as l,r as p,o as i,c as u,a as n,b as s,d as a,w as t,f as d,e as r}from"./app-fBVbqwGY.js";const k={},h=n("h1",{id:"_2467-树上最大得分和路径",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_2467-树上最大得分和路径","aria-hidden":"true"},"#"),s(" 2467. 树上最大得分和路径")],-1),m=n("code",null,"树",-1),g=n("code",null,"深度优先搜索",-1),b=n("code",null,"广度优先搜索",-1),v=n("code",null,"图",-1),f=n("code",null,"数组",-1),_={href:"https://leetcode.cn/problems/most-profitable-path-in-a-tree",target:"_blank",rel:"noopener noreferrer"},y=n("code",null,"力扣",-1),w={href:"https://leetcode.com/problems/most-profitable-path-in-a-tree",target:"_blank",rel:"noopener noreferrer"},x=n("code",null,"LeetCode",-1),A=r(`<h2 id="题目" tabindex="-1"><a class="header-anchor" href="#题目" aria-hidden="true">#</a> 题目</h2><p>There is an undirected tree with <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>, rooted at node <code>0</code>. You are given a 2D integer array <code>edges</code> of length <code>n - 1</code> where <code>edges[i] = [ai, bi]</code> indicates that there is an edge between nodes <code>ai</code> and <code>bi</code> in the tree.</p><p>At every node <code>i</code>, there is a gate. You are also given an array of even integers <code>amount</code>, where <code>amount[i]</code> represents:</p><ul><li>the price needed to open the gate at node <code>i</code>, if <code>amount[i]</code> is negative, or,</li><li>the cash reward obtained on opening the gate at node <code>i</code>, otherwise.</li></ul><p>The game goes on as follows:</p><ul><li><p>Initially, Alice is at node <code>0</code> and Bob is at node <code>bob</code>.</p></li><li><p>At every second, Alice and Bob <strong>each</strong> move to an adjacent node. Alice moves towards some <strong>leaf node</strong> , while Bob moves towards node <code>0</code>.</p></li><li><p>For <strong>every</strong> node along their path, Alice and Bob either spend money to open the gate at that node, or accept the reward. Note that:</p><ul><li><p>If the gate is <strong>already open</strong> , no price will be required, nor will there be any cash reward.</p></li><li><p>If Alice and Bob reach the node <strong>simultaneously</strong> , they share the price/reward for opening the gate there. In other words, if the price to open the gate is <code>c</code>, then both Alice and Bob pay <code>c / 2</code> each. Similarly, if the reward at the gate is <code>c</code>, both of them receive <code>c / 2</code> each.</p></li></ul></li><li><p>If Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches node <code>0</code>, he stops moving. Note that these events are <strong>independent</strong> of each other.</p></li></ul><p>Return <em>the <strong>maximum</strong> net income Alice can have if she travels towards the optimal leaf node.</em></p><p><strong>Example 1:</strong></p><figure><img src="https://assets.leetcode.com/uploads/2022/10/29/eg1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>Input: edges = [[0,1],[1,2],[1,3],[3,4]], bob = 3, amount = [-2,4,2,-4,6]</p><p>Output: 6</p><p>Explanation:</p><p>The above diagram represents the given tree. The game goes as follows:</p><ul><li><p>Alice is initially on node 0, Bob on node 3. They open the gates of their respective nodes.</p><p>Alice&#39;s net income is now -2.</p></li><li><p>Both Alice and Bob move to node 1.</p><p>Since they reach here simultaneously, they open the gate together and share the reward.</p><p>Alice&#39;s net income becomes -2 + (4 / 2) = 0.</p></li><li><p>Alice moves on to node 3. Since Bob already opened its gate, Alice&#39;s income remains unchanged.</p><p>Bob moves on to node 0, and stops moving.</p></li><li><p>Alice moves on to node 4 and opens the gate there. Her net income becomes 0 + 6 = 6.</p></li></ul><p>Now, neither Alice nor Bob can make any further moves, and the game ends.</p><p>It is not possible for Alice to get a higher net income.</p></blockquote><p><strong>Example 2:</strong></p><figure><img src="https://assets.leetcode.com/uploads/2022/10/29/eg2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>Input: edges = [[0,1]], bob = 1, amount = [-7280,2350]</p><p>Output: -7280</p><p>Explanation:</p><p>Alice follows the path 0-&gt;1 whereas Bob follows the path 1-&gt;0.</p><p>Thus, Alice opens the gate at node 0 only. Hence, her net income is -7280.</p></blockquote><p><strong>Constraints:</strong></p><ul><li><code>2 &lt;= n &lt;= 10^5</code></li><li><code>edges.length == n - 1</code></li><li><code>edges[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; n</code></li><li><code>ai != bi</code></li><li><code>edges</code> represents a valid tree.</li><li><code>1 &lt;= bob &lt; n</code></li><li><code>amount.length == n</code></li><li><code>amount[i]</code> is an <strong>even</strong> integer in the range <code>[-10^4, 10^4]</code>.</li></ul><h2 id="题目大意" tabindex="-1"><a class="header-anchor" href="#题目大意" aria-hidden="true">#</a> 题目大意</h2><p>一个 <code>n</code> 个节点的无向树，节点编号为 <code>0</code> 到 <code>n - 1</code> ，树的根结点是 <code>0</code> 号节点。给你一个长度为 <code>n - 1</code> 的二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ai, bi]</code> ，表示节点 <code>ai</code> 和 <code>bi</code> 在树中有一条边。</p><p>在每一个节点 <code>i</code> 处有一扇门。同时给你一个都是偶数的数组 <code>amount</code> ，其中 <code>amount[i]</code> 表示：</p><ul><li>如果 <code>amount[i]</code> 的值是负数，那么它表示打开节点 <code>i</code> 处门扣除的分数。</li><li>如果 <code>amount[i]</code> 的值是正数，那么它表示打开节点 <code>i</code> 处门加上的分数。</li></ul><p>游戏按照如下规则进行：</p><ul><li><p>一开始，Alice 在节点 <code>0</code> 处，Bob 在节点 <code>bob</code> 处。</p></li><li><p>每一秒钟，Alice 和 Bob <strong>分别</strong> 移动到相邻的节点。Alice 朝着某个 <strong>叶子结点</strong> 移动，Bob 朝着节点 <code>0</code> 移动。</p></li><li><p>对于他们之间路径上的 <strong>每一个</strong> 节点，Alice 和 Bob 要么打开门并扣分，要么打开门并加分。注意：</p><ul><li><p>如果门 <strong>已经打开</strong> （被另一个人打开），不会有额外加分也不会扣分。</p></li><li><p>如果 Alice 和 Bob <strong>同时</strong> 到达一个节点，他们会共享这个节点的加分或者扣分。换言之，如果打开这扇门扣 <code>c</code> 分，那么 Alice 和 Bob 分别扣 <code>c / 2</code> 分。如果这扇门的加分为 <code>c</code> ，那么他们分别加 <code>c / 2</code> 分。</p></li></ul></li><li><p>如果 Alice 到达了一个叶子结点，她会停止移动。类似的，如果 Bob 到达了节点 <code>0</code> ，他也会停止移动。注意这些事件互相 <strong>独立</strong> ，不会影响另一方移动。</p></li></ul><p>请你返回 Alice 朝最优叶子结点移动的 <strong>最大</strong> 净得分。</p><p><strong>示例 1：</strong></p><figure><img src="https://assets.leetcode.com/uploads/2022/10/29/eg1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p><strong>输入：</strong> edges = [[0,1],[1,2],[1,3],[3,4]], bob = 3, amount = [-2,4,2,-4,6]</p><p><strong>输出：</strong> 6</p><p><strong>解释：</strong></p><p>上图展示了输入给出的一棵树。游戏进行如下：</p><ul><li><p>Alice 一开始在节点 0 处，Bob 在节点 3 处。他们分别打开所在节点的门。</p><p>Alice 得分为 -2 。</p></li><li><p>Alice 和 Bob 都移动到节点 1 。</p><p>因为他们同时到达这个节点，他们一起打开门并平分得分。</p><p>Alice 的得分变为 -2 + (4 / 2) = 0 。</p></li><li><p>Alice 移动到节点 3 。因为 Bob 已经打开了这扇门，Alice 得分不变。</p><p>Bob 移动到节点 0 ，并停止移动。</p></li><li><p>Alice 移动到节点 4 并打开这个节点的门，她得分变为 0 + 6 = 6 。</p></li></ul><p>现在，Alice 和 Bob 都不能进行任何移动了，所以游戏结束。</p><p>Alice 无法得到更高分数。</p></blockquote><p><strong>示例 2：</strong></p><figure><img src="https://assets.leetcode.com/uploads/2022/10/29/eg2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p><strong>输入：</strong> edges = [[0,1]], bob = 1, amount = [-7280,2350]</p><p><strong>输出：</strong> -7280</p><p><strong>解释：</strong></p><p>Alice 按照路径 0-&gt;1 移动，同时 Bob 按照路径 1-&gt;0 移动。</p><p>所以 Alice 只打开节点 0 处的门，她的得分为 -7280 。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 10^5</code></li><li><code>edges.length == n - 1</code></li><li><code>edges[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; n</code></li><li><code>ai != bi</code></li><li><code>edges</code> 表示一棵有效的树。</li><li><code>1 &lt;= bob &lt; n</code></li><li><code>amount.length == n</code></li><li><code>amount[i]</code> 是范围 <code>[-10^4, 10^4]</code> 之间的一个 <strong>偶数</strong> 。</li></ul><h2 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路" aria-hidden="true">#</a> 解题思路</h2><ol><li><strong>建图</strong>：由于输入是一棵树，我们使用 <strong>邻接表</strong> 存储无向图结构。</li><li><strong>找到 Bob 的路径</strong>： <ul><li>Bob 只能沿 <strong>唯一的一条路径</strong> 从 <code>bob</code> 走到 <code>0</code>，我们使用 <strong>DFS（深度优先搜索）</strong> 找到 Bob 的路径，并记录 Bob 经过每个节点的时间步 <code>bobPath[node]</code>。</li></ul></li><li><strong>DFS 计算 Alice 的最大收益</strong>： <ul><li>Alice 选择一条路径，使得她的收益最大。Alice 的收益计算如下： <ul><li>如果 Alice <strong>先到达</strong> <code>node</code>，她可以获得 <strong>全部 <code>amount[node]</code></strong>。</li><li>如果 Bob <strong>先到达</strong> <code>node</code>，Alice <strong>无法获得</strong> <code>amount[node]</code>。</li><li>如果 Alice 和 Bob <strong>同时到达</strong>，Alice <strong>只能获得 <code>amount[node] / 2</code></strong>。</li></ul></li><li>由于 Alice 需要找到 <strong>从 <code>0</code> 号节点到叶子节点的最大收益路径</strong>，我们采用 <strong>DFS 进行收益计算</strong>。</li></ul></li></ol><h4 id="复杂度分析" tabindex="-1"><a class="header-anchor" href="#复杂度分析" aria-hidden="true">#</a> 复杂度分析</h4><ul><li><strong>时间复杂度</strong>：<code>O(n)</code>，遍历整棵树，执行两次 DFS（一次找到 Bob 路径，一次 Alice 计算收益）。</li><li><strong>空间复杂度</strong>：<code>O(n)</code>，存储邻接表 <code>graph</code>、Bob 访问路径 <code>bobPath</code>、DFS 递归栈。</li></ul><h2 id="代码" tabindex="-1"><a class="header-anchor" href="#代码" aria-hidden="true">#</a> 代码</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span> <span class="token parameter">edges</span>
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">}</span></span> <span class="token parameter">bob</span>
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span> <span class="token parameter">amount</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">mostProfitablePath</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">edges<span class="token punctuation">,</span> bob<span class="token punctuation">,</span> amount</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">let</span> graph <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span> <span class="token keyword">of</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>graph<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span> graph<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>graph<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">)</span> graph<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		graph<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
		graph<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 记录 Bob 经过的路径</span>
	<span class="token keyword">const</span> <span class="token function-variable function">findBobPath</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> path</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
		path<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
		visited<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			bobPath <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>node<span class="token punctuation">,</span> i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记录 Bob 经过的节点及步数</span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 找到路径后终止搜索</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> child <span class="token keyword">of</span> graph<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">findBobPath</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		path<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token keyword">const</span> <span class="token function-variable function">findMaxIncome</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> score<span class="token punctuation">,</span> step</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
		visited<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token keyword">if</span> <span class="token punctuation">(</span>bobPath<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">let</span> bobStep <span class="token operator">=</span> bobPath<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>step <span class="token operator">&lt;</span> bobStep<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				score <span class="token operator">+=</span> amount<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>step <span class="token operator">===</span> bobStep<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				score <span class="token operator">+=</span> amount<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			score <span class="token operator">+=</span> amount<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">if</span> <span class="token punctuation">(</span>graph<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> node <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			maxIncome <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxIncome<span class="token punctuation">,</span> score<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> child <span class="token keyword">of</span> graph<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
					<span class="token function">findMaxIncome</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> score<span class="token punctuation">,</span> step <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		visited<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token keyword">let</span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">let</span> bobPath<span class="token punctuation">;</span>
	<span class="token function">findBobPath</span><span class="token punctuation">(</span>bob<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">let</span> maxIncome <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">Infinity</span><span class="token punctuation">;</span>
	visited<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">findMaxIncome</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> maxIncome<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="相关题目" tabindex="-1"><a class="header-anchor" href="#相关题目" aria-hidden="true">#</a> 相关题目</h2>`,37),B=n("thead",null,[n("tr",null,[n("th",{style:{"text-align":"center"}},"题号"),n("th",{style:{"text-align":"left"}},"标题"),n("th",{style:{"text-align":"center"}},"题解"),n("th",{style:{"text-align":"left"}},"标签"),n("th",{style:{"text-align":"center"}},"难度"),n("th",{style:{"text-align":"center"}},"力扣")])],-1),I=n("td",{style:{"text-align":"center"}},"909",-1),S=n("td",{style:{"text-align":"left"}},"蛇梯棋",-1),P={style:{"text-align":"center"}},q={style:{"text-align":"left"}},N=n("code",null,"广度优先搜索",-1),E=n("code",null,"数组",-1),T=n("code",null,"矩阵",-1),D=n("td",{style:{"text-align":"center"}},"🟠",-1),F={style:{"text-align":"center"}},M={href:"https://leetcode.cn/problems/snakes-and-ladders",target:"_blank",rel:"noopener noreferrer"},C={href:"https://leetcode.com/problems/snakes-and-ladders",target:"_blank",rel:"noopener noreferrer"},L=n("td",{style:{"text-align":"center"}},"3241",-1),V=n("td",{style:{"text-align":"left"}},"标记所有节点需要的时间",-1),j=n("td",{style:{"text-align":"center"}},null,-1),z={style:{"text-align":"left"}},O=n("code",null,"树",-1),R=n("code",null,"深度优先搜索",-1),H=n("code",null,"图",-1),Y=n("code",null,"1+",-1),G=n("td",{style:{"text-align":"center"}},"🔴",-1),J={style:{"text-align":"center"}},K={href:"https://leetcode.cn/problems/time-taken-to-mark-all-nodes",target:"_blank",rel:"noopener noreferrer"},Q={href:"https://leetcode.com/problems/time-taken-to-mark-all-nodes",target:"_blank",rel:"noopener noreferrer"};function U(W,X){const c=p("font"),e=p("RouterLink"),o=p("ExternalLinkIcon");return i(),u("div",null,[h,n("p",null,[s("🟠 "),a(c,{color:"#ffb800"},{default:t(()=>[s("Medium")]),_:1}),s("  🔖  "),a(e,{to:"/tag/tree.html"},{default:t(()=>[m]),_:1}),s(),a(e,{to:"/tag/depth-first-search.html"},{default:t(()=>[g]),_:1}),s(),a(e,{to:"/tag/breadth-first-search.html"},{default:t(()=>[b]),_:1}),s(),a(e,{to:"/tag/graph.html"},{default:t(()=>[v]),_:1}),s(),a(e,{to:"/tag/array.html"},{default:t(()=>[f]),_:1}),s("  🔗 "),n("a",_,[y,a(o)]),s(),n("a",w,[x,a(o)])]),A,d(" prettier-ignore "),n("table",null,[B,n("tbody",null,[n("tr",null,[I,S,n("td",P,[a(e,{to:"/problem/0909.html"},{default:t(()=>[s("[✓]")]),_:1})]),n("td",q,[a(e,{to:"/tag/breadth-first-search.html"},{default:t(()=>[N]),_:1}),s(),a(e,{to:"/tag/array.html"},{default:t(()=>[E]),_:1}),s(),a(e,{to:"/tag/matrix.html"},{default:t(()=>[T]),_:1})]),D,n("td",F,[n("a",M,[s("🀄️"),a(o)]),s(),n("a",C,[s("🔗"),a(o)])])]),n("tr",null,[L,V,j,n("td",z,[a(e,{to:"/tag/tree.html"},{default:t(()=>[O]),_:1}),s(),a(e,{to:"/tag/depth-first-search.html"},{default:t(()=>[R]),_:1}),s(),a(e,{to:"/tag/graph.html"},{default:t(()=>[H]),_:1}),s(),Y]),G,n("td",J,[n("a",K,[s("🀄️"),a(o)]),s(),n("a",Q,[s("🔗"),a(o)])])])])])])}const $=l(k,[["render",U],["__file","2467.html.vue"]]);export{$ as default};
