import{_ as l,r as c,o as i,c as r,a as e,b as n,d as t,w as s,f as u,e as p}from"./app-fBVbqwGY.js";const b={},v=e("h1",{id:"_1656-设计有序流",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_1656-设计有序流","aria-hidden":"true"},"#"),n(" 1656. 设计有序流")],-1),m=e("code",null,"设计",-1),q=e("code",null,"数组",-1),h=e("code",null,"哈希表",-1),k=e("code",null,"数据流",-1),g={href:"https://leetcode.cn/problems/design-an-ordered-stream",target:"_blank",rel:"noopener noreferrer"},_=e("code",null,"力扣",-1),f={href:"https://leetcode.com/problems/design-an-ordered-stream",target:"_blank",rel:"noopener noreferrer"},y=e("code",null,"LeetCode",-1),x=p(`<h2 id="题目" tabindex="-1"><a class="header-anchor" href="#题目" aria-hidden="true">#</a> 题目</h2><p>There is a stream of <code>n</code> <code>(idKey, value)</code> pairs arriving in an <strong>arbitrary</strong> order, where <code>idKey</code> is an integer between <code>1</code> and <code>n</code> and <code>value</code> is a string. No two pairs have the same <code>id</code>.</p><p>Design a stream that returns the values in <strong>increasing order of their IDs</strong> by returning a <strong>chunk</strong> (list) of values after each insertion. The concatenation of all the <strong>chunks</strong> should result in a list of the sorted values.</p><p>Implement the <code>OrderedStream</code> class:</p><ul><li><code>OrderedStream(int n)</code> Constructs the stream to take <code>n</code> values.</li><li><code>String[] insert(int idKey, String value)</code> Inserts the pair <code>(idKey, value)</code> into the stream, then returns the <strong>largest possible chunk</strong> of currently inserted values that appear next in the order.</li></ul><p><strong>Example:</strong></p><p><strong><img src="https://assets.leetcode.com/uploads/2020/11/10/q1.gif" alt="" loading="lazy"></strong></p><blockquote><p><strong>Input</strong></p><p><code>[&quot;OrderedStream&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;insert&quot;]</code></p><p><code>[[5], [3, &quot;ccccc&quot;], [1, &quot;aaaaa&quot;], [2, &quot;bbbbb&quot;], [5, &quot;eeeee&quot;], [4, &quot;ddddd&quot;]]</code></p><p><strong>Output</strong></p><p><code>[null, [], [&quot;aaaaa&quot;], [&quot;bbbbb&quot;, &quot;ccccc&quot;], [], [&quot;ddddd&quot;, &quot;eeeee&quot;]]</code></p><p><strong>Explanation</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// Note that the values ordered by ID is [&quot;aaaaa&quot;, &quot;bbbbb&quot;, &quot;ccccc&quot;, &quot;ddddd&quot;, &quot;eeeee&quot;].

OrderedStream os = new OrderedStream(5);

os.insert(3, &quot;ccccc&quot;); // Inserts (3, &quot;ccccc&quot;), returns [].

os.insert(1, &quot;aaaaa&quot;); // Inserts (1, &quot;aaaaa&quot;), returns [&quot;aaaaa&quot;].

os.insert(2, &quot;bbbbb&quot;); // Inserts (2, &quot;bbbbb&quot;), returns [&quot;bbbbb&quot;, &quot;ccccc&quot;].

os.insert(5, &quot;eeeee&quot;); // Inserts (5, &quot;eeeee&quot;), returns [].

os.insert(4, &quot;ddddd&quot;); // Inserts (4, &quot;ddddd&quot;), returns [&quot;ddddd&quot;, &quot;eeeee&quot;].

// Concatentating all the chunks returned:

// [] + [&quot;aaaaa&quot;] + [&quot;bbbbb&quot;, &quot;ccccc&quot;] + [] + [&quot;ddddd&quot;, &quot;eeeee&quot;] = [&quot;aaaaa&quot;, &quot;bbbbb&quot;, &quot;ccccc&quot;, &quot;ddddd&quot;, &quot;eeeee&quot;]

// The resulting order is the same as the order above.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= id &lt;= n</code></li><li><code>value.length == 5</code></li><li><code>value</code> consists only of lowercase letters.</li><li>Each call to <code>insert</code> will have a unique <code>id.</code></li><li>Exactly <code>n</code> calls will be made to <code>insert</code>.</li></ul><h2 id="题目大意" tabindex="-1"><a class="header-anchor" href="#题目大意" aria-hidden="true">#</a> 题目大意</h2><p>有 <code>n</code> 个 <code>(id, value)</code> 对，其中 <code>id</code> 是 <code>1</code> 到 <code>n</code> 之间的一个整数，<code>value</code> 是一个字符串。不存在 <code>id</code> 相同的两个 <code>(id, value)</code> 对。</p><p>设计一个流，以 <strong>任意</strong> 顺序获取 <code>n</code> 个 <code>(id, value)</code> 对，并在多次调用时 <strong>按<code>id</code> 递增的顺序</strong> 返回一些值。</p><p>实现 <code>OrderedStream</code> 类：</p><ul><li><p><code>OrderedStream(int n)</code> 构造一个能接收 <code>n</code> 个值的流，并将当前指针 <code>ptr</code> 设为 <code>1</code> 。</p></li><li><p><code>String[] insert(int id, String value)</code> 向流中存储新的 <code>(id, value)</code> 对。存储后：</p><ul><li><p>如果流存储有 <code>id = ptr</code> 的 <code>(id, value)</code> 对，则找出从 <code>id = ptr</code> 开始的 <strong>最长 id 连续递增序列</strong> ，并 <strong>按顺序</strong> 返回与这些 id 关联的值的列表。然后，将 <code>ptr</code> 更新为最后那个 <code>id + 1</code> 。</p></li><li><p>否则，返回一个空列表。</p></li></ul></li></ul><p><strong>示例：</strong></p><p><strong>![](https://assets.leetcode-cn.com/aliyun-lc- upload/uploads/2020/11/15/q1.gif)</strong></p><blockquote><p><strong>输入</strong></p><p><code>[&quot;OrderedStream&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;insert&quot;]</code></p><p><code>[[5], [3, &quot;ccccc&quot;], [1, &quot;aaaaa&quot;], [2, &quot;bbbbb&quot;], [5, &quot;eeeee&quot;], [4, &quot;ddddd&quot;]]</code></p><p><strong>输出</strong></p><p><code>[null, [], [&quot;aaaaa&quot;], [&quot;bbbbb&quot;, &quot;ccccc&quot;], [], [&quot;ddddd&quot;, &quot;eeeee&quot;]]</code></p><p><strong>解释</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>OrderedStream os= new OrderedStream(5);

os.insert(3, &quot;ccccc&quot;); // 插入 (3, &quot;ccccc&quot;)，返回 []

os.insert(1, &quot;aaaaa&quot;); // 插入 (1, &quot;aaaaa&quot;)，返回 [&quot;aaaaa&quot;]

os.insert(2, &quot;bbbbb&quot;); // 插入 (2, &quot;bbbbb&quot;)，返回 [&quot;bbbbb&quot;, &quot;ccccc&quot;]

os.insert(5, &quot;eeeee&quot;); // 插入 (5, &quot;eeeee&quot;)，返回 []

os.insert(4, &quot;ddddd&quot;); // 插入 (4, &quot;ddddd&quot;)，返回 [&quot;ddddd&quot;, &quot;eeeee&quot;]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= id &lt;= n</code></li><li><code>value.length == 5</code></li><li><code>value</code> 仅由小写字母组成</li><li>每次调用 <code>insert</code> 都会使用一个唯一的 <code>id</code></li><li>恰好调用 <code>n</code> 次 <code>insert</code></li></ul><h2 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路" aria-hidden="true">#</a> 解题思路</h2><p><code>OrderedStream</code> 是一个数据流管理器，可以按照插入的顺序存储数据，并在 <code>insert</code> 方法被调用时，返回从当前指针位置连续的、按顺序的字符串。</p><ol><li><p><strong>初始化</strong>：</p><ul><li>使用一个数组 <code>order</code> 存储数据流，长度为 <code>n</code>。</li><li>定义一个指针 <code>ptr</code>，初始值为 <code>0</code>，表示当前可以输出的最左位置。</li></ul></li><li><p><strong>插入逻辑</strong>：</p><ul><li>将 <code>value</code> 存储在数组的索引位置 <code>idKey - 1</code> 中（因为 <code>idKey</code> 是 1-based，而数组是 0-based）。</li><li>检查从 <code>ptr</code> 开始是否有连续的非空值： <ul><li>如果有，逐个收集这些值并将 <code>ptr</code> 向后移动。</li></ul></li><li>返回收集到的值组成的数组。</li></ul></li></ol><h4 id="复杂度分析" tabindex="-1"><a class="header-anchor" href="#复杂度分析" aria-hidden="true">#</a> 复杂度分析</h4><ul><li><strong>时间复杂度</strong>：<code>O(n)</code>，每次 <code>insert</code> 操作最多遍历一次指针后的连续元素，因此最坏情况下遍历 <code>n</code> 个元素。</li><li><strong>空间复杂度</strong>：<code>O(n)</code>，使用了一个长度为 <code>n</code> 的数组存储数据。</li></ul><h2 id="代码" tabindex="-1"><a class="header-anchor" href="#代码" aria-hidden="true">#</a> 代码</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">}</span></span> <span class="token parameter">n</span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">OrderedStream</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>order <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 存储数据的数组</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>ptr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 当前指针位置</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">}</span></span> <span class="token parameter">idKey</span>
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>string<span class="token punctuation">}</span></span> <span class="token parameter">value</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>string<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span>
 */</span>
<span class="token class-name">OrderedStream</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">insert</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">idKey<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>order<span class="token punctuation">[</span>idKey <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token comment">// 插入值</span>
	<span class="token keyword">let</span> answer <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

	<span class="token comment">// 从指针位置开始收集连续的非空值</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>order<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>ptr<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		answer<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>order<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>ptr<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> answer<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token doc-comment comment">/**
 * Your OrderedStream object will be instantiated and called as such:
 * var obj = new OrderedStream(n)
 * var param_1 = obj.insert(idKey,value)
 */</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="相关题目" tabindex="-1"><a class="header-anchor" href="#相关题目" aria-hidden="true">#</a> 相关题目</h2>`,28),w=e("thead",null,[e("tr",null,[e("th",{style:{"text-align":"center"}},"题号"),e("th",{style:{"text-align":"left"}},"标题"),e("th",{style:{"text-align":"center"}},"题解"),e("th",{style:{"text-align":"left"}},"标签"),e("th",{style:{"text-align":"center"}},"难度"),e("th",{style:{"text-align":"center"}},"力扣")])],-1),S=e("td",{style:{"text-align":"center"}},"2424",-1),O=e("td",{style:{"text-align":"left"}},"最长上传前缀",-1),I=e("td",{style:{"text-align":"center"}},null,-1),K={style:{"text-align":"left"}},E=e("code",null,"并查集",-1),C=e("code",null,"设计",-1),N=e("code",null,"树状数组",-1),j=e("code",null,"4+",-1),L=e("td",{style:{"text-align":"center"}},"🟠",-1),V={style:{"text-align":"center"}},T={href:"https://leetcode.cn/problems/longest-uploaded-prefix",target:"_blank",rel:"noopener noreferrer"},B={href:"https://leetcode.com/problems/longest-uploaded-prefix",target:"_blank",rel:"noopener noreferrer"};function D(R,z){const d=c("font"),a=c("RouterLink"),o=c("ExternalLinkIcon");return i(),r("div",null,[v,e("p",null,[n("🟢 "),t(d,{color:"#15bd66"},{default:s(()=>[n("Easy")]),_:1}),n("  🔖  "),t(a,{to:"/tag/design.html"},{default:s(()=>[m]),_:1}),n(),t(a,{to:"/tag/array.html"},{default:s(()=>[q]),_:1}),n(),t(a,{to:"/tag/hash-table.html"},{default:s(()=>[h]),_:1}),n(),t(a,{to:"/tag/data-stream.html"},{default:s(()=>[k]),_:1}),n("  🔗 "),e("a",g,[_,t(o)]),n(),e("a",f,[y,t(o)])]),x,u(" prettier-ignore "),e("table",null,[w,e("tbody",null,[e("tr",null,[S,O,I,e("td",K,[t(a,{to:"/tag/union-find.html"},{default:s(()=>[E]),_:1}),n(),t(a,{to:"/tag/design.html"},{default:s(()=>[C]),_:1}),n(),t(a,{to:"/tag/binary-indexed-tree.html"},{default:s(()=>[N]),_:1}),n(),j]),L,e("td",V,[e("a",T,[n("🀄️"),t(o)]),n(),e("a",B,[n("🔗"),t(o)])])])])])])}const Y=l(b,[["render",D],["__file","1656.html.vue"]]);export{Y as default};
