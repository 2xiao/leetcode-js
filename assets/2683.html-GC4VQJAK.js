import{_ as l,r as i,o as d,c,a as e,b as n,d as o,w as t,f as p,e as g}from"./app-aQeLbVW9.js";const u={},h=e("h1",{id:"_2683-相邻值的按位异或",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_2683-相邻值的按位异或","aria-hidden":"true"},"#"),n(" 2683. 相邻值的按位异或")],-1),v=e("code",null,"位运算",-1),k=e("code",null,"数组",-1),m={href:"https://leetcode.cn/problems/neighboring-bitwise-xor",target:"_blank",rel:"noopener noreferrer"},b=e("code",null,"力扣",-1),_={href:"https://leetcode.com/problems/neighboring-bitwise-xor",target:"_blank",rel:"noopener noreferrer"},f=e("code",null,"LeetCode",-1),y=g(`<h2 id="题目" tabindex="-1"><a class="header-anchor" href="#题目" aria-hidden="true">#</a> 题目</h2><p>A <strong>0-indexed</strong> array <code>derived</code> with length <code>n</code> is derived by computing the <strong>bitwise XOR</strong> (⊕) of adjacent values in a <strong>binary array</strong> <code>original</code> of length <code>n</code>.</p><p>Specifically, for each index <code>i</code> in the range <code>[0, n - 1]</code>:</p><ul><li>If <code>i = n - 1</code>, then <code>derived[i] = original[i] ⊕ original[0]</code>.</li><li>Otherwise, <code>derived[i] = original[i] ⊕ original[i + 1]</code>.</li></ul><p>Given an array <code>derived</code>, your task is to determine whether there exists a <strong>valid binary array</strong> <code>original</code> that could have formed <code>derived</code>.</p><p>Return <em><strong>true</strong> if such an array exists or <strong>false</strong> otherwise.</em></p><ul><li>A binary array is an array containing only <strong>0 &#39;s</strong> and <strong>1 &#39;s</strong></li></ul><p><strong>Example 1:</strong></p><blockquote><p>Input: derived = [1,1,0]</p><p>Output: true</p><p>Explanation: A valid original array that gives derived is [0,1,0].</p><p>derived[0] = original[0] ⊕ original[1] = 0 ⊕ 1 = 1</p><p>derived[1] = original[1] ⊕ original[2] = 1 ⊕ 0 = 1</p><p>derived[2] = original[2] ⊕ original[0] = 0 ⊕ 0 = 0</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p>Input: derived = [1,1]</p><p>Output: true</p><p>Explanation: A valid original array that gives derived is [0,1].</p><p>derived[0] = original[0] ⊕ original[1] = 1</p><p>derived[1] = original[1] ⊕ original[0] = 1</p></blockquote><p><strong>Example 3:</strong></p><blockquote><p>Input: derived = [1,0]</p><p>Output: false</p><p>Explanation: There is no valid original array that gives derived.</p></blockquote><p><strong>Constraints:</strong></p><ul><li><code>n == derived.length</code></li><li><code>1 &lt;= n &lt;= 10^5</code></li><li>The values in <code>derived</code> are either <strong>0 &#39;s</strong> or <strong>1 &#39;s</strong></li></ul><h2 id="题目大意" tabindex="-1"><a class="header-anchor" href="#题目大意" aria-hidden="true">#</a> 题目大意</h2><p>下标从 <strong>0</strong> 开始、长度为 <code>n</code> 的数组 <code>derived</code> 是由同样长度为 <code>n</code> 的原始 <strong>二进制数组</strong> <code>original</code> 通过计算相邻值的 <strong>按位异或（⊕）</strong> 派生而来。</p><p>特别地，对于范围 <code>[0, n - 1]</code> 内的每个下标 <code>i</code> ：</p><ul><li>如果 <code>i = n - 1</code> ，那么 <code>derived[i] = original[i] ⊕ original[0]</code></li><li>否则 <code>derived[i] = original[i] ⊕ original[i + 1]</code></li></ul><p>给你一个数组 <code>derived</code> ，请判断是否存在一个能够派生得到 <code>derived</code> 的 <strong>有效原始二进制数组</strong> <code>original</code> 。</p><p>如果存在满足要求的原始二进制数组，返回 <em><strong>true</strong></em>；否则，返回 <em><strong>false</strong></em>。</p><ul><li>二进制数组是仅由 <strong>0</strong> 和 <strong>1</strong> 组成的数组。</li></ul><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> derived = [1,1,0]</p><p><strong>输出：</strong> true</p><p><strong>解释：</strong> 能够派生得到 [1,1,0] 的有效原始二进制数组是 [0,1,0] ：</p><p>derived[0] = original[0] ⊕ original[1] = 0 ⊕ 1 = 1</p><p>derived[1] = original[1] ⊕ original[2] = 1 ⊕ 0 = 1</p><p>derived[2] = original[2] ⊕ original[0] = 0 ⊕ 0 = 0</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> derived = [1,1]</p><p><strong>输出：</strong> true</p><p><strong>解释：</strong> 能够派生得到 [1,1] 的有效原始二进制数组是 [0,1] ：</p><p>derived[0] = original[0] ⊕ original[1] = 1</p><p>derived[1] = original[1] ⊕ original[0] = 1</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> derived = [1,0]</p><p><strong>输出：</strong> false</p><p><strong>解释：</strong> 不存在能够派生得到 [1,0] 的有效原始二进制数组。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>n == derived.length</code></li><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>derived</code> 中的值不是 <strong>0</strong> 就是 <strong>1</strong> 。</li></ul><h2 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路" aria-hidden="true">#</a> 解题思路</h2><p>题目考察的是一个数组是否可以通过异或操作还原成有效的原始数组。关键点在于：</p><ol><li>异或的性质： <ul><li><code>a ^ b = c</code>，那么 <code>b = a ^ c</code>。</li><li>因此，异或操作具有可逆性。</li></ul></li><li>原始数组的有效性： <ul><li>如果能形成一个循环的异或关系（即首尾元素连接后满足规则），那么原始数组是有效的。</li></ul></li></ol><p>由于数组是循环的，可以通过假设 <code>original[0]</code> 的初值为 <code>0</code> 或 <code>1</code> 两种情况进行模拟：</p><ol><li><strong>假设 1：<code>original[0] = 0</code></strong>： <ul><li>根据公式 <code>derived[i] = original[i] ^ original[i + 1]</code> 推算整个数组。</li><li>判断推导出的 <code>original</code> 是否有效（即形成闭环，满足 <code>original[n] = original[0]</code>）。</li></ul></li><li><strong>假设 2：<code>original[0] = 1</code></strong>： <ul><li>同样推导数组并判断闭环条件。</li></ul></li></ol><p>如果任一假设成立，则返回 <code>true</code>；否则返回 <code>false</code>。</p><ul><li>用两个变量 <code>case1</code> 和 <code>case2</code> 表示假设 <code>original[0] = 0</code> 和 <code>original[0] = 1</code> 的推导结果。</li><li>遍历 <code>derived</code> 数组，用异或公式更新 <code>case1</code> 和 <code>case2</code>。</li><li>判断最终结果是否满足闭环条件。</li></ul><h4 id="复杂度分析" tabindex="-1"><a class="header-anchor" href="#复杂度分析" aria-hidden="true">#</a> 复杂度分析</h4><ul><li><strong>时间复杂度</strong>：<code>O(n)</code>，只需遍历一次 <code>derived</code>。</li><li><strong>空间复杂度</strong>：<code>O(1)</code>，使用常量空间。</li></ul><h2 id="代码" tabindex="-1"><a class="header-anchor" href="#代码" aria-hidden="true">#</a> 代码</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span> <span class="token parameter">derived</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>boolean<span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">doesValidArrayExist</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">derived</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">let</span> case1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">// 假设 original[0] = 0</span>
		case2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 假设 original[0] = 1</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> num <span class="token keyword">of</span> derived<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		case1 <span class="token operator">=</span> num <span class="token operator">^</span> case1<span class="token punctuation">;</span>
		case2 <span class="token operator">=</span> num <span class="token operator">^</span> case2<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 如果任一闭环成立，返回 true</span>
	<span class="token keyword">return</span> case1 <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">||</span> case2 <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="相关题目" tabindex="-1"><a class="header-anchor" href="#相关题目" aria-hidden="true">#</a> 相关题目</h2>`,42),x=e("thead",null,[e("tr",null,[e("th",{style:{"text-align":"center"}},"题号"),e("th",{style:{"text-align":"left"}},"标题"),e("th",{style:{"text-align":"center"}},"题解"),e("th",{style:{"text-align":"left"}},"标签"),e("th",{style:{"text-align":"center"}},"难度"),e("th",{style:{"text-align":"center"}},"力扣")])],-1),w=e("td",{style:{"text-align":"center"}},"3173",-1),q=e("td",{style:{"text-align":"left"}},"相邻元素的按位或 🔒",-1),E=e("td",{style:{"text-align":"center"}},null,-1),O={style:{"text-align":"left"}},j=e("code",null,"位运算",-1),I=e("code",null,"数组",-1),V=e("td",{style:{"text-align":"center"}},"🟢",-1),A={style:{"text-align":"center"}},C={href:"https://leetcode.cn/problems/bitwise-or-of-adjacent-elements",target:"_blank",rel:"noopener noreferrer"},L={href:"https://leetcode.com/problems/bitwise-or-of-adjacent-elements",target:"_blank",rel:"noopener noreferrer"};function N(R,B){const r=i("font"),a=i("RouterLink"),s=i("ExternalLinkIcon");return d(),c("div",null,[h,e("p",null,[n("🟠 "),o(r,{color:"#ffb800"},{default:t(()=>[n("Medium")]),_:1}),n("  🔖  "),o(a,{to:"/tag/bit-manipulation.html"},{default:t(()=>[v]),_:1}),n(),o(a,{to:"/tag/array.html"},{default:t(()=>[k]),_:1}),n("  🔗 "),e("a",m,[b,o(s)]),n(),e("a",_,[f,o(s)])]),y,p(" prettier-ignore "),e("table",null,[x,e("tbody",null,[e("tr",null,[w,q,E,e("td",O,[o(a,{to:"/tag/bit-manipulation.html"},{default:t(()=>[j]),_:1}),n(),o(a,{to:"/tag/array.html"},{default:t(()=>[I]),_:1})]),V,e("td",A,[e("a",C,[n("🀄️"),o(s)]),n(),e("a",L,[n("🔗"),o(s)])])])])])])}const S=l(u,[["render",N],["__file","2683.html.vue"]]);export{S as default};
