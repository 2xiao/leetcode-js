import{_ as c,r as l,o as i,c as r,a as n,b as s,d as t,w as e,f as u,e as d}from"./app-aQeLbVW9.js";const k={},m=n("h1",{id:"_89-格雷编码",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_89-格雷编码","aria-hidden":"true"},"#"),s(" 89. 格雷编码")],-1),g=n("code",null,"位运算",-1),b=n("code",null,"数学",-1),h=n("code",null,"回溯",-1),v={href:"https://leetcode.cn/problems/gray-code",target:"_blank",rel:"noopener noreferrer"},f=n("code",null,"力扣",-1),_={href:"https://leetcode.com/problems/gray-code",target:"_blank",rel:"noopener noreferrer"},y=n("code",null,"LeetCode",-1),x=d(`<h2 id="题目" tabindex="-1"><a class="header-anchor" href="#题目" aria-hidden="true">#</a> 题目</h2><p>An <strong>n-bit gray code sequence</strong> is a sequence of <code>2n</code> integers where:</p><ul><li>Every integer is in the <strong>inclusive</strong> range <code>[0, 2n - 1]</code>,</li><li>The first integer is <code>0</code>,</li><li>An integer appears <strong>no more than once</strong> in the sequence,</li><li>The binary representation of every pair of <strong>adjacent</strong> integers differs by <strong>exactly one bit</strong> , and</li><li>The binary representation of the <strong>first</strong> and <strong>last</strong> integers differs by <strong>exactly one bit</strong>.</li></ul><p>Given an integer <code>n</code>, return <em>any valid<strong>n-bit gray code sequence</strong></em>.</p><p><strong>Example 1:</strong></p><blockquote><p>Input: n = 2</p><p>Output: [0,1,3,2]</p><p>Explanation:</p><p>The binary representation of [0,1,3,2] is [00,01,11,10].</p><ul><li>0 <em>0</em> and 0 <em>1</em> differ by one bit</li><li><em>0</em> 1 and <em>1</em> 1 differ by one bit</li><li>1 <em>1</em> and 1 <em>0</em> differ by one bit</li><li><em>1</em> 0 and <em>0</em> 0 differ by one bit</li></ul><p>[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].</p><ul><li><em>0</em> 0 and <em>1</em> 0 differ by one bit</li><li>1 <em>0</em> and 1 <em>1</em> differ by one bit</li><li><em>1</em> 1 and <em>0</em> 1 differ by one bit</li><li>0 <em>1</em> and 0 <em>0</em> differ by one bit</li></ul></blockquote><p><strong>Example 2:</strong></p><blockquote><p>Input: n = 1</p><p>Output: [0,1]</p></blockquote><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 16</code></li></ul><h2 id="题目大意" tabindex="-1"><a class="header-anchor" href="#题目大意" aria-hidden="true">#</a> 题目大意</h2><p><strong>n 位格雷码序列</strong> 是一个由 <code>2n</code> 个整数组成的序列，其中：</p><ul><li>每个整数都在范围 <code>[0, 2n - 1]</code> 内（含 <code>0</code> 和 <code>2n - 1</code>）</li><li>第一个整数是 <code>0</code></li><li>一个整数在序列中出现 <strong>不超过一次</strong></li><li>每对 <strong>相邻</strong> 整数的二进制表示 <strong>恰好一位不同</strong> ，且</li><li><strong>第一个</strong> 和 <strong>最后一个</strong> 整数的二进制表示 <strong>恰好一位不同</strong></li></ul><p>给你一个整数 <code>n</code> ，返回任一有效的 <strong>n 位格雷码序列</strong> 。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> n = 2</p><p><strong>输出：</strong>[0,1,3,2]</p><p><strong>解释：</strong></p><p>[0,1,3,2] 的二进制表示是 [00,01,11,10] 。</p><ul><li>0** <em>0</em>** 和 0 <em><strong>1</strong></em> 有一位不同</li><li><em><strong>0</strong></em> 1 和 <em><strong>1</strong></em> 1 有一位不同</li><li>1 <em><strong>1</strong></em> 和 1 <em><strong>0</strong></em> 有一位不同</li><li><em><strong>1</strong></em> 0 和 <em><strong>0</strong></em> 0 有一位不同</li></ul><p>[0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。</p><ul><li><em><strong>0</strong></em> 0 和 <em><strong>1</strong></em> 0 有一位不同</li><li>1 <em><strong>0</strong></em> 和 1 <em><strong>1</strong></em> 有一位不同</li><li><em><strong>1</strong></em> 1 和 <em><strong>0</strong></em> 1 有一位不同</li><li>0 <em><strong>1</strong></em> 和 0 <em><strong>0</strong></em> 有一位不同</li></ul></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> n = 1</p><p><strong>输出：</strong>[0,1]</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 16</code></li></ul><h2 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路" aria-hidden="true">#</a> 解题思路</h2><ol><li><p><strong>状态记录</strong>：</p><ul><li>使用一个数组 <code>res</code> 保存当前的结果序列。</li><li>使用一个集合 <code>used</code> 记录已经加入序列的数字，避免重复。</li><li>初始化结果数组 <code>res</code> 和集合 <code>used</code>，将起点 <code>0</code> 加入其中。</li></ul></li><li><p><strong>递归过程</strong>：</p><ul><li>使用回溯法，递归尝试将下一个符合条件的数字加入到结果序列中。</li><li>每次尝试从当前数字开始，翻转其二进制表示的某一位以生成一个新数字。</li><li>翻转第 <code>i</code> 位可以通过公式 <code>num ^ (1 &lt;&lt; i)</code> 实现。</li><li>如果新数字未被使用，将其加入序列，并继续递归。</li><li>如果无法继续（当前路径无法覆盖所有数字），回溯并尝试其他可能的路径。</li></ul></li><li><p><strong>递归退出条件</strong>：</p><ul><li>当结果序列长度达到 <code>2^n</code>，说明所有数字均已访问，返回序列。</li></ul></li></ol><h4 id="复杂度分析" tabindex="-1"><a class="header-anchor" href="#复杂度分析" aria-hidden="true">#</a> 复杂度分析</h4><ul><li><strong>时间复杂度</strong>：<code>O(2^n * n)</code>，回溯会尝试所有可能的数字组合，最多尝试 <code>2^n</code> 个数字，每次需要遍历 <code>n</code> 位。</li><li><strong>空间复杂度</strong>：<code>O(2^n)</code><ul><li>递归栈深度最多为 <code>O(2^n)</code>。</li><li><code>used</code> 集合存储最多 <code>2^n</code> 个数字，空间复杂度为 <code>O(2^n)</code>。</li><li>整体空间复杂度为 <code>O(2^n)</code>。</li></ul></li></ul><h2 id="代码" tabindex="-1"><a class="header-anchor" href="#代码" aria-hidden="true">#</a> 代码</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">}</span></span> <span class="token parameter">n</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">grayCode</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 初始序列</span>
	<span class="token keyword">let</span> used <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记录已使用的数字</span>

	<span class="token keyword">const</span> <span class="token function-variable function">backtrack</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
		<span class="token comment">// 如果序列长度达到 2^n，返回 true</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>length <span class="token operator">===</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token comment">// 遍历每一位，尝试翻转</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">const</span> next <span class="token operator">=</span> num <span class="token operator">^</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 翻转第 i 位</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>used<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// 如果已经使用过，跳过</span>

			res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将数字加入序列</span>
			used<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 标记为已使用</span>

			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">backtrack</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 递归，如果成功，直接返回</span>

			<span class="token comment">// 回溯</span>
			res<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			used<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 无法继续扩展，返回 false</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从 0 开始生成序列</span>
	<span class="token keyword">return</span> res<span class="token punctuation">;</span> <span class="token comment">// 返回结果</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="相关题目" tabindex="-1"><a class="header-anchor" href="#相关题目" aria-hidden="true">#</a> 相关题目</h2>`,27),w=n("thead",null,[n("tr",null,[n("th",{style:{"text-align":"center"}},"题号"),n("th",{style:{"text-align":"left"}},"标题"),n("th",{style:{"text-align":"center"}},"题解"),n("th",{style:{"text-align":"left"}},"标签"),n("th",{style:{"text-align":"center"}},"难度"),n("th",{style:{"text-align":"center"}},"力扣")])],-1),q=n("td",{style:{"text-align":"center"}},"717",-1),E=n("td",{style:{"text-align":"left"}},"1 比特与 2 比特字符",-1),O={style:{"text-align":"center"}},C={style:{"text-align":"left"}},L=n("code",null,"数组",-1),N=n("td",{style:{"text-align":"center"}},"🟢",-1),T={style:{"text-align":"center"}},V={href:"https://leetcode.cn/problems/1-bit-and-2-bit-characters",target:"_blank",rel:"noopener noreferrer"},j={href:"https://leetcode.com/problems/1-bit-and-2-bit-characters",target:"_blank",rel:"noopener noreferrer"};function I(B,A){const p=l("font"),a=l("RouterLink"),o=l("ExternalLinkIcon");return i(),r("div",null,[m,n("p",null,[s("🟠 "),t(p,{color:"#ffb800"},{default:e(()=>[s("Medium")]),_:1}),s("  🔖  "),t(a,{to:"/tag/bit-manipulation.html"},{default:e(()=>[g]),_:1}),s(),t(a,{to:"/tag/math.html"},{default:e(()=>[b]),_:1}),s(),t(a,{to:"/tag/backtracking.html"},{default:e(()=>[h]),_:1}),s("  🔗 "),n("a",v,[f,t(o)]),s(),n("a",_,[y,t(o)])]),x,u(" prettier-ignore "),n("table",null,[w,n("tbody",null,[n("tr",null,[q,E,n("td",O,[t(a,{to:"/problem/0717.html"},{default:e(()=>[s("[✓]")]),_:1})]),n("td",C,[t(a,{to:"/tag/array.html"},{default:e(()=>[L]),_:1})]),N,n("td",T,[n("a",V,[s("🀄️"),t(o)]),s(),n("a",j,[s("🔗"),t(o)])])])])])])}const R=c(k,[["render",I],["__file","0089.html.vue"]]);export{R as default};
