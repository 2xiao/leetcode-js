import{_ as c,r as e,o as i,c as r,a as n,b as s,d as a,w as t,e as u}from"./app-B5EG-zH0.js";const d={},k=n("h1",{id:"_1863-找出所有子集的异或总和再求和",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_1863-找出所有子集的异或总和再求和","aria-hidden":"true"},"#"),s(" 1863. 找出所有子集的异或总和再求和")],-1),m=n("code",null,"位运算",-1),g=n("code",null,"数组",-1),h=n("code",null,"数学",-1),b=n("code",null,"回溯",-1),f=n("code",null,"组合数学",-1),v=n("code",null,"枚举",-1),O={href:"https://leetcode.cn/problems/sum-of-all-subset-xor-totals",target:"_blank",rel:"noopener noreferrer"},_=n("code",null,"力扣",-1),R={href:"https://leetcode.com/problems/sum-of-all-subset-xor-totals",target:"_blank",rel:"noopener noreferrer"},X=n("code",null,"LeetCode",-1),y=u(`<h2 id="题目" tabindex="-1"><a class="header-anchor" href="#题目" aria-hidden="true">#</a> 题目</h2><p>The <strong>XOR total</strong> of an array is defined as the bitwise <code>XOR</code> of<strong>all its elements</strong> , or <code>0</code> if the array is<strong>empty</strong>.</p><ul><li>For example, the <strong>XOR total</strong> of the array <code>[2,5,6]</code> is <code>2 XOR 5 XOR 6 = 1</code>.</li></ul><p>Given an array <code>nums</code>, return <em>the <strong>sum</strong> of all <strong>XOR totals</strong> for every <strong>subset</strong> of</em> <code>nums</code>.</p><p><strong>Note:</strong> Subsets with the <strong>same</strong> elements should be counted <strong>multiple</strong> times.</p><p>An array <code>a</code> is a <strong>subset</strong> of an array <code>b</code> if <code>a</code> can be obtained from <code>b</code> by deleting some (possibly zero) elements of <code>b</code>.</p><p><strong>Example 1:</strong></p><blockquote><p>Input: nums = [1,3]</p><p>Output: 6</p><p>Explanation: The 4 subsets of [1,3] are:</p><ul><li>The empty subset has an XOR total of 0.</li><li>[1] has an XOR total of 1.</li><li>[3] has an XOR total of 3.</li><li>[1,3] has an XOR total of 1 XOR 3 = 2.</li></ul><p>0 + 1 + 3 + 2 = 6</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p>Input: nums = [5,1,6]</p><p>Output: 28</p><p>Explanation: The 8 subsets of [5,1,6] are:</p><ul><li>The empty subset has an XOR total of 0.</li><li>[5] has an XOR total of 5.</li><li>[1] has an XOR total of 1.</li><li>[6] has an XOR total of 6.</li><li>[5,1] has an XOR total of 5 XOR 1 = 4.</li><li>[5,6] has an XOR total of 5 XOR 6 = 3.</li><li>[1,6] has an XOR total of 1 XOR 6 = 7.</li><li>[5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.</li></ul><p>0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28</p></blockquote><p><strong>Example 3:</strong></p><blockquote><p>Input: nums = [3,4,5,6,7,8]</p><p>Output: 480</p><p>Explanation: The sum of all XOR totals for every subset is 480.</p></blockquote><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 12</code></li><li><code>1 &lt;= nums[i] &lt;= 20</code></li></ul><h2 id="题目大意" tabindex="-1"><a class="header-anchor" href="#题目大意" aria-hidden="true">#</a> 题目大意</h2><p>一个数组的<strong>异或总和</strong> 定义为数组中所有元素按位 <code>XOR</code> 的结果；如果数组为 <strong>空</strong> ，则异或总和为 <code>0</code> 。</p><ul><li>例如，数组 <code>[2,5,6]</code> 的 <strong>异或总和</strong> 为 <code>2 XOR 5 XOR 6 = 1</code> 。</li></ul><p>给你一个数组 <code>nums</code> ，请你求出 <code>nums</code> 中每个 <strong>子集</strong> 的 <strong>异或总和</strong> ，计算并返回这些值相加之 <strong>和</strong> 。</p><p><strong>注意：</strong> 在本题中，元素 <strong>相同</strong> 的不同子集应 <strong>多次</strong> 计数。</p><p>数组 <code>a</code> 是数组 <code>b</code> 的一个 <strong>子集</strong> 的前提条件是：从 <code>b</code> 删除几个（也可能不删除）元素能够得到 <code>a</code> 。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> nums = [1,3]</p><p><strong>输出：</strong> 6</p><p><strong>解释：</strong>[1,3] 共有 4 个子集：</p><ul><li>空子集的异或总和是 0 。</li><li>[1] 的异或总和为 1 。</li><li>[3] 的异或总和为 3 。</li><li>[1,3] 的异或总和为 1 XOR 3 = 2 。</li></ul><p>0 + 1 + 3 + 2 = 6</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> nums = [5,1,6]</p><p><strong>输出：</strong> 28</p><p><strong>解释：</strong>[5,1,6] 共有 8 个子集：</p><ul><li>空子集的异或总和是 0 。</li><li>[5] 的异或总和为 5 。</li><li>[1] 的异或总和为 1 。</li><li>[6] 的异或总和为 6 。</li><li>[5,1] 的异或总和为 5 XOR 1 = 4 。</li><li>[5,6] 的异或总和为 5 XOR 6 = 3 。</li><li>[1,6] 的异或总和为 1 XOR 6 = 7 。</li><li>[5,1,6] 的异或总和为 5 XOR 1 XOR 6 = 2 。</li></ul><p>0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong> nums = [3,4,5,6,7,8]</p><p><strong>输出：</strong> 480</p><p><strong>解释：</strong> 每个子集的全部异或总和值之和为 480 。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 12</code></li><li><code>1 &lt;= nums[i] &lt;= 20</code></li></ul><h2 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路" aria-hidden="true">#</a> 解题思路</h2><p>可以采用回溯算法（backtracking）来生成所有子集，并计算每个子集的 XOR 值。</p><ol><li><p><strong>回溯函数（backtrack）</strong>：</p><ul><li>使用 <code>start</code> 来控制从哪个位置开始选择元素，以避免重复选取元素。</li><li>通过一个局部变量 <code>XOR</code> 来保持当前子集的 XOR 值。每次进入递归时，都会将当前元素加入到 <code>XOR</code> 中，递归完成后，再撤销这个选择（即通过 <code>XOR ^= nums[i]</code> 恢复）。</li><li>每次递归都会累加 <code>XOR</code> 到 <code>sum</code> 中，表示当前子集的 XOR 值已经计算完毕。</li></ul></li><li><p><strong>回溯的递归展开</strong>：</p><ul><li>从 <code>start</code> 开始，依次选择每个元素加入到当前子集中，并递归地计算下一个元素可能的组合。</li><li>在递归过程中，撤销当前选择的元素，返回到上一层递归继续考虑其他可能的选择。</li></ul></li></ol><h4 id="复杂度分析" tabindex="-1"><a class="header-anchor" href="#复杂度分析" aria-hidden="true">#</a> 复杂度分析</h4><ul><li><strong>时间复杂度</strong>：<code>O(2^n)</code>，其中 <code>n</code> 是数组 <code>nums</code> 的长度，回溯生成的子集总数为 <code>2^n</code>，即每个元素有两种选择（选与不选）。</li><li><strong>空间复杂度</strong>：<code>O(n)</code>，主要取决于递归栈的深度，最深的递归深度是 <code>n</code>。</li></ul><h2 id="代码" tabindex="-1"><a class="header-anchor" href="#代码" aria-hidden="true">#</a> 代码</h2><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span> <span class="token parameter">nums</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">subsetXORSum</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 记录所有子集的 XOR 和</span>
	<span class="token keyword">let</span> <span class="token constant">XOR</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 当前子集的 XOR 值</span>

	<span class="token comment">// 回溯函数，生成所有子集</span>
	<span class="token keyword">const</span> <span class="token function-variable function">backtrack</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">start</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
		sum <span class="token operator">+=</span> <span class="token constant">XOR</span><span class="token punctuation">;</span> <span class="token comment">// 每次递归到达叶节点时，累加当前子集的 XOR 值</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token constant">XOR</span> <span class="token operator">^=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 将当前元素加入 XOR</span>
			<span class="token function">backtrack</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归调用，尝试加入下一个元素</span>
			<span class="token constant">XOR</span> <span class="token operator">^=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 撤销选择，回到之前的状态</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从第一个元素开始递归</span>
	<span class="token keyword">return</span> sum<span class="token punctuation">;</span> <span class="token comment">// 返回所有子集的 XOR 和</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,35);function x(w,q){const p=e("font"),o=e("RouterLink"),l=e("ExternalLinkIcon");return i(),r("div",null,[k,n("p",null,[s("🟢 "),a(p,{color:"#15bd66"},{default:t(()=>[s("Easy")]),_:1}),s("  🔖  "),a(o,{to:"/tag/bit-manipulation.html"},{default:t(()=>[m]),_:1}),s(),a(o,{to:"/tag/array.html"},{default:t(()=>[g]),_:1}),s(),a(o,{to:"/tag/math.html"},{default:t(()=>[h]),_:1}),s(),a(o,{to:"/tag/backtracking.html"},{default:t(()=>[b]),_:1}),s(),a(o,{to:"/tag/combinatorics.html"},{default:t(()=>[f]),_:1}),s(),a(o,{to:"/tag/enumeration.html"},{default:t(()=>[v]),_:1}),s("  🔗 "),n("a",O,[_,a(l)]),s(),n("a",R,[X,a(l)])]),y])}const T=c(d,[["render",x],["__file","1863.html.vue"]]);export{T as default};
